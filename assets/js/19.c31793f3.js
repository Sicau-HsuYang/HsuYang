(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{327:function(_,t,v){"use strict";v.r(t);var e=v(14),o=Object(e.a)({},(function(){var _=this,t=_._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h2",{attrs:{id:"求-top-k"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#求-top-k"}},[_._v("#")]),_._v(" 求 TOP K")]),_._v(" "),t("p",[_._v("求前 K 大的元素，这个题在面试中是比较常见题目，推广问题求中位数也是同样的解法，即"),t("code",[_._v("K=Math.floor(N/2)")]),_._v("，N 为数组的长度。")]),_._v(" "),t("h3",{attrs:{id:"_1、直接排序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、直接排序"}},[_._v("#")]),_._v(" 1、直接排序")]),_._v(" "),t("p",[_._v("这个解法是没有受过任何算法训练的同学都可以做出来的解法，直接拿最快的排序算法应用在整个数组上，直接根据下标取值。最优时间复杂度是"),t("code",[_._v("O(N*LogN)")]),_._v("，如果在实际面试中遇到了，那么采用这种方式也是一种应急的办法。")]),_._v(" "),t("h3",{attrs:{id:"_2、堆"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、堆"}},[_._v("#")]),_._v(" 2、堆")]),_._v(" "),t("p",[_._v("堆，或者被称为是优先队列，是一类特殊的二叉树，其任何一条从根节点到叶节点的路径都保持着从大到小或者从小到大的性质（如果是从小到大，那么就称为是"),t("code",[_._v("极小堆")]),_._v("，"),t("code",[_._v("最小堆")]),_._v("，"),t("code",[_._v("小顶堆")]),_._v("，如果是从大到小，那么就称为是"),t("code",[_._v("极大堆")]),_._v("，"),t("code",[_._v("最小堆")]),_._v("，"),t("code",[_._v("大顶堆")]),_._v("）。")]),_._v(" "),t("p",[_._v("利用堆的求解思路非常简单，首先我们必须要采取极小堆，遍历数组的过程中，如果当前堆中的元素不够 K 个，那么当前遍历的数据就无脑的往堆中插入即可；如果当前堆中的元素已经存在 K 个了，那么就看一下堆顶的元素，如果当前遍历的数组元素比堆顶的元素大，那说明堆顶元素不符合要求，需要删除堆顶元素，并且将当前遍历的数组元素插入到堆中。当遍历操作完成时，堆顶的元素刚好是第 K 大的元素，如果说要把前 K 大的元素都输出，那就依次输出堆中的元素就行了。")]),_._v(" "),t("p",[_._v("建堆的时间复杂度是"),t("code",[_._v("O(K)")]),_._v("，删除堆的元素的时间复杂度是"),t("code",[_._v("O(K*logK)")]),_._v("，K 最坏情况下等于 N，")])])}),[],!1,null,null,null);t.default=o.exports}}]);