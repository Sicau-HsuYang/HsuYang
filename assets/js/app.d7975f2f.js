(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var r,o,s=e[0],l=e[1],d=e[2],u=0,h=[];u<s.length;u++)o=s[u],Object.prototype.hasOwnProperty.call(a,o)&&a[o]&&h.push(a[o][0]),a[o]=0;for(r in l)Object.prototype.hasOwnProperty.call(l,r)&&(n[r]=l[r]);for(c&&c(e);h.length;)h.shift()();return i.push.apply(i,d||[]),t()}function t(){for(var n,e=0;e<i.length;e++){for(var t=i[e],r=!0,s=1;s<t.length;s++){var l=t[s];0!==a[l]&&(r=!1)}r&&(i.splice(e--,1),n=o(o.s=t[0]))}return n}var r={},a={1:0},i=[];function o(e){if(r[e])return r[e].exports;var t=r[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,o),t.l=!0,t.exports}o.e=function(n){var e=[],t=a[n];if(0!==t)if(t)e.push(t[2]);else{var r=new Promise((function(e,r){t=a[n]=[e,r]}));e.push(t[2]=r);var i,s=document.createElement("script");s.charset="utf-8",s.timeout=120,o.nc&&s.setAttribute("nonce",o.nc),s.src=function(n){return o.p+"assets/js/"+({}[n]||n)+"."+{2:"bd5c3d55",3:"4352d15c",4:"7cc47491",5:"582876a0",6:"0cef7858",7:"360fe7ec",8:"667390d0",9:"ec2bcd79",10:"44d40487",11:"552da99d",12:"727b7ea6",13:"f0b73018",14:"c3485005",15:"ef9c6a14",16:"bbe57604",17:"50e735ac",18:"8b6d498b",19:"b9f3ba5b",20:"9ff28a6f",21:"691c92cc",22:"ed6caa9c",23:"b22848e0",24:"832d6098",25:"c672be73",26:"3cf43416",27:"62d392df",28:"2cc56991",29:"5bf368bb",30:"29637198",31:"a0d34d12",32:"b80c53fe",33:"c1cad0d6",34:"125bc4b4",35:"57f0bcda",36:"acf8ef28",37:"222821b1",38:"caee3ad0",39:"647ddf15",40:"5c2eeb00",41:"bfe2b1db",42:"ed96b42f",43:"187fab1e",44:"2361c9c3",45:"b0c5b5e4",46:"af616c97",47:"102c59d7",48:"89f6a5ff",49:"870ae1e0",50:"d7e7c9ef",51:"d3b828f8",52:"adfedf46",53:"c5ba761b",54:"a032c68b",55:"9b433869",56:"d40e9a8c",57:"fc44f736",58:"798905f4",59:"295ef54e",60:"3249a786",61:"4ab09ad9",62:"e5b38211",63:"ff7f8ef0",64:"921ac485",65:"5e966b25",66:"d51999d3",67:"0cceef5e",68:"d69243fb",69:"bee50b6e",70:"7bc7b48f",71:"e52b11b3",72:"0bc1aea5",73:"6d5d5a2a",74:"2e878921",75:"983cb32a",76:"145f2172",77:"df4bb34c",78:"1e77be3e",79:"0ad9c015",80:"416408ff",81:"eb404af0",82:"2b1cfb3a",83:"0013d355",84:"e3a48da5",85:"c6e875d2",86:"2844609d",87:"e896369a",88:"a1349b9d",89:"df37502a",90:"818e4bbb",91:"00aa7cd4",92:"feea8339",93:"aaac3817",94:"f0e082bd",95:"3fd8d63c",96:"36fafdd5",97:"e986bf2b",98:"07d68a71",99:"a64cd409"}[n]+".js"}(n);var l=new Error;i=function(e){s.onerror=s.onload=null,clearTimeout(d);var t=a[n];if(0!==t){if(t){var r=e&&("load"===e.type?"missing":e.type),i=e&&e.target&&e.target.src;l.message="Loading chunk "+n+" failed.\n("+r+": "+i+")",l.name="ChunkLoadError",l.type=r,l.request=i,t[1](l)}a[n]=void 0}};var d=setTimeout((function(){i({type:"timeout",target:s})}),12e4);s.onerror=s.onload=i,document.head.appendChild(s)}return Promise.all(e)},o.m=n,o.c=r,o.d=function(n,e,t){o.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},o.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},o.t=function(n,e){if(1&e&&(n=o(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(o.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var r in n)o.d(t,r,function(e){return n[e]}.bind(null,r));return t},o.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return o.d(e,"a",e),e},o.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},o.p="/",o.oe=function(n){throw console.error(n),n};var s=window.webpackJsonp=window.webpackJsonp||[],l=s.push.bind(s);s.push=e,s=s.slice();for(var d=0;d<s.length;d++)e(s[d]);var c=l;i.push([97,0]),t()}([function(n,e,t){"use strict";t.d(e,"a",(function(){return Ut}));
/*!
 * Vue.js v2.7.8
 * (c) 2014-2022 Evan You
 * Released under the MIT License.
 */
var r=Object.freeze({}),a=Array.isArray;function i(n){return null==n}function o(n){return null!=n}function s(n){return!0===n}function l(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function d(n){return"function"==typeof n}function c(n){return null!==n&&"object"==typeof n}var u=Object.prototype.toString;function h(n){return"[object Object]"===u.call(n)}function p(n){return"[object RegExp]"===u.call(n)}function f(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function m(n){return o(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function g(n){return null==n?"":Array.isArray(n)||h(n)&&n.toString===u?JSON.stringify(n,null,2):String(n)}function v(n){var e=parseFloat(n);return isNaN(e)?n:e}function b(n,e){for(var t=Object.create(null),r=n.split(","),a=0;a<r.length;a++)t[r[a]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}b("slot,component",!0);var y=b("key,ref,slot,slot-scope,is");function x(n,e){if(n.length){var t=n.indexOf(e);if(t>-1)return n.splice(t,1)}}var _=Object.prototype.hasOwnProperty;function w(n,e){return _.call(n,e)}function N(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var k=/-(\w)/g,j=N((function(n){return n.replace(k,(function(n,e){return e?e.toUpperCase():""}))})),S=N((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),T=/\B([A-Z])/g,C=N((function(n){return n.replace(T,"-$1").toLowerCase()}));var A=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var r=arguments.length;return r?r>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function z(n,e){e=e||0;for(var t=n.length-e,r=new Array(t);t--;)r[t]=n[t+e];return r}function O(n,e){for(var t in e)n[t]=e[t];return n}function P(n){for(var e={},t=0;t<n.length;t++)n[t]&&O(e,n[t]);return e}function I(n,e,t){}var E=function(n,e,t){return!1},L=function(n){return n};function M(n,e){if(n===e)return!0;var t=c(n),r=c(e);if(!t||!r)return!t&&!r&&String(n)===String(e);try{var a=Array.isArray(n),i=Array.isArray(e);if(a&&i)return n.length===e.length&&n.every((function(n,t){return M(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(a||i)return!1;var o=Object.keys(n),s=Object.keys(e);return o.length===s.length&&o.every((function(t){return M(n[t],e[t])}))}catch(n){return!1}}function V(n,e){for(var t=0;t<n.length;t++)if(M(n[t],e))return t;return-1}function R(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}function $(n,e){return n===e?0===n&&1/n!=1/e:n==n||e==e}var D=["component","directive","filter"],q=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch","renderTracked","renderTriggered"],F={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:E,isReservedAttr:E,isUnknownElement:E,getTagNamespace:I,parsePlatformTagName:L,mustUseProp:E,async:!0,_lifecycleHooks:q},B=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function H(n){var e=(n+"").charCodeAt(0);return 36===e||95===e}function U(n,e,t,r){Object.defineProperty(n,e,{value:t,enumerable:!!r,writable:!0,configurable:!0})}var K=new RegExp("[^".concat(B.source,".$_\\d]"));var J="__proto__"in{},Y="undefined"!=typeof window,W=Y&&window.navigator.userAgent.toLowerCase(),X=W&&/msie|trident/.test(W),G=W&&W.indexOf("msie 9.0")>0,Q=W&&W.indexOf("edge/")>0;W&&W.indexOf("android");var Z=W&&/iphone|ipad|ipod|ios/.test(W);W&&/chrome\/\d+/.test(W),W&&/phantomjs/.test(W);var nn,en=W&&W.match(/firefox\/(\d+)/),tn={}.watch,rn=!1;if(Y)try{var an={};Object.defineProperty(an,"passive",{get:function(){rn=!0}}),window.addEventListener("test-passive",null,an)}catch(n){}var on=function(){return void 0===nn&&(nn=!Y&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),nn},sn=Y&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function ln(n){return"function"==typeof n&&/native code/.test(n.toString())}var dn,cn="undefined"!=typeof Symbol&&ln(Symbol)&&"undefined"!=typeof Reflect&&ln(Reflect.ownKeys);dn="undefined"!=typeof Set&&ln(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var un=null;function hn(n){void 0===n&&(n=null),n||un&&un._scope.off(),un=n,n&&n._scope.on()}var pn=function(){function n(n,e,t,r,a,i,o,s){this.tag=n,this.data=e,this.children=t,this.text=r,this.elm=a,this.ns=void 0,this.context=i,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=o,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=s,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}return Object.defineProperty(n.prototype,"child",{get:function(){return this.componentInstance},enumerable:!1,configurable:!0}),n}(),fn=function(n){void 0===n&&(n="");var e=new pn;return e.text=n,e.isComment=!0,e};function mn(n){return new pn(void 0,void 0,void 0,String(n))}function gn(n){var e=new pn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}var vn=0,bn=function(){function n(){this.id=vn++,this.subs=[]}return n.prototype.addSub=function(n){this.subs.push(n)},n.prototype.removeSub=function(n){x(this.subs,n)},n.prototype.depend=function(e){n.target&&n.target.addDep(this)},n.prototype.notify=function(n){var e=this.subs.slice();for(var t=0,r=e.length;t<r;t++){e[t].update()}},n}();bn.target=null;var yn=[];function xn(n){yn.push(n),bn.target=n}function _n(){yn.pop(),bn.target=yn[yn.length-1]}var wn=Array.prototype,Nn=Object.create(wn);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=wn[n];U(Nn,n,(function(){for(var t=[],r=0;r<arguments.length;r++)t[r]=arguments[r];var a,i=e.apply(this,t),o=this.__ob__;switch(n){case"push":case"unshift":a=t;break;case"splice":a=t.slice(2)}return a&&o.observeArray(a),o.dep.notify(),i}))}));var kn=Object.getOwnPropertyNames(Nn),jn={},Sn=!0;function Tn(n){Sn=n}var Cn={notify:I,depend:I,addSub:I,removeSub:I},An=function(){function n(n,e,t){if(void 0===e&&(e=!1),void 0===t&&(t=!1),this.value=n,this.shallow=e,this.mock=t,this.dep=t?Cn:new bn,this.vmCount=0,U(n,"__ob__",this),a(n)){if(!t)if(J)n.__proto__=Nn;else for(var r=0,i=kn.length;r<i;r++){U(n,s=kn[r],Nn[s])}e||this.observeArray(n)}else{var o=Object.keys(n);for(r=0;r<o.length;r++){var s;On(n,s=o[r],jn,void 0,e,t)}}}return n.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)zn(n[e],!1,this.mock)},n}();function zn(n,e,t){var r;if(!(!c(n)||Rn(n)||n instanceof pn))return w(n,"__ob__")&&n.__ob__ instanceof An?r=n.__ob__:!Sn||!t&&on()||!a(n)&&!h(n)||!Object.isExtensible(n)||n.__v_skip||(r=new An(n,e,t)),r}function On(n,e,t,r,i,o){var s=new bn,l=Object.getOwnPropertyDescriptor(n,e);if(!l||!1!==l.configurable){var d=l&&l.get,c=l&&l.set;d&&!c||t!==jn&&2!==arguments.length||(t=n[e]);var u=!i&&zn(t,!1,o);return Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=d?d.call(n):t;return bn.target&&(s.depend(),u&&(u.dep.depend(),a(e)&&En(e))),Rn(e)&&!i?e.value:e},set:function(e){var r=d?d.call(n):t;if($(r,e)){if(c)c.call(n,e);else{if(d)return;if(!i&&Rn(r)&&!Rn(e))return void(r.value=e);t=e}u=!i&&zn(e,!1,o),s.notify()}}}),s}}function Pn(n,e,t){if(!Vn(n)){var r=n.__ob__;return a(n)&&f(e)?(n.length=Math.max(n.length,e),n.splice(e,1,t),r&&!r.shallow&&r.mock&&zn(t,!1,!0),t):e in n&&!(e in Object.prototype)?(n[e]=t,t):n._isVue||r&&r.vmCount?t:r?(On(r.value,e,t,void 0,r.shallow,r.mock),r.dep.notify(),t):(n[e]=t,t)}}function In(n,e){if(a(n)&&f(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||Vn(n)||w(n,e)&&(delete n[e],t&&t.dep.notify())}}function En(n){for(var e=void 0,t=0,r=n.length;t<r;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),a(e)&&En(e)}function Ln(n){return Mn(n,!0),U(n,"__v_isShallow",!0),n}function Mn(n,e){if(!Vn(n)){zn(n,e,on());0}}function Vn(n){return!(!n||!n.__v_isReadonly)}function Rn(n){return!(!n||!0!==n.__v_isRef)}function $n(n,e,t){Object.defineProperty(n,t,{enumerable:!0,configurable:!0,get:function(){var n=e[t];if(Rn(n))return n.value;var r=n&&n.__ob__;return r&&r.dep.depend(),n},set:function(n){var r=e[t];Rn(r)&&!Rn(n)?r.value=n:e[t]=n}})}"".concat("watcher"," callback"),"".concat("watcher"," getter"),"".concat("watcher"," cleanup");var Dn;var qn=function(){function n(n){void 0===n&&(n=!1),this.active=!0,this.effects=[],this.cleanups=[],!n&&Dn&&(this.parent=Dn,this.index=(Dn.scopes||(Dn.scopes=[])).push(this)-1)}return n.prototype.run=function(n){if(this.active){var e=Dn;try{return Dn=this,n()}finally{Dn=e}}else 0},n.prototype.on=function(){Dn=this},n.prototype.off=function(){Dn=this.parent},n.prototype.stop=function(n){if(this.active){var e=void 0,t=void 0;for(e=0,t=this.effects.length;e<t;e++)this.effects[e].teardown();for(e=0,t=this.cleanups.length;e<t;e++)this.cleanups[e]();if(this.scopes)for(e=0,t=this.scopes.length;e<t;e++)this.scopes[e].stop(!0);if(this.parent&&!n){var r=this.parent.scopes.pop();r&&r!==this&&(this.parent.scopes[this.index]=r,r.index=this.index)}this.active=!1}},n}();function Fn(n){var e=n._provided,t=n.$parent&&n.$parent._provided;return t===e?n._provided=Object.create(t):e}var Bn=N((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),r="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=r?n.slice(1):n,once:t,capture:r,passive:e}}));function Hn(n,e){function t(){var n=t.fns;if(!a(n))return Se(n,null,arguments,e,"v-on handler");for(var r=n.slice(),i=0;i<r.length;i++)Se(r[i],null,arguments,e,"v-on handler")}return t.fns=n,t}function Un(n,e,t,r,a,o){var l,d,c,u;for(l in n)d=n[l],c=e[l],u=Bn(l),i(d)||(i(c)?(i(d.fns)&&(d=n[l]=Hn(d,o)),s(u.once)&&(d=n[l]=a(u.name,d,u.capture)),t(u.name,d,u.capture,u.passive,u.params)):d!==c&&(c.fns=d,n[l]=c));for(l in e)i(n[l])&&r((u=Bn(l)).name,e[l],u.capture)}function Kn(n,e,t){var r;n instanceof pn&&(n=n.data.hook||(n.data.hook={}));var a=n[e];function l(){t.apply(this,arguments),x(r.fns,l)}i(a)?r=Hn([l]):o(a.fns)&&s(a.merged)?(r=a).fns.push(l):r=Hn([a,l]),r.merged=!0,n[e]=r}function Jn(n,e,t,r,a){if(o(e)){if(w(e,t))return n[t]=e[t],a||delete e[t],!0;if(w(e,r))return n[t]=e[r],a||delete e[r],!0}return!1}function Yn(n){return l(n)?[mn(n)]:a(n)?function n(e,t){var r,d,c,u,h=[];for(r=0;r<e.length;r++)i(d=e[r])||"boolean"==typeof d||(c=h.length-1,u=h[c],a(d)?d.length>0&&(Wn((d=n(d,"".concat(t||"","_").concat(r)))[0])&&Wn(u)&&(h[c]=mn(u.text+d[0].text),d.shift()),h.push.apply(h,d)):l(d)?Wn(u)?h[c]=mn(u.text+d):""!==d&&h.push(mn(d)):Wn(d)&&Wn(u)?h[c]=mn(u.text+d.text):(s(e._isVList)&&o(d.tag)&&i(d.key)&&o(t)&&(d.key="__vlist".concat(t,"_").concat(r,"__")),h.push(d)));return h}(n):void 0}function Wn(n){return o(n)&&o(n.text)&&!1===n.isComment}function Xn(n,e){var t,r,i,s,l=null;if(a(n)||"string"==typeof n)for(l=new Array(n.length),t=0,r=n.length;t<r;t++)l[t]=e(n[t],t);else if("number"==typeof n)for(l=new Array(n),t=0;t<n;t++)l[t]=e(t+1,t);else if(c(n))if(cn&&n[Symbol.iterator]){l=[];for(var d=n[Symbol.iterator](),u=d.next();!u.done;)l.push(e(u.value,l.length)),u=d.next()}else for(i=Object.keys(n),l=new Array(i.length),t=0,r=i.length;t<r;t++)s=i[t],l[t]=e(n[s],s,t);return o(l)||(l=[]),l._isVList=!0,l}function Gn(n,e,t,r){var a,i=this.$scopedSlots[n];i?(t=t||{},r&&(t=O(O({},r),t)),a=i(t)||(d(e)?e():e)):a=this.$slots[n]||(d(e)?e():e);var o=t&&t.slot;return o?this.$createElement("template",{slot:o},a):a}function Qn(n){return At(this.$options,"filters",n,!0)||L}function Zn(n,e){return a(n)?-1===n.indexOf(e):n!==e}function ne(n,e,t,r,a){var i=F.keyCodes[e]||t;return a&&r&&!F.keyCodes[e]?Zn(a,r):i?Zn(i,n):r?C(r)!==e:void 0===n}function ee(n,e,t,r,i){if(t)if(c(t)){a(t)&&(t=P(t));var o=void 0,s=function(a){if("class"===a||"style"===a||y(a))o=n;else{var s=n.attrs&&n.attrs.type;o=r||F.mustUseProp(e,s,a)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var l=j(a),d=C(a);l in o||d in o||(o[a]=t[a],i&&((n.on||(n.on={}))["update:".concat(a)]=function(n){t[a]=n}))};for(var l in t)s(l)}else;return n}function te(n,e){var t=this._staticTrees||(this._staticTrees=[]),r=t[n];return r&&!e||ae(r=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,this._c,this),"__static__".concat(n),!1),r}function re(n,e,t){return ae(n,"__once__".concat(e).concat(t?"_".concat(t):""),!0),n}function ae(n,e,t){if(a(n))for(var r=0;r<n.length;r++)n[r]&&"string"!=typeof n[r]&&ie(n[r],"".concat(e,"_").concat(r),t);else ie(n,e,t)}function ie(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function oe(n,e){if(e)if(h(e)){var t=n.on=n.on?O({},n.on):{};for(var r in e){var a=t[r],i=e[r];t[r]=a?[].concat(a,i):i}}else;return n}function se(n,e,t,r){e=e||{$stable:!t};for(var i=0;i<n.length;i++){var o=n[i];a(o)?se(o,e,t):o&&(o.proxy&&(o.fn.proxy=!0),e[o.key]=o.fn)}return r&&(e.$key=r),e}function le(n,e){for(var t=0;t<e.length;t+=2){var r=e[t];"string"==typeof r&&r&&(n[e[t]]=e[t+1])}return n}function de(n,e){return"string"==typeof n?e+n:n}function ce(n){n._o=re,n._n=v,n._s=g,n._l=Xn,n._t=Gn,n._q=M,n._i=V,n._m=te,n._f=Qn,n._k=ne,n._b=ee,n._v=mn,n._e=fn,n._u=se,n._g=oe,n._d=le,n._p=de}function ue(n,e){if(!n||!n.length)return{};for(var t={},r=0,a=n.length;r<a;r++){var i=n[r],o=i.data;if(o&&o.attrs&&o.attrs.slot&&delete o.attrs.slot,i.context!==e&&i.fnContext!==e||!o||null==o.slot)(t.default||(t.default=[])).push(i);else{var s=o.slot,l=t[s]||(t[s]=[]);"template"===i.tag?l.push.apply(l,i.children||[]):l.push(i)}}for(var d in t)t[d].every(he)&&delete t[d];return t}function he(n){return n.isComment&&!n.asyncFactory||" "===n.text}function pe(n){return n.isComment&&n.asyncFactory}function fe(n,e,t,a){var i,o=Object.keys(t).length>0,s=e?!!e.$stable:!o,l=e&&e.$key;if(e){if(e._normalized)return e._normalized;if(s&&a&&a!==r&&l===a.$key&&!o&&!a.$hasNormal)return a;for(var d in i={},e)e[d]&&"$"!==d[0]&&(i[d]=me(n,t,d,e[d]))}else i={};for(var c in t)c in i||(i[c]=ge(t,c));return e&&Object.isExtensible(e)&&(e._normalized=i),U(i,"$stable",s),U(i,"$key",l),U(i,"$hasNormal",o),i}function me(n,e,t,r){var i=function(){var e=un;hn(n);var t=arguments.length?r.apply(null,arguments):r({}),i=(t=t&&"object"==typeof t&&!a(t)?[t]:Yn(t))&&t[0];return hn(e),t&&(!i||1===t.length&&i.isComment&&!pe(i))?void 0:t};return r.proxy&&Object.defineProperty(e,t,{get:i,enumerable:!0,configurable:!0}),i}function ge(n,e){return function(){return n[e]}}function ve(n){return{get attrs(){if(!n._attrsProxy){var e=n._attrsProxy={};U(e,"_v_attr_proxy",!0),be(e,n.$attrs,r,n,"$attrs")}return n._attrsProxy},get listeners(){n._listenersProxy||be(n._listenersProxy={},n.$listeners,r,n,"$listeners");return n._listenersProxy},get slots(){return function(n){n._slotsProxy||xe(n._slotsProxy={},n.$scopedSlots);return n._slotsProxy}(n)},emit:A(n.$emit,n),expose:function(e){e&&Object.keys(e).forEach((function(t){return $n(n,e,t)}))}}}function be(n,e,t,r,a){var i=!1;for(var o in e)o in n?e[o]!==t[o]&&(i=!0):(i=!0,ye(n,o,r,a));for(var o in n)o in e||(i=!0,delete n[o]);return i}function ye(n,e,t,r){Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){return t[r][e]}})}function xe(n,e){for(var t in e)n[t]=e[t];for(var t in n)t in e||delete n[t]}var _e=null;function we(n,e){return(n.__esModule||cn&&"Module"===n[Symbol.toStringTag])&&(n=n.default),c(n)?e.extend(n):n}function Ne(n){if(a(n))for(var e=0;e<n.length;e++){var t=n[e];if(o(t)&&(o(t.componentOptions)||pe(t)))return t}}function ke(n,e,t,r,u,h){return(a(t)||l(t))&&(u=r,r=t,t=void 0),s(h)&&(u=2),function(n,e,t,r,l){if(o(t)&&o(t.__ob__))return fn();o(t)&&o(t.is)&&(e=t.is);if(!e)return fn();0;a(r)&&d(r[0])&&((t=t||{}).scopedSlots={default:r[0]},r.length=0);2===l?r=Yn(r):1===l&&(r=function(n){for(var e=0;e<n.length;e++)if(a(n[e]))return Array.prototype.concat.apply([],n);return n}(r));var u,h;if("string"==typeof e){var p=void 0;h=n.$vnode&&n.$vnode.ns||F.getTagNamespace(e),u=F.isReservedTag(e)?new pn(F.parsePlatformTagName(e),t,r,void 0,void 0,n):t&&t.pre||!o(p=At(n.$options,"components",e))?new pn(e,t,r,void 0,void 0,n):yt(p,t,n,r,e)}else u=yt(e,t,n,r);return a(u)?u:o(u)?(o(h)&&function n(e,t,r){e.ns=t,"foreignObject"===e.tag&&(t=void 0,r=!0);if(o(e.children))for(var a=0,l=e.children.length;a<l;a++){var d=e.children[a];o(d.tag)&&(i(d.ns)||s(r)&&"svg"!==d.tag)&&n(d,t,r)}}(u,h),o(t)&&function(n){c(n.style)&&qe(n.style);c(n.class)&&qe(n.class)}(t),u):fn()}(n,e,t,r,u)}function je(n,e,t){xn();try{if(e)for(var r=e;r=r.$parent;){var a=r.$options.errorCaptured;if(a)for(var i=0;i<a.length;i++)try{if(!1===a[i].call(r,n,e,t))return}catch(n){Te(n,r,"errorCaptured hook")}}Te(n,e,t)}finally{_n()}}function Se(n,e,t,r,a){var i;try{(i=t?n.apply(e,t):n.call(e))&&!i._isVue&&m(i)&&!i._handled&&(i.catch((function(n){return je(n,r,a+" (Promise/async)")})),i._handled=!0)}catch(n){je(n,r,a)}return i}function Te(n,e,t){if(F.errorHandler)try{return F.errorHandler.call(null,n,e,t)}catch(e){e!==n&&Ce(e,null,"config.errorHandler")}Ce(n,e,t)}function Ce(n,e,t){if(!Y||"undefined"==typeof console)throw n;console.error(n)}var Ae,ze=!1,Oe=[],Pe=!1;function Ie(){Pe=!1;var n=Oe.slice(0);Oe.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&ln(Promise)){var Ee=Promise.resolve();Ae=function(){Ee.then(Ie),Z&&setTimeout(I)},ze=!0}else if(X||"undefined"==typeof MutationObserver||!ln(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Ae="undefined"!=typeof setImmediate&&ln(setImmediate)?function(){setImmediate(Ie)}:function(){setTimeout(Ie,0)};else{var Le=1,Me=new MutationObserver(Ie),Ve=document.createTextNode(String(Le));Me.observe(Ve,{characterData:!0}),Ae=function(){Le=(Le+1)%2,Ve.data=String(Le)},ze=!0}function Re(n,e){var t;if(Oe.push((function(){if(n)try{n.call(e)}catch(n){je(n,e,"nextTick")}else t&&t(e)})),Pe||(Pe=!0,Ae()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}function $e(n){return function(e,t){if(void 0===t&&(t=un),t)return function(n,e,t){var r=n.$options;r[e]=jt(r[e],t)}(t,n,e)}}$e("beforeMount"),$e("mounted"),$e("beforeUpdate"),$e("updated"),$e("beforeDestroy"),$e("destroyed"),$e("errorCaptured"),$e("activated"),$e("deactivated"),$e("serverPrefetch"),$e("renderTracked"),$e("renderTriggered");var De=new dn;function qe(n){return function n(e,t){var r,i,o=a(e);if(!o&&!c(e)||Object.isFrozen(e)||e instanceof pn)return;if(e.__ob__){var s=e.__ob__.dep.id;if(t.has(s))return;t.add(s)}if(o)for(r=e.length;r--;)n(e[r],t);else if(Rn(e))n(e.value,t);else for(i=Object.keys(e),r=i.length;r--;)n(e[i[r]],t)}(n,De),De.clear(),n}var Fe,Be=0,He=function(){function n(n,e,t,r,a){var i,o;i=this,void 0===(o=Dn||(n?n._scope:void 0))&&(o=Dn),o&&o.active&&o.effects.push(i),(this.vm=n)&&a&&(n._watcher=this),r?(this.deep=!!r.deep,this.user=!!r.user,this.lazy=!!r.lazy,this.sync=!!r.sync,this.before=r.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++Be,this.active=!0,this.post=!1,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new dn,this.newDepIds=new dn,this.expression="",d(e)?this.getter=e:(this.getter=function(n){if(!K.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=I)),this.value=this.lazy?void 0:this.get()}return n.prototype.get=function(){var n;xn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;je(n,e,'getter for watcher "'.concat(this.expression,'"'))}finally{this.deep&&qe(n),_n(),this.cleanupDeps()}return n},n.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},n.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},n.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():ut(this)},n.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||c(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'.concat(this.expression,'"');Se(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},n.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},n.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},n.prototype.teardown=function(){if(this.vm&&!this.vm._isBeingDestroyed&&x(this.vm._scope.effects,this),this.active){for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1,this.onStop&&this.onStop()}},n}();function Ue(n,e){Fe.$on(n,e)}function Ke(n,e){Fe.$off(n,e)}function Je(n,e){var t=Fe;return function r(){var a=e.apply(null,arguments);null!==a&&t.$off(n,r)}}function Ye(n,e,t){Fe=n,Un(e,t||{},Ue,Ke,Je,n),Fe=void 0}var We=null;function Xe(n){var e=We;return We=n,function(){We=e}}function Ge(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function Qe(n,e){if(e){if(n._directInactive=!1,Ge(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)Qe(n.$children[t]);Ze(n,"activated")}}function Ze(n,e,t,r){void 0===r&&(r=!0),xn();var a=un;r&&hn(n);var i=n.$options[e],o="".concat(e," hook");if(i)for(var s=0,l=i.length;s<l;s++)Se(i[s],n,t||null,n,o);n._hasHookEvent&&n.$emit("hook:"+e),r&&hn(a),_n()}var nt=[],et=[],tt={},rt=!1,at=!1,it=0;var ot=0,st=Date.now;if(Y&&!X){var lt=window.performance;lt&&"function"==typeof lt.now&&st()>document.createEvent("Event").timeStamp&&(st=function(){return lt.now()})}var dt=function(n,e){if(n.post){if(!e.post)return 1}else if(e.post)return-1;return n.id-e.id};function ct(){var n,e;for(ot=st(),at=!0,nt.sort(dt),it=0;it<nt.length;it++)(n=nt[it]).before&&n.before(),e=n.id,tt[e]=null,n.run();var t=et.slice(),r=nt.slice();it=nt.length=et.length=0,tt={},rt=at=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,Qe(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],r=t.vm;r&&r._watcher===t&&r._isMounted&&!r._isDestroyed&&Ze(r,"updated")}}(r),sn&&F.devtools&&sn.emit("flush")}function ut(n){var e=n.id;if(null==tt[e]&&(n!==bn.target||!n.noRecurse)){if(tt[e]=!0,at){for(var t=nt.length-1;t>it&&nt[t].id>n.id;)t--;nt.splice(t+1,0,n)}else nt.push(n);rt||(rt=!0,Re(ct))}}function ht(n,e){if(n){for(var t=Object.create(null),r=cn?Reflect.ownKeys(n):Object.keys(n),a=0;a<r.length;a++){var i=r[a];if("__ob__"!==i){var o=n[i].from;if(o in e._provided)t[i]=e._provided[o];else if("default"in n[i]){var s=n[i].default;t[i]=d(s)?s.call(e):s}else 0}}return t}}function pt(n,e,t,i,o){var l,d=this,c=o.options;w(i,"_uid")?(l=Object.create(i))._original=i:(l=i,i=i._original);var u=s(c._compiled),h=!u;this.data=n,this.props=e,this.children=t,this.parent=i,this.listeners=n.on||r,this.injections=ht(c.inject,i),this.slots=function(){return d.$slots||fe(i,n.scopedSlots,d.$slots=ue(t,i)),d.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return fe(i,n.scopedSlots,this.slots())}}),u&&(this.$options=c,this.$slots=this.slots(),this.$scopedSlots=fe(i,n.scopedSlots,this.$slots)),c._scopeId?this._c=function(n,e,t,r){var o=ke(l,n,e,t,r,h);return o&&!a(o)&&(o.fnScopeId=c._scopeId,o.fnContext=i),o}:this._c=function(n,e,t,r){return ke(l,n,e,t,r,h)}}function ft(n,e,t,r,a){var i=gn(n);return i.fnContext=t,i.fnOptions=r,e.slot&&((i.data||(i.data={})).slot=e.slot),i}function mt(n,e){for(var t in e)n[j(t)]=e[t]}function gt(n){return n.name||n.__name||n._componentTag}ce(pt.prototype);var vt={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;vt.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},r=n.data.inlineTemplate;o(r)&&(t.render=r.render,t.staticRenderFns=r.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,We)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,a,i){var o=a.data.scopedSlots,s=n.$scopedSlots,l=!!(o&&!o.$stable||s!==r&&!s.$stable||o&&n.$scopedSlots.$key!==o.$key||!o&&n.$scopedSlots.$key),d=!!(i||n.$options._renderChildren||l),c=n.$vnode;n.$options._parentVnode=a,n.$vnode=a,n._vnode&&(n._vnode.parent=a),n.$options._renderChildren=i;var u=a.data.attrs||r;n._attrsProxy&&be(n._attrsProxy,u,c.data&&c.data.attrs||r,n,"$attrs")&&(d=!0),n.$attrs=u,t=t||r;var h=n.$options._parentListeners;if(n._listenersProxy&&be(n._listenersProxy,t,h||r,n,"$listeners"),n.$listeners=n.$options._parentListeners=t,Ye(n,t,h),e&&n.$options.props){Tn(!1);for(var p=n._props,f=n.$options._propKeys||[],m=0;m<f.length;m++){var g=f[m],v=n.$options.props;p[g]=zt(g,v,e,n)}Tn(!0),n.$options.propsData=e}d&&(n.$slots=ue(i,a.context),n.$forceUpdate())}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,r=n.componentInstance;r._isMounted||(r._isMounted=!0,Ze(r,"mounted")),n.data.keepAlive&&(t._isMounted?((e=r)._inactive=!1,et.push(e)):Qe(r,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(!(t&&(e._directInactive=!0,Ge(e))||e._inactive)){e._inactive=!0;for(var r=0;r<e.$children.length;r++)n(e.$children[r]);Ze(e,"deactivated")}}(e,!0):e.$destroy())}},bt=Object.keys(vt);function yt(n,e,t,l,d){if(!i(n)){var u=t.$options._base;if(c(n)&&(n=u.extend(n)),"function"==typeof n){var h;if(i(n.cid)&&void 0===(n=function(n,e){if(s(n.error)&&o(n.errorComp))return n.errorComp;if(o(n.resolved))return n.resolved;var t=_e;if(t&&o(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t),s(n.loading)&&o(n.loadingComp))return n.loadingComp;if(t&&!o(n.owners)){var r=n.owners=[t],a=!0,l=null,d=null;t.$on("hook:destroyed",(function(){return x(r,t)}));var u=function(n){for(var e=0,t=r.length;e<t;e++)r[e].$forceUpdate();n&&(r.length=0,null!==l&&(clearTimeout(l),l=null),null!==d&&(clearTimeout(d),d=null))},h=R((function(t){n.resolved=we(t,e),a?r.length=0:u(!0)})),p=R((function(e){o(n.errorComp)&&(n.error=!0,u(!0))})),f=n(h,p);return c(f)&&(m(f)?i(n.resolved)&&f.then(h,p):m(f.component)&&(f.component.then(h,p),o(f.error)&&(n.errorComp=we(f.error,e)),o(f.loading)&&(n.loadingComp=we(f.loading,e),0===f.delay?n.loading=!0:l=setTimeout((function(){l=null,i(n.resolved)&&i(n.error)&&(n.loading=!0,u(!1))}),f.delay||200)),o(f.timeout)&&(d=setTimeout((function(){d=null,i(n.resolved)&&p(null)}),f.timeout)))),a=!1,n.loading?n.loadingComp:n.resolved}}(h=n,u)))return function(n,e,t,r,a){var i=fn();return i.asyncFactory=n,i.asyncMeta={data:e,context:t,children:r,tag:a},i}(h,e,t,l,d);e=e||{},Ht(n),o(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",r=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var i=e.on||(e.on={}),s=i[r],l=e.model.callback;o(s)?(a(s)?-1===s.indexOf(l):s!==l)&&(i[r]=[l].concat(s)):i[r]=l}(n.options,e);var p=function(n,e,t){var r=e.options.props;if(!i(r)){var a={},s=n.attrs,l=n.props;if(o(s)||o(l))for(var d in r){var c=C(d);Jn(a,l,d,c,!0)||Jn(a,s,d,c,!1)}return a}}(e,n);if(s(n.options.functional))return function(n,e,t,i,s){var l=n.options,d={},c=l.props;if(o(c))for(var u in c)d[u]=zt(u,c,e||r);else o(t.attrs)&&mt(d,t.attrs),o(t.props)&&mt(d,t.props);var h=new pt(t,d,s,i,n),p=l.render.call(null,h._c,h);if(p instanceof pn)return ft(p,t,h.parent,l,h);if(a(p)){for(var f=Yn(p)||[],m=new Array(f.length),g=0;g<f.length;g++)m[g]=ft(f[g],t,h.parent,l,h);return m}}(n,p,e,t,l);var f=e.on;if(e.on=e.nativeOn,s(n.options.abstract)){var g=e.slot;e={},g&&(e.slot=g)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<bt.length;t++){var r=bt[t],a=e[r],i=vt[r];a===i||a&&a._merged||(e[r]=a?xt(i,a):i)}}(e);var v=gt(n.options)||d;return new pn("vue-component-".concat(n.cid).concat(v?"-".concat(v):""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:p,listeners:f,tag:d,children:l},h)}}}function xt(n,e){var t=function(t,r){n(t,r),e(t,r)};return t._merged=!0,t}var _t=I,wt=F.optionMergeStrategies;function Nt(n,e){if(!e)return n;for(var t,r,a,i=cn?Reflect.ownKeys(e):Object.keys(e),o=0;o<i.length;o++)"__ob__"!==(t=i[o])&&(r=n[t],a=e[t],w(n,t)?r!==a&&h(r)&&h(a)&&Nt(r,a):Pn(n,t,a));return n}function kt(n,e,t){return t?function(){var r=d(e)?e.call(t,t):e,a=d(n)?n.call(t,t):n;return r?Nt(r,a):a}:e?n?function(){return Nt(d(e)?e.call(this,this):e,d(n)?n.call(this,this):n)}:e:n}function jt(n,e){var t=e?n?n.concat(e):a(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function St(n,e,t,r){var a=Object.create(n||null);return e?O(a,e):a}wt.data=function(n,e,t){return t?kt(n,e,t):e&&"function"!=typeof e?n:kt(n,e)},q.forEach((function(n){wt[n]=jt})),D.forEach((function(n){wt[n+"s"]=St})),wt.watch=function(n,e,t,r){if(n===tn&&(n=void 0),e===tn&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var i={};for(var o in O(i,n),e){var s=i[o],l=e[o];s&&!a(s)&&(s=[s]),i[o]=s?s.concat(l):a(l)?l:[l]}return i},wt.props=wt.methods=wt.inject=wt.computed=function(n,e,t,r){if(!n)return e;var a=Object.create(null);return O(a,n),e&&O(a,e),a},wt.provide=kt;var Tt=function(n,e){return void 0===e?n:e};function Ct(n,e,t){if(d(e)&&(e=e.options),function(n,e){var t=n.props;if(t){var r,i,o={};if(a(t))for(r=t.length;r--;)"string"==typeof(i=t[r])&&(o[j(i)]={type:null});else if(h(t))for(var s in t)i=t[s],o[j(s)]=h(i)?i:{type:i};else 0;n.props=o}}(e),function(n,e){var t=n.inject;if(t){var r=n.inject={};if(a(t))for(var i=0;i<t.length;i++)r[t[i]]={from:t[i]};else if(h(t))for(var o in t){var s=t[o];r[o]=h(s)?O({from:o},s):{from:s}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var r=e[t];d(r)&&(e[t]={bind:r,update:r})}}(e),!e._base&&(e.extends&&(n=Ct(n,e.extends,t)),e.mixins))for(var r=0,i=e.mixins.length;r<i;r++)n=Ct(n,e.mixins[r],t);var o,s={};for(o in n)l(o);for(o in e)w(n,o)||l(o);function l(r){var a=wt[r]||Tt;s[r]=a(n[r],e[r],t,r)}return s}function At(n,e,t,r){if("string"==typeof t){var a=n[e];if(w(a,t))return a[t];var i=j(t);if(w(a,i))return a[i];var o=S(i);return w(a,o)?a[o]:a[t]||a[i]||a[o]}}function zt(n,e,t,r){var a=e[n],i=!w(t,n),o=t[n],s=Et(Boolean,a.type);if(s>-1)if(i&&!w(a,"default"))o=!1;else if(""===o||o===C(n)){var l=Et(String,a.type);(l<0||s<l)&&(o=!0)}if(void 0===o){o=function(n,e,t){if(!w(e,"default"))return;var r=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return d(r)&&"Function"!==Pt(e.type)?r.call(n):r}(r,a,n);var c=Sn;Tn(!0),zn(o),Tn(c)}return o}var Ot=/^\s*function (\w+)/;function Pt(n){var e=n&&n.toString().match(Ot);return e?e[1]:""}function It(n,e){return Pt(n)===Pt(e)}function Et(n,e){if(!a(e))return It(e,n)?0:-1;for(var t=0,r=e.length;t<r;t++)if(It(e[t],n))return t;return-1}var Lt={enumerable:!0,configurable:!0,get:I,set:I};function Mt(n,e,t){Lt.get=function(){return this[e][t]},Lt.set=function(n){this[e][t]=n},Object.defineProperty(n,t,Lt)}function Vt(n){var e=n.$options;if(e.props&&function(n,e){var t=n.$options.propsData||{},r=n._props=Ln({}),a=n.$options._propKeys=[];n.$parent&&Tn(!1);var i=function(i){a.push(i);var o=zt(i,e,t,n);On(r,i,o),i in n||Mt(n,"_props",i)};for(var o in e)i(o);Tn(!0)}(n,e.props),function(n){var e=n.$options,t=e.setup;if(t){var r=n._setupContext=ve(n);hn(n),xn();var a=Se(t,null,[n._props||Ln({}),r],n,"setup");if(_n(),hn(),d(a))e.render=a;else if(c(a))if(n._setupState=a,a.__sfc){var i=n._setupProxy={};for(var o in a)"__sfc"!==o&&$n(i,a,o)}else for(var o in a)H(o)||$n(n,a,o);else 0}}(n),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?I:A(e[t],n)}(n,e.methods),e.data)!function(n){var e=n.$options.data;h(e=n._data=d(e)?function(n,e){xn();try{return n.call(e,e)}catch(n){return je(n,e,"data()"),{}}finally{_n()}}(e,n):e||{})||(e={});var t=Object.keys(e),r=n.$options.props,a=(n.$options.methods,t.length);for(;a--;){var i=t[a];0,r&&w(r,i)||H(i)||Mt(n,"_data",i)}var o=zn(e);o&&o.vmCount++}(n);else{var t=zn(n._data={});t&&t.vmCount++}e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),r=on();for(var a in e){var i=e[a],o=d(i)?i:i.get;0,r||(t[a]=new He(n,o||I,I,Rt)),a in n||$t(n,a,i)}}(n,e.computed),e.watch&&e.watch!==tn&&function(n,e){for(var t in e){var r=e[t];if(a(r))for(var i=0;i<r.length;i++)Ft(n,t,r[i]);else Ft(n,t,r)}}(n,e.watch)}var Rt={lazy:!0};function $t(n,e,t){var r=!on();d(t)?(Lt.get=r?Dt(e):qt(t),Lt.set=I):(Lt.get=t.get?r&&!1!==t.cache?Dt(e):qt(t.get):I,Lt.set=t.set||I),Object.defineProperty(n,e,Lt)}function Dt(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),bn.target&&e.depend(),e.value}}function qt(n){return function(){return n.call(this,this)}}function Ft(n,e,t,r){return h(t)&&(r=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,r)}var Bt=0;function Ht(n){var e=n.options;if(n.super){var t=Ht(n.super);if(t!==n.superOptions){n.superOptions=t;var r=function(n){var e,t=n.options,r=n.sealedOptions;for(var a in t)t[a]!==r[a]&&(e||(e={}),e[a]=t[a]);return e}(n);r&&O(n.extendOptions,r),(e=n.options=Ct(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function Ut(n){this._init(n)}function Kt(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,r=t.cid,a=n._Ctor||(n._Ctor={});if(a[r])return a[r];var i=gt(n)||gt(t.options);var o=function(n){this._init(n)};return(o.prototype=Object.create(t.prototype)).constructor=o,o.cid=e++,o.options=Ct(t.options,n),o.super=t,o.options.props&&function(n){var e=n.options.props;for(var t in e)Mt(n.prototype,"_props",t)}(o),o.options.computed&&function(n){var e=n.options.computed;for(var t in e)$t(n.prototype,t,e[t])}(o),o.extend=t.extend,o.mixin=t.mixin,o.use=t.use,D.forEach((function(n){o[n]=t[n]})),i&&(o.options.components[i]=o),o.superOptions=t.options,o.extendOptions=n,o.sealedOptions=O({},o.options),a[r]=o,o}}function Jt(n){return n&&(gt(n.Ctor.options)||n.tag)}function Yt(n,e){return a(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!p(n)&&n.test(e)}function Wt(n,e){var t=n.cache,r=n.keys,a=n._vnode;for(var i in t){var o=t[i];if(o){var s=o.name;s&&!e(s)&&Xt(t,i,r,a)}}}function Xt(n,e,t,r){var a=n[e];!a||r&&a.tag===r.tag||a.componentInstance.$destroy(),n[e]=null,x(t,e)}!function(n){n.prototype._init=function(n){var e=this;e._uid=Bt++,e._isVue=!0,e.__v_skip=!0,e._scope=new qn(!0),n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),r=e._parentVnode;t.parent=e.parent,t._parentVnode=r;var a=r.componentOptions;t.propsData=a.propsData,t._parentListeners=a.listeners,t._renderChildren=a.children,t._componentTag=a.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=Ct(Ht(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._provided=t?t._provided:Object.create(null),n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Ye(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,a=t&&t.context;n.$slots=ue(e._renderChildren,a),n.$scopedSlots=t?fe(n.$parent,t.data.scopedSlots,n.$slots):r,n._c=function(e,t,r,a){return ke(n,e,t,r,a,!1)},n.$createElement=function(e,t,r,a){return ke(n,e,t,r,a,!0)};var i=t&&t.data;On(n,"$attrs",i&&i.attrs||r,null,!0),On(n,"$listeners",e._parentListeners||r,null,!0)}(e),Ze(e,"beforeCreate",void 0,!1),function(n){var e=ht(n.$options.inject,n);e&&(Tn(!1),Object.keys(e).forEach((function(t){On(n,t,e[t])})),Tn(!0))}(e),Vt(e),function(n){var e=n.$options.provide;if(e){var t=d(e)?e.call(n):e;if(!c(t))return;for(var r=Fn(n),a=cn?Reflect.ownKeys(t):Object.keys(t),i=0;i<a.length;i++){var o=a[i];Object.defineProperty(r,o,Object.getOwnPropertyDescriptor(t,o))}}}(e),Ze(e,"created"),e.$options.el&&e.$mount(e.$options.el)}}(Ut),function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=Pn,n.prototype.$delete=In,n.prototype.$watch=function(n,e,t){if(h(e))return Ft(this,n,e,t);(t=t||{}).user=!0;var r=new He(this,n,e,t);if(t.immediate){var a='callback for immediate watcher "'.concat(r.expression,'"');xn(),Se(e,this,[r.value],this,a),_n()}return function(){r.teardown()}}}(Ut),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var r=this;if(a(n))for(var i=0,o=n.length;i<o;i++)r.$on(n[i],t);else(r._events[n]||(r._events[n]=[])).push(t),e.test(n)&&(r._hasHookEvent=!0);return r},n.prototype.$once=function(n,e){var t=this;function r(){t.$off(n,r),e.apply(t,arguments)}return r.fn=e,t.$on(n,r),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(a(n)){for(var r=0,i=n.length;r<i;r++)t.$off(n[r],e);return t}var o,s=t._events[n];if(!s)return t;if(!e)return t._events[n]=null,t;for(var l=s.length;l--;)if((o=s[l])===e||o.fn===e){s.splice(l,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?z(t):t;for(var r=z(arguments,1),a='event handler for "'.concat(n,'"'),i=0,o=t.length;i<o;i++)Se(t[i],e,r,e,a)}return e}}(Ut),function(n){n.prototype._update=function(n,e){var t=this,r=t.$el,a=t._vnode,i=Xe(t);t._vnode=n,t.$el=a?t.__patch__(a,n):t.__patch__(t.$el,n,e,!1),i(),r&&(r.__vue__=null),t.$el&&(t.$el.__vue__=t),t.$vnode&&t.$parent&&t.$vnode===t.$parent._vnode&&(t.$parent.$el=t.$el)},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){Ze(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||x(e.$children,n),n._scope.stop(),n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),Ze(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(Ut),function(n){ce(n.prototype),n.prototype.$nextTick=function(n){return Re(n,this)},n.prototype._render=function(){var n,e=this,t=e.$options,r=t.render,i=t._parentVnode;i&&e._isMounted&&(e.$scopedSlots=fe(e.$parent,i.data.scopedSlots,e.$slots,e.$scopedSlots),e._slotsProxy&&xe(e._slotsProxy,e.$scopedSlots)),e.$vnode=i;try{hn(e),_e=e,n=r.call(e._renderProxy,e.$createElement)}catch(t){je(t,e,"render"),n=e._vnode}finally{_e=null,hn()}return a(n)&&1===n.length&&(n=n[0]),n instanceof pn||(n=fn()),n.parent=i,n}}(Ut);var Gt=[String,RegExp,Array],Qt={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Gt,exclude:Gt,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,r=this.keyToCache;if(t){var a=t.tag,i=t.componentInstance,o=t.componentOptions;n[r]={name:Jt(o),tag:a,componentInstance:i},e.push(r),this.max&&e.length>parseInt(this.max)&&Xt(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)Xt(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){Wt(n,(function(n){return Yt(e,n)}))})),this.$watch("exclude",(function(e){Wt(n,(function(n){return!Yt(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=Ne(n),t=e&&e.componentOptions;if(t){var r=Jt(t),a=this.include,i=this.exclude;if(a&&(!r||!Yt(a,r))||i&&r&&Yt(i,r))return e;var o=this.cache,s=this.keys,l=null==e.key?t.Ctor.cid+(t.tag?"::".concat(t.tag):""):e.key;o[l]?(e.componentInstance=o[l].componentInstance,x(s,l),s.push(l)):(this.vnodeToCache=e,this.keyToCache=l),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return F}};Object.defineProperty(n,"config",e),n.util={warn:_t,extend:O,mergeOptions:Ct,defineReactive:On},n.set=Pn,n.delete=In,n.nextTick=Re,n.observable=function(n){return zn(n),n},n.options=Object.create(null),D.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,O(n.options.components,Qt),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=z(arguments,1);return t.unshift(this),d(n.install)?n.install.apply(n,t):d(n)&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=Ct(this.options,n),this}}(n),Kt(n),function(n){D.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&h(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&d(t)&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(Ut),Object.defineProperty(Ut.prototype,"$isServer",{get:on}),Object.defineProperty(Ut.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Ut,"FunctionalRenderContext",{value:pt}),Ut.version="2.7.8";var Zt=b("style,class"),nr=b("input,textarea,option,select,progress"),er=b("contenteditable,draggable,spellcheck"),tr=b("events,caret,typing,plaintext-only"),rr=b("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),ar="http://www.w3.org/1999/xlink",ir=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},or=function(n){return ir(n)?n.slice(6,n.length):""},sr=function(n){return null==n||!1===n};function lr(n){for(var e=n.data,t=n,r=n;o(r.componentInstance);)(r=r.componentInstance._vnode)&&r.data&&(e=dr(r.data,e));for(;o(t=t.parent);)t&&t.data&&(e=dr(e,t.data));return function(n,e){if(o(n)||o(e))return cr(n,ur(e));return""}(e.staticClass,e.class)}function dr(n,e){return{staticClass:cr(n.staticClass,e.staticClass),class:o(n.class)?[n.class,e.class]:e.class}}function cr(n,e){return n?e?n+" "+e:n:e||""}function ur(n){return Array.isArray(n)?function(n){for(var e,t="",r=0,a=n.length;r<a;r++)o(e=ur(n[r]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):c(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var hr={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},pr=b("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),fr=b("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),mr=function(n){return pr(n)||fr(n)};var gr=Object.create(null);var vr=b("text,number,password,search,email,tel,url");var br=Object.freeze({__proto__:null,createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(hr[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),yr={create:function(n,e){xr(e)},update:function(n,e){n.data.ref!==e.data.ref&&(xr(n,!0),xr(e))},destroy:function(n){xr(n,!0)}};function xr(n,e){var t=n.data.ref;if(o(t)){var r=n.context,i=n.componentInstance||n.elm,s=e?null:i,l=e?void 0:i;if(d(t))Se(t,r,[s],r,"template ref function");else{var c=n.data.refInFor,u="string"==typeof t||"number"==typeof t,h=Rn(t),p=r.$refs;if(u||h)if(c){var f=u?p[t]:t.value;e?a(f)&&x(f,i):a(f)?f.includes(i)||f.push(i):u?(p[t]=[i],_r(r,t,p[t])):t.value=[i]}else if(u){if(e&&p[t]!==i)return;p[t]=l,_r(r,t,s)}else if(h){if(e&&t.value!==i)return;t.value=s}else 0}}}function _r(n,e,t){var r=n._setupState;r&&w(r,e)&&(Rn(r[e])?r[e].value=t:r[e]=t)}var wr=new pn("",{},[]),Nr=["create","activate","update","remove","destroy"];function kr(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&o(n.data)===o(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,r=o(t=n.data)&&o(t=t.attrs)&&t.type,a=o(t=e.data)&&o(t=t.attrs)&&t.type;return r===a||vr(r)&&vr(a)}(n,e)||s(n.isAsyncPlaceholder)&&i(e.asyncFactory.error))}function jr(n,e,t){var r,a,i={};for(r=e;r<=t;++r)o(a=n[r].key)&&(i[a]=r);return i}var Sr={create:Tr,update:Tr,destroy:function(n){Tr(n,wr)}};function Tr(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,r,a,i=n===wr,o=e===wr,s=Ar(n.data.directives,n.context),l=Ar(e.data.directives,e.context),d=[],c=[];for(t in l)r=s[t],a=l[t],r?(a.oldValue=r.value,a.oldArg=r.arg,Or(a,"update",e,n),a.def&&a.def.componentUpdated&&c.push(a)):(Or(a,"bind",e,n),a.def&&a.def.inserted&&d.push(a));if(d.length){var u=function(){for(var t=0;t<d.length;t++)Or(d[t],"inserted",e,n)};i?Kn(e,"insert",u):u()}c.length&&Kn(e,"postpatch",(function(){for(var t=0;t<c.length;t++)Or(c[t],"componentUpdated",e,n)}));if(!i)for(t in s)l[t]||Or(s[t],"unbind",n,n,o)}(n,e)}var Cr=Object.create(null);function Ar(n,e){var t,r,a=Object.create(null);if(!n)return a;for(t=0;t<n.length;t++)(r=n[t]).modifiers||(r.modifiers=Cr),a[zr(r)]=r,e._setupState&&e._setupState.__sfc&&(r.def=r.def||At(e,"_setupState","v-"+r.name)),r.def=r.def||At(e.$options,"directives",r.name);return a}function zr(n){return n.rawName||"".concat(n.name,".").concat(Object.keys(n.modifiers||{}).join("."))}function Or(n,e,t,r,a){var i=n.def&&n.def[e];if(i)try{i(t.elm,n,t,r,a)}catch(r){je(r,t.context,"directive ".concat(n.name," ").concat(e," hook"))}}var Pr=[yr,Sr];function Ir(n,e){var t=e.componentOptions;if(!(o(t)&&!1===t.Ctor.options.inheritAttrs||i(n.data.attrs)&&i(e.data.attrs))){var r,a,l=e.elm,d=n.data.attrs||{},c=e.data.attrs||{};for(r in(o(c.__ob__)||s(c._v_attr_proxy))&&(c=e.data.attrs=O({},c)),c)a=c[r],d[r]!==a&&Er(l,r,a,e.data.pre);for(r in(X||Q)&&c.value!==d.value&&Er(l,"value",c.value),d)i(c[r])&&(ir(r)?l.removeAttributeNS(ar,or(r)):er(r)||l.removeAttribute(r))}}function Er(n,e,t,r){r||n.tagName.indexOf("-")>-1?Lr(n,e,t):rr(e)?sr(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):er(e)?n.setAttribute(e,function(n,e){return sr(e)||"false"===e?"false":"contenteditable"===n&&tr(e)?e:"true"}(e,t)):ir(e)?sr(t)?n.removeAttributeNS(ar,or(e)):n.setAttributeNS(ar,e,t):Lr(n,e,t)}function Lr(n,e,t){if(sr(t))n.removeAttribute(e);else{if(X&&!G&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var r=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",r)};n.addEventListener("input",r),n.__ieph=!0}n.setAttribute(e,t)}}var Mr={create:Ir,update:Ir};function Vr(n,e){var t=e.elm,r=e.data,a=n.data;if(!(i(r.staticClass)&&i(r.class)&&(i(a)||i(a.staticClass)&&i(a.class)))){var s=lr(e),l=t._transitionClasses;o(l)&&(s=cr(s,ur(l))),s!==t._prevClass&&(t.setAttribute("class",s),t._prevClass=s)}}var Rr,$r={create:Vr,update:Vr};function Dr(n,e,t){var r=Rr;return function a(){var i=e.apply(null,arguments);null!==i&&Br(n,a,t,r)}}var qr=ze&&!(en&&Number(en[1])<=53);function Fr(n,e,t,r){if(qr){var a=ot,i=e;e=i._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=a||n.timeStamp<=0||n.target.ownerDocument!==document)return i.apply(this,arguments)}}Rr.addEventListener(n,e,rn?{capture:t,passive:r}:t)}function Br(n,e,t,r){(r||Rr).removeEventListener(n,e._wrapper||e,t)}function Hr(n,e){if(!i(n.data.on)||!i(e.data.on)){var t=e.data.on||{},r=n.data.on||{};Rr=e.elm||n.elm,function(n){if(o(n.__r)){var e=X?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}o(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),Un(t,r,Fr,Br,Dr,e.context),Rr=void 0}}var Ur,Kr={create:Hr,update:Hr,destroy:function(n){return Hr(n,wr)}};function Jr(n,e){if(!i(n.data.domProps)||!i(e.data.domProps)){var t,r,a=e.elm,l=n.data.domProps||{},d=e.data.domProps||{};for(t in(o(d.__ob__)||s(d._v_attr_proxy))&&(d=e.data.domProps=O({},d)),l)t in d||(a[t]="");for(t in d){if(r=d[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),r===l[t])continue;1===a.childNodes.length&&a.removeChild(a.childNodes[0])}if("value"===t&&"PROGRESS"!==a.tagName){a._value=r;var c=i(r)?"":String(r);Yr(a,c)&&(a.value=c)}else if("innerHTML"===t&&fr(a.tagName)&&i(a.innerHTML)){(Ur=Ur||document.createElement("div")).innerHTML="<svg>".concat(r,"</svg>");for(var u=Ur.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;u.firstChild;)a.appendChild(u.firstChild)}else if(r!==l[t])try{a[t]=r}catch(n){}}}}function Yr(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,r=n._vModifiers;if(o(r)){if(r.number)return v(t)!==v(e);if(r.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var Wr={create:Jr,update:Jr},Xr=N((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var r=n.split(t);r.length>1&&(e[r[0].trim()]=r[1].trim())}})),e}));function Gr(n){var e=Qr(n.style);return n.staticStyle?O(n.staticStyle,e):e}function Qr(n){return Array.isArray(n)?P(n):"string"==typeof n?Xr(n):n}var Zr,na=/^--/,ea=/\s*!important$/,ta=function(n,e,t){if(na.test(e))n.style.setProperty(e,t);else if(ea.test(t))n.style.setProperty(C(e),t.replace(ea,""),"important");else{var r=aa(e);if(Array.isArray(t))for(var a=0,i=t.length;a<i;a++)n.style[r]=t[a];else n.style[r]=t}},ra=["Webkit","Moz","ms"],aa=N((function(n){if(Zr=Zr||document.createElement("div").style,"filter"!==(n=j(n))&&n in Zr)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<ra.length;t++){var r=ra[t]+e;if(r in Zr)return r}}));function ia(n,e){var t=e.data,r=n.data;if(!(i(t.staticStyle)&&i(t.style)&&i(r.staticStyle)&&i(r.style))){var a,s,l=e.elm,d=r.staticStyle,c=r.normalizedStyle||r.style||{},u=d||c,h=Qr(e.data.style)||{};e.data.normalizedStyle=o(h.__ob__)?O({},h):h;var p=function(n,e){var t,r={};if(e)for(var a=n;a.componentInstance;)(a=a.componentInstance._vnode)&&a.data&&(t=Gr(a.data))&&O(r,t);(t=Gr(n.data))&&O(r,t);for(var i=n;i=i.parent;)i.data&&(t=Gr(i.data))&&O(r,t);return r}(e,!0);for(s in u)i(p[s])&&ta(l,s,"");for(s in p)(a=p[s])!==u[s]&&ta(l,s,null==a?"":a)}}var oa={create:ia,update:ia},sa=/\s+/;function la(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(sa).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" ".concat(n.getAttribute("class")||""," ");t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function da(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(sa).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" ".concat(n.getAttribute("class")||""," "),r=" "+e+" ";t.indexOf(r)>=0;)t=t.replace(r," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function ca(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&O(e,ua(n.name||"v")),O(e,n),e}return"string"==typeof n?ua(n):void 0}}var ua=N((function(n){return{enterClass:"".concat(n,"-enter"),enterToClass:"".concat(n,"-enter-to"),enterActiveClass:"".concat(n,"-enter-active"),leaveClass:"".concat(n,"-leave"),leaveToClass:"".concat(n,"-leave-to"),leaveActiveClass:"".concat(n,"-leave-active")}})),ha=Y&&!G,pa="transition",fa="transitionend",ma="animation",ga="animationend";ha&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(pa="WebkitTransition",fa="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(ma="WebkitAnimation",ga="webkitAnimationEnd"));var va=Y?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function ba(n){va((function(){va(n)}))}function ya(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),la(n,e))}function xa(n,e){n._transitionClasses&&x(n._transitionClasses,e),da(n,e)}function _a(n,e,t){var r=Na(n,e),a=r.type,i=r.timeout,o=r.propCount;if(!a)return t();var s="transition"===a?fa:ga,l=0,d=function(){n.removeEventListener(s,c),t()},c=function(e){e.target===n&&++l>=o&&d()};setTimeout((function(){l<o&&d()}),i+1),n.addEventListener(s,c)}var wa=/\b(transform|all)(,|$)/;function Na(n,e){var t,r=window.getComputedStyle(n),a=(r[pa+"Delay"]||"").split(", "),i=(r[pa+"Duration"]||"").split(", "),o=ka(a,i),s=(r[ma+"Delay"]||"").split(", "),l=(r[ma+"Duration"]||"").split(", "),d=ka(s,l),c=0,u=0;return"transition"===e?o>0&&(t="transition",c=o,u=i.length):"animation"===e?d>0&&(t="animation",c=d,u=l.length):u=(t=(c=Math.max(o,d))>0?o>d?"transition":"animation":null)?"transition"===t?i.length:l.length:0,{type:t,timeout:c,propCount:u,hasTransform:"transition"===t&&wa.test(r[pa+"Property"])}}function ka(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return ja(e)+ja(n[t])})))}function ja(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function Sa(n,e){var t=n.elm;o(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var r=ca(n.data.transition);if(!i(r)&&!o(t._enterCb)&&1===t.nodeType){for(var a=r.css,s=r.type,l=r.enterClass,u=r.enterToClass,h=r.enterActiveClass,p=r.appearClass,f=r.appearToClass,m=r.appearActiveClass,g=r.beforeEnter,b=r.enter,y=r.afterEnter,x=r.enterCancelled,_=r.beforeAppear,w=r.appear,N=r.afterAppear,k=r.appearCancelled,j=r.duration,S=We,T=We.$vnode;T&&T.parent;)S=T.context,T=T.parent;var C=!S._isMounted||!n.isRootInsert;if(!C||w||""===w){var A=C&&p?p:l,z=C&&m?m:h,O=C&&f?f:u,P=C&&_||g,I=C&&d(w)?w:b,E=C&&N||y,L=C&&k||x,M=v(c(j)?j.enter:j);0;var V=!1!==a&&!G,$=Aa(I),D=t._enterCb=R((function(){V&&(xa(t,O),xa(t,z)),D.cancelled?(V&&xa(t,A),L&&L(t)):E&&E(t),t._enterCb=null}));n.data.show||Kn(n,"insert",(function(){var e=t.parentNode,r=e&&e._pending&&e._pending[n.key];r&&r.tag===n.tag&&r.elm._leaveCb&&r.elm._leaveCb(),I&&I(t,D)})),P&&P(t),V&&(ya(t,A),ya(t,z),ba((function(){xa(t,A),D.cancelled||(ya(t,O),$||(Ca(M)?setTimeout(D,M):_a(t,s,D)))}))),n.data.show&&(e&&e(),I&&I(t,D)),V||$||D()}}}function Ta(n,e){var t=n.elm;o(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var r=ca(n.data.transition);if(i(r)||1!==t.nodeType)return e();if(!o(t._leaveCb)){var a=r.css,s=r.type,l=r.leaveClass,d=r.leaveToClass,u=r.leaveActiveClass,h=r.beforeLeave,p=r.leave,f=r.afterLeave,m=r.leaveCancelled,g=r.delayLeave,b=r.duration,y=!1!==a&&!G,x=Aa(p),_=v(c(b)?b.leave:b);0;var w=t._leaveCb=R((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),y&&(xa(t,d),xa(t,u)),w.cancelled?(y&&xa(t,l),m&&m(t)):(e(),f&&f(t)),t._leaveCb=null}));g?g(N):N()}function N(){w.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),h&&h(t),y&&(ya(t,l),ya(t,u),ba((function(){xa(t,l),w.cancelled||(ya(t,d),x||(Ca(_)?setTimeout(w,_):_a(t,s,w)))}))),p&&p(t,w),y||x||w())}}function Ca(n){return"number"==typeof n&&!isNaN(n)}function Aa(n){if(i(n))return!1;var e=n.fns;return o(e)?Aa(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function za(n,e){!0!==e.data.show&&Sa(e)}var Oa=function(n){var e,t,r={},d=n.modules,c=n.nodeOps;for(e=0;e<Nr.length;++e)for(r[Nr[e]]=[],t=0;t<d.length;++t)o(d[t][Nr[e]])&&r[Nr[e]].push(d[t][Nr[e]]);function u(n){var e=c.parentNode(n);o(e)&&c.removeChild(e,n)}function h(n,e,t,a,i,l,d){if(o(n.elm)&&o(l)&&(n=l[d]=gn(n)),n.isRootInsert=!i,!function(n,e,t,a){var i=n.data;if(o(i)){var l=o(n.componentInstance)&&i.keepAlive;if(o(i=i.hook)&&o(i=i.init)&&i(n,!1),o(n.componentInstance))return p(n,e),f(t,n.elm,a),s(l)&&function(n,e,t,a){var i,s=n;for(;s.componentInstance;)if(s=s.componentInstance._vnode,o(i=s.data)&&o(i=i.transition)){for(i=0;i<r.activate.length;++i)r.activate[i](wr,s);e.push(s);break}f(t,n.elm,a)}(n,e,t,a),!0}}(n,e,t,a)){var u=n.data,h=n.children,g=n.tag;o(g)?(n.elm=n.ns?c.createElementNS(n.ns,g):c.createElement(g,n),y(n),m(n,h,e),o(u)&&v(n,e),f(t,n.elm,a)):s(n.isComment)?(n.elm=c.createComment(n.text),f(t,n.elm,a)):(n.elm=c.createTextNode(n.text),f(t,n.elm,a))}}function p(n,e){o(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,g(n)?(v(n,e),y(n)):(xr(n),e.push(n))}function f(n,e,t){o(n)&&(o(t)?c.parentNode(t)===n&&c.insertBefore(n,e,t):c.appendChild(n,e))}function m(n,e,t){if(a(e)){0;for(var r=0;r<e.length;++r)h(e[r],t,n.elm,null,!0,e,r)}else l(n.text)&&c.appendChild(n.elm,c.createTextNode(String(n.text)))}function g(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return o(n.tag)}function v(n,t){for(var a=0;a<r.create.length;++a)r.create[a](wr,n);o(e=n.data.hook)&&(o(e.create)&&e.create(wr,n),o(e.insert)&&t.push(n))}function y(n){var e;if(o(e=n.fnScopeId))c.setStyleScope(n.elm,e);else for(var t=n;t;)o(e=t.context)&&o(e=e.$options._scopeId)&&c.setStyleScope(n.elm,e),t=t.parent;o(e=We)&&e!==n.context&&e!==n.fnContext&&o(e=e.$options._scopeId)&&c.setStyleScope(n.elm,e)}function x(n,e,t,r,a,i){for(;r<=a;++r)h(t[r],i,n,e,!1,t,r)}function _(n){var e,t,a=n.data;if(o(a))for(o(e=a.hook)&&o(e=e.destroy)&&e(n),e=0;e<r.destroy.length;++e)r.destroy[e](n);if(o(e=n.children))for(t=0;t<n.children.length;++t)_(n.children[t])}function w(n,e,t){for(;e<=t;++e){var r=n[e];o(r)&&(o(r.tag)?(N(r),_(r)):u(r.elm))}}function N(n,e){if(o(e)||o(n.data)){var t,a=r.remove.length+1;for(o(e)?e.listeners+=a:e=function(n,e){function t(){0==--t.listeners&&u(n)}return t.listeners=e,t}(n.elm,a),o(t=n.componentInstance)&&o(t=t._vnode)&&o(t.data)&&N(t,e),t=0;t<r.remove.length;++t)r.remove[t](n,e);o(t=n.data.hook)&&o(t=t.remove)?t(n,e):e()}else u(n.elm)}function k(n,e,t,r){for(var a=t;a<r;a++){var i=e[a];if(o(i)&&kr(n,i))return a}}function j(n,e,t,a,l,d){if(n!==e){o(e.elm)&&o(a)&&(e=a[l]=gn(e));var u=e.elm=n.elm;if(s(n.isAsyncPlaceholder))o(e.asyncFactory.resolved)?C(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(s(e.isStatic)&&s(n.isStatic)&&e.key===n.key&&(s(e.isCloned)||s(e.isOnce)))e.componentInstance=n.componentInstance;else{var p,f=e.data;o(f)&&o(p=f.hook)&&o(p=p.prepatch)&&p(n,e);var m=n.children,v=e.children;if(o(f)&&g(e)){for(p=0;p<r.update.length;++p)r.update[p](n,e);o(p=f.hook)&&o(p=p.update)&&p(n,e)}i(e.text)?o(m)&&o(v)?m!==v&&function(n,e,t,r,a){var s,l,d,u=0,p=0,f=e.length-1,m=e[0],g=e[f],v=t.length-1,b=t[0],y=t[v],_=!a;for(0;u<=f&&p<=v;)i(m)?m=e[++u]:i(g)?g=e[--f]:kr(m,b)?(j(m,b,r,t,p),m=e[++u],b=t[++p]):kr(g,y)?(j(g,y,r,t,v),g=e[--f],y=t[--v]):kr(m,y)?(j(m,y,r,t,v),_&&c.insertBefore(n,m.elm,c.nextSibling(g.elm)),m=e[++u],y=t[--v]):kr(g,b)?(j(g,b,r,t,p),_&&c.insertBefore(n,g.elm,m.elm),g=e[--f],b=t[++p]):(i(s)&&(s=jr(e,u,f)),i(l=o(b.key)?s[b.key]:k(b,e,u,f))?h(b,r,n,m.elm,!1,t,p):kr(d=e[l],b)?(j(d,b,r,t,p),e[l]=void 0,_&&c.insertBefore(n,d.elm,m.elm)):h(b,r,n,m.elm,!1,t,p),b=t[++p]);u>f?x(n,i(t[v+1])?null:t[v+1].elm,t,p,v,r):p>v&&w(e,u,f)}(u,m,v,t,d):o(v)?(o(n.text)&&c.setTextContent(u,""),x(u,null,v,0,v.length-1,t)):o(m)?w(m,0,m.length-1):o(n.text)&&c.setTextContent(u,""):n.text!==e.text&&c.setTextContent(u,e.text),o(f)&&o(p=f.hook)&&o(p=p.postpatch)&&p(n,e)}}}function S(n,e,t){if(s(t)&&o(n.parent))n.parent.data.pendingInsert=e;else for(var r=0;r<e.length;++r)e[r].data.hook.insert(e[r])}var T=b("attrs,class,staticClass,staticStyle,key");function C(n,e,t,r){var a,i=e.tag,l=e.data,d=e.children;if(r=r||l&&l.pre,e.elm=n,s(e.isComment)&&o(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(o(l)&&(o(a=l.hook)&&o(a=a.init)&&a(e,!0),o(a=e.componentInstance)))return p(e,t),!0;if(o(i)){if(o(d))if(n.hasChildNodes())if(o(a=l)&&o(a=a.domProps)&&o(a=a.innerHTML)){if(a!==n.innerHTML)return!1}else{for(var c=!0,u=n.firstChild,h=0;h<d.length;h++){if(!u||!C(u,d[h],t,r)){c=!1;break}u=u.nextSibling}if(!c||u)return!1}else m(e,d,t);if(o(l)){var f=!1;for(var g in l)if(!T(g)){f=!0,v(e,t);break}!f&&l.class&&qe(l.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,a){if(!i(e)){var l,d=!1,u=[];if(i(n))d=!0,h(e,u);else{var p=o(n.nodeType);if(!p&&kr(n,e))j(n,e,u,null,null,a);else{if(p){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),s(t)&&C(n,e,u))return S(e,u,!0),n;l=n,n=new pn(c.tagName(l).toLowerCase(),{},[],void 0,l)}var f=n.elm,m=c.parentNode(f);if(h(e,u,f._leaveCb?null:m,c.nextSibling(f)),o(e.parent))for(var v=e.parent,b=g(e);v;){for(var y=0;y<r.destroy.length;++y)r.destroy[y](v);if(v.elm=e.elm,b){for(var x=0;x<r.create.length;++x)r.create[x](wr,v);var N=v.data.hook.insert;if(N.merged)for(var k=1;k<N.fns.length;k++)N.fns[k]()}else xr(v);v=v.parent}o(m)?w([n],0,0):o(n.tag)&&_(n)}}return S(e,u,d),e.elm}o(n)&&_(n)}}({nodeOps:br,modules:[Mr,$r,Kr,Wr,oa,Y?{create:za,activate:za,remove:function(n,e){!0!==n.data.show?Ta(n,e):e()}}:{}].concat(Pr)});G&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&$a(n,"input")}));var Pa={inserted:function(n,e,t,r){"select"===t.tag?(r.elm&&!r.elm._vOptions?Kn(t,"postpatch",(function(){Pa.componentUpdated(n,e,t)})):Ia(n,e,t.context),n._vOptions=[].map.call(n.options,Ma)):("textarea"===t.tag||vr(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",Va),n.addEventListener("compositionend",Ra),n.addEventListener("change",Ra),G&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){Ia(n,e,t.context);var r=n._vOptions,a=n._vOptions=[].map.call(n.options,Ma);if(a.some((function(n,e){return!M(n,r[e])})))(n.multiple?e.value.some((function(n){return La(n,a)})):e.value!==e.oldValue&&La(e.value,a))&&$a(n,"change")}}};function Ia(n,e,t){Ea(n,e,t),(X||Q)&&setTimeout((function(){Ea(n,e,t)}),0)}function Ea(n,e,t){var r=e.value,a=n.multiple;if(!a||Array.isArray(r)){for(var i,o,s=0,l=n.options.length;s<l;s++)if(o=n.options[s],a)i=V(r,Ma(o))>-1,o.selected!==i&&(o.selected=i);else if(M(Ma(o),r))return void(n.selectedIndex!==s&&(n.selectedIndex=s));a||(n.selectedIndex=-1)}}function La(n,e){return e.every((function(e){return!M(e,n)}))}function Ma(n){return"_value"in n?n._value:n.value}function Va(n){n.target.composing=!0}function Ra(n){n.target.composing&&(n.target.composing=!1,$a(n.target,"input"))}function $a(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function Da(n){return!n.componentInstance||n.data&&n.data.transition?n:Da(n.componentInstance._vnode)}var qa={model:Pa,show:{bind:function(n,e,t){var r=e.value,a=(t=Da(t)).data&&t.data.transition,i=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;r&&a?(t.data.show=!0,Sa(t,(function(){n.style.display=i}))):n.style.display=r?i:"none"},update:function(n,e,t){var r=e.value;!r!=!e.oldValue&&((t=Da(t)).data&&t.data.transition?(t.data.show=!0,r?Sa(t,(function(){n.style.display=n.__vOriginalDisplay})):Ta(t,(function(){n.style.display="none"}))):n.style.display=r?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,r,a){a||(n.style.display=n.__vOriginalDisplay)}}},Fa={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function Ba(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?Ba(Ne(e.children)):n}function Ha(n){var e={},t=n.$options;for(var r in t.propsData)e[r]=n[r];var a=t._parentListeners;for(var r in a)e[j(r)]=a[r];return e}function Ua(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var Ka=function(n){return n.tag||pe(n)},Ja=function(n){return"show"===n.name},Ya={name:"transition",props:Fa,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(Ka)).length){0;var r=this.mode;0;var a=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return a;var i=Ba(a);if(!i)return a;if(this._leaving)return Ua(n,a);var o="__transition-".concat(this._uid,"-");i.key=null==i.key?i.isComment?o+"comment":o+i.tag:l(i.key)?0===String(i.key).indexOf(o)?i.key:o+i.key:i.key;var s=(i.data||(i.data={})).transition=Ha(this),d=this._vnode,c=Ba(d);if(i.data.directives&&i.data.directives.some(Ja)&&(i.data.show=!0),c&&c.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(i,c)&&!pe(c)&&(!c.componentInstance||!c.componentInstance._vnode.isComment)){var u=c.data.transition=O({},s);if("out-in"===r)return this._leaving=!0,Kn(u,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),Ua(n,a);if("in-out"===r){if(pe(i))return d;var h,p=function(){h()};Kn(s,"afterEnter",p),Kn(s,"enterCancelled",p),Kn(u,"delayLeave",(function(n){h=n}))}}return a}}},Wa=O({tag:String,moveClass:String},Fa);function Xa(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Ga(n){n.data.newPos=n.elm.getBoundingClientRect()}function Qa(n){var e=n.data.pos,t=n.data.newPos,r=e.left-t.left,a=e.top-t.top;if(r||a){n.data.moved=!0;var i=n.elm.style;i.transform=i.WebkitTransform="translate(".concat(r,"px,").concat(a,"px)"),i.transitionDuration="0s"}}delete Wa.mode;var Za={Transition:Ya,TransitionGroup:{props:Wa,beforeMount:function(){var n=this,e=this._update;this._update=function(t,r){var a=Xe(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,a(),e.call(n,t,r)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),r=this.prevChildren=this.children,a=this.$slots.default||[],i=this.children=[],o=Ha(this),s=0;s<a.length;s++){if((c=a[s]).tag)if(null!=c.key&&0!==String(c.key).indexOf("__vlist"))i.push(c),t[c.key]=c,(c.data||(c.data={})).transition=o;else;}if(r){var l=[],d=[];for(s=0;s<r.length;s++){var c;(c=r[s]).data.transition=o,c.data.pos=c.elm.getBoundingClientRect(),t[c.key]?l.push(c):d.push(c)}this.kept=n(e,null,l),this.removed=d}return n(e,null,i)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Xa),n.forEach(Ga),n.forEach(Qa),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,r=t.style;ya(t,e),r.transform=r.WebkitTransform=r.transitionDuration="",t.addEventListener(fa,t._moveCb=function n(r){r&&r.target!==t||r&&!/transform$/.test(r.propertyName)||(t.removeEventListener(fa,n),t._moveCb=null,xa(t,e))})}})))},methods:{hasMove:function(n,e){if(!ha)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){da(t,n)})),la(t,e),t.style.display="none",this.$el.appendChild(t);var r=Na(t);return this.$el.removeChild(t),this._hasMove=r.hasTransform}}}};Ut.config.mustUseProp=function(n,e,t){return"value"===t&&nr(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},Ut.config.isReservedTag=mr,Ut.config.isReservedAttr=Zt,Ut.config.getTagNamespace=function(n){return fr(n)?"svg":"math"===n?"math":void 0},Ut.config.isUnknownElement=function(n){if(!Y)return!0;if(mr(n))return!1;if(n=n.toLowerCase(),null!=gr[n])return gr[n];var e=document.createElement(n);return n.indexOf("-")>-1?gr[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:gr[n]=/HTMLUnknownElement/.test(e.toString())},O(Ut.options.directives,qa),O(Ut.options.components,Za),Ut.prototype.__patch__=Y?Oa:I,Ut.prototype.$mount=function(n,e){return function(n,e,t){var r;n.$el=e,n.$options.render||(n.$options.render=fn),Ze(n,"beforeMount"),r=function(){n._update(n._render(),t)},new He(n,r,I,{before:function(){n._isMounted&&!n._isDestroyed&&Ze(n,"beforeUpdate")}},!0),t=!1;var a=n._preWatchers;if(a)for(var i=0;i<a.length;i++)a[i].run();return null==n.$vnode&&(n._isMounted=!0,Ze(n,"mounted")),n}(this,n=n&&Y?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},Y&&setTimeout((function(){F.devtools&&sn&&sn.emit("init",Ut)}),0)},function(n,e){n.exports=function(n){return"function"==typeof n}},function(n,e,t){var r=t(25),a=Function.prototype,i=a.bind,o=a.call,s=r&&i.bind(o,o);n.exports=r?function(n){return n&&s(n)}:function(n){return n&&function(){return o.apply(n,arguments)}}},function(n,e){var t=function(n){return n&&n.Math==Math&&n};n.exports=t("object"==typeof globalThis&&globalThis)||t("object"==typeof window&&window)||t("object"==typeof self&&self)||t("object"==typeof global&&global)||function(){return this}()||Function("return this")()},function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){var r=t(66),a="object"==typeof self&&self&&self.Object===Object&&self,i=r||a||Function("return this")();n.exports=i},function(n,e,t){var r=t(4);n.exports=!r((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e,t){var r=t(2),a=t(45),i=r({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return i(a(n),e)}},function(n,e,t){var r=t(1);n.exports=function(n){return"object"==typeof n?null!==n:r(n)}},function(n,e,t){var r=t(151),a=t(154);n.exports=function(n,e){var t=a(n,e);return r(t)?t:void 0}},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){var r=t(13),a=t(136),i=t(137),o=r?r.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":o&&o in Object(n)?a(n):i(n)}},function(n,e,t){var r=t(6).Symbol;n.exports=r},function(n,e,t){"use strict";function r(n,e,t,r,a,i,o,s){var l,d="function"==typeof n?n.options:n;if(e&&(d.render=e,d.staticRenderFns=t,d._compiled=!0),r&&(d.functional=!0),i&&(d._scopeId="data-v-"+i),o?(l=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),a&&a.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(o)},d._ssrRegister=l):a&&(l=s?function(){a.call(this,(d.functional?this.parent:this).$root.$options.shadowRoot)}:a),l)if(d.functional){d._injectStyles=l;var c=d.render;d.render=function(n,e){return l.call(e),c(n,e)}}else{var u=d.beforeCreate;d.beforeCreate=u?[].concat(u,l):[l]}return{exports:n,options:d}}t.d(e,"a",(function(){return r}))},function(n,e,t){var r=t(7),a=t(60),i=t(92),o=t(24),s=t(51),l=TypeError,d=Object.defineProperty,c=Object.getOwnPropertyDescriptor;e.f=r?i?function(n,e,t){if(o(n),e=s(e),o(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var r=c(n,e);r&&r.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:r.configurable,enumerable:"enumerable"in t?t.enumerable:r.enumerable,writable:!1})}return d(n,e,t)}:d:function(n,e,t){if(o(n),e=s(e),o(t),a)try{return d(n,e,t)}catch(n){}if("get"in t||"set"in t)throw l("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var r=t(3),a=t(1),i=function(n){return a(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?i(r[n]):r[n]&&r[n][e]}},function(n,e,t){var r=t(7),a=t(15),i=t(29);n.exports=r?function(n,e,t){return a.f(n,e,i(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){var r=t(141),a=t(142),i=t(143),o=t(144),s=t(145);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=a,l.prototype.get=i,l.prototype.has=o,l.prototype.set=s,n.exports=l},function(n,e,t){var r=t(68);n.exports=function(n,e){for(var t=n.length;t--;)if(r(n[t][0],e))return t;return-1}},function(n,e,t){var r=t(10)(Object,"create");n.exports=r},function(n,e,t){var r=t(163);n.exports=function(n,e){var t=n.__data__;return r(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var r=t(40);n.exports=function(n){if("string"==typeof n||r(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){var r,a;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(a="function"==typeof(r=function(){var n,e,t={version:"0.2.0"},r=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function a(n,e,t){return n<e?e:n>t?t:n}function i(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(r[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=a(n,r.minimum,1),t.status=1===n?null:n;var l=t.render(!e),d=l.querySelector(r.barSelector),c=r.speed,u=r.easing;return l.offsetWidth,o((function(e){""===r.positionUsing&&(r.positionUsing=t.getPositioningCSS()),s(d,function(n,e,t){var a;return(a="translate3d"===r.positionUsing?{transform:"translate3d("+i(n)+"%,0,0)"}:"translate"===r.positionUsing?{transform:"translate("+i(n)+"%,0)"}:{"margin-left":i(n)+"%"}).transition="all "+e+"ms "+t,a}(n,c,u)),1===n?(s(l,{transition:"none",opacity:1}),l.offsetWidth,setTimeout((function(){s(l,{transition:"all "+c+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),c)}),c)):setTimeout(e,c)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),r.trickleSpeed)};return r.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*a(Math.random()*e,.1,.95)),e=a(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*r.trickleRate)},n=0,e=0,t.promise=function(r){return r&&"resolved"!==r.state()?(0===e&&t.start(),n++,e++,r.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");d(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=r.template;var a,o=e.querySelector(r.barSelector),l=n?"-100":i(t.status||0),c=document.querySelector(r.parent);return s(o,{transition:"all 0 linear",transform:"translate3d("+l+"%,0,0)"}),r.showSpinner||(a=e.querySelector(r.spinnerSelector))&&h(a),c!=document.body&&d(c,"nprogress-custom-parent"),c.appendChild(e),e},t.remove=function(){c(document.documentElement,"nprogress-busy"),c(document.querySelector(r.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&h(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var o=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),s=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var r,a=n.length,i=e.charAt(0).toUpperCase()+e.slice(1);a--;)if((r=n[a]+i)in t)return r;return e}(t))}function r(n,e,r){e=t(e),n.style[e]=r}return function(n,e){var t,a,i=arguments;if(2==i.length)for(t in e)void 0!==(a=e[t])&&e.hasOwnProperty(t)&&r(n,t,a);else r(n,i[1],i[2])}}();function l(n,e){return("string"==typeof n?n:u(n)).indexOf(" "+e+" ")>=0}function d(n,e){var t=u(n),r=t+e;l(t,e)||(n.className=r.substring(1))}function c(n,e){var t,r=u(n);l(n,e)&&(t=r.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function u(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function h(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?r.call(e,t,e,n):r)||(n.exports=a)},function(n,e,t){var r=t(9),a=String,i=TypeError;n.exports=function(n){if(r(n))return n;throw i(a(n)+" is not an object")}},function(n,e,t){var r=t(4);n.exports=!r((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e,t){var r=t(43),a=t(50);n.exports=function(n){return r(a(n))}},function(n,e,t){var r=t(3),a=t(57),i=t(8),o=t(59),s=t(55),l=t(54),d=a("wks"),c=r.Symbol,u=c&&c.for,h=l?c:c&&c.withoutSetter||o;n.exports=function(n){if(!i(d,n)||!s&&"string"!=typeof d[n]){var e="Symbol."+n;s&&i(c,n)?d[n]=c[n]:d[n]=l&&u?u(e):h(e)}return d[n]}},function(n,e,t){var r=t(25),a=Function.prototype.call;n.exports=r?a.bind(a):function(){return a.apply(a,arguments)}},function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){var r=t(2),a=r({}.toString),i=r("".slice);n.exports=function(n){return i(a(n),8,-1)}},function(n,e,t){var r=t(3),a=t(32),i=r["__core-js_shared__"]||a("__core-js_shared__",{});n.exports=i},function(n,e,t){var r=t(3),a=Object.defineProperty;n.exports=function(n,e){try{a(r,n,{value:e,configurable:!0,writable:!0})}catch(t){r[n]=e}return e}},function(n,e,t){var r=t(135),a=t(11),i=Object.prototype,o=i.hasOwnProperty,s=i.propertyIsEnumerable,l=r(function(){return arguments}())?r:function(n){return a(n)&&o.call(n,"callee")&&!s.call(n,"callee")};n.exports=l},function(n,e,t){var r=t(10)(t(6),"Map");n.exports=r},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var r=t(155),a=t(162),i=t(164),o=t(165),s=t(166);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=a,l.prototype.get=i,l.prototype.has=o,l.prototype.set=s,n.exports=l},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var r=t(5),a=t(40),i=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,o=/^\w*$/;n.exports=function(n,e){if(r(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!a(n))||(o.test(n)||!i.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var r=t(12),a=t(11);n.exports=function(n){return"symbol"==typeof n||a(n)&&"[object Symbol]"==r(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){var r=t(3),a=t(49).f,i=t(17),o=t(105),s=t(32),l=t(62),d=t(117);n.exports=function(n,e){var t,c,u,h,p,f=n.target,m=n.global,g=n.stat;if(t=m?r:g?r[f]||s(f,{}):(r[f]||{}).prototype)for(c in e){if(h=e[c],u=n.dontCallGetSet?(p=a(t,c))&&p.value:t[c],!d(m?c:f+(g?".":"#")+c,n.forced)&&void 0!==u){if(typeof h==typeof u)continue;l(h,u)}(n.sham||u&&u.sham)&&i(h,"sham",!0),o(t,c,h,n)}}},function(n,e,t){var r=t(2),a=t(4),i=t(30),o=Object,s=r("".split);n.exports=a((function(){return!o("z").propertyIsEnumerable(0)}))?function(n){return"String"==i(n)?s(n,""):o(n)}:o},function(n,e,t){var r=t(1),a=t(103),i=TypeError;n.exports=function(n){if(r(n))return n;throw i(a(n)+" is not a function")}},function(n,e,t){var r=t(50),a=Object;n.exports=function(n){return a(r(n))}},function(n,e){n.exports={}},function(n,e,t){var r=t(115);n.exports=function(n){return r(n.length)}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e,t){var r=t(7),a=t(28),i=t(99),o=t(29),s=t(26),l=t(51),d=t(8),c=t(60),u=Object.getOwnPropertyDescriptor;e.f=r?u:function(n,e){if(n=s(n),e=l(e),c)try{return u(n,e)}catch(n){}if(d(n,e))return o(!a(i.f,n,e),n[e])}},function(n,e){var t=TypeError;n.exports=function(n){if(null==n)throw t("Can't call method on "+n);return n}},function(n,e,t){var r=t(100),a=t(52);n.exports=function(n){var e=r(n,"string");return a(e)?e:e+""}},function(n,e,t){var r=t(16),a=t(1),i=t(53),o=t(54),s=Object;n.exports=o?function(n){return"symbol"==typeof n}:function(n){var e=r("Symbol");return a(e)&&i(e.prototype,s(n))}},function(n,e,t){var r=t(2);n.exports=r({}.isPrototypeOf)},function(n,e,t){var r=t(55);n.exports=r&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){var r=t(56),a=t(4);n.exports=!!Object.getOwnPropertySymbols&&!a((function(){var n=Symbol();return!String(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&r&&r<41}))},function(n,e,t){var r,a,i=t(3),o=t(101),s=i.process,l=i.Deno,d=s&&s.versions||l&&l.version,c=d&&d.v8;c&&(a=(r=c.split("."))[0]>0&&r[0]<4?1:+(r[0]+r[1])),!a&&o&&(!(r=o.match(/Edge\/(\d+)/))||r[1]>=74)&&(r=o.match(/Chrome\/(\d+)/))&&(a=+r[1]),n.exports=a},function(n,e,t){var r=t(58),a=t(31);(n.exports=function(n,e){return a[n]||(a[n]=void 0!==e?e:{})})("versions",[]).push({version:"3.24.0",mode:r?"pure":"global",copyright:"© 2014-2022 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.24.0/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e){n.exports=!1},function(n,e,t){var r=t(2),a=0,i=Math.random(),o=r(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+o(++a+i,36)}},function(n,e,t){var r=t(7),a=t(4),i=t(91);n.exports=!r&&!a((function(){return 7!=Object.defineProperty(i("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){var r=t(2),a=t(1),i=t(31),o=r(Function.toString);a(i.inspectSource)||(i.inspectSource=function(n){return o(n)}),n.exports=i.inspectSource},function(n,e,t){var r=t(8),a=t(110),i=t(49),o=t(15);n.exports=function(n,e,t){for(var s=a(e),l=o.f,d=i.f,c=0;c<s.length;c++){var u=s[c];r(n,u)||t&&r(t,u)||l(n,u,d(e,u))}}},function(n,e,t){var r=t(114);n.exports=function(n){var e=+n;return e!=e||0===e?0:r(e)}},function(n,e,t){var r=t(2),a=t(24),i=t(123);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=r(Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set))(t,[]),e=t instanceof Array}catch(n){}return function(t,r){return a(t),i(r),e?n(t,r):t.__proto__=r,t}}():void 0)},function(n,e){n.exports=function(n,e){for(var t=-1,r=e.length,a=n.length;++t<r;)n[a+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var r=t(18),a=t(146),i=t(147),o=t(148),s=t(149),l=t(150);function d(n){var e=this.__data__=new r(n);this.size=e.size}d.prototype.clear=a,d.prototype.delete=i,d.prototype.get=o,d.prototype.has=s,d.prototype.set=l,n.exports=d},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var r=t(12),a=t(35);n.exports=function(n){if(!a(n))return!1;var e=r(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var r=t(167),a=t(11);n.exports=function n(e,t,i,o,s){return e===t||(null==e||null==t||!a(e)&&!a(t)?e!=e&&t!=t:r(e,t,i,o,n,s))}},function(n,e,t){var r=t(73),a=t(170),i=t(74);n.exports=function(n,e,t,o,s,l){var d=1&t,c=n.length,u=e.length;if(c!=u&&!(d&&u>c))return!1;var h=l.get(n),p=l.get(e);if(h&&p)return h==e&&p==n;var f=-1,m=!0,g=2&t?new r:void 0;for(l.set(n,e),l.set(e,n);++f<c;){var v=n[f],b=e[f];if(o)var y=d?o(b,v,f,e,n,l):o(v,b,f,n,e,l);if(void 0!==y){if(y)continue;m=!1;break}if(g){if(!a(e,(function(n,e){if(!i(g,e)&&(v===n||s(v,n,t,o,l)))return g.push(e)}))){m=!1;break}}else if(v!==b&&!s(v,b,t,o,l)){m=!1;break}}return l.delete(n),l.delete(e),m}},function(n,e,t){var r=t(36),a=t(168),i=t(169);function o(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new r;++e<t;)this.add(n[e])}o.prototype.add=o.prototype.push=a,o.prototype.has=i,n.exports=o},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var r=t(180),a=t(186),i=t(79);n.exports=function(n){return i(n)?r(n):a(n)}},function(n,e,t){(function(n){var r=t(6),a=t(182),i=e&&!e.nodeType&&e,o=i&&"object"==typeof n&&n&&!n.nodeType&&n,s=o&&o.exports===i?r.Buffer:void 0,l=(s?s.isBuffer:void 0)||a;n.exports=l}).call(this,t(48)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var r=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==r||"symbol"!=r&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var r=t(183),a=t(184),i=t(185),o=i&&i.isTypedArray,s=o?a(o):r;n.exports=s},function(n,e,t){var r=t(69),a=t(38);n.exports=function(n){return null!=n&&a(n.length)&&!r(n)}},function(n,e,t){var r=t(10)(t(6),"Set");n.exports=r},function(n,e,t){var r=t(35);n.exports=function(n){return n==n&&!r(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var r=t(84),a=t(22);n.exports=function(n,e){for(var t=0,i=(e=r(e,n)).length;null!=n&&t<i;)n=n[a(e[t++])];return t&&t==i?n:void 0}},function(n,e,t){var r=t(5),a=t(39),i=t(197),o=t(200);n.exports=function(n,e){return r(n)?n:a(n,e)?[n]:i(o(n))}},function(n,e,t){},function(n,e,t){},function(n,e,t){var r=t(133),a=t(138),i=t(209),o=t(217),s=t(226),l=t(96),d=i((function(n){var e=l(n);return s(e)&&(e=void 0),o(r(n,1,s,!0),a(e,2))}));n.exports=d},function(n,e,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var r=/["'&<>]/;n.exports=function(n){var e,t=""+n,a=r.exec(t);if(!a)return t;var i="",o=0,s=0;for(o=a.index;o<t.length;o++){switch(t.charCodeAt(o)){case 34:e="&quot;";break;case 38:e="&amp;";break;case 39:e="&#39;";break;case 60:e="&lt;";break;case 62:e="&gt;";break;default:continue}s!==o&&(i+=t.substring(s,o)),s=o+1,i+=e}return s!==o?i+t.substring(s,o):i}},function(n,e){var t=/^\s+|\s+$/g,r=/^[-+]0x[0-9a-f]+$/i,a=/^0b[01]+$/i,i=/^0o[0-7]+$/i,o=parseInt,s="object"==typeof global&&global&&global.Object===Object&&global,l="object"==typeof self&&self&&self.Object===Object&&self,d=s||l||Function("return this")(),c=Object.prototype.toString,u=Math.max,h=Math.min,p=function(){return d.Date.now()};function f(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function m(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==c.call(n)}(n))return NaN;if(f(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=f(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var s=a.test(n);return s||i.test(n)?o(n.slice(2),s?2:8):r.test(n)?NaN:+n}n.exports=function(n,e,t){var r,a,i,o,s,l,d=0,c=!1,g=!1,v=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function b(e){var t=r,i=a;return r=a=void 0,d=e,o=n.apply(i,t)}function y(n){return d=n,s=setTimeout(_,e),c?b(n):o}function x(n){var t=n-l;return void 0===l||t>=e||t<0||g&&n-d>=i}function _(){var n=p();if(x(n))return w(n);s=setTimeout(_,function(n){var t=e-(n-l);return g?h(t,i-(n-d)):t}(n))}function w(n){return s=void 0,v&&r?b(n):(r=a=void 0,o)}function N(){var n=p(),t=x(n);if(r=arguments,a=this,l=n,t){if(void 0===s)return y(l);if(g)return s=setTimeout(_,e),b(l)}return void 0===s&&(s=setTimeout(_,e)),o}return e=m(e)||0,f(t)&&(c=!!t.leading,i=(g="maxWait"in t)?u(m(t.maxWait)||0,e):i,v="trailing"in t?!!t.trailing:v),N.cancel=function(){void 0!==s&&clearTimeout(s),d=0,r=l=a=s=void 0},N.flush=function(){return void 0===s?o:w(p())},N}},function(n,e){n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){var r=t(3),a=t(9),i=r.document,o=a(i)&&a(i.createElement);n.exports=function(n){return o?i.createElement(n):{}}},function(n,e,t){var r=t(7),a=t(4);n.exports=r&&a((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){var r=t(57),a=t(59),i=r("keys");n.exports=function(n){return i[n]||(i[n]=a(n))}},function(n,e,t){var r=t(2),a=t(8),i=t(26),o=t(112).indexOf,s=t(46),l=r([].push);n.exports=function(n,e){var t,r=i(n),d=0,c=[];for(t in r)!a(s,t)&&a(r,t)&&l(c,t);for(;e.length>d;)a(r,t=e[d++])&&(~o(c,t)||l(c,t));return c}},function(n,e,t){var r=t(42),a=t(3),i=t(121),o=t(122),s=a.WebAssembly,l=7!==Error("e",{cause:7}).cause,d=function(n,e){var t={};t[n]=o(n,e,l),r({global:!0,constructor:!0,arity:1,forced:l},t)},c=function(n,e){if(s&&s[n]){var t={};t[n]=o("WebAssembly."+n,e,l),r({target:"WebAssembly",stat:!0,constructor:!0,arity:1,forced:l},t)}};d("Error",(function(n){return function(e){return i(n,this,arguments)}})),d("EvalError",(function(n){return function(e){return i(n,this,arguments)}})),d("RangeError",(function(n){return function(e){return i(n,this,arguments)}})),d("ReferenceError",(function(n){return function(e){return i(n,this,arguments)}})),d("SyntaxError",(function(n){return function(e){return i(n,this,arguments)}})),d("TypeError",(function(n){return function(e){return i(n,this,arguments)}})),d("URIError",(function(n){return function(e){return i(n,this,arguments)}})),c("CompileError",(function(n){return function(e){return i(n,this,arguments)}})),c("LinkError",(function(n){return function(e){return i(n,this,arguments)}})),c("RuntimeError",(function(n){return function(e){return i(n,this,arguments)}}))},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){n.exports=t(232)},function(n,e,t){"use strict";var r=t(42),a=t(118).left,i=t(119),o=t(56),s=t(120);r({target:"Array",proto:!0,forced:!i("reduce")||!s&&o>79&&o<83},{reduce:function(n){var e=arguments.length;return a(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var r={}.propertyIsEnumerable,a=Object.getOwnPropertyDescriptor,i=a&&!r.call({1:2},1);e.f=i?function(n){var e=a(this,n);return!!e&&e.enumerable}:r},function(n,e,t){var r=t(28),a=t(9),i=t(52),o=t(102),s=t(104),l=t(27),d=TypeError,c=l("toPrimitive");n.exports=function(n,e){if(!a(n)||i(n))return n;var t,l=o(n,c);if(l){if(void 0===e&&(e="default"),t=r(l,n,e),!a(t)||i(t))return t;throw d("Can't convert object to primitive value")}return void 0===e&&(e="number"),s(n,e)}},function(n,e,t){var r=t(16);n.exports=r("navigator","userAgent")||""},function(n,e,t){var r=t(44);n.exports=function(n,e){var t=n[e];return null==t?void 0:r(t)}},function(n,e){var t=String;n.exports=function(n){try{return t(n)}catch(n){return"Object"}}},function(n,e,t){var r=t(28),a=t(1),i=t(9),o=TypeError;n.exports=function(n,e){var t,s;if("string"===e&&a(t=n.toString)&&!i(s=r(t,n)))return s;if(a(t=n.valueOf)&&!i(s=r(t,n)))return s;if("string"!==e&&a(t=n.toString)&&!i(s=r(t,n)))return s;throw o("Can't convert object to primitive value")}},function(n,e,t){var r=t(1),a=t(15),i=t(106),o=t(32);n.exports=function(n,e,t,s){s||(s={});var l=s.enumerable,d=void 0!==s.name?s.name:e;if(r(t)&&i(t,d,s),s.global)l?n[e]=t:o(e,t);else{try{s.unsafe?n[e]&&(l=!0):delete n[e]}catch(n){}l?n[e]=t:a.f(n,e,{value:t,enumerable:!1,configurable:!s.nonConfigurable,writable:!s.nonWritable})}return n}},function(n,e,t){var r=t(4),a=t(1),i=t(8),o=t(7),s=t(107).CONFIGURABLE,l=t(61),d=t(108),c=d.enforce,u=d.get,h=Object.defineProperty,p=o&&!r((function(){return 8!==h((function(){}),"length",{value:8}).length})),f=String(String).split("String"),m=n.exports=function(n,e,t){"Symbol("===String(e).slice(0,7)&&(e="["+String(e).replace(/^Symbol\(([^)]*)\)/,"$1")+"]"),t&&t.getter&&(e="get "+e),t&&t.setter&&(e="set "+e),(!i(n,"name")||s&&n.name!==e)&&(o?h(n,"name",{value:e,configurable:!0}):n.name=e),p&&t&&i(t,"arity")&&n.length!==t.arity&&h(n,"length",{value:t.arity});try{t&&i(t,"constructor")&&t.constructor?o&&h(n,"prototype",{writable:!1}):n.prototype&&(n.prototype=void 0)}catch(n){}var r=c(n);return i(r,"source")||(r.source=f.join("string"==typeof e?e:"")),n};Function.prototype.toString=m((function(){return a(this)&&u(this).source||l(this)}),"toString")},function(n,e,t){var r=t(7),a=t(8),i=Function.prototype,o=r&&Object.getOwnPropertyDescriptor,s=a(i,"name"),l=s&&"something"===function(){}.name,d=s&&(!r||r&&o(i,"name").configurable);n.exports={EXISTS:s,PROPER:l,CONFIGURABLE:d}},function(n,e,t){var r,a,i,o=t(109),s=t(3),l=t(2),d=t(9),c=t(17),u=t(8),h=t(31),p=t(93),f=t(46),m=s.TypeError,g=s.WeakMap;if(o||h.state){var v=h.state||(h.state=new g),b=l(v.get),y=l(v.has),x=l(v.set);r=function(n,e){if(y(v,n))throw new m("Object already initialized");return e.facade=n,x(v,n,e),e},a=function(n){return b(v,n)||{}},i=function(n){return y(v,n)}}else{var _=p("state");f[_]=!0,r=function(n,e){if(u(n,_))throw new m("Object already initialized");return e.facade=n,c(n,_,e),e},a=function(n){return u(n,_)?n[_]:{}},i=function(n){return u(n,_)}}n.exports={set:r,get:a,has:i,enforce:function(n){return i(n)?a(n):r(n,{})},getterFor:function(n){return function(e){var t;if(!d(e)||(t=a(e)).type!==n)throw m("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){var r=t(3),a=t(1),i=t(61),o=r.WeakMap;n.exports=a(o)&&/native code/.test(i(o))},function(n,e,t){var r=t(16),a=t(2),i=t(111),o=t(116),s=t(24),l=a([].concat);n.exports=r("Reflect","ownKeys")||function(n){var e=i.f(s(n)),t=o.f;return t?l(e,t(n)):e}},function(n,e,t){var r=t(94),a=t(90).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return r(n,a)}},function(n,e,t){var r=t(26),a=t(113),i=t(47),o=function(n){return function(e,t,o){var s,l=r(e),d=i(l),c=a(o,d);if(n&&t!=t){for(;d>c;)if((s=l[c++])!=s)return!0}else for(;d>c;c++)if((n||c in l)&&l[c]===t)return n||c||0;return!n&&-1}};n.exports={includes:o(!0),indexOf:o(!1)}},function(n,e,t){var r=t(63),a=Math.max,i=Math.min;n.exports=function(n,e){var t=r(n);return t<0?a(t+e,0):i(t,e)}},function(n,e){var t=Math.ceil,r=Math.floor;n.exports=Math.trunc||function(n){var e=+n;return(e>0?r:t)(e)}},function(n,e,t){var r=t(63),a=Math.min;n.exports=function(n){return n>0?a(r(n),9007199254740991):0}},function(n,e){e.f=Object.getOwnPropertySymbols},function(n,e,t){var r=t(4),a=t(1),i=/#|\.prototype\./,o=function(n,e){var t=l[s(n)];return t==c||t!=d&&(a(e)?r(e):!!e)},s=o.normalize=function(n){return String(n).replace(i,".").toLowerCase()},l=o.data={},d=o.NATIVE="N",c=o.POLYFILL="P";n.exports=o},function(n,e,t){var r=t(44),a=t(45),i=t(43),o=t(47),s=TypeError,l=function(n){return function(e,t,l,d){r(t);var c=a(e),u=i(c),h=o(c),p=n?h-1:0,f=n?-1:1;if(l<2)for(;;){if(p in u){d=u[p],p+=f;break}if(p+=f,n?p<0:h<=p)throw s("Reduce of empty array with no initial value")}for(;n?p>=0:h>p;p+=f)p in u&&(d=t(d,u[p],p,c));return d}};n.exports={left:l(!1),right:l(!0)}},function(n,e,t){"use strict";var r=t(4);n.exports=function(n,e){var t=[][n];return!!t&&r((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){var r=t(30),a=t(3);n.exports="process"==r(a.process)},function(n,e,t){var r=t(25),a=Function.prototype,i=a.apply,o=a.call;n.exports="object"==typeof Reflect&&Reflect.apply||(r?o.bind(i):function(){return o.apply(i,arguments)})},function(n,e,t){"use strict";var r=t(16),a=t(8),i=t(17),o=t(53),s=t(64),l=t(62),d=t(124),c=t(125),u=t(126),h=t(130),p=t(131),f=t(132),m=t(7),g=t(58);n.exports=function(n,e,t,v){var b=v?2:1,y=n.split("."),x=y[y.length-1],_=r.apply(null,y);if(_){var w=_.prototype;if(!g&&a(w,"cause")&&delete w.cause,!t)return _;var N=r("Error"),k=e((function(n,e){var t=u(v?e:n,void 0),r=v?new _(n):new _;return void 0!==t&&i(r,"message",t),f&&i(r,"stack",p(r.stack,2)),this&&o(w,this)&&c(r,this,k),arguments.length>b&&h(r,arguments[b]),r}));if(k.prototype=w,"Error"!==x?s?s(k,N):l(k,N,{name:!0}):m&&"stackTraceLimit"in _&&(d(k,_,"stackTraceLimit"),d(k,_,"prepareStackTrace")),l(k,_),!g)try{w.name!==x&&i(w,"name",x),w.constructor=k}catch(n){}return k}}},function(n,e,t){var r=t(1),a=String,i=TypeError;n.exports=function(n){if("object"==typeof n||r(n))return n;throw i("Can't set "+a(n)+" as a prototype")}},function(n,e,t){var r=t(15).f;n.exports=function(n,e,t){t in n||r(n,t,{configurable:!0,get:function(){return e[t]},set:function(n){e[t]=n}})}},function(n,e,t){var r=t(1),a=t(9),i=t(64);n.exports=function(n,e,t){var o,s;return i&&r(o=e.constructor)&&o!==t&&a(s=o.prototype)&&s!==t.prototype&&i(n,s),n}},function(n,e,t){var r=t(127);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:r(n)}},function(n,e,t){var r=t(128),a=String;n.exports=function(n){if("Symbol"===r(n))throw TypeError("Cannot convert a Symbol value to a string");return a(n)}},function(n,e,t){var r=t(129),a=t(1),i=t(30),o=t(27)("toStringTag"),s=Object,l="Arguments"==i(function(){return arguments}());n.exports=r?i:function(n){var e,t,r;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=s(n),o))?t:l?i(e):"Object"==(r=i(e))&&a(e.callee)?"Arguments":r}},function(n,e,t){var r={};r[t(27)("toStringTag")]="z",n.exports="[object z]"===String(r)},function(n,e,t){var r=t(9),a=t(17);n.exports=function(n,e){r(e)&&"cause"in e&&a(n,"cause",e.cause)}},function(n,e,t){var r=t(2),a=Error,i=r("".replace),o=String(a("zxcasd").stack),s=/\n\s*at [^:]*:[^\n]*/,l=s.test(o);n.exports=function(n,e){if(l&&"string"==typeof n&&!a.prepareStackTrace)for(;e--;)n=i(n,s,"");return n}},function(n,e,t){var r=t(4),a=t(29);n.exports=!r((function(){var n=Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",a(1,7)),7!==n.stack)}))},function(n,e,t){var r=t(65),a=t(134);n.exports=function n(e,t,i,o,s){var l=-1,d=e.length;for(i||(i=a),s||(s=[]);++l<d;){var c=e[l];t>0&&i(c)?t>1?n(c,t-1,i,o,s):r(s,c):o||(s[s.length]=c)}return s}},function(n,e,t){var r=t(13),a=t(33),i=t(5),o=r?r.isConcatSpreadable:void 0;n.exports=function(n){return i(n)||a(n)||!!(o&&n&&n[o])}},function(n,e,t){var r=t(12),a=t(11);n.exports=function(n){return a(n)&&"[object Arguments]"==r(n)}},function(n,e,t){var r=t(13),a=Object.prototype,i=a.hasOwnProperty,o=a.toString,s=r?r.toStringTag:void 0;n.exports=function(n){var e=i.call(n,s),t=n[s];try{n[s]=void 0;var r=!0}catch(n){}var a=o.call(n);return r&&(e?n[s]=t:delete n[s]),a}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var r=t(139),a=t(195),i=t(41),o=t(5),s=t(206);n.exports=function(n){return"function"==typeof n?n:null==n?i:"object"==typeof n?o(n)?a(n[0],n[1]):r(n):s(n)}},function(n,e,t){var r=t(140),a=t(194),i=t(82);n.exports=function(n){var e=a(n);return 1==e.length&&e[0][2]?i(e[0][0],e[0][1]):function(t){return t===n||r(t,n,e)}}},function(n,e,t){var r=t(67),a=t(71);n.exports=function(n,e,t,i){var o=t.length,s=o,l=!i;if(null==n)return!s;for(n=Object(n);o--;){var d=t[o];if(l&&d[2]?d[1]!==n[d[0]]:!(d[0]in n))return!1}for(;++o<s;){var c=(d=t[o])[0],u=n[c],h=d[1];if(l&&d[2]){if(void 0===u&&!(c in n))return!1}else{var p=new r;if(i)var f=i(u,h,c,n,e,p);if(!(void 0===f?a(h,u,3,i,p):f))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var r=t(19),a=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=r(e,n);return!(t<0)&&(t==e.length-1?e.pop():a.call(e,t,1),--this.size,!0)}},function(n,e,t){var r=t(19);n.exports=function(n){var e=this.__data__,t=r(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var r=t(19);n.exports=function(n){return r(this.__data__,n)>-1}},function(n,e,t){var r=t(19);n.exports=function(n,e){var t=this.__data__,a=r(t,n);return a<0?(++this.size,t.push([n,e])):t[a][1]=e,this}},function(n,e,t){var r=t(18);n.exports=function(){this.__data__=new r,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var r=t(18),a=t(34),i=t(36);n.exports=function(n,e){var t=this.__data__;if(t instanceof r){var o=t.__data__;if(!a||o.length<199)return o.push([n,e]),this.size=++t.size,this;t=this.__data__=new i(o)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var r=t(69),a=t(152),i=t(35),o=t(70),s=/^\[object .+?Constructor\]$/,l=Function.prototype,d=Object.prototype,c=l.toString,u=d.hasOwnProperty,h=RegExp("^"+c.call(u).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!i(n)||a(n))&&(r(n)?h:s).test(o(n))}},function(n,e,t){var r,a=t(153),i=(r=/[^.]+$/.exec(a&&a.keys&&a.keys.IE_PROTO||""))?"Symbol(src)_1."+r:"";n.exports=function(n){return!!i&&i in n}},function(n,e,t){var r=t(6)["__core-js_shared__"];n.exports=r},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var r=t(156),a=t(18),i=t(34);n.exports=function(){this.size=0,this.__data__={hash:new r,map:new(i||a),string:new r}}},function(n,e,t){var r=t(157),a=t(158),i=t(159),o=t(160),s=t(161);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=a,l.prototype.get=i,l.prototype.has=o,l.prototype.set=s,n.exports=l},function(n,e,t){var r=t(20);n.exports=function(){this.__data__=r?r(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var r=t(20),a=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(r){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return a.call(e,n)?e[n]:void 0}},function(n,e,t){var r=t(20),a=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return r?void 0!==e[n]:a.call(e,n)}},function(n,e,t){var r=t(20);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=r&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var r=t(21);n.exports=function(n){var e=r(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var r=t(21);n.exports=function(n){return r(this,n).get(n)}},function(n,e,t){var r=t(21);n.exports=function(n){return r(this,n).has(n)}},function(n,e,t){var r=t(21);n.exports=function(n,e){var t=r(this,n),a=t.size;return t.set(n,e),this.size+=t.size==a?0:1,this}},function(n,e,t){var r=t(67),a=t(72),i=t(171),o=t(174),s=t(190),l=t(5),d=t(76),c=t(78),u="[object Object]",h=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,p,f,m){var g=l(n),v=l(e),b=g?"[object Array]":s(n),y=v?"[object Array]":s(e),x=(b="[object Arguments]"==b?u:b)==u,_=(y="[object Arguments]"==y?u:y)==u,w=b==y;if(w&&d(n)){if(!d(e))return!1;g=!0,x=!1}if(w&&!x)return m||(m=new r),g||c(n)?a(n,e,t,p,f,m):i(n,e,b,t,p,f,m);if(!(1&t)){var N=x&&h.call(n,"__wrapped__"),k=_&&h.call(e,"__wrapped__");if(N||k){var j=N?n.value():n,S=k?e.value():e;return m||(m=new r),f(j,S,t,p,m)}}return!!w&&(m||(m=new r),o(n,e,t,p,f,m))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length;++t<r;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var r=t(13),a=t(172),i=t(68),o=t(72),s=t(173),l=t(37),d=r?r.prototype:void 0,c=d?d.valueOf:void 0;n.exports=function(n,e,t,r,d,u,h){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!u(new a(n),new a(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return i(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var p=s;case"[object Set]":var f=1&r;if(p||(p=l),n.size!=e.size&&!f)return!1;var m=h.get(n);if(m)return m==e;r|=2,h.set(n,e);var g=o(p(n),p(e),r,d,u,h);return h.delete(n),g;case"[object Symbol]":if(c)return c.call(n)==c.call(e)}return!1}},function(n,e,t){var r=t(6).Uint8Array;n.exports=r},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,r){t[++e]=[r,n]})),t}},function(n,e,t){var r=t(175),a=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,i,o,s){var l=1&t,d=r(n),c=d.length;if(c!=r(e).length&&!l)return!1;for(var u=c;u--;){var h=d[u];if(!(l?h in e:a.call(e,h)))return!1}var p=s.get(n),f=s.get(e);if(p&&f)return p==e&&f==n;var m=!0;s.set(n,e),s.set(e,n);for(var g=l;++u<c;){var v=n[h=d[u]],b=e[h];if(i)var y=l?i(b,v,h,e,n,s):i(v,b,h,n,e,s);if(!(void 0===y?v===b||o(v,b,t,i,s):y)){m=!1;break}g||(g="constructor"==h)}if(m&&!g){var x=n.constructor,_=e.constructor;x==_||!("constructor"in n)||!("constructor"in e)||"function"==typeof x&&x instanceof x&&"function"==typeof _&&_ instanceof _||(m=!1)}return s.delete(n),s.delete(e),m}},function(n,e,t){var r=t(176),a=t(177),i=t(75);n.exports=function(n){return r(n,i,a)}},function(n,e,t){var r=t(65),a=t(5);n.exports=function(n,e,t){var i=e(n);return a(n)?i:r(i,t(n))}},function(n,e,t){var r=t(178),a=t(179),i=Object.prototype.propertyIsEnumerable,o=Object.getOwnPropertySymbols,s=o?function(n){return null==n?[]:(n=Object(n),r(o(n),(function(e){return i.call(n,e)})))}:a;n.exports=s},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,a=0,i=[];++t<r;){var o=n[t];e(o,t,n)&&(i[a++]=o)}return i}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var r=t(181),a=t(33),i=t(5),o=t(76),s=t(77),l=t(78),d=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=i(n),c=!t&&a(n),u=!t&&!c&&o(n),h=!t&&!c&&!u&&l(n),p=t||c||u||h,f=p?r(n.length,String):[],m=f.length;for(var g in n)!e&&!d.call(n,g)||p&&("length"==g||u&&("offset"==g||"parent"==g)||h&&("buffer"==g||"byteLength"==g||"byteOffset"==g)||s(g,m))||f.push(g);return f}},function(n,e){n.exports=function(n,e){for(var t=-1,r=Array(n);++t<n;)r[t]=e(t);return r}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var r=t(12),a=t(38),i=t(11),o={};o["[object Float32Array]"]=o["[object Float64Array]"]=o["[object Int8Array]"]=o["[object Int16Array]"]=o["[object Int32Array]"]=o["[object Uint8Array]"]=o["[object Uint8ClampedArray]"]=o["[object Uint16Array]"]=o["[object Uint32Array]"]=!0,o["[object Arguments]"]=o["[object Array]"]=o["[object ArrayBuffer]"]=o["[object Boolean]"]=o["[object DataView]"]=o["[object Date]"]=o["[object Error]"]=o["[object Function]"]=o["[object Map]"]=o["[object Number]"]=o["[object Object]"]=o["[object RegExp]"]=o["[object Set]"]=o["[object String]"]=o["[object WeakMap]"]=!1,n.exports=function(n){return i(n)&&a(n.length)&&!!o[r(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var r=t(66),a=e&&!e.nodeType&&e,i=a&&"object"==typeof n&&n&&!n.nodeType&&n,o=i&&i.exports===a&&r.process,s=function(){try{var n=i&&i.require&&i.require("util").types;return n||o&&o.binding&&o.binding("util")}catch(n){}}();n.exports=s}).call(this,t(48)(n))},function(n,e,t){var r=t(187),a=t(188),i=Object.prototype.hasOwnProperty;n.exports=function(n){if(!r(n))return a(n);var e=[];for(var t in Object(n))i.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var r=t(189)(Object.keys,Object);n.exports=r},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var r=t(191),a=t(34),i=t(192),o=t(80),s=t(193),l=t(12),d=t(70),c=d(r),u=d(a),h=d(i),p=d(o),f=d(s),m=l;(r&&"[object DataView]"!=m(new r(new ArrayBuffer(1)))||a&&"[object Map]"!=m(new a)||i&&"[object Promise]"!=m(i.resolve())||o&&"[object Set]"!=m(new o)||s&&"[object WeakMap]"!=m(new s))&&(m=function(n){var e=l(n),t="[object Object]"==e?n.constructor:void 0,r=t?d(t):"";if(r)switch(r){case c:return"[object DataView]";case u:return"[object Map]";case h:return"[object Promise]";case p:return"[object Set]";case f:return"[object WeakMap]"}return e}),n.exports=m},function(n,e,t){var r=t(10)(t(6),"DataView");n.exports=r},function(n,e,t){var r=t(10)(t(6),"Promise");n.exports=r},function(n,e,t){var r=t(10)(t(6),"WeakMap");n.exports=r},function(n,e,t){var r=t(81),a=t(75);n.exports=function(n){for(var e=a(n),t=e.length;t--;){var i=e[t],o=n[i];e[t]=[i,o,r(o)]}return e}},function(n,e,t){var r=t(71),a=t(196),i=t(203),o=t(39),s=t(81),l=t(82),d=t(22);n.exports=function(n,e){return o(n)&&s(e)?l(d(n),e):function(t){var o=a(t,n);return void 0===o&&o===e?i(t,n):r(e,o,3)}}},function(n,e,t){var r=t(83);n.exports=function(n,e,t){var a=null==n?void 0:r(n,e);return void 0===a?t:a}},function(n,e,t){var r=t(198),a=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,i=/\\(\\)?/g,o=r((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(a,(function(n,t,r,a){e.push(r?a.replace(i,"$1"):t||n)})),e}));n.exports=o},function(n,e,t){var r=t(199);n.exports=function(n){var e=r(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var r=t(36);function a(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var r=arguments,a=e?e.apply(this,r):r[0],i=t.cache;if(i.has(a))return i.get(a);var o=n.apply(this,r);return t.cache=i.set(a,o)||i,o};return t.cache=new(a.Cache||r),t}a.Cache=r,n.exports=a},function(n,e,t){var r=t(201);n.exports=function(n){return null==n?"":r(n)}},function(n,e,t){var r=t(13),a=t(202),i=t(5),o=t(40),s=r?r.prototype:void 0,l=s?s.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(i(e))return a(e,n)+"";if(o(e))return l?l.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,a=Array(r);++t<r;)a[t]=e(n[t],t,n);return a}},function(n,e,t){var r=t(204),a=t(205);n.exports=function(n,e){return null!=n&&a(n,e,r)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var r=t(84),a=t(33),i=t(5),o=t(77),s=t(38),l=t(22);n.exports=function(n,e,t){for(var d=-1,c=(e=r(e,n)).length,u=!1;++d<c;){var h=l(e[d]);if(!(u=null!=n&&t(n,h)))break;n=n[h]}return u||++d!=c?u:!!(c=null==n?0:n.length)&&s(c)&&o(h,c)&&(i(n)||a(n))}},function(n,e,t){var r=t(207),a=t(208),i=t(39),o=t(22);n.exports=function(n){return i(n)?r(o(n)):a(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var r=t(83);n.exports=function(n){return function(e){return r(e,n)}}},function(n,e,t){var r=t(41),a=t(210),i=t(212);n.exports=function(n,e){return i(a(n,e,r),n+"")}},function(n,e,t){var r=t(211),a=Math.max;n.exports=function(n,e,t){return e=a(void 0===e?n.length-1:e,0),function(){for(var i=arguments,o=-1,s=a(i.length-e,0),l=Array(s);++o<s;)l[o]=i[e+o];o=-1;for(var d=Array(e+1);++o<e;)d[o]=i[o];return d[e]=t(l),r(n,this,d)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var r=t(213),a=t(216)(r);n.exports=a},function(n,e,t){var r=t(214),a=t(215),i=t(41),o=a?function(n,e){return a(n,"toString",{configurable:!0,enumerable:!1,value:r(e),writable:!0})}:i;n.exports=o},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var r=t(10),a=function(){try{var n=r(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=a},function(n,e){var t=Date.now;n.exports=function(n){var e=0,r=0;return function(){var a=t(),i=16-(a-r);if(r=a,i>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var r=t(73),a=t(218),i=t(223),o=t(74),s=t(224),l=t(37);n.exports=function(n,e,t){var d=-1,c=a,u=n.length,h=!0,p=[],f=p;if(t)h=!1,c=i;else if(u>=200){var m=e?null:s(n);if(m)return l(m);h=!1,c=o,f=new r}else f=e?[]:p;n:for(;++d<u;){var g=n[d],v=e?e(g):g;if(g=t||0!==g?g:0,h&&v==v){for(var b=f.length;b--;)if(f[b]===v)continue n;e&&f.push(v),p.push(g)}else c(f,v,t)||(f!==p&&f.push(v),p.push(g))}return p}},function(n,e,t){var r=t(219);n.exports=function(n,e){return!!(null==n?0:n.length)&&r(n,e,0)>-1}},function(n,e,t){var r=t(220),a=t(221),i=t(222);n.exports=function(n,e,t){return e==e?i(n,e,t):r(n,a,t)}},function(n,e){n.exports=function(n,e,t,r){for(var a=n.length,i=t+(r?1:-1);r?i--:++i<a;)if(e(n[i],i,n))return i;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var r=t-1,a=n.length;++r<a;)if(n[r]===e)return r;return-1}},function(n,e){n.exports=function(n,e,t){for(var r=-1,a=null==n?0:n.length;++r<a;)if(t(e,n[r]))return!0;return!1}},function(n,e,t){var r=t(80),a=t(225),i=t(37),o=r&&1/i(new r([,-0]))[1]==1/0?function(n){return new r(n)}:a;n.exports=o},function(n,e){n.exports=function(){}},function(n,e,t){var r=t(79),a=t(11);n.exports=function(n){return a(n)&&r(n)}},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(85)},function(n,e,t){"use strict";t(86)},function(n,e,t){"use strict";t.r(e);var r=t(0);
/*!
  * vue-router v3.5.4
  * (c) 2022 Evan You
  * @license MIT
  */function a(n,e){for(var t in e)n[t]=e[t];return n}var i=/[!'()*]/g,o=function(n){return"%"+n.charCodeAt(0).toString(16)},s=/%2C/g,l=function(n){return encodeURIComponent(n).replace(i,o).replace(s,",")};function d(n){try{return decodeURIComponent(n)}catch(n){0}return n}var c=function(n){return null==n||"object"==typeof n?n:String(n)};function u(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),r=d(t.shift()),a=t.length>0?d(t.join("=")):null;void 0===e[r]?e[r]=a:Array.isArray(e[r])?e[r].push(a):e[r]=[e[r],a]})),e):e}function h(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return l(e);if(Array.isArray(t)){var r=[];return t.forEach((function(n){void 0!==n&&(null===n?r.push(l(e)):r.push(l(e)+"="+l(n)))})),r.join("&")}return l(e)+"="+l(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var p=/\/?$/;function f(n,e,t,r){var a=r&&r.options.stringifyQuery,i=e.query||{};try{i=m(i)}catch(n){}var o={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:i,params:e.params||{},fullPath:b(e,a),matched:n?v(n):[]};return t&&(o.redirectedFrom=b(t,a)),Object.freeze(o)}function m(n){if(Array.isArray(n))return n.map(m);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=m(n[t]);return e}return n}var g=f(null,{path:"/"});function v(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function b(n,e){var t=n.path,r=n.query;void 0===r&&(r={});var a=n.hash;return void 0===a&&(a=""),(t||"/")+(e||h)(r)+a}function y(n,e,t){return e===g?n===e:!!e&&(n.path&&e.path?n.path.replace(p,"")===e.path.replace(p,"")&&(t||n.hash===e.hash&&x(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&x(n.query,e.query)&&x(n.params,e.params))))}function x(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),r=Object.keys(e).sort();return t.length===r.length&&t.every((function(t,a){var i=n[t];if(r[a]!==t)return!1;var o=e[t];return null==i||null==o?i===o:"object"==typeof i&&"object"==typeof o?x(i,o):String(i)===String(o)}))}function _(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var r in t.instances){var a=t.instances[r],i=t.enteredCbs[r];if(a&&i){delete t.enteredCbs[r];for(var o=0;o<i.length;o++)a._isBeingDestroyed||i[o](a)}}}}var w={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,r=e.children,i=e.parent,o=e.data;o.routerView=!0;for(var s=i.$createElement,l=t.name,d=i.$route,c=i._routerViewCache||(i._routerViewCache={}),u=0,h=!1;i&&i._routerRoot!==i;){var p=i.$vnode?i.$vnode.data:{};p.routerView&&u++,p.keepAlive&&i._directInactive&&i._inactive&&(h=!0),i=i.$parent}if(o.routerViewDepth=u,h){var f=c[l],m=f&&f.component;return m?(f.configProps&&N(m,o,f.route,f.configProps),s(m,o,r)):s()}var g=d.matched[u],v=g&&g.components[l];if(!g||!v)return c[l]=null,s();c[l]={component:v},o.registerRouteInstance=function(n,e){var t=g.instances[l];(e&&t!==n||!e&&t===n)&&(g.instances[l]=e)},(o.hook||(o.hook={})).prepatch=function(n,e){g.instances[l]=e.componentInstance},o.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==g.instances[l]&&(g.instances[l]=n.componentInstance),_(d)};var b=g.props&&g.props[l];return b&&(a(c[l],{route:d,configProps:b}),N(v,o,d,b)),s(v,o,r)}};function N(n,e,t,r){var i=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,r);if(i){i=e.props=a({},i);var o=e.attrs=e.attrs||{};for(var s in i)n.props&&s in n.props||(o[s]=i[s],delete i[s])}}function k(n,e,t){var r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;var a=e.split("/");t&&a[a.length-1]||a.pop();for(var i=n.replace(/^\//,"").split("/"),o=0;o<i.length;o++){var s=i[o];".."===s?a.pop():"."!==s&&a.push(s)}return""!==a[0]&&a.unshift(""),a.join("/")}function j(n){return n.replace(/\/(?:\s*\/)+/g,"/")}var S=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},T=q,C=I,A=function(n,e){return L(I(n,e),e)},z=L,O=D,P=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function I(n,e){for(var t,r=[],a=0,i=0,o="",s=e&&e.delimiter||"/";null!=(t=P.exec(n));){var l=t[0],d=t[1],c=t.index;if(o+=n.slice(i,c),i=c+l.length,d)o+=d[1];else{var u=n[i],h=t[2],p=t[3],f=t[4],m=t[5],g=t[6],v=t[7];o&&(r.push(o),o="");var b=null!=h&&null!=u&&u!==h,y="+"===g||"*"===g,x="?"===g||"*"===g,_=t[2]||s,w=f||m;r.push({name:p||a++,prefix:h||"",delimiter:_,optional:x,repeat:y,partial:b,asterisk:!!v,pattern:w?V(w):v?".*":"[^"+M(_)+"]+?"})}}return i<n.length&&(o+=n.substr(i)),o&&r.push(o),r}function E(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function L(n,e){for(var t=new Array(n.length),r=0;r<n.length;r++)"object"==typeof n[r]&&(t[r]=new RegExp("^(?:"+n[r].pattern+")$",$(e)));return function(e,r){for(var a="",i=e||{},o=(r||{}).pretty?E:encodeURIComponent,s=0;s<n.length;s++){var l=n[s];if("string"!=typeof l){var d,c=i[l.name];if(null==c){if(l.optional){l.partial&&(a+=l.prefix);continue}throw new TypeError('Expected "'+l.name+'" to be defined')}if(S(c)){if(!l.repeat)throw new TypeError('Expected "'+l.name+'" to not repeat, but received `'+JSON.stringify(c)+"`");if(0===c.length){if(l.optional)continue;throw new TypeError('Expected "'+l.name+'" to not be empty')}for(var u=0;u<c.length;u++){if(d=o(c[u]),!t[s].test(d))throw new TypeError('Expected all "'+l.name+'" to match "'+l.pattern+'", but received `'+JSON.stringify(d)+"`");a+=(0===u?l.prefix:l.delimiter)+d}}else{if(d=l.asterisk?encodeURI(c).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):o(c),!t[s].test(d))throw new TypeError('Expected "'+l.name+'" to match "'+l.pattern+'", but received "'+d+'"');a+=l.prefix+d}}else a+=l}return a}}function M(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function V(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function R(n,e){return n.keys=e,n}function $(n){return n&&n.sensitive?"":"i"}function D(n,e,t){S(e)||(t=e||t,e=[]);for(var r=(t=t||{}).strict,a=!1!==t.end,i="",o=0;o<n.length;o++){var s=n[o];if("string"==typeof s)i+=M(s);else{var l=M(s.prefix),d="(?:"+s.pattern+")";e.push(s),s.repeat&&(d+="(?:"+l+d+")*"),i+=d=s.optional?s.partial?l+"("+d+")?":"(?:"+l+"("+d+"))?":l+"("+d+")"}}var c=M(t.delimiter||"/"),u=i.slice(-c.length)===c;return r||(i=(u?i.slice(0,-c.length):i)+"(?:"+c+"(?=$))?"),i+=a?"$":r&&u?"":"(?="+c+"|$)",R(new RegExp("^"+i,$(t)),e)}function q(n,e,t){return S(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var r=0;r<t.length;r++)e.push({name:r,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return R(n,e)}(n,e):S(n)?function(n,e,t){for(var r=[],a=0;a<n.length;a++)r.push(q(n[a],e,t).source);return R(new RegExp("(?:"+r.join("|")+")",$(t)),e)}(n,e,t):function(n,e,t){return D(I(n,t),e,t)}(n,e,t)}T.parse=C,T.compile=A,T.tokensToFunction=z,T.tokensToRegExp=O;var F=Object.create(null);function B(n,e,t){e=e||{};try{var r=F[n]||(F[n]=T.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),r(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function H(n,e,t,r){var i="string"==typeof n?{path:n}:n;if(i._normalized)return i;if(i.name){var o=(i=a({},n)).params;return o&&"object"==typeof o&&(i.params=a({},o)),i}if(!i.path&&i.params&&e){(i=a({},i))._normalized=!0;var s=a(a({},e.params),i.params);if(e.name)i.name=e.name,i.params=s;else if(e.matched.length){var l=e.matched[e.matched.length-1].path;i.path=B(l,s,e.path)}else 0;return i}var d=function(n){var e="",t="",r=n.indexOf("#");r>=0&&(e=n.slice(r),n=n.slice(0,r));var a=n.indexOf("?");return a>=0&&(t=n.slice(a+1),n=n.slice(0,a)),{path:n,query:t,hash:e}}(i.path||""),h=e&&e.path||"/",p=d.path?k(d.path,h,t||i.append):h,f=function(n,e,t){void 0===e&&(e={});var r,a=t||u;try{r=a(n||"")}catch(n){r={}}for(var i in e){var o=e[i];r[i]=Array.isArray(o)?o.map(c):c(o)}return r}(d.query,i.query,r&&r.options.parseQuery),m=i.hash||d.hash;return m&&"#"!==m.charAt(0)&&(m="#"+m),{_normalized:!0,path:p,query:f,hash:m}}var U,K=function(){},J={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,r=this.$route,i=t.resolve(this.to,r,this.append),o=i.location,s=i.route,l=i.href,d={},c=t.options.linkActiveClass,u=t.options.linkExactActiveClass,h=null==c?"router-link-active":c,m=null==u?"router-link-exact-active":u,g=null==this.activeClass?h:this.activeClass,v=null==this.exactActiveClass?m:this.exactActiveClass,b=s.redirectedFrom?f(null,H(s.redirectedFrom),null,t):s;d[v]=y(r,b,this.exactPath),d[g]=this.exact||this.exactPath?d[v]:function(n,e){return 0===n.path.replace(p,"/").indexOf(e.path.replace(p,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(r,b);var x=d[v]?this.ariaCurrentValue:null,_=function(n){Y(n)&&(e.replace?t.replace(o,K):t.push(o,K))},w={click:Y};Array.isArray(this.event)?this.event.forEach((function(n){w[n]=_})):w[this.event]=_;var N={class:d},k=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:l,route:s,navigate:_,isActive:d[g],isExactActive:d[v]});if(k){if(1===k.length)return k[0];if(k.length>1||!k.length)return 0===k.length?n():n("span",{},k)}if("a"===this.tag)N.on=w,N.attrs={href:l,"aria-current":x};else{var j=function n(e){var t;if(e)for(var r=0;r<e.length;r++){if("a"===(t=e[r]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(j){j.isStatic=!1;var S=j.data=a({},j.data);for(var T in S.on=S.on||{},S.on){var C=S.on[T];T in w&&(S.on[T]=Array.isArray(C)?C:[C])}for(var A in w)A in S.on?S.on[A].push(w[A]):S.on[A]=_;var z=j.data.attrs=a({},j.data.attrs);z.href=l,z["aria-current"]=x}else N.on=w}return n(this.tag,N,this.$slots.default)}};function Y(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var W="undefined"!=typeof window;function X(n,e,t,r,a){var i=e||[],o=t||Object.create(null),s=r||Object.create(null);n.forEach((function(n){!function n(e,t,r,a,i,o){var s=a.path,l=a.name;0;var d=a.pathToRegexpOptions||{},c=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return j(e.path+"/"+n)}(s,i,d.strict);"boolean"==typeof a.caseSensitive&&(d.sensitive=a.caseSensitive);var u={path:c,regex:G(c,d),components:a.components||{default:a.component},alias:a.alias?"string"==typeof a.alias?[a.alias]:a.alias:[],instances:{},enteredCbs:{},name:l,parent:i,matchAs:o,redirect:a.redirect,beforeEnter:a.beforeEnter,meta:a.meta||{},props:null==a.props?{}:a.components?a.props:{default:a.props}};a.children&&a.children.forEach((function(a){var i=o?j(o+"/"+a.path):void 0;n(e,t,r,a,u,i)}));t[u.path]||(e.push(u.path),t[u.path]=u);if(void 0!==a.alias)for(var h=Array.isArray(a.alias)?a.alias:[a.alias],p=0;p<h.length;++p){0;var f={path:h[p],children:a.children};n(e,t,r,f,i,u.path||"/")}l&&(r[l]||(r[l]=u))}(i,o,s,n,a)}));for(var l=0,d=i.length;l<d;l++)"*"===i[l]&&(i.push(i.splice(l,1)[0]),d--,l--);return{pathList:i,pathMap:o,nameMap:s}}function G(n,e){return T(n,[],e)}function Q(n,e){var t=X(n),r=t.pathList,a=t.pathMap,i=t.nameMap;function o(n,t,o){var s=H(n,t,!1,e),d=s.name;if(d){var c=i[d];if(!c)return l(null,s);var u=c.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof s.params&&(s.params={}),t&&"object"==typeof t.params)for(var h in t.params)!(h in s.params)&&u.indexOf(h)>-1&&(s.params[h]=t.params[h]);return s.path=B(c.path,s.params),l(c,s,o)}if(s.path){s.params={};for(var p=0;p<r.length;p++){var f=r[p],m=a[f];if(Z(m.regex,s.path,s.params))return l(m,s,o)}}return l(null,s)}function s(n,t){var r=n.redirect,a="function"==typeof r?r(f(n,t,null,e)):r;if("string"==typeof a&&(a={path:a}),!a||"object"!=typeof a)return l(null,t);var s=a,d=s.name,c=s.path,u=t.query,h=t.hash,p=t.params;if(u=s.hasOwnProperty("query")?s.query:u,h=s.hasOwnProperty("hash")?s.hash:h,p=s.hasOwnProperty("params")?s.params:p,d){i[d];return o({_normalized:!0,name:d,query:u,hash:h,params:p},void 0,t)}if(c){var m=function(n,e){return k(n,e.parent?e.parent.path:"/",!0)}(c,n);return o({_normalized:!0,path:B(m,p),query:u,hash:h},void 0,t)}return l(null,t)}function l(n,t,r){return n&&n.redirect?s(n,r||t):n&&n.matchAs?function(n,e,t){var r=o({_normalized:!0,path:B(t,e.params)});if(r){var a=r.matched,i=a[a.length-1];return e.params=r.params,l(i,e)}return l(null,e)}(0,t,n.matchAs):f(n,t,r,e)}return{match:o,addRoute:function(n,e){var t="object"!=typeof n?i[n]:void 0;X([e||n],r,a,i,t),t&&t.alias.length&&X(t.alias.map((function(n){return{path:n,children:[e]}})),r,a,i,t)},getRoutes:function(){return r.map((function(n){return a[n]}))},addRoutes:function(n){X(n,r,a,i)}}}function Z(n,e,t){var r=e.match(n);if(!r)return!1;if(!t)return!0;for(var a=1,i=r.length;a<i;++a){var o=n.keys[a-1];o&&(t[o.name||"pathMatch"]="string"==typeof r[a]?d(r[a]):r[a])}return!0}var nn=W&&window.performance&&window.performance.now?window.performance:Date;function en(){return nn.now().toFixed(3)}var tn=en();function rn(){return tn}function an(n){return tn=n}var on=Object.create(null);function sn(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=a({},window.history.state);return t.key=rn(),window.history.replaceState(t,"",e),window.addEventListener("popstate",cn),function(){window.removeEventListener("popstate",cn)}}function ln(n,e,t,r){if(n.app){var a=n.options.scrollBehavior;a&&n.app.$nextTick((function(){var i=function(){var n=rn();if(n)return on[n]}(),o=a.call(n,e,t,r?i:null);o&&("function"==typeof o.then?o.then((function(n){mn(n,i)})).catch((function(n){0})):mn(o,i))}))}}function dn(){var n=rn();n&&(on[n]={x:window.pageXOffset,y:window.pageYOffset})}function cn(n){dn(),n.state&&n.state.key&&an(n.state.key)}function un(n){return pn(n.x)||pn(n.y)}function hn(n){return{x:pn(n.x)?n.x:window.pageXOffset,y:pn(n.y)?n.y:window.pageYOffset}}function pn(n){return"number"==typeof n}var fn=/^#\d/;function mn(n,e){var t,r="object"==typeof n;if(r&&"string"==typeof n.selector){var a=fn.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(a){var i=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),r=n.getBoundingClientRect();return{x:r.left-t.left-e.x,y:r.top-t.top-e.y}}(a,i={x:pn((t=i).x)?t.x:0,y:pn(t.y)?t.y:0})}else un(n)&&(e=hn(n))}else r&&un(n)&&(e=hn(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var gn,vn=W&&((-1===(gn=window.navigator.userAgent).indexOf("Android 2.")&&-1===gn.indexOf("Android 4.0")||-1===gn.indexOf("Mobile Safari")||-1!==gn.indexOf("Chrome")||-1!==gn.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function bn(n,e){dn();var t=window.history;try{if(e){var r=a({},t.state);r.key=rn(),t.replaceState(r,"",n)}else t.pushState({key:an(en())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function yn(n){bn(n,!0)}function xn(n,e,t){var r=function(a){a>=n.length?t():n[a]?e(n[a],(function(){r(a+1)})):r(a+1)};r(0)}var _n={redirected:2,aborted:4,cancelled:8,duplicated:16};function wn(n,e){return kn(n,e,_n.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return jn.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function Nn(n,e){return kn(n,e,_n.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function kn(n,e,t,r){var a=new Error(r);return a._isRouter=!0,a.from=n,a.to=e,a.type=t,a}var jn=["params","query","hash"];function Sn(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function Tn(n,e){return Sn(n)&&n._isRouter&&(null==e||n.type===e)}function Cn(n){return function(e,t,r){var a=!1,i=0,o=null;An(n,(function(n,e,t,s){if("function"==typeof n&&void 0===n.cid){a=!0,i++;var l,d=Pn((function(e){var a;((a=e).__esModule||On&&"Module"===a[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:U.extend(e),t.components[s]=e,--i<=0&&r()})),c=Pn((function(n){var e="Failed to resolve async component "+s+": "+n;o||(o=Sn(n)?n:new Error(e),r(o))}));try{l=n(d,c)}catch(n){c(n)}if(l)if("function"==typeof l.then)l.then(d,c);else{var u=l.component;u&&"function"==typeof u.then&&u.then(d,c)}}})),a||r()}}function An(n,e){return zn(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function zn(n){return Array.prototype.concat.apply([],n)}var On="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function Pn(n){var e=!1;return function(){for(var t=[],r=arguments.length;r--;)t[r]=arguments[r];if(!e)return e=!0,n.apply(this,t)}}var In=function(n,e){this.router=n,this.base=function(n){if(!n)if(W){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=g,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function En(n,e,t,r){var a=An(n,(function(n,r,a,i){var o=function(n,e){"function"!=typeof n&&(n=U.extend(n));return n.options[e]}(n,e);if(o)return Array.isArray(o)?o.map((function(n){return t(n,r,a,i)})):t(o,r,a,i)}));return zn(r?a.reverse():a)}function Ln(n,e){if(e)return function(){return n.apply(e,arguments)}}In.prototype.listen=function(n){this.cb=n},In.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},In.prototype.onError=function(n){this.errorCbs.push(n)},In.prototype.transitionTo=function(n,e,t){var r,a=this;try{r=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var i=this.current;this.confirmTransition(r,(function(){a.updateRoute(r),e&&e(r),a.ensureURL(),a.router.afterHooks.forEach((function(n){n&&n(r,i)})),a.ready||(a.ready=!0,a.readyCbs.forEach((function(n){n(r)})))}),(function(n){t&&t(n),n&&!a.ready&&(Tn(n,_n.redirected)&&i===g||(a.ready=!0,a.readyErrorCbs.forEach((function(e){e(n)}))))}))},In.prototype.confirmTransition=function(n,e,t){var r=this,a=this.current;this.pending=n;var i,o,s=function(n){!Tn(n)&&Sn(n)&&(r.errorCbs.length?r.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},l=n.matched.length-1,d=a.matched.length-1;if(y(n,a)&&l===d&&n.matched[l]===a.matched[d])return this.ensureURL(),n.hash&&ln(this.router,a,n,!1),s(((o=kn(i=a,n,_n.duplicated,'Avoided redundant navigation to current location: "'+i.fullPath+'".')).name="NavigationDuplicated",o));var c=function(n,e){var t,r=Math.max(n.length,e.length);for(t=0;t<r&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),u=c.updated,h=c.deactivated,p=c.activated,f=[].concat(function(n){return En(n,"beforeRouteLeave",Ln,!0)}(h),this.router.beforeHooks,function(n){return En(n,"beforeRouteUpdate",Ln)}(u),p.map((function(n){return n.beforeEnter})),Cn(p)),m=function(e,t){if(r.pending!==n)return s(Nn(a,n));try{e(n,a,(function(e){!1===e?(r.ensureURL(!0),s(function(n,e){return kn(n,e,_n.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(a,n))):Sn(e)?(r.ensureURL(!0),s(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(s(wn(a,n)),"object"==typeof e&&e.replace?r.replace(e):r.push(e)):t(e)}))}catch(n){s(n)}};xn(f,m,(function(){xn(function(n){return En(n,"beforeRouteEnter",(function(n,e,t,r){return function(n,e,t){return function(r,a,i){return n(r,a,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),i(n)}))}}(n,t,r)}))}(p).concat(r.router.resolveHooks),m,(function(){if(r.pending!==n)return s(Nn(a,n));r.pending=null,e(n),r.router.app&&r.router.app.$nextTick((function(){_(n)}))}))}))},In.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},In.prototype.setupListeners=function(){},In.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=g,this.pending=null};var Mn=function(n){function e(e,t){n.call(this,e,t),this._startLocation=Vn(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,r=vn&&t;r&&this.listeners.push(sn());var a=function(){var t=n.current,a=Vn(n.base);n.current===g&&a===n._startLocation||n.transitionTo(a,(function(n){r&&ln(e,n,t,!0)}))};window.addEventListener("popstate",a),this.listeners.push((function(){window.removeEventListener("popstate",a)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){bn(j(r.base+n.fullPath)),ln(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){yn(j(r.base+n.fullPath)),ln(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(Vn(this.base)!==this.current.fullPath){var e=j(this.base+this.current.fullPath);n?bn(e):yn(e)}},e.prototype.getCurrentLocation=function(){return Vn(this.base)},e}(In);function Vn(n){var e=window.location.pathname,t=e.toLowerCase(),r=n.toLowerCase();return!n||t!==r&&0!==t.indexOf(j(r+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var Rn=function(n){function e(e,t,r){n.call(this,e,t),r&&function(n){var e=Vn(n);if(!/^\/#/.test(e))return window.location.replace(j(n+"/#"+e)),!0}(this.base)||$n()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=vn&&e;t&&this.listeners.push(sn());var r=function(){var e=n.current;$n()&&n.transitionTo(Dn(),(function(r){t&&ln(n.router,r,e,!0),vn||Bn(r.fullPath)}))},a=vn?"popstate":"hashchange";window.addEventListener(a,r),this.listeners.push((function(){window.removeEventListener(a,r)}))}},e.prototype.push=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){Fn(n.fullPath),ln(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){Bn(n.fullPath),ln(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;Dn()!==e&&(n?Fn(e):Bn(e))},e.prototype.getCurrentLocation=function(){return Dn()},e}(In);function $n(){var n=Dn();return"/"===n.charAt(0)||(Bn("/"+n),!1)}function Dn(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function qn(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function Fn(n){vn?bn(qn(n)):window.location.hash=n}function Bn(n){vn?yn(qn(n)):window.location.replace(qn(n))}var Hn=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index+1).concat(n),r.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var r=this.stack[t];this.confirmTransition(r,(function(){var n=e.current;e.index=t,e.updateRoute(r),e.router.afterHooks.forEach((function(e){e&&e(r,n)}))}),(function(n){Tn(n,_n.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(In),Un=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Q(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!vn&&!1!==n.fallback,this.fallback&&(e="hash"),W||(e="abstract"),this.mode=e,e){case"history":this.history=new Mn(this,n.base);break;case"hash":this.history=new Rn(this,n.base,this.fallback);break;case"abstract":this.history=new Hn(this,n.base);break;default:0}},Kn={currentRoute:{configurable:!0}};function Jn(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}Un.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},Kn.currentRoute.get=function(){return this.history&&this.history.current},Un.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof Mn||t instanceof Rn){var r=function(n){t.setupListeners(),function(n){var r=t.current,a=e.options.scrollBehavior;vn&&a&&"fullPath"in n&&ln(e,n,r,!1)}(n)};t.transitionTo(t.getCurrentLocation(),r,r)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},Un.prototype.beforeEach=function(n){return Jn(this.beforeHooks,n)},Un.prototype.beforeResolve=function(n){return Jn(this.resolveHooks,n)},Un.prototype.afterEach=function(n){return Jn(this.afterHooks,n)},Un.prototype.onReady=function(n,e){this.history.onReady(n,e)},Un.prototype.onError=function(n){this.history.onError(n)},Un.prototype.push=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.push(n,e,t)}));this.history.push(n,e,t)},Un.prototype.replace=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.replace(n,e,t)}));this.history.replace(n,e,t)},Un.prototype.go=function(n){this.history.go(n)},Un.prototype.back=function(){this.go(-1)},Un.prototype.forward=function(){this.go(1)},Un.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},Un.prototype.resolve=function(n,e,t){var r=H(n,e=e||this.history.current,t,this),a=this.match(r,e),i=a.redirectedFrom||a.fullPath;return{location:r,route:a,href:function(n,e,t){var r="hash"===t?"#"+e:e;return n?j(n+"/"+r):r}(this.history.base,i,this.mode),normalizedTo:r,resolved:a}},Un.prototype.getRoutes=function(){return this.matcher.getRoutes()},Un.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==g&&this.history.transitionTo(this.history.getCurrentLocation())},Un.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==g&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(Un.prototype,Kn),Un.install=function n(e){if(!n.installed||U!==e){n.installed=!0,U=e;var t=function(n){return void 0!==n},r=function(n,e){var r=n.$options._parentVnode;t(r)&&t(r=r.data)&&t(r=r.registerRouteInstance)&&r(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,r(this,this)},destroyed:function(){r(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",w),e.component("RouterLink",J);var a=e.config.optionMergeStrategies;a.beforeRouteEnter=a.beforeRouteLeave=a.beforeRouteUpdate=a.created}},Un.version="3.5.4",Un.isNavigationFailure=Tn,Un.NavigationFailureType=_n,Un.START_LOCATION=g,W&&window.Vue&&window.Vue.use(Un);var Yn=Un;t(98);t(95);var Wn={NotFound:()=>t.e(13).then(t.bind(null,316)),Layout:()=>Promise.all([t.e(0),t.e(2)]).then(t.bind(null,314))},Xn={"v-3ad4456b":()=>t.e(14).then(t.bind(null,321)),"v-07d34d7a":()=>t.e(16).then(t.bind(null,322)),"v-0bddd3a4":()=>t.e(82).then(t.bind(null,323)),"v-79ce3195":()=>t.e(15).then(t.bind(null,324)),"v-a65f4076":()=>t.e(19).then(t.bind(null,325)),"v-1c6e3f95":()=>t.e(17).then(t.bind(null,326)),"v-41a4fc5e":()=>t.e(20).then(t.bind(null,327)),"v-217dde16":()=>t.e(22).then(t.bind(null,328)),"v-76a57669":()=>t.e(21).then(t.bind(null,329)),"v-e036e756":()=>t.e(23).then(t.bind(null,330)),"v-9139b18a":()=>t.e(24).then(t.bind(null,331)),"v-49904405":()=>t.e(25).then(t.bind(null,332)),"v-649ccb56":()=>t.e(26).then(t.bind(null,333)),"v-9751b882":()=>t.e(18).then(t.bind(null,334)),"v-65084bb4":()=>t.e(29).then(t.bind(null,335)),"v-2ef6a612":()=>t.e(27).then(t.bind(null,336)),"v-3b24155e":()=>t.e(28).then(t.bind(null,337)),"v-7f8a6bd5":()=>t.e(30).then(t.bind(null,338)),"v-57159cad":()=>t.e(31).then(t.bind(null,339)),"v-c99dd316":()=>t.e(32).then(t.bind(null,340)),"v-f3c1e4e2":()=>t.e(33).then(t.bind(null,341)),"v-03d8873b":()=>t.e(35).then(t.bind(null,342)),"v-7af007f5":()=>t.e(34).then(t.bind(null,343)),"v-ea677b16":()=>t.e(36).then(t.bind(null,344)),"v-45875829":()=>t.e(40).then(t.bind(null,345)),"v-42bdb895":()=>t.e(37).then(t.bind(null,346)),"v-79b9b1d7":()=>t.e(39).then(t.bind(null,347)),"v-bb0e9124":()=>t.e(44).then(t.bind(null,348)),"v-390e2f26":()=>t.e(41).then(t.bind(null,349)),"v-162bf415":()=>t.e(42).then(t.bind(null,350)),"v-ce31282e":()=>t.e(43).then(t.bind(null,351)),"v-6e866b56":()=>t.e(45).then(t.bind(null,352)),"v-1fd34c35":()=>t.e(48).then(t.bind(null,353)),"v-0e9221d6":()=>t.e(47).then(t.bind(null,354)),"v-1696c5b5":()=>t.e(46).then(t.bind(null,355)),"v-1a0d3835":()=>t.e(49).then(t.bind(null,356)),"v-f36ef296":()=>t.e(50).then(t.bind(null,357)),"v-3feaf1d5":()=>t.e(51).then(t.bind(null,358)),"v-5428026a":()=>t.e(52).then(t.bind(null,359)),"v-bbc4fa82":()=>t.e(38).then(t.bind(null,360)),"v-495d0d29":()=>t.e(54).then(t.bind(null,361)),"v-21516316":()=>t.e(53).then(t.bind(null,362)),"v-78408355":()=>t.e(55).then(t.bind(null,363)),"v-0f60c256":()=>t.e(56).then(t.bind(null,364)),"v-02a48cf5":()=>t.e(57).then(t.bind(null,365)),"v-3a2914f5":()=>t.e(59).then(t.bind(null,366)),"v-0352edef":()=>t.e(61).then(t.bind(null,367)),"v-f3313c56":()=>t.e(60).then(t.bind(null,368)),"v-f5497496":()=>t.e(62).then(t.bind(null,369)),"v-a66e355c":()=>t.e(64).then(t.bind(null,370)),"v-aaa51dc2":()=>t.e(65).then(t.bind(null,371)),"v-d039a31a":()=>t.e(68).then(t.bind(null,372)),"v-20aeabe7":()=>t.e(70).then(t.bind(null,373)),"v-785b8656":()=>t.e(66).then(t.bind(null,374)),"v-e73b2872":()=>t.e(71).then(t.bind(null,375)),"v-0d51cfe9":()=>t.e(72).then(t.bind(null,376)),"v-4ff83756":()=>t.e(69).then(t.bind(null,377)),"v-04c70155":()=>t.e(75).then(t.bind(null,378)),"v-1690bca1":()=>t.e(76).then(t.bind(null,379)),"v-73b8d232":()=>t.e(73).then(t.bind(null,380)),"v-56edd5c6":()=>t.e(67).then(t.bind(null,381)),"v-ebee5d56":()=>t.e(78).then(t.bind(null,382)),"v-23d56c5b":()=>t.e(63).then(t.bind(null,383)),"v-2264f0f6":()=>t.e(79).then(t.bind(null,384)),"v-2b5eefb2":()=>t.e(77).then(t.bind(null,385)),"v-19a2deaa":()=>t.e(80).then(t.bind(null,386)),"v-3a2a67dc":()=>t.e(74).then(t.bind(null,387)),"v-fa7f0416":()=>t.e(84).then(t.bind(null,388)),"v-e18b4c64":()=>t.e(81).then(t.bind(null,389)),"v-c0792b56":()=>t.e(83).then(t.bind(null,390)),"v-0171d335":()=>t.e(58).then(t.bind(null,391)),"v-900bc0e2":()=>t.e(87).then(t.bind(null,392)),"v-4b62e23a":()=>t.e(89).then(t.bind(null,393)),"v-5da62161":()=>t.e(90).then(t.bind(null,394)),"v-4f9c3516":()=>t.e(92).then(t.bind(null,395)),"v-b548d0fa":()=>t.e(86).then(t.bind(null,396)),"v-397682b5":()=>t.e(91).then(t.bind(null,397)),"v-7e8a4b55":()=>t.e(96).then(t.bind(null,398)),"v-5ed5b2a2":()=>t.e(85).then(t.bind(null,399)),"v-49363b4b":()=>t.e(95).then(t.bind(null,400)),"v-3c1db7b5":()=>t.e(98).then(t.bind(null,401)),"v-2006ac96":()=>t.e(88).then(t.bind(null,402)),"v-7b268c62":()=>t.e(94).then(t.bind(null,403)),"v-4cfc62f5":()=>t.e(93).then(t.bind(null,404)),"v-778a4b06":()=>t.e(97).then(t.bind(null,405)),"v-571ef5f5":()=>t.e(99).then(t.bind(null,406))};function Gn(n){const e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}const Qn=/-(\w)/g,Zn=Gn(n=>n.replace(Qn,(n,e)=>e?e.toUpperCase():"")),ne=/\B([A-Z])/g,ee=Gn(n=>n.replace(ne,"-$1").toLowerCase()),te=Gn(n=>n.charAt(0).toUpperCase()+n.slice(1));function re(n,e){if(!e)return;if(n(e))return n(e);return e.includes("-")?n(te(Zn(e))):n(te(e))||n(ee(e))}const ae=Object.assign({},Wn,Xn),ie=n=>ae[n],oe=n=>Xn[n],se=n=>Wn[n],le=n=>r.a.component(n);function de(n){return re(oe,n)}function ce(n){return re(se,n)}function ue(n){return re(ie,n)}function he(n){return re(le,n)}function pe(...n){return Promise.all(n.filter(n=>n).map(async n=>{if(!he(n)&&ue(n)){const e=await ue(n)();r.a.component(n,e.default)}}))}function fe(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}var me=t(87),ge=t.n(me),ve=t(88),be=t.n(ve),ye={created(){if(this.siteMeta=this.$site.headTags.filter(([n])=>"meta"===n).map(([n,e])=>e),this.$ssrContext){const e=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(n=e)?n.map(n=>{let e="<meta";return Object.keys(n).forEach(t=>{e+=` ${t}="${be()(n[t])}"`}),e+">"}).join("\n    "):"",this.$ssrContext.canonicalLink=_e(this.$canonicalUrl)}var n},mounted(){this.currentMetaTags=[...document.querySelectorAll("meta")],this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta(){document.title=this.$title,document.documentElement.lang=this.$lang;const n=this.getMergedMetaTags();this.currentMetaTags=we(n,this.currentMetaTags)},getMergedMetaTags(){const n=this.$page.frontmatter.meta||[];return ge()([{name:"description",content:this.$description}],n,this.siteMeta,Ne)},updateCanonicalLink(){xe(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",_e(this.$canonicalUrl))}},watch:{$page(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy(){we(null,this.currentMetaTags),xe()}};function xe(){const n=document.querySelector("link[rel='canonical']");n&&n.remove()}function _e(n=""){return n?`<link href="${n}" rel="canonical" />`:""}function we(n,e){if(e&&[...e].filter(n=>n.parentNode===document.head).forEach(n=>document.head.removeChild(n)),n)return n.map(n=>{const e=document.createElement("meta");return Object.keys(n).forEach(t=>{e.setAttribute(t,n[t])}),document.head.appendChild(e),e})}function Ne(n){for(const e of["name","property","itemprop"])if(n.hasOwnProperty(e))return n[e]+e;return JSON.stringify(n)}var ke=t(89),je={mounted(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(ke)()((function(){this.setActiveHash()}),300),setActiveHash(){const n=[].slice.call(document.querySelectorAll(".sidebar-link")),e=[].slice.call(document.querySelectorAll(".header-anchor")).filter(e=>n.some(n=>n.hash===e.hash)),t=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),r=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),a=window.innerHeight+t;for(let n=0;n<e.length;n++){const i=e[n],o=e[n+1],s=0===n&&0===t||t>=i.parentElement.offsetTop+10&&(!o||t<o.parentElement.offsetTop-10),l=decodeURIComponent(this.$route.hash);if(s&&l!==decodeURIComponent(i.hash)){const t=i;if(a===r)for(let t=n+1;t<e.length;t++)if(l===decodeURIComponent(e[t].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(t.hash),()=>{this.$nextTick(()=>{this.$vuepress.$set("disableScrollBehavior",!1)})})}}}},beforeDestroy(){window.removeEventListener("scroll",this.onScroll)}},Se=(t(227),{data:()=>({zoom:null}),mounted(){this.updateCopy()},updated(){this.updateCopy()},methods:{updateCopy(){setTimeout(()=>{document.querySelectorAll('div[class*="language-"]').forEach(this.generateCopyButton)},1e3)},generateCopyButton:function(n){if(n.classList.contains("codecopy-enabled"))return;const e=document.createElement("span");e.className="code-copy",e.title="Click to Copy to Clipboard",e.addEventListener("click",()=>{this.copyToClipboard(n.innerText),e.classList.add("copied");const t=setTimeout(()=>{e.classList.remove("copied"),clearTimeout(t)},2e3)}),n.appendChild(e),n.classList.add("codecopy-enabled")},copyToClipboard:function(n){const e=document.createElement("textarea");e.value=n,e.setAttribute("readonly",""),e.style.position="absolute",e.style.left="-9999px",document.body.appendChild(e);const t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);e.select(),document.execCommand("copy"),document.body.removeChild(e),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))}}}),Te=t(23),Ce=t.n(Te),Ae=[ye,je,Se,{mounted(){Ce.a.configure({showSpinner:!1}),this.$router.beforeEach((n,e,t)=>{n.path===e.path||r.a.component(n.name)||Ce.a.start(),t()}),this.$router.afterEach(()=>{Ce.a.done(),this.isSidebarOpen=!1})}}],ze={name:"GlobalLayout",computed:{layout(){const n=this.getLayout();return fe("layout",n),r.a.component(n)}},methods:{getLayout(){if(this.$page.path){const n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},Oe=t(14),Pe=Object(Oe.a)(ze,(function(){return(0,this._self._c)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),n[e].push(...t);break;default:throw new Error("Unknown option name.")}}(Pe,"mixins",Ae);const Ie=[{name:"v-3ad4456b",path:"/cloud-server.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-3ad4456b").then(t)}},{name:"v-07d34d7a",path:"/data-structure/graph/bfs.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-07d34d7a").then(t)}},{name:"v-0bddd3a4",path:"/",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-0bddd3a4").then(t)}},{path:"/index.html",redirect:"/"},{name:"v-79ce3195",path:"/command.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-79ce3195").then(t)}},{name:"v-a65f4076",path:"/data-structure/graph/minimum-spanning-tree.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-a65f4076").then(t)}},{name:"v-1c6e3f95",path:"/data-structure/graph/desc.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-1c6e3f95").then(t)}},{name:"v-41a4fc5e",path:"/data-structure/graph/shortest-path.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-41a4fc5e").then(t)}},{name:"v-217dde16",path:"/data-structure/hash/buildTree.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-217dde16").then(t)}},{name:"v-76a57669",path:"/data-structure/graph/topology-sort.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-76a57669").then(t)}},{name:"v-e036e756",path:"/data-structure/hash/deepClone.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-e036e756").then(t)}},{name:"v-9139b18a",path:"/data-structure/hash/desc.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-9139b18a").then(t)}},{name:"v-49904405",path:"/data-structure/hash/removeZero.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-49904405").then(t)}},{name:"v-649ccb56",path:"/data-structure/hash/sum.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-649ccb56").then(t)}},{name:"v-9751b882",path:"/data-structure/graph/dfs.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-9751b882").then(t)}},{name:"v-65084bb4",path:"/data-structure/",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-65084bb4").then(t)}},{path:"/data-structure/index.html",redirect:"/data-structure/"},{name:"v-2ef6a612",path:"/data-structure/heap/desc.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-2ef6a612").then(t)}},{name:"v-3b24155e",path:"/data-structure/heap/topKFrequent.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-3b24155e").then(t)}},{name:"v-7f8a6bd5",path:"/data-structure/list/array.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-7f8a6bd5").then(t)}},{name:"v-57159cad",path:"/data-structure/list/doubleLinkedList.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-57159cad").then(t)}},{name:"v-c99dd316",path:"/data-structure/list/lfu-cache.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-c99dd316").then(t)}},{name:"v-f3c1e4e2",path:"/data-structure/list/linkedList.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-f3c1e4e2").then(t)}},{name:"v-03d8873b",path:"/data-structure/list/mergeArray.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-03d8873b").then(t)}},{name:"v-7af007f5",path:"/data-structure/list/lru-cache.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-7af007f5").then(t)}},{name:"v-ea677b16",path:"/data-structure/queue/desc.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-ea677b16").then(t)}},{name:"v-45875829",path:"/data-structure/sort/bubbleSort.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-45875829").then(t)}},{name:"v-42bdb895",path:"/data-structure/search/avlTree.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-42bdb895").then(t)}},{name:"v-79b9b1d7",path:"/data-structure/search/skipList.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-79b9b1d7").then(t)}},{name:"v-bb0e9124",path:"/data-structure/sort/",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-bb0e9124").then(t)}},{path:"/data-structure/sort/index.html",redirect:"/data-structure/sort/"},{name:"v-390e2f26",path:"/data-structure/sort/bucketSort.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-390e2f26").then(t)}},{name:"v-162bf415",path:"/data-structure/sort/compare.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-162bf415").then(t)}},{name:"v-ce31282e",path:"/data-structure/sort/heapSort.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-ce31282e").then(t)}},{name:"v-6e866b56",path:"/data-structure/sort/insertionSort.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-6e866b56").then(t)}},{name:"v-1fd34c35",path:"/data-structure/sort/radixSort.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-1fd34c35").then(t)}},{name:"v-0e9221d6",path:"/data-structure/sort/quickSort.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-0e9221d6").then(t)}},{name:"v-1696c5b5",path:"/data-structure/sort/mergeSort.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-1696c5b5").then(t)}},{name:"v-1a0d3835",path:"/data-structure/sort/selectionSort.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-1a0d3835").then(t)}},{name:"v-f36ef296",path:"/data-structure/sort/shellSort.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-f36ef296").then(t)}},{name:"v-3feaf1d5",path:"/data-structure/stack/desc.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-3feaf1d5").then(t)}},{name:"v-5428026a",path:"/data-structure/stack/dfs.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-5428026a").then(t)}},{name:"v-bbc4fa82",path:"/data-structure/search/binarySearch.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-bbc4fa82").then(t)}},{name:"v-495d0d29",path:"/data-structure/stack/reverse.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-495d0d29").then(t)}},{name:"v-21516316",path:"/data-structure/stack/monotonous-stack.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-21516316").then(t)}},{name:"v-78408355",path:"/data-structure/stack/syntaxAnalysis.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-78408355").then(t)}},{name:"v-0f60c256",path:"/data-structure/string/KMP.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-0f60c256").then(t)}},{name:"v-02a48cf5",path:"/data-structure/tree/N-Tree/Trie.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-02a48cf5").then(t)}},{name:"v-3a2914f5",path:"/data-structure/tree/N-Tree/dfsVisit.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-3a2914f5").then(t)}},{name:"v-0352edef",path:"/data-structure/tree/binaryTree/construct.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-0352edef").then(t)}},{name:"v-f3313c56",path:"/data-structure/tree/binarySearchTree/desc.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-f3313c56").then(t)}},{name:"v-f5497496",path:"/data-structure/tree/binaryTree/inOrderVisit.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-f5497496").then(t)}},{name:"v-a66e355c",path:"/data-structure/tree/binaryTree/morrisVisit%20copy.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-a66e355c").then(t)}},{path:"/data-structure/tree/binaryTree/morrisVisit copy.html",redirect:"/data-structure/tree/binaryTree/morrisVisit%20copy.html"},{path:"/data-structure/tree/binaryTree/morrisVisit copy.html",redirect:"/data-structure/tree/binaryTree/morrisVisit%20copy.html"},{name:"v-aaa51dc2",path:"/data-structure/tree/binaryTree/morrisVisit.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-aaa51dc2").then(t)}},{name:"v-d039a31a",path:"/design-pattern/adaptor.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-d039a31a").then(t)}},{name:"v-20aeabe7",path:"/design-pattern/command.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-20aeabe7").then(t)}},{name:"v-785b8656",path:"/data-structure/tree/binaryTree/postOrderVisit.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-785b8656").then(t)}},{name:"v-e73b2872",path:"/design-pattern/decorator.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-e73b2872").then(t)}},{name:"v-0d51cfe9",path:"/design-pattern/factory.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-0d51cfe9").then(t)}},{name:"v-4ff83756",path:"/design-pattern/bridge.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-4ff83756").then(t)}},{name:"v-04c70155",path:"/design-pattern/mediator.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-04c70155").then(t)}},{name:"v-1690bca1",path:"/design-pattern/proxy.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-1690bca1").then(t)}},{name:"v-73b8d232",path:"/design-pattern/flyweight.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-73b8d232").then(t)}},{name:"v-56edd5c6",path:"/data-structure/tree/binaryTree/preOrderVisit.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-56edd5c6").then(t)}},{name:"v-ebee5d56",path:"/design-pattern/strategy.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-ebee5d56").then(t)}},{name:"v-23d56c5b",path:"/data-structure/tree/binaryTree/levelOrderVisit.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-23d56c5b").then(t)}},{name:"v-2264f0f6",path:"/design-pattern/watcher.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-2264f0f6").then(t)}},{name:"v-2b5eefb2",path:"/design-pattern/singleton.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-2b5eefb2").then(t)}},{name:"v-19a2deaa",path:"/frameworks/",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-19a2deaa").then(t)}},{path:"/frameworks/index.html",redirect:"/frameworks/"},{name:"v-3a2a67dc",path:"/design-pattern/",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-3a2a67dc").then(t)}},{path:"/design-pattern/index.html",redirect:"/design-pattern/"},{name:"v-fa7f0416",path:"/javascript/ajax.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-fa7f0416").then(t)}},{name:"v-e18b4c64",path:"/guide/",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-e18b4c64").then(t)}},{path:"/guide/index.html",redirect:"/guide/"},{name:"v-c0792b56",path:"/javascript/RegExp.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-c0792b56").then(t)}},{name:"v-0171d335",path:"/data-structure/tree/N-Tree/bfsVisit.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-0171d335").then(t)}},{name:"v-900bc0e2",path:"/javascript/es6/spread-symbol.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-900bc0e2").then(t)}},{name:"v-4b62e23a",path:"/javascript/",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-4b62e23a").then(t)}},{path:"/javascript/index.html",redirect:"/javascript/"},{name:"v-5da62161",path:"/javascript/prototype.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-5da62161").then(t)}},{name:"v-4f9c3516",path:"/javascript/write/EventEmitter.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-4f9c3516").then(t)}},{name:"v-b548d0fa",path:"/javascript/es6/class.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-b548d0fa").then(t)}},{name:"v-397682b5",path:"/javascript/this.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-397682b5").then(t)}},{name:"v-7e8a4b55",path:"/javascript/write/debounce.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-7e8a4b55").then(t)}},{name:"v-5ed5b2a2",path:"/javascript/closure.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-5ed5b2a2").then(t)}},{name:"v-49363b4b",path:"/javascript/write/clone.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-49363b4b").then(t)}},{name:"v-3c1db7b5",path:"/javascript/write/throttle.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-3c1db7b5").then(t)}},{name:"v-2006ac96",path:"/javascript/extend.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-2006ac96").then(t)}},{name:"v-7b268c62",path:"/javascript/write/Promise.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-7b268c62").then(t)}},{name:"v-4cfc62f5",path:"/javascript/write/JSON.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-4cfc62f5").then(t)}},{name:"v-778a4b06",path:"/javascript/write/flatten.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-778a4b06").then(t)}},{name:"v-571ef5f5",path:"/mysql.html",component:Pe,beforeEnter:(n,e,t)=>{pe("Layout","v-571ef5f5").then(t)}},{path:"*",component:Pe}],Ee={title:"awesome-frontend-code",description:"HsuYang的个人博客，主要对于平时学习知识的理解与记录",base:"/",headTags:[["script",{},'\n    var _hmt = _hmt || [];\n    (function() {\n      var hm = document.createElement("script");\n      hm.src = "https://hm.baidu.com/hm.js?2c567a12c7860a8915d6ce4cb17a538e";\n      var s = document.getElementsByTagName("script")[0]; \n      s.parentNode.insertBefore(hm, s);\n    })();\n      '],["meta",{name:"referrer",content:"no-referrer-when-downgrade"}],["link",{rel:"icon",href:"/favicon.ico"}]],pages:[{title:"云服务器相关",frontmatter:{},regularPath:"/cloud-server.html",relativePath:"cloud-server.md",key:"v-3ad4456b",path:"/cloud-server.html",headersStr:null,content:"# 云服务器相关\n\n使用命令行登录\n\nssh [user]@[ip]\n\n\n使得服务器可以支持root账号登录，修改root账号登录\n\nUbuntu安装docker\n\ndocker ps [-a]\ndocker rmi [镜像ID]\ndocker pull [镜像源名称]\ndocker rm -f [容器实例]\ndocker build -t [TagName] [dir]\ndocker run -d -p [端口映射关系] [容器ID]\ndocker exec -it [容器实例，如gitlab] [内部的bin名称]\n\n\ndocker run -d --name yapi --restart=always --privileged=true -p 3000:3000 -e YAPI_ADMIN_ACCOUNT=admin@yangxu.com -e YAPI_ADMIN_PASSWORD=123456 -e YAPI_CLOSE_REGISTER=true -e YAPI_DB_SERVERNAME=1.12.243.15 -e YAPI_DB_PORT=27017 -e YAPI_DB_DATABASE=yapi -e YAPI_DB_USER=admin -e YAPI_DB_PASS=123456 -e YAPI_DB_AUTH_SOURCE=admin -e YAPI_MAIL_ENABLE=false -e YAPI_PLUGINS=[] jayfong/yapi\n\ndocker run -itd --name redis -p 6379:6379 redis\n\ndocker run -d -p 8443:443 -p 8090:80 -p 8022:22 --restart always --name gitlab -v /usr/local/gitlab/etc:/etc/gitlab -v /usr/local/gitlab/log:/var/log/gitlab -v /usr/local/gitlab/data:/var/opt/gitlab --privileged=true --platform linux/amd64 twang2218/gitlab-ce-zh\n\ndocker run --name nginx -p 8080:80 -d nginx",normalizedContent:"# 云服务器相关\n\n使用命令行登录\n\nssh [user]@[ip]\n\n\n使得服务器可以支持root账号登录，修改root账号登录\n\nubuntu安装docker\n\ndocker ps [-a]\ndocker rmi [镜像id]\ndocker pull [镜像源名称]\ndocker rm -f [容器实例]\ndocker build -t [tagname] [dir]\ndocker run -d -p [端口映射关系] [容器id]\ndocker exec -it [容器实例，如gitlab] [内部的bin名称]\n\n\ndocker run -d --name yapi --restart=always --privileged=true -p 3000:3000 -e yapi_admin_account=admin@yangxu.com -e yapi_admin_password=123456 -e yapi_close_register=true -e yapi_db_servername=1.12.243.15 -e yapi_db_port=27017 -e yapi_db_database=yapi -e yapi_db_user=admin -e yapi_db_pass=123456 -e yapi_db_auth_source=admin -e yapi_mail_enable=false -e yapi_plugins=[] jayfong/yapi\n\ndocker run -itd --name redis -p 6379:6379 redis\n\ndocker run -d -p 8443:443 -p 8090:80 -p 8022:22 --restart always --name gitlab -v /usr/local/gitlab/etc:/etc/gitlab -v /usr/local/gitlab/log:/var/log/gitlab -v /usr/local/gitlab/data:/var/opt/gitlab --privileged=true --platform linux/amd64 twang2218/gitlab-ce-zh\n\ndocker run --name nginx -p 8080:80 -d nginx",charsets:{cjk:!0}},{title:"广度优先搜索",frontmatter:{},regularPath:"/data-structure/graph/bfs.html",relativePath:"data-structure/graph/bfs.md",key:"v-07d34d7a",path:"/data-structure/graph/bfs.html",headers:[{level:2,title:"广度优先搜索",slug:"广度优先搜索",normalizedTitle:"广度优先搜索",charIndex:2},{level:3,title:"BFS 的标准范式",slug:"bfs-的标准范式",normalizedTitle:"bfs 的标准范式",charIndex:267},{level:3,title:"BFS 的应用",slug:"bfs-的应用",normalizedTitle:"bfs 的应用",charIndex:717}],headersStr:"广度优先搜索 BFS 的标准范式 BFS 的应用",content:'# 广度优先搜索\n\n广度优先搜索算法（Breadth-First Search，缩写为 BFS），又称为宽度优先搜索，是一种图形搜索算法。简单的说，BFS 是从根结点开始，沿着树的宽度遍历树的结点。如果所有结点均被访问，则算法中止。\n\n下图生动形象的为我们展示了BFS的处理流程。\n\n\n\n它总是一圈一圈的从内往外处理，每次都是一滴不漏的处理完每个角落，才会开始下一圈的处理。\n\n比如下图展示的就是一个使用 BFS 遍历二叉树的过程：\n\n\n\n由于本文和DFS有着非常强的关联，请各位读者在阅读之前，请确保已经阅读深度优先搜索。\n\n\n# BFS 的标准范式\n\nBFS，从一个给定的节点开始，每遍历一个节点，将当前节点标记为已遍历，并且将当前节点的未处理过的所有邻接节点加入队列中，若队列为空则遍历完成，若不为空，则从队列中再取出一个节点继续上述流程，直到遍历完成。\n\nfunction bfs(v, visited) {\n  // 将当前节点标记为已处理\n  visited[v] = true;\n  // 将当前节点入队\n  enqueue(v, Q);\n  // 当队列中存在元素\n  while (!isEmpty(Q)) {\n    // 从队列中取出一个节点\n    v = dequeue(v, Q);\n    for(v 的每个邻接点 W) {\n      // 若当前邻接点没有处理过，则将其标记为处理过，并且加入队列中去\n      if(!visited[W]) {\n        visited[W] = true;\n        enqueue(v, w);\n      }\n    }\n  }\n}\n\n\n\n# BFS 的应用\n\n一般来说，能够使用DFS进行处理的问题都可以使用BFS处理，我们还是以之前DFS节讨论过的问题为例，看看使用 BFS 的话，可以怎么样实现它。因为BFS是非递归的算法，如果在数据量比较大的时候，请考虑要非递归实现DFS或直接使用BFS。\n\n# 拍平数组（flat）\n\n假设有这样的数组： [1,[2,3,[[4]]],[5],[[[[[6],7,8]]],9], 10]，请将其展平为[1,2,3,4,5,6,7,8,9,10]。\n\n/**\n * 以广度优先的方式拍平数组\n * @param {any[]} arr\n */\nfunction flat(arr) {\n  const results = [];\n  // 将数据加入到队列中\n  const queue = [];\n  if (Array.isArray(arr)) {\n    queue.push(arr);\n  }\n  // 当队列内容不为空时，继续拍平数据\n  while (queue.length) {\n    // 从队列中取出一个元素，并且这个出队的一定是数组\n    const ele = queue.shift();\n    ele.forEach((subEle) => {\n      if (Array.isArray(subEle)) {\n        queue.push(subEle);\n      } else {\n        results.push(subEle);\n      }\n    });\n  }\n  return results.sort((a, b) => a - b);\n}\n\n\n为什么需要排序呢，因为在拍平的过程中，对于嵌套较深的元素，它的处理过程是滞后于不嵌套的元素的，比如先处理了 1，然后立马处理的是 10，所以 10 就跑到了 2,3 的前面去了。所以说，在根据实际情况，选择使用DFS或DFS，显然本例就不适合使用BFS。\n\n# 深拷贝对象\n\n使用广度优先深拷贝一个对象有个比较不容易想到的地方，就是对象的key，不同于像普通的树或图那样，你持有某个引用，你可以方便的使用curObj.xxx获取到它的邻接点。所以我经过思考后，每次入队的都是一对的源对象和被拷贝对象，这样就可以很方便的直接根据当前源对象进行遍历然后依次给拷贝对象添加属性了。\n\n注意，在此处我实现的深拷贝并没有完整考虑所有的情况，如果对深拷贝感兴趣的同学，请移步 lodash 的源码参考其实现。\n\n/**\n * 使用广度优先深拷贝一个对象\n * @param {Array<any> | object} obj\n * @returns\n */\nfunction deepClone(obj) {\n  // 根据目标对象确定拷贝是数组还是对象\n  let cloneObj = Array.isArray(obj) ? [] : {};\n  // 用一个map用以记住被拷贝过的内容\n  const map = new Map();\n  // 记住当前对象已经被拷贝过了\n  map.set(obj, cloneObj);\n  // 把原始内容和拷贝的内容追加到队列中去，准备开始以广度优先的方式进行深拷贝\n  const queue = [\n    {\n      source: obj,\n      clone: cloneObj,\n    },\n  ];\n  while (queue.length > 0) {\n    const { source, clone } = queue.shift();\n    for (let prop in source) {\n      if (source[prop] instanceof Object) {\n        // 如果已经拷贝过，则直接将内容复制到目标对象上去\n        if (map.get(source[prop])) {\n          clone[prop] = map.get(source[prop]);\n        } else {\n          // 把当前对象和拷贝的空对象加入到队列中去，准备后序的深拷贝\n          const nextClone = Array.isArray(source[prop]) ? [] : {};\n          queue.push({\n            source: source[prop],\n            clone: nextClone,\n          });\n          // 建立拷贝关系，本轮还是空内容（可以理解为拷贝一个容器），待下一轮循环才拷贝值\n          clone[prop] = nextClone;\n          // 将已经拷贝的内容加入到map中去，防止循环拷贝\n          map.set(source[prop], nextClone);\n        }\n      } else {\n        // 基本类型，可直接拷贝\n        clone[prop] = source[prop];\n      }\n    }\n  }\n  return cloneObj;\n}\n\n\n# 迷宫问题\n\n这是华为的一道机考题。\n\n定义一个二维数组 N*M ，如 5 × 5 数组下所示：\n\n[\n  [0, 1, 0, 0, 0],\n  [0, 1, 1, 1, 0],\n  [0, 0, 0, 0, 0],\n  [0, 1, 1, 1, 0],\n  [0, 0, 0, 1, 0],\n];\n\n\n它表示一个迷宫，其中的 1 表示墙壁，0 表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的路线。入口点为[0,0],既第一格是可以走的路。\n\n输入两个整数，分别表示二维数组的行数，列数。再输入相应的数组，其中的 1 表示墙壁，0 表示可以走的路。数据保证有唯一解,不考虑有多解的情况，即迷宫只有一条通道。\n\n/**\n * 以BFS的形式找迷宫的出口\n * @param {number[]} matrix\n */\nfunction findPath(matrix) {\n  const height = matrix.length;\n  const width = matrix[0].length;\n  // 定义一个队列\n  const queue = [];\n  // 定义一个标记数组\n  const maker = Array.from({\n    length: height,\n  }).map(() => {\n    return Array.from({\n      length: width,\n    }).fill(0);\n  });\n  // 先将开始节点加入到队列中去\n  queue.push({\n    x: 0,\n    y: 0,\n    path: [[0, 0]],\n  });\n  // 将起始节点标记为已处理\n  maker[0][0] = true;\n  let distPath = null;\n  while (queue.length) {\n    const { x, y, path } = queue.shift();\n    if (x === width - 1 && y === height - 1) {\n      distPath = path;\n    }\n    // 上边的点，存在且没有被访问过，并且不是障碍物\n    const topPoint =\n      isExist(matrix, x, y - 1) && !maker[y - 1][x] && matrix[y - 1][x] !== 1\n        ? { x, y: y - 1 }\n        : null;\n    if (topPoint) {\n      queue.push({\n        x: topPoint.x,\n        y: topPoint.y,\n        path: [...path, [topPoint.y, topPoint.x]],\n      });\n      maker[y - 1][x] = true;\n    }\n    // 右边的点，存在且没有被访问过，并且不是障碍物\n    const rightPoint =\n      isExist(matrix, x + 1, y) && !maker[y][x + 1] && matrix[y][x + 1] !== 1\n        ? { x: x + 1, y }\n        : null;\n    if (rightPoint) {\n      queue.push({\n        x: rightPoint.x,\n        y: rightPoint.y,\n        path: [...path, [rightPoint.y, rightPoint.x]],\n      });\n      maker[y][x + 1] = true;\n    }\n    // 下边的点，存在且没有被访问过，并且不是障碍物\n    const bottomPoint =\n      isExist(matrix, x, y + 1) && !maker[y + 1][x] && matrix[y + 1][x] !== 1\n        ? { x, y: y + 1 }\n        : null;\n    if (bottomPoint) {\n      queue.push({\n        x: bottomPoint.x,\n        y: bottomPoint.y,\n        path: [...path, [bottomPoint.y, bottomPoint.x]],\n      });\n      maker[y + 1][x] = true;\n    }\n    // 左边的点 存在且没有被访问过，并且不是障碍物\n    const leftPoint =\n      isExist(matrix, x - 1, y) && !maker[y][x - 1] && matrix[y][x - 1] !== 1\n        ? { x: x - 1, y }\n        : null;\n    if (leftPoint) {\n      queue.push({\n        x: leftPoint.x,\n        y: leftPoint.y,\n        path: [...path, [leftPoint.y, leftPoint.x]],\n      });\n      maker[y][x - 1] = true;\n    }\n  }\n  return distPath;\n}\n\n/**\n * 判断当前元素是否存在于迷宫中\n * @param {number[][]} matrix\n * @param {number} x\n * @param {number} y\n */\nfunction isExist(matrix, x, y) {\n  return Array.isArray(matrix[y]) && typeof matrix[y][x] !== "undefined";\n}\n\n\n使用BFS查找迷宫的出路有个问题，虽然我们在找路的时候比较方便，但是怎么把这个路径记录下来却是个问题。\n\n因此，我在上述搜索过程中把对应已经走过的 path 一并加入到了队列中，在取出节点进行判断的时候，可以很方便的知道之前走过的路径是怎么样的，但是问题就是这样会占用大量的内存空间，所以对于这个问题，我实现的BFS是不如DFS的，如果读者有更好的解法，欢迎提出，大家一起交流，把它完善的更美好，以传递更好的知识。\n\n在后来，我学习并理解了最短路径算法之后，发现可以有一个比较优雅的解法，其做法和无权图的最短路径求解手段类似，在求解过程中利用哈希表把当前节点和它对应的父节点记录下来，这样就可以从终点一直倒推到起点，再反序输出即可得到正序的路径。\n\n下面的实现相对于上面的实现占用的内存空间占用会小的多。\n\n/**\n * 以BFS的形式找迷宫的出口\n * @param {number[]} matrix\n */\nfunction findPath(matrix) {\n  const height = matrix.length;\n  const width = matrix[0].length;\n  /* 定义一个哈希表，用于记住经过的路径 */\n  const pathMap = new Map();\n  // 定义一个队列\n  const queue = [];\n  // 定义一个标记数组\n  const maker = Array.from({\n    length: height,\n  }).map(() => {\n    return Array.from({\n      length: width,\n    }).fill(0);\n  });\n  // 先将开始节点加入到队列中去\n  queue.push({\n    node: { x: 0, y: 0 },\n    /* 入口的父节点为空 */\n    parent: null,\n  });\n  // 将起始节点标记为已处理\n  maker[0][0] = true;\n  let distNode = null;\n  while (queue.length) {\n    const { node, parent } = queue.shift();\n    /* 将当前节点记录在到终点的路径上 */\n    pathMap.set(node, parent);\n    const { x, y } = node;\n    if (x === width - 1 && y === height - 1) {\n      distNode = node;\n      break;\n    }\n    // 上边的点，存在且没有被访问过，并且不是障碍物\n    const topPoint =\n      isExist(matrix, x, y - 1) && !maker[y - 1][x] && matrix[y - 1][x] !== 1\n        ? { x, y: y - 1 }\n        : null;\n    if (topPoint) {\n      queue.push({\n        node: topPoint,\n        parent: node,\n      });\n      maker[y - 1][x] = true;\n    }\n    // 右边的点，存在且没有被访问过，并且不是障碍物\n    const rightPoint =\n      isExist(matrix, x + 1, y) && !maker[y][x + 1] && matrix[y][x + 1] !== 1\n        ? { x: x + 1, y }\n        : null;\n    if (rightPoint) {\n      queue.push({\n        node: rightPoint,\n        parent: node,\n      });\n      maker[y][x + 1] = true;\n    }\n    // 下边的点，存在且没有被访问过，并且不是障碍物\n    const bottomPoint =\n      isExist(matrix, x, y + 1) && !maker[y + 1][x] && matrix[y + 1][x] !== 1\n        ? { x, y: y + 1 }\n        : null;\n    if (bottomPoint) {\n      queue.push({\n        node: bottomPoint,\n        parent: node,\n      });\n      maker[y + 1][x] = true;\n    }\n    // 左边的点 存在且没有被访问过，并且不是障碍物\n    const leftPoint =\n      isExist(matrix, x - 1, y) && !maker[y][x - 1] && matrix[y][x - 1] !== 1\n        ? { x: x - 1, y }\n        : null;\n    if (leftPoint) {\n      queue.push({\n        node: leftPoint,\n        parent: node,\n      });\n      maker[y][x - 1] = true;\n    }\n  }\n  /* 本来正常的做法是需要使用栈记录逆序的路径，但是我们直接利用JS的方法反向插入最终得到的即可是一个正序的路径，可以少一个循环 */\n  /* 注意不要把distNode记录掉了 */\n  const path = [distNode];\n  let parent = pathMap.get(distNode);\n  /* 直到找到入口节点，循环终止 */\n  while (parent) {\n    path.unshift(parent);\n    distNode = parent;\n    parent = pathMap.get(distNode);\n  }\n\n  return path.map((node) => {\n    return [node.x, node.y];\n  });\n}\n\n/**\n * 判断当前元素是否存在于迷宫中\n * @param {number[][]} matrix\n * @param {number} x\n * @param {number} y\n */\nfunction isExist(matrix, x, y) {\n  return Array.isArray(matrix[y]) && typeof matrix[y][x] !== "undefined";\n}\n\n\n关于 BFS 还有很多有趣的问题，我暂时就先为大家介绍这几种常见的用法，欢迎大家补充。',normalizedContent:'# 广度优先搜索\n\n广度优先搜索算法（breadth-first search，缩写为 bfs），又称为宽度优先搜索，是一种图形搜索算法。简单的说，bfs 是从根结点开始，沿着树的宽度遍历树的结点。如果所有结点均被访问，则算法中止。\n\n下图生动形象的为我们展示了bfs的处理流程。\n\n\n\n它总是一圈一圈的从内往外处理，每次都是一滴不漏的处理完每个角落，才会开始下一圈的处理。\n\n比如下图展示的就是一个使用 bfs 遍历二叉树的过程：\n\n\n\n由于本文和dfs有着非常强的关联，请各位读者在阅读之前，请确保已经阅读深度优先搜索。\n\n\n# bfs 的标准范式\n\nbfs，从一个给定的节点开始，每遍历一个节点，将当前节点标记为已遍历，并且将当前节点的未处理过的所有邻接节点加入队列中，若队列为空则遍历完成，若不为空，则从队列中再取出一个节点继续上述流程，直到遍历完成。\n\nfunction bfs(v, visited) {\n  // 将当前节点标记为已处理\n  visited[v] = true;\n  // 将当前节点入队\n  enqueue(v, q);\n  // 当队列中存在元素\n  while (!isempty(q)) {\n    // 从队列中取出一个节点\n    v = dequeue(v, q);\n    for(v 的每个邻接点 w) {\n      // 若当前邻接点没有处理过，则将其标记为处理过，并且加入队列中去\n      if(!visited[w]) {\n        visited[w] = true;\n        enqueue(v, w);\n      }\n    }\n  }\n}\n\n\n\n# bfs 的应用\n\n一般来说，能够使用dfs进行处理的问题都可以使用bfs处理，我们还是以之前dfs节讨论过的问题为例，看看使用 bfs 的话，可以怎么样实现它。因为bfs是非递归的算法，如果在数据量比较大的时候，请考虑要非递归实现dfs或直接使用bfs。\n\n# 拍平数组（flat）\n\n假设有这样的数组： [1,[2,3,[[4]]],[5],[[[[[6],7,8]]],9], 10]，请将其展平为[1,2,3,4,5,6,7,8,9,10]。\n\n/**\n * 以广度优先的方式拍平数组\n * @param {any[]} arr\n */\nfunction flat(arr) {\n  const results = [];\n  // 将数据加入到队列中\n  const queue = [];\n  if (array.isarray(arr)) {\n    queue.push(arr);\n  }\n  // 当队列内容不为空时，继续拍平数据\n  while (queue.length) {\n    // 从队列中取出一个元素，并且这个出队的一定是数组\n    const ele = queue.shift();\n    ele.foreach((subele) => {\n      if (array.isarray(subele)) {\n        queue.push(subele);\n      } else {\n        results.push(subele);\n      }\n    });\n  }\n  return results.sort((a, b) => a - b);\n}\n\n\n为什么需要排序呢，因为在拍平的过程中，对于嵌套较深的元素，它的处理过程是滞后于不嵌套的元素的，比如先处理了 1，然后立马处理的是 10，所以 10 就跑到了 2,3 的前面去了。所以说，在根据实际情况，选择使用dfs或dfs，显然本例就不适合使用bfs。\n\n# 深拷贝对象\n\n使用广度优先深拷贝一个对象有个比较不容易想到的地方，就是对象的key，不同于像普通的树或图那样，你持有某个引用，你可以方便的使用curobj.xxx获取到它的邻接点。所以我经过思考后，每次入队的都是一对的源对象和被拷贝对象，这样就可以很方便的直接根据当前源对象进行遍历然后依次给拷贝对象添加属性了。\n\n注意，在此处我实现的深拷贝并没有完整考虑所有的情况，如果对深拷贝感兴趣的同学，请移步 lodash 的源码参考其实现。\n\n/**\n * 使用广度优先深拷贝一个对象\n * @param {array<any> | object} obj\n * @returns\n */\nfunction deepclone(obj) {\n  // 根据目标对象确定拷贝是数组还是对象\n  let cloneobj = array.isarray(obj) ? [] : {};\n  // 用一个map用以记住被拷贝过的内容\n  const map = new map();\n  // 记住当前对象已经被拷贝过了\n  map.set(obj, cloneobj);\n  // 把原始内容和拷贝的内容追加到队列中去，准备开始以广度优先的方式进行深拷贝\n  const queue = [\n    {\n      source: obj,\n      clone: cloneobj,\n    },\n  ];\n  while (queue.length > 0) {\n    const { source, clone } = queue.shift();\n    for (let prop in source) {\n      if (source[prop] instanceof object) {\n        // 如果已经拷贝过，则直接将内容复制到目标对象上去\n        if (map.get(source[prop])) {\n          clone[prop] = map.get(source[prop]);\n        } else {\n          // 把当前对象和拷贝的空对象加入到队列中去，准备后序的深拷贝\n          const nextclone = array.isarray(source[prop]) ? [] : {};\n          queue.push({\n            source: source[prop],\n            clone: nextclone,\n          });\n          // 建立拷贝关系，本轮还是空内容（可以理解为拷贝一个容器），待下一轮循环才拷贝值\n          clone[prop] = nextclone;\n          // 将已经拷贝的内容加入到map中去，防止循环拷贝\n          map.set(source[prop], nextclone);\n        }\n      } else {\n        // 基本类型，可直接拷贝\n        clone[prop] = source[prop];\n      }\n    }\n  }\n  return cloneobj;\n}\n\n\n# 迷宫问题\n\n这是华为的一道机考题。\n\n定义一个二维数组 n*m ，如 5 × 5 数组下所示：\n\n[\n  [0, 1, 0, 0, 0],\n  [0, 1, 1, 1, 0],\n  [0, 0, 0, 0, 0],\n  [0, 1, 1, 1, 0],\n  [0, 0, 0, 1, 0],\n];\n\n\n它表示一个迷宫，其中的 1 表示墙壁，0 表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的路线。入口点为[0,0],既第一格是可以走的路。\n\n输入两个整数，分别表示二维数组的行数，列数。再输入相应的数组，其中的 1 表示墙壁，0 表示可以走的路。数据保证有唯一解,不考虑有多解的情况，即迷宫只有一条通道。\n\n/**\n * 以bfs的形式找迷宫的出口\n * @param {number[]} matrix\n */\nfunction findpath(matrix) {\n  const height = matrix.length;\n  const width = matrix[0].length;\n  // 定义一个队列\n  const queue = [];\n  // 定义一个标记数组\n  const maker = array.from({\n    length: height,\n  }).map(() => {\n    return array.from({\n      length: width,\n    }).fill(0);\n  });\n  // 先将开始节点加入到队列中去\n  queue.push({\n    x: 0,\n    y: 0,\n    path: [[0, 0]],\n  });\n  // 将起始节点标记为已处理\n  maker[0][0] = true;\n  let distpath = null;\n  while (queue.length) {\n    const { x, y, path } = queue.shift();\n    if (x === width - 1 && y === height - 1) {\n      distpath = path;\n    }\n    // 上边的点，存在且没有被访问过，并且不是障碍物\n    const toppoint =\n      isexist(matrix, x, y - 1) && !maker[y - 1][x] && matrix[y - 1][x] !== 1\n        ? { x, y: y - 1 }\n        : null;\n    if (toppoint) {\n      queue.push({\n        x: toppoint.x,\n        y: toppoint.y,\n        path: [...path, [toppoint.y, toppoint.x]],\n      });\n      maker[y - 1][x] = true;\n    }\n    // 右边的点，存在且没有被访问过，并且不是障碍物\n    const rightpoint =\n      isexist(matrix, x + 1, y) && !maker[y][x + 1] && matrix[y][x + 1] !== 1\n        ? { x: x + 1, y }\n        : null;\n    if (rightpoint) {\n      queue.push({\n        x: rightpoint.x,\n        y: rightpoint.y,\n        path: [...path, [rightpoint.y, rightpoint.x]],\n      });\n      maker[y][x + 1] = true;\n    }\n    // 下边的点，存在且没有被访问过，并且不是障碍物\n    const bottompoint =\n      isexist(matrix, x, y + 1) && !maker[y + 1][x] && matrix[y + 1][x] !== 1\n        ? { x, y: y + 1 }\n        : null;\n    if (bottompoint) {\n      queue.push({\n        x: bottompoint.x,\n        y: bottompoint.y,\n        path: [...path, [bottompoint.y, bottompoint.x]],\n      });\n      maker[y + 1][x] = true;\n    }\n    // 左边的点 存在且没有被访问过，并且不是障碍物\n    const leftpoint =\n      isexist(matrix, x - 1, y) && !maker[y][x - 1] && matrix[y][x - 1] !== 1\n        ? { x: x - 1, y }\n        : null;\n    if (leftpoint) {\n      queue.push({\n        x: leftpoint.x,\n        y: leftpoint.y,\n        path: [...path, [leftpoint.y, leftpoint.x]],\n      });\n      maker[y][x - 1] = true;\n    }\n  }\n  return distpath;\n}\n\n/**\n * 判断当前元素是否存在于迷宫中\n * @param {number[][]} matrix\n * @param {number} x\n * @param {number} y\n */\nfunction isexist(matrix, x, y) {\n  return array.isarray(matrix[y]) && typeof matrix[y][x] !== "undefined";\n}\n\n\n使用bfs查找迷宫的出路有个问题，虽然我们在找路的时候比较方便，但是怎么把这个路径记录下来却是个问题。\n\n因此，我在上述搜索过程中把对应已经走过的 path 一并加入到了队列中，在取出节点进行判断的时候，可以很方便的知道之前走过的路径是怎么样的，但是问题就是这样会占用大量的内存空间，所以对于这个问题，我实现的bfs是不如dfs的，如果读者有更好的解法，欢迎提出，大家一起交流，把它完善的更美好，以传递更好的知识。\n\n在后来，我学习并理解了最短路径算法之后，发现可以有一个比较优雅的解法，其做法和无权图的最短路径求解手段类似，在求解过程中利用哈希表把当前节点和它对应的父节点记录下来，这样就可以从终点一直倒推到起点，再反序输出即可得到正序的路径。\n\n下面的实现相对于上面的实现占用的内存空间占用会小的多。\n\n/**\n * 以bfs的形式找迷宫的出口\n * @param {number[]} matrix\n */\nfunction findpath(matrix) {\n  const height = matrix.length;\n  const width = matrix[0].length;\n  /* 定义一个哈希表，用于记住经过的路径 */\n  const pathmap = new map();\n  // 定义一个队列\n  const queue = [];\n  // 定义一个标记数组\n  const maker = array.from({\n    length: height,\n  }).map(() => {\n    return array.from({\n      length: width,\n    }).fill(0);\n  });\n  // 先将开始节点加入到队列中去\n  queue.push({\n    node: { x: 0, y: 0 },\n    /* 入口的父节点为空 */\n    parent: null,\n  });\n  // 将起始节点标记为已处理\n  maker[0][0] = true;\n  let distnode = null;\n  while (queue.length) {\n    const { node, parent } = queue.shift();\n    /* 将当前节点记录在到终点的路径上 */\n    pathmap.set(node, parent);\n    const { x, y } = node;\n    if (x === width - 1 && y === height - 1) {\n      distnode = node;\n      break;\n    }\n    // 上边的点，存在且没有被访问过，并且不是障碍物\n    const toppoint =\n      isexist(matrix, x, y - 1) && !maker[y - 1][x] && matrix[y - 1][x] !== 1\n        ? { x, y: y - 1 }\n        : null;\n    if (toppoint) {\n      queue.push({\n        node: toppoint,\n        parent: node,\n      });\n      maker[y - 1][x] = true;\n    }\n    // 右边的点，存在且没有被访问过，并且不是障碍物\n    const rightpoint =\n      isexist(matrix, x + 1, y) && !maker[y][x + 1] && matrix[y][x + 1] !== 1\n        ? { x: x + 1, y }\n        : null;\n    if (rightpoint) {\n      queue.push({\n        node: rightpoint,\n        parent: node,\n      });\n      maker[y][x + 1] = true;\n    }\n    // 下边的点，存在且没有被访问过，并且不是障碍物\n    const bottompoint =\n      isexist(matrix, x, y + 1) && !maker[y + 1][x] && matrix[y + 1][x] !== 1\n        ? { x, y: y + 1 }\n        : null;\n    if (bottompoint) {\n      queue.push({\n        node: bottompoint,\n        parent: node,\n      });\n      maker[y + 1][x] = true;\n    }\n    // 左边的点 存在且没有被访问过，并且不是障碍物\n    const leftpoint =\n      isexist(matrix, x - 1, y) && !maker[y][x - 1] && matrix[y][x - 1] !== 1\n        ? { x: x - 1, y }\n        : null;\n    if (leftpoint) {\n      queue.push({\n        node: leftpoint,\n        parent: node,\n      });\n      maker[y][x - 1] = true;\n    }\n  }\n  /* 本来正常的做法是需要使用栈记录逆序的路径，但是我们直接利用js的方法反向插入最终得到的即可是一个正序的路径，可以少一个循环 */\n  /* 注意不要把distnode记录掉了 */\n  const path = [distnode];\n  let parent = pathmap.get(distnode);\n  /* 直到找到入口节点，循环终止 */\n  while (parent) {\n    path.unshift(parent);\n    distnode = parent;\n    parent = pathmap.get(distnode);\n  }\n\n  return path.map((node) => {\n    return [node.x, node.y];\n  });\n}\n\n/**\n * 判断当前元素是否存在于迷宫中\n * @param {number[][]} matrix\n * @param {number} x\n * @param {number} y\n */\nfunction isexist(matrix, x, y) {\n  return array.isarray(matrix[y]) && typeof matrix[y][x] !== "undefined";\n}\n\n\n关于 bfs 还有很多有趣的问题，我暂时就先为大家介绍这几种常见的用法，欢迎大家补充。',charsets:{cjk:!0}},{title:"Home",frontmatter:{home:!0,actionText:"开始阅读",actionLink:"/guide/",features:[{title:"数据结构专题",details:"常见数据结构和算法（树、图、数组、堆、栈，队列）的基本使用以及典型题目分析。"},{title:"设计模式专题",details:"常见的设计模式基于 JavaScript 的实现。"},{title:"JavaScript API 专题",details:"JavaScript常见的一些核心概念以及部分API的手写实现。"},{title:"杂项专题",details:"常见的前端八股文等。"}]},regularPath:"/",relativePath:"index.md",key:"v-0bddd3a4",path:"/",headersStr:null,content:"awesome-frontend-code\n\n盘点前端常见的知识点总结\n\nReleased under the MIT License.\nCopyright © 2022 HsuYang",normalizedContent:"awesome-frontend-code\n\n盘点前端常见的知识点总结\n\nreleased under the mit license.\ncopyright © 2022 hsuyang",charsets:{cjk:!0}},{title:"常用的Linux命令",frontmatter:{},regularPath:"/command.html",relativePath:"command.md",key:"v-79ce3195",path:"/command.html",headers:[{level:2,title:"常用的Linux命令",slug:"常用的linux命令",normalizedTitle:"常用的linux命令",charIndex:2},{level:3,title:"文件管理",slug:"文件管理",normalizedTitle:"文件管理",charIndex:154},{level:3,title:"文档编辑",slug:"文档编辑",normalizedTitle:"文档编辑",charIndex:166},{level:3,title:"文件传输",slug:"文件传输",normalizedTitle:"文件传输",charIndex:178}],headersStr:"常用的Linux命令 文件管理 文档编辑 文件传输",content:"# 常用的Linux命令\n\npwd\n# 获取当前目录\nwhereis\n# 获取程序的安装目录 whereis git\nwhatis\n# 获取某个命令的使用方法 whatis whereis\nls\n# 展示当前文件下面的所有文件夹 参数：-a所有文件  -l展示详细信息 -h 以人类可读的形式展示\n\n\n\n# 文件管理\n\n\n\n\n\n# 文档编辑\n\n\n\n\n\n# 文件传输\n\n\n",normalizedContent:"# 常用的linux命令\n\npwd\n# 获取当前目录\nwhereis\n# 获取程序的安装目录 whereis git\nwhatis\n# 获取某个命令的使用方法 whatis whereis\nls\n# 展示当前文件下面的所有文件夹 参数：-a所有文件  -l展示详细信息 -h 以人类可读的形式展示\n\n\n\n# 文件管理\n\n\n\n\n\n# 文档编辑\n\n\n\n\n\n# 文件传输\n\n\n",charsets:{cjk:!0}},{title:"最小生成树",frontmatter:{},regularPath:"/data-structure/graph/minimum-spanning-tree.html",relativePath:"data-structure/graph/minimum-spanning-tree.md",key:"v-a65f4076",path:"/data-structure/graph/minimum-spanning-tree.html",headers:[{level:2,title:"最小生成树",slug:"最小生成树",normalizedTitle:"最小生成树",charIndex:2}],headersStr:"最小生成树",content:"# 最小生成树\n\n建设中，敬请期待...",normalizedContent:"# 最小生成树\n\n建设中，敬请期待...",charsets:{cjk:!0}},{title:"图",frontmatter:{},regularPath:"/data-structure/graph/desc.html",relativePath:"data-structure/graph/desc.md",key:"v-1c6e3f95",path:"/data-structure/graph/desc.html",headers:[{level:2,title:"图",slug:"图",normalizedTitle:"图",charIndex:2},{level:3,title:"图中的概念",slug:"图中的概念",normalizedTitle:"图中的概念",charIndex:171},{level:3,title:"图在计算机中的表示",slug:"图在计算机中的表示",normalizedTitle:"图在计算机中的表示",charIndex:611}],headersStr:"图 图中的概念 图在计算机中的表示",content:'# 图\n\n在我们日常生活中，线性表表示一对一的关系，树表示一对多的关系，图表示的是多对多的关系，线性表和树相当于是图的子集。\n\n图是我们现实生活中连接关系的抽象，例如朋友圈、微博的关注关系，互联网的连接等。\n\n在前端的实际开发中，如果当你遇到和流程图相关的业务时，可能会用到图；若你从事和地图相关的业务，那可能你得天天和图打交道了。\n\n\n# 图中的概念\n\n图中的专业术语特别的多，我们只列一些在实际开发中可能会用到的一些关键词。\n\n图中的两点如果存在权重的话，则称为带权图，图的两个顶点中间如果不存在方向的话，则称为无向图，有向的话则称为有向图\n\n对于图中任意一个顶点与该顶点相关联的边的条数，称为图的度；\n\n对于有向图来说的话，从顶点引出的边叫它的出度，别的顶点指向它的边叫做它的入度。\n\n在无向图中，如果从顶点 vi 到顶点 vj 有路径，则称 vi 和 vj 连通，如果图中任意两个顶点之间都连通，则称该图为连通图，否则，将其中的极大连通子图称为连通分量。（我觉得用同俗易懂的语言来理解这个概念就是说这个图里面是否有一个或几个顶点单着呢。）\n\n\n\n在有向图中，如果对于每一对顶点 vi 和 vj，从 vi 到 vj 和从 vj 到 vi 都有路径，则称该图为强连通图；否则，将其中的极大连通子图称为强连通分量。\n\n目前我在实际开发中所用到的关于图的名词就如上所述，对于图有兴趣的同学，可以自行查阅相关资料。\n\n\n# 图在计算机中的表示\n\n首先，大家一定不要拘泥于老师所讲述的邻接矩阵和邻接表的表示方法。曾经我就是对老师所授内容囫囵吞枣，导致理解上产生了偏差。只要你能够表示逻辑的关系（不管是一对一，多对一还是多对多），只要你的这个标识方法能够最快的解决你的问题，那就是一个好的表示方法。\n\n举个前端实际开发中的例子，像一个对象中可能存在一个或者多个循环引用，那就是图。\n\n但是，我们还是需要讲一下图的两种最常见的表示法：邻接矩阵和邻接表法。\n\n对于下面这个图，我们分别尝试用邻接矩阵和邻接表来表示它。\n\n\n\n我们对这些城市分别编个号\n\nconst cities = [\n  "北京",\n  "南京",\n  "广州",\n  "深圳",\n  "香港",\n  "成都",\n  "西安",\n  "乌鲁木齐",\n];\n\n\n# 邻接矩阵表示法\n\n一个二维数组，数组的长度和宽度为图的顶点数，若两点之间存在路径，则matrix[i][j]不为零，否则为零。\n\n对角线全部为 0，因为城市不需要自己和自己连接\n\n北京和南京存在连接，则 matrix[0][1]=1，matrix[1][0] = 1，因为我们是无向图，如果想表达仅可以从北京到南京，则matrix[0][1]=1\n\n南京和广州存在连接，matrix[1][2]=1，matrix[2][1] = 1\n\n深圳和广州存在连接，matrix[3][2]=1，matrix[2][3] = 1\n\n深圳和香港存在连接，matrix[3][4]=1，matrix[4][3] = 1\n\n广州和香港存在连接，matrix[2][4]=1，matrix[4][2] = 1\n\n广州和成都存在连接，matrix[2][5]=1，matrix[5][2] = 1\n\n西安和成都存在连接，matrix[5][6]=1，matrix[6][5] = 1\n\n西安和乌鲁木齐存在连接，matrix[6][7]=1，matrix[7][6] = 1\n\n西安和北京存在连接，matrix[0][7]=1，matrix[7][0] = 1\n\n[\n  [0, 1, 0, 0, 0, 0, 0, 1],\n  [1, 0, 0, 1, 1, 1, 0, 0],\n  [0, 0, 0, 0, 0, 0, 0, 0],\n  [0, 1, 0, 0, 1, 0, 0, 0],\n  [0, 1, 0, 1, 0, 0, 0, 0],\n  [0, 1, 0, 0, 0, 0, 1, 0],\n  [0, 0, 0, 0, 0, 1, 0, 1],\n  [1, 0, 0, 0, 0, 0, 1, 0],\n];\n\n\n若两点之间需要表示权重，需要将 1 改为权重即可。\n\n# 邻接表表示法\n\n一个一维数组，数组的每个元素为一个链表，链表指向当前顶点的所有邻接点。\n\ninterface Vertex {\n  cityName: string;\n  next: Vertex | null;\n}\n\n\n[\n  {\n    cityName: "北京",\n    next: {\n      cityName: "西安",\n      next: {\n        cityName: "南京",\n        next: {\n          cityName: "乌鲁木齐",\n          next: null,\n        },\n      },\n    },\n  },\n  {\n    cityName: "南京",\n    next: {\n      cityName: "北京",\n      next: {\n        cityName: "广州",\n        next: null,\n      },\n    },\n  },\n  {\n    cityName: "广州",\n    next: {\n      cityName: "成都",\n      next: {\n        cityName: "南京",\n        next: {\n          cityName: "深圳",\n          next: null,\n        },\n      },\n    },\n  },\n  {\n    cityName: "香港",\n    next: {\n      cityName: "深圳",\n      next: {\n        cityName: "广州",\n        next: null,\n      },\n    },\n  },\n  {\n    cityName: "深圳",\n    next: {\n      cityName: "广州",\n      next: {\n        cityName: "香港",\n        next: null,\n      },\n    },\n  },\n  {\n    cityName: "成都",\n    next: {\n      cityName: "西安",\n      next: {\n        cityName: "广州",\n        next: null,\n      },\n    },\n  },\n  {\n    cityName: "西安",\n    next: {\n      cityName: "成都",\n      next: {\n        cityName: "北京",\n        next: {\n          cityName: "乌鲁木齐",\n          next: null,\n        },\n      },\n    },\n  },\n  {\n    cityName: "乌鲁木齐",\n    next: {\n      cityName: "西安",\n      next: {\n        cityName: "北京",\n        next: null,\n      },\n    },\n  },\n];\n\n\n使用邻接表表示，若两点之间需要表示权重，还需要额外在链表节点增加一个域用以表示权重。\n\n上面两种表示法都把同一条边存了 2 次的，我们也之前也介绍了，图的表示方法有很多种，选择一种适合你的就好，接下来我介绍一下我个人在开发中的表示法。 首先定义图和顶点\n\nclass Edge {\n  constructor(name) {\n    this.name = name;\n  }\n  /**\n   * 边的编号\n   */\n  name;\n  /**\n   * 起始点\n   * @type {Vertex}\n   */\n  from;\n  /**\n   * 终止点\n   * @type {Vertex}\n   */\n  to;\n}\n\nclass Vertex {\n  /**\n   * 城市名称\n   */\n  cityName;\n  /**\n   * 邻接点\n   */\n  siblings = [];\n  constructor(cityName) {\n    this.cityName = cityName;\n  }\n}\n\nclass Graph {\n  vertexList = [];\n  edgeList = [];\n  addVertex(v) {\n    this.vertexList.push(v);\n  }\n\n  /**\n   * 增加边\n   * @param {Vertex} from\n   * @param {Vertex} to\n   */\n  addEdge(from, to) {\n    const name = `${from.cityName}至${to.cityName}`;\n    const edge = new Edge(name);\n    this.edgeList.push(edge);\n    from.siblings.push(to);\n    to.siblings.push(from);\n  }\n}\n\n\n接着，初始化数据：\n\nconst g = new Graph();\nconst beijing = new Vertex("北京");\nconst nanjing = new Vertex("南京");\nconst guangzhou = new Vertex("广州");\nconst shenzhen = new Vertex("深圳");\nconst hongkong = new Vertex("香港");\nconst chengdu = new Vertex("成都");\nconst xian = new Vertex("西安");\nconst urumchi = new Vertex("乌鲁木齐");\n\n/**\n * 将城市加入到图中\n */\ng.addVertex(beijing);\ng.addVertex(nanjing);\ng.addVertex(guangzhou);\ng.addVertex(shenzhen);\ng.addVertex(hongkong);\ng.addVertex(chengdu);\ng.addVertex(xian);\ng.addVertex(urumchi);\n/**\n * 建立连接关系\n */\ng.addEdge(beijing, nanjing);\ng.addEdge(beijing, xian);\ng.addEdge(nanjing, guangzhou);\ng.addEdge(guangzhou, shenzhen);\ng.addEdge(guangzhou, hongkong);\ng.addEdge(hongkong, shenzhen);\ng.addEdge(chengdu, guangzhou);\ng.addEdge(chengdu, xian);\ng.addEdge(urumchi, xian);\ng.addEdge(urumchi, beijing);\n\n\n上述这种方法是大家在实际开发中最可能用到的。后面，一些图的算法，我们还会基于这个例子阐述。',normalizedContent:'# 图\n\n在我们日常生活中，线性表表示一对一的关系，树表示一对多的关系，图表示的是多对多的关系，线性表和树相当于是图的子集。\n\n图是我们现实生活中连接关系的抽象，例如朋友圈、微博的关注关系，互联网的连接等。\n\n在前端的实际开发中，如果当你遇到和流程图相关的业务时，可能会用到图；若你从事和地图相关的业务，那可能你得天天和图打交道了。\n\n\n# 图中的概念\n\n图中的专业术语特别的多，我们只列一些在实际开发中可能会用到的一些关键词。\n\n图中的两点如果存在权重的话，则称为带权图，图的两个顶点中间如果不存在方向的话，则称为无向图，有向的话则称为有向图\n\n对于图中任意一个顶点与该顶点相关联的边的条数，称为图的度；\n\n对于有向图来说的话，从顶点引出的边叫它的出度，别的顶点指向它的边叫做它的入度。\n\n在无向图中，如果从顶点 vi 到顶点 vj 有路径，则称 vi 和 vj 连通，如果图中任意两个顶点之间都连通，则称该图为连通图，否则，将其中的极大连通子图称为连通分量。（我觉得用同俗易懂的语言来理解这个概念就是说这个图里面是否有一个或几个顶点单着呢。）\n\n\n\n在有向图中，如果对于每一对顶点 vi 和 vj，从 vi 到 vj 和从 vj 到 vi 都有路径，则称该图为强连通图；否则，将其中的极大连通子图称为强连通分量。\n\n目前我在实际开发中所用到的关于图的名词就如上所述，对于图有兴趣的同学，可以自行查阅相关资料。\n\n\n# 图在计算机中的表示\n\n首先，大家一定不要拘泥于老师所讲述的邻接矩阵和邻接表的表示方法。曾经我就是对老师所授内容囫囵吞枣，导致理解上产生了偏差。只要你能够表示逻辑的关系（不管是一对一，多对一还是多对多），只要你的这个标识方法能够最快的解决你的问题，那就是一个好的表示方法。\n\n举个前端实际开发中的例子，像一个对象中可能存在一个或者多个循环引用，那就是图。\n\n但是，我们还是需要讲一下图的两种最常见的表示法：邻接矩阵和邻接表法。\n\n对于下面这个图，我们分别尝试用邻接矩阵和邻接表来表示它。\n\n\n\n我们对这些城市分别编个号\n\nconst cities = [\n  "北京",\n  "南京",\n  "广州",\n  "深圳",\n  "香港",\n  "成都",\n  "西安",\n  "乌鲁木齐",\n];\n\n\n# 邻接矩阵表示法\n\n一个二维数组，数组的长度和宽度为图的顶点数，若两点之间存在路径，则matrix[i][j]不为零，否则为零。\n\n对角线全部为 0，因为城市不需要自己和自己连接\n\n北京和南京存在连接，则 matrix[0][1]=1，matrix[1][0] = 1，因为我们是无向图，如果想表达仅可以从北京到南京，则matrix[0][1]=1\n\n南京和广州存在连接，matrix[1][2]=1，matrix[2][1] = 1\n\n深圳和广州存在连接，matrix[3][2]=1，matrix[2][3] = 1\n\n深圳和香港存在连接，matrix[3][4]=1，matrix[4][3] = 1\n\n广州和香港存在连接，matrix[2][4]=1，matrix[4][2] = 1\n\n广州和成都存在连接，matrix[2][5]=1，matrix[5][2] = 1\n\n西安和成都存在连接，matrix[5][6]=1，matrix[6][5] = 1\n\n西安和乌鲁木齐存在连接，matrix[6][7]=1，matrix[7][6] = 1\n\n西安和北京存在连接，matrix[0][7]=1，matrix[7][0] = 1\n\n[\n  [0, 1, 0, 0, 0, 0, 0, 1],\n  [1, 0, 0, 1, 1, 1, 0, 0],\n  [0, 0, 0, 0, 0, 0, 0, 0],\n  [0, 1, 0, 0, 1, 0, 0, 0],\n  [0, 1, 0, 1, 0, 0, 0, 0],\n  [0, 1, 0, 0, 0, 0, 1, 0],\n  [0, 0, 0, 0, 0, 1, 0, 1],\n  [1, 0, 0, 0, 0, 0, 1, 0],\n];\n\n\n若两点之间需要表示权重，需要将 1 改为权重即可。\n\n# 邻接表表示法\n\n一个一维数组，数组的每个元素为一个链表，链表指向当前顶点的所有邻接点。\n\ninterface vertex {\n  cityname: string;\n  next: vertex | null;\n}\n\n\n[\n  {\n    cityname: "北京",\n    next: {\n      cityname: "西安",\n      next: {\n        cityname: "南京",\n        next: {\n          cityname: "乌鲁木齐",\n          next: null,\n        },\n      },\n    },\n  },\n  {\n    cityname: "南京",\n    next: {\n      cityname: "北京",\n      next: {\n        cityname: "广州",\n        next: null,\n      },\n    },\n  },\n  {\n    cityname: "广州",\n    next: {\n      cityname: "成都",\n      next: {\n        cityname: "南京",\n        next: {\n          cityname: "深圳",\n          next: null,\n        },\n      },\n    },\n  },\n  {\n    cityname: "香港",\n    next: {\n      cityname: "深圳",\n      next: {\n        cityname: "广州",\n        next: null,\n      },\n    },\n  },\n  {\n    cityname: "深圳",\n    next: {\n      cityname: "广州",\n      next: {\n        cityname: "香港",\n        next: null,\n      },\n    },\n  },\n  {\n    cityname: "成都",\n    next: {\n      cityname: "西安",\n      next: {\n        cityname: "广州",\n        next: null,\n      },\n    },\n  },\n  {\n    cityname: "西安",\n    next: {\n      cityname: "成都",\n      next: {\n        cityname: "北京",\n        next: {\n          cityname: "乌鲁木齐",\n          next: null,\n        },\n      },\n    },\n  },\n  {\n    cityname: "乌鲁木齐",\n    next: {\n      cityname: "西安",\n      next: {\n        cityname: "北京",\n        next: null,\n      },\n    },\n  },\n];\n\n\n使用邻接表表示，若两点之间需要表示权重，还需要额外在链表节点增加一个域用以表示权重。\n\n上面两种表示法都把同一条边存了 2 次的，我们也之前也介绍了，图的表示方法有很多种，选择一种适合你的就好，接下来我介绍一下我个人在开发中的表示法。 首先定义图和顶点\n\nclass edge {\n  constructor(name) {\n    this.name = name;\n  }\n  /**\n   * 边的编号\n   */\n  name;\n  /**\n   * 起始点\n   * @type {vertex}\n   */\n  from;\n  /**\n   * 终止点\n   * @type {vertex}\n   */\n  to;\n}\n\nclass vertex {\n  /**\n   * 城市名称\n   */\n  cityname;\n  /**\n   * 邻接点\n   */\n  siblings = [];\n  constructor(cityname) {\n    this.cityname = cityname;\n  }\n}\n\nclass graph {\n  vertexlist = [];\n  edgelist = [];\n  addvertex(v) {\n    this.vertexlist.push(v);\n  }\n\n  /**\n   * 增加边\n   * @param {vertex} from\n   * @param {vertex} to\n   */\n  addedge(from, to) {\n    const name = `${from.cityname}至${to.cityname}`;\n    const edge = new edge(name);\n    this.edgelist.push(edge);\n    from.siblings.push(to);\n    to.siblings.push(from);\n  }\n}\n\n\n接着，初始化数据：\n\nconst g = new graph();\nconst beijing = new vertex("北京");\nconst nanjing = new vertex("南京");\nconst guangzhou = new vertex("广州");\nconst shenzhen = new vertex("深圳");\nconst hongkong = new vertex("香港");\nconst chengdu = new vertex("成都");\nconst xian = new vertex("西安");\nconst urumchi = new vertex("乌鲁木齐");\n\n/**\n * 将城市加入到图中\n */\ng.addvertex(beijing);\ng.addvertex(nanjing);\ng.addvertex(guangzhou);\ng.addvertex(shenzhen);\ng.addvertex(hongkong);\ng.addvertex(chengdu);\ng.addvertex(xian);\ng.addvertex(urumchi);\n/**\n * 建立连接关系\n */\ng.addedge(beijing, nanjing);\ng.addedge(beijing, xian);\ng.addedge(nanjing, guangzhou);\ng.addedge(guangzhou, shenzhen);\ng.addedge(guangzhou, hongkong);\ng.addedge(hongkong, shenzhen);\ng.addedge(chengdu, guangzhou);\ng.addedge(chengdu, xian);\ng.addedge(urumchi, xian);\ng.addedge(urumchi, beijing);\n\n\n上述这种方法是大家在实际开发中最可能用到的。后面，一些图的算法，我们还会基于这个例子阐述。',charsets:{cjk:!0}},{title:"最短路径",frontmatter:{},regularPath:"/data-structure/graph/shortest-path.html",relativePath:"data-structure/graph/shortest-path.md",key:"v-41a4fc5e",path:"/data-structure/graph/shortest-path.html",headers:[{level:2,title:"最短路径",slug:"最短路径",normalizedTitle:"最短路径",charIndex:2},{level:3,title:"无权图单源最短路",slug:"无权图单源最短路",normalizedTitle:"无权图单源最短路",charIndex:465},{level:3,title:"带权图单源最短路径算法",slug:"带权图单源最短路径算法",normalizedTitle:"带权图单源最短路径算法",charIndex:4451},{level:3,title:"带权图多源最短路径算法",slug:"带权图多源最短路径算法",normalizedTitle:"带权图多源最短路径算法",charIndex:11312}],headersStr:"最短路径 无权图单源最短路 带权图单源最短路径算法 带权图多源最短路径算法",content:'# 最短路径\n\n最短路径问题，这个问题几乎是我们每天必定会接触到的问题了吧。\n\n当你打开高德地图，输入目的地，高德地图一下就可以给你计算出来了怎么走，甚至还能让你选条件，比如途经点，用时最短，里程最短等条件。我一直感叹其中的神奇，在我没有接触图这章的知识的时候，想破脑袋也不知道其中的原理，但是我从未放弃过要去搞明白计算机是怎么样解决这类问题的。\n\n曾经我有一个朋友，他是银行职员，当时正值炎炎夏日，他需要在一周内拜访成都市区几百家客户，他来求助我，是否可以帮忙写一个程序算一下怎么安排这些客户的拜访顺序，囿于当时我的水平有限，只能遗憾的告诉他我不会啊，真实心疼他。他的这个需求其实是结合了图的最短路径问题和最小生成树问题的场景。\n\n如果你掌握了本节内容，将来和朋友们出去玩儿的时候，编程求解旅行的规划，那应该可以狠狠地秀大家一把吧；\n\n如果你不仅掌握了本节内容，还掌握了后面将会介绍的最小生成树问题，将来某一天大家有类似我朋友这种极端的需求的时候，一定可以帮到他哟，这就是程序员的力量，代码的魅力，加油，拿下这节知识。\n\n\n# 无权图单源最短路\n\n无权图的单源最短路问题，跟我们的广度优先遍历的思路非常相似，我们从起点出发，依次操作当前节点的邻接点，若其还没有处理过，则处理，并且更新起点到这个点的距离，然后还要把这个点加到我们记录的一个路径数据集里面去。重复上述操作，直到处理完图中所有的点。\n\n我们以这个图为例：\n\n\n\n并且以如下表示方法表示图：\n\n/**\n * 边类\n */\nclass Edge {\n  constructor(name) {\n    this.name = name;\n  }\n  /**\n   * 边的编号\n   */\n  name;\n  /**\n   * 起始点\n   * @type {Vertex}\n   */\n  from;\n  /**\n   * 终止点\n   * @type {Vertex}\n   */\n  to;\n}\n\n/**\n * 顶点类\n */\nclass Vertex {\n  /**\n   * 城市名称\n   */\n  cityName;\n  /**\n   * 邻接点\n   */\n  siblings = [];\n  constructor(cityName) {\n    this.cityName = cityName;\n  }\n}\n\n/**\n * 图类\n */\nclass Graph {\n  /**\n   * 顶点集合\n   * @type {Vertex[]}\n   */\n  vertexList = [];\n  /**\n   * 边集合\n   * @type {Edge[]}\n   */\n  edgeList = [];\n  /**\n   * 向图中插入一个顶点\n   */\n  addVertex(v) {\n    this.vertexList.push(v);\n  }\n  /**\n   * 增加边，连接from和to两个顶点\n   * @param {Vertex} from\n   * @param {Vertex} to\n   */\n  addEdge(from, to) {\n    const name = `${from.cityName}至${to.cityName}`;\n    const edge = new Edge(name);\n    this.edgeList.push(edge);\n    from.siblings.push(to);\n    to.siblings.push(from);\n  }\n}\n\n\n接着，根据上面的那个图，构建出我们想要的连接关系：\n\nconst g = new Graph();\nconst beijing = new Vertex("北京");\nconst nanjing = new Vertex("南京");\nconst guangzhou = new Vertex("广州");\nconst shenzhen = new Vertex("深圳");\nconst hongkong = new Vertex("香港");\nconst chengdu = new Vertex("成都");\nconst xian = new Vertex("西安");\nconst urumchi = new Vertex("乌鲁木齐");\n/**\n * 将城市加入到图中\n */\ng.addVertex(beijing);\ng.addVertex(nanjing);\ng.addVertex(guangzhou);\ng.addVertex(shenzhen);\ng.addVertex(hongkong);\ng.addVertex(chengdu);\ng.addVertex(xian);\ng.addVertex(urumchi);\n/**\n * 建立连接关系\n */\ng.addEdge(beijing, nanjing);\ng.addEdge(beijing, xian);\ng.addEdge(nanjing, guangzhou);\ng.addEdge(guangzhou, shenzhen);\ng.addEdge(guangzhou, hongkong);\ng.addEdge(hongkong, shenzhen);\ng.addEdge(chengdu, guangzhou);\ng.addEdge(chengdu, xian);\ng.addEdge(urumchi, xian);\ng.addEdge(urumchi, beijing);\n\n\n那么，最短路径求解算法如下：\n\n/**\n * 单源无权图的最短路算法\n * @param {Vertex} start\n * @param {Vertex} end\n */\nfunction unweightedShortestPath(start, end) {\n  const queue = [];\n  /* 距离哈希表，用于存储开始顶点到任意节点的距离 */\n  const dist = new Map();\n  /* 路径哈希表，用于存储开始顶点到任意节点所经过的顶点 */\n  const path = new Map();\n  dist.set(start, 0);\n  queue.push(start);\n  while (queue.length > 0) {\n    let vertex = queue.shift();\n    for (let i = 0; i < vertex.siblings.length; i++) {\n      // 取出当前正在处理的顶点的邻接点进行处理\n      let adjoinVertex = vertex.siblings[i];\n      /* 若adjoinVertex未被访问过 */\n      if (typeof dist.get(adjoinVertex) === "undefined") {\n        /* 将这个点到start的距离更新 */\n        dist.set(adjoinVertex, dist.get(vertex) + 1);\n        /* 将这个点记录在S到adjoinVertex的路径上 */\n        path.set(adjoinVertex, vertex);\n        // 并且将当前邻接点入队\n        queue.push(adjoinVertex);\n      }\n    }\n  }\n  // 获取终点的最短路径长度\n  const distance = dist.get(end);\n  // 使用栈记住终点\n  const stack = [end];\n  let preVertex = path.get(end);\n  // 沿途处理从终点到起点所经过的路径\n  while (preVertex) {\n    stack.push(preVertex);\n    // 继续向上迭代，寻找经过的顶点\n    preVertex = path.get(preVertex);\n  }\n  // 经过逆序，得到了正确的路径\n  let via = "";\n  while (stack.length) {\n    const city = stack.pop();\n    via += "->" + city.cityName;\n  }\n  return { distance, path: via.replace(/(^->)|(->$)/g, "") };\n}\n\n\n假设我们想求出成都到北京的最短距离，并且需要求出是怎么样达到北京的，如下：\n\nconst { path, distance } = unweightedShortestPath(chengdu, beijing);\n// path 成都->西安->北京\n// distance 3\n\n\n下面，我们画图描述一下这个处理流程。\n\n首先，在开始时将成都入队，同时设置距离为0，因为我们设置了它的距离，其实际上就相当于之前我们在广度优先遍历节的时候所提到的标记当前的节点已经被处理的手段，一举两得。接着，我们把成都出队，准备处理它的邻接点。\n\n\n\n紧接着，我们把西安和广州入队\n\n\n\n接着，把西安出队，同时标记成都到西安的最短距离，然后将西安的邻接节点乌鲁木齐和北京入队。\n\n\n\n接着，把广州出队，同时标记成都到广州的最短距离，然后将广州的邻接节点深圳、香港和南京入队。\n\n\n\n接着，把乌鲁木齐出队，同时标记成都到乌鲁木齐的最短距离，然后把乌鲁木齐的邻接节点加入队列（虽然会将其邻接点加入队列，但是因为后面其实这些邻接点并不会重复处理，为了简便起见，我们在图上就不体现其邻接节点加入队列的过程）。\n\n乌鲁木齐到成都需要经过西安，已知成都到西安的距离，故可以求得成都到乌鲁木齐的距离。\n\n\n\n接着，把北京出队，同时标记成都到北京的最短距离，然后把北京的邻接节点加入队列，同理，邻接节点入队这个过程我们图上就没有体现了。\n\n北京到成都需要经过西安，已知成都到西安的距离，故可以求得成都到北京的距离。\n\n\n\n同理可以求得深圳、香港、南京的最短距离。\n\n即最终结果如下：\n\n\n\n因为我们在求解过程中把经过的路径已经计算出来了，类同于链表的原理，我们可以从终点倒推到起点，便可以求得经过的节点，因为这个是一个逆序的结果，所以我们需要使用栈再次将其逆序，即可求得最终的结果。\n\n不管是有向还是无向图，我们都可以使用上述算法求得从某个指定的开始节点到所有节点的最短路径。\n\n\n# 带权图单源最短路径算法\n\n对于这个问题，我们还是基于上面我们使用的那个城市相对位置的例子来阐述，不过，需要引入权重。\n\n\n\n因为增加了权重，上面的表示方法也有一定的调整：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n\n\n\nclass Edge {\n  constructor(name, cost) {\n    this.name = name;\n    this.cost = cost;\n  }\n  /**\n   * 边的编号\n   */\n  name;\n  /**\n   * 起始点\n   * @type {Vertex}\n   */\n  from;\n  /**\n   * 终止点\n   * @type {Vertex}\n   */\n  to;\n  /**\n   * @type {number}\n   */\n  cost;\n}\n\nclass Vertex {\n  constructor(cityName) {\n    this.cityName = cityName;\n  }\n  /**\n   * 城市名称\n   */\n  cityName;\n  /**\n   * 邻接边\n   */\n  edges = [];\n}\n\nclass Graph {\n  /**\n   * 顶点列表\n   */\n  vertexList = [];\n\n  addVertex(v) {\n    this.vertexList.push(v);\n  }\n  /**\n   * 增加边\n   * @param {Vertex} from\n   * @param {Vertex} to\n   * @param {number} cost\n   */\n  addEdge(from, to, cost) {\n    const into = new Edge(`${from.cityName}至${to.cityName}`, cost);\n    const outside = new Edge(`${to.cityName}至${from.cityName}`, cost);\n    // 建立两个城市的指向关系\n    from.edges.push(outside);\n    to.edges.push(into);\n  }\n}\n\n\n然后，初始化数据：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n\n\nconst g = new Graph();\nconst beijing = new Vertex("北京");\nconst nanjing = new Vertex("南京");\nconst guangzhou = new Vertex("广州");\nconst shenzhen = new Vertex("深圳");\nconst hongkong = new Vertex("香港");\nconst chengdu = new Vertex("成都");\nconst xian = new Vertex("西安");\nconst urumchi = new Vertex("乌鲁木齐");\n\n/**\n * 将城市加入到图中\n */\ng.addVertex(beijing);\ng.addVertex(nanjing);\ng.addVertex(guangzhou);\ng.addVertex(shenzhen);\ng.addVertex(hongkong);\ng.addVertex(chengdu);\ng.addVertex(xian);\ng.addVertex(urumchi);\n/**\n * 建立连接关系\n */\ng.addEdge(beijing, nanjing, 35);\ng.addEdge(beijing, xian, 1000);\ng.addEdge(nanjing, guangzhou, 15);\ng.addEdge(guangzhou, shenzhen, 10);\ng.addEdge(guangzhou, hongkong, 10);\ng.addEdge(hongkong, shenzhen, 10);\ng.addEdge(chengdu, guangzhou, 50);\ng.addEdge(chengdu, xian, 120);\ng.addEdge(urumchi, xian, 100);\ng.addEdge(urumchi, beijing, 300);\n\n\n接下来是根据上面图的表示方法给出的对应求解的核心代码，也就是大名鼎鼎的迪杰斯特拉算法：\n\n/**\n * 在图中返回未被收录顶点中dist最小者\n * @param {Graph} graph\n * @param {Map<number, number>} distance\n * @param {Map<Vertex, boolean>} collected\n * @returns {Vertex | null}\n */\nfunction findMinDist(graph, distance, collected) {\n  /* 返回未被收录顶点中dist最小顶点 */\n  let minVertex;\n  let minDist = Infinity;\n  for (let i = 0; i < graph.vertexList.length; i++) {\n    const curVertex = graph.vertexList[i];\n    /* 若curVertex未被收录，且dist.get(curVertex)更小 */\n    if (!collected.get(curVertex) && distance.get(curVertex) < minDist) {\n      /* 更新最小距离 */\n      minDist = distance.get(curVertex);\n      /* 更新对应顶点 */\n      minVertex = curVertex;\n    }\n  }\n  // 如果能够找到这样的顶点，则返回最小的距离，否则，这样的距离不存在\n  return minDist < Infinity ? minVertex : null;\n}\n\n/**\n * 迪杰斯特拉算法求解最短路径\n * @param {Graph} graph\n * @param {Vertex} start\n * @returns\n */\nfunction dijkstra(graph, start) {\n  let collected = new Map();\n  let distance = new Map();\n  let path = new Map();\n  /* 先将起点收入集合 */\n  distance.set(start, 0);\n  collected.set(start, true);\n  graph.vertexList.forEach((vertex) => {\n    if (vertex === start) {\n      // 对start节点本身除外\n      return;\n    }\n    // 找到start节点的邻接点，如果当前节点存在出度指向起点，则证明当前节点是开始节点的邻接点\n    const neighborEdge = vertex.edges.find((v) => v.to === start);\n    // 若存在连接的话，则按权重初试化，否则初始化为无穷大\n    if (neighborEdge) {\n      distance.set(vertex, neighborEdge.cost);\n      path.set(vertex, start);\n    } else {\n      distance.set(vertex, Infinity);\n    }\n  });\n  while (true) {\n    /* vertex为未被收录顶点中distance最小者 */\n    let vertex = findMinDist(graph, distance, collected);\n    /* 若这样的vertex不存在，流程结束 */\n    if (!vertex) {\n      break;\n    }\n    /* 收录vertex */\n    collected.set(vertex, true);\n    /* 遍历图中的每个顶点 */\n    for (let i = 0; i < graph.vertexList.length; i++) {\n      let curVertex = graph.vertexList[i];\n      /* 若curVertex是vertex的邻接点并且未被收录 */\n      const linkEdge = curVertex.edges.find((edge) => edge.to === vertex);\n      if (!collected.get(curVertex) && linkEdge) {\n        /* 若有负边 */\n        if (linkEdge < 0) {\n          /* 不能正确解决，返回错误标记 */\n          return { distance: null, path: null };\n        }\n        /* 若收录vertex使得distance变小 */\n        if (distance.get(vertex) + linkEdge.cost < distance.get(curVertex)) {\n          /* 更新dist */\n          distance.set(curVertex, distance.get(vertex) + linkEdge.cost);\n          /* 更新start到curVertex的路径 */\n          path.set(curVertex, vertex);\n        }\n      }\n    }\n  }\n  return { distance, path };\n}\n\n/**\n * 根据迪杰斯特拉算法求解结果求最终的结果\n * @param {Map<Vertex, number>} distance\n * @param {Map<Vertex, Vertex>} path\n * @param {Vertex} destination\n */\nfunction getShortestPath(path, distance, destination) {\n  if (path === null || distance === null) {\n    return { cost: -1, path: null };\n  }\n  const stack = [destination];\n  let preVertex = path.get(destination);\n  while (preVertex) {\n    stack.push(preVertex);\n    preVertex = path.get(preVertex);\n  }\n  let via = "";\n  let cost = distance.get(destination);\n  while (stack.length) {\n    via += "->" + stack.pop().cityName;\n  }\n  return { path: via.replace(/(^->)|(->$)/g, ""), cost };\n}\n\n\n我们来分析一下迪杰斯特拉算法的求解过程：\n\n首先，将起始节点收录，然后找到它的所有邻接点，如果找的到邻接点的话，初始化该邻接点到起点的距离，并且将该邻接点更新在起始节点的路径上，西安和广州是成都的邻接点，因此可以得到如下图：\n\n\n\n接着，我们找到未收录节点中的最小的节点，经过查找，找到的是广州，因为发现成都到南京，香港，深圳的距离由原来的无穷大变成经过广州再到对应的城市，因此可以更新距离和路径，可以得到如下图：\n\n\n\n接着，继续找到未收录节点中的最小节点，经过查找，找到的是香港，因为发现成都到香港的距离可以保持不变，其邻接点深圳也是处理过的，因此，仅仅需要将香港收录，可以得到下图：\n\n\n\n接着，继续找到未收录节点中的最小节点，经过查找，找到的是深圳，和香港同理，因此可以得到下图：\n\n\n\n接着，我们找到未收录节点中的最小的节点，经过查找，找到的是南京，因为发现成都到北京的距离由原来的无穷大变成经过南京再到北京，因此可以更新距离和路径，可以得到如下图：\n\n\n\n接着，我们找到未收录节点中的最小的节点，经过查找，找到的是北京，因为发现成都到乌鲁木齐的距离由原来的无穷大变成经过北京再到乌鲁木齐，因此可以更新距离和路径，可以得到如下图：\n\n\n\n接着，我们找到未收录节点中的最小的节点，经过查找，找到的是乌鲁木齐，因为发现成都到西安的距离可以保持不变，因此可以不更新距离和路径，可以得到如下图：\n\n\n\n接着，我们找到未收录节点中的最小的节点，经过查找，找到的是西安，因为发现成都到乌鲁木齐的距离可以变得更小，因此可以更新成都到乌鲁木齐距离，并且把西安更新到成都到乌鲁木齐的路径上，可以得到如下图：\n\n\n\n到现在，我们已经把所有的顶点都收录完成了，因此，找不到未收录的最小顶点，退出循环，程序结束。\n\n分析了上面的流程，我们就可以写出迪杰斯特拉算法的伪代码了，如下：\n\n/* 单源有权最短路径算法 */\nfunction dijkstra(vertex) {\n  collected[vertex] = true;\n  for(图中所有顶点 V) {\n    if(当前 V 是 vertex的邻接点) {\n      distance[V] = vertex到V的权重\n      把 V 更新在 vertex的路径上\n    } else {\n      distance[V] = 无穷大\n    }\n  }\n  while(true) {\n    minVertex = 找出未收录顶点的最小者；\n    if(找不到这样的minVertex) {\n      break;\n    }\n    collected[minVertex] = true;\n    for(minVertex 的每个邻接点 neighborVertex) {\n      if(!collected[neighborVertex]) {\n        if(存在负值圈) {\n          return false;\n        }\n        if(distance[minVertex] + minVertex到neighborVertex的权重 < distance[neighborVertex]) {\n          distance[neighborVertex] = distance[neighborVertex] + minVertex到neighborVertex的权重\n          path[neighborVertex] = minVertex\n        }\n      }\n    }\n  }\n  return true;\n}\n\n\n可以看到的是，迪杰斯特拉算法还是基于广度优先的思想在做的，不过神奇的是却没有用到队列，是基于贪心算法的思想，对此有兴趣的同学可以自行查阅相关资料。\n\n需要注意的是，迪杰斯特拉算法是不能解决负值圈的问题的，就好比，你每在那个地方兜一下，不仅不花钱，别人还要倒给你钱，只要你不断兜圈子，那这儿的权重就会变成负无穷。\n\n还有一个需要大家注意的问题是，对于辅助函数findMinDist，每次都找最小值，这个操作我们是否已经在哪儿见过了呀？很容易就联想到，可以引入最小堆来加快每次查找最小未收录节点的效率。\n\n和无权图的情况类似，不管是有向图还是无向图，都可以使用迪杰斯特拉算法进行求解。\n\n\n# 带权图多源最短路径算法\n\n迪杰斯特拉算法解决的是单源最短路径的问题，如何求多源最短路径呢，有的朋友会说，那直接把迪杰斯特拉算法对每个顶点都进行一次求解就可以了啊，这个确实是可以的，但是，还可以有更高明的算法，这就是接下来要阐述的弗洛伊德算法。\n\n不幸的消息又来了，弗洛伊德算法是基于动态规划思想的，在前文我们阐述KMP的时候提到过next数组的求解过程也是基于动态规划的，这是一个老大难问题，这方面比较小白的朋友，可以先尝试学习这门课程，然后再回过来看这篇博客较好。\n\n既然是基于动态规划，那么就一定是存在递推关系的，接下来就看一看这个递推关系是怎么建立的。\n\n令：Dpk[i][j] = 路径 {i->{l<=k}->j}的最小长度，和迪杰斯特拉算法一样，这儿只是表示已经收进到集合中的当前编号小于等于k的顶点从i到j的最短路径。\n\n那么，Dp0[i][j]，Dp1[i][j]，... Dpsize-1[i][j]给出了i到j真正的最短距离，size为图中的顶点个数。\n\n当 Dpk-1[i][j]已经完成，递推到 Dpk[i][j]时，存在下面两种情况：\n\n如果 k∉ 最短路径{i->{l<=k}->j}，则 Dpk-1[i][j] = Dpk[i][j]\n\n如果 k∈ 最短路径{i->{l<=k}->j}，则该路径必定由两段最短路径组成，即： Dpk[i][j] = Dpk-1[i][k] + Dpk-1[k][i](最外层循环控制序列，内两层循环控制两点，所以在求 Dpk[i][j]时，一定已经求出了 Dpk-1[i][k] 和 Dpk-1[k][i])\n\n如果使用邻接矩阵表示图的话，弗洛伊德算法代码看起来会比较简洁，但是我们依然使用上面的那种表示方法，那么实现就如下：\n\n/**\n * 弗洛伊德算法\n * @param {Graph} graph\n */\nfunction floyd(graph) {\n  // 根据图中最大的顶点数初始化dp数组\n  let size = graph.vertexList.length;\n  // 初始化无穷大，为了在日后的计算中将最短距离缩小，dp[i][j]的意义就是任意两点i和j之间的最短距离\n  const dp = Array.from({\n    length: size,\n  }).map(() => {\n    return Array.from({\n      length: size,\n    }).fill(Infinity);\n  });\n  // 初始化为-1，代表两点之间不存在中间节点\n  const path = Array.from({\n    length: size,\n  }).map(() => {\n    return Array.from({\n      length: size,\n    }).fill(-1);\n  });\n  /**\n   * 定义一个求两点之间最短路径的函数\n   * @param {Vertex} start\n   * @param {Vertex} end\n   * @returns\n   */\n  const getShortestPath = (start, end) => {\n    const shortestPath = (i, j) => {\n      let k = path[i][j];\n      // 如果两点之间不存在中间节点\n      if (k < 0) {\n        return (\n          graph.vertexList[i].cityName + "->" + graph.vertexList[j].cityName\n        );\n      }\n      // 从i到k的路径\n      const leftVia = shortestPath(i, k);\n      // 从k到j的路径\n      const rightVia = shortestPath(k, j);\n      // 因为计算途径路径的时候，多算了一个k节点，因此，需要给它替换掉\n      const via = leftVia + "->" + rightVia.replace(/^[\\u4e00-\\u9fa5]+->/, "");\n      return via;\n    };\n    const i = graph.vertexList.findIndex((v) => v === start);\n    const j = graph.vertexList.findIndex((v) => v === end);\n    if (i < 0 || j < 0) {\n      return "";\n    }\n    return shortestPath(i, j);\n  };\n  /**\n   * 定义一个求两点之间最小化肥的函数\n   * @param {Vertex} start\n   * @param {Vertex} end\n   */\n  const getShortestDistance = (start, end) => {\n    const i = graph.vertexList.findIndex((v) => v === start);\n    const j = graph.vertexList.findIndex((v) => v === end);\n    return i >= 0 && j >= 0 ? dp[i][j] : null;\n  };\n  // 初始化dp的值，若两点之间存在边，则初始化为权重，若不存在边，则初始为无穷大\n  for (let i = 0; i < size; i++) {\n    // 将对角线初始化为0，因为不允许自回路\n    dp[i][i] = 0;\n    const v1 = graph.vertexList[i];\n    // 将存在邻接点的点初始化为两点之间的权重，若不存在则初始化为无穷大\n    v1.edges.forEach((edge) => {\n      const j = graph.vertexList.findIndex((x) => x === edge.to);\n      dp[i][j] = edge.cost;\n    });\n  }\n  /**\n   * 错误断言函数\n   */\n  const assertError = () => {\n    throw new Error("存在负值圈，无法计算");\n  };\n  for (k = 0; k < size; k++) {\n    for (i = 0; i < size; i++) {\n      for (j = 0; j < size; j++) {\n        // 将下标为k的节点加入{i->{l<=k}->j}的集合中，如果从i到k的距离和k到j的距离比当前的小，则更新i到j的最短距离，并且i和j之间的最短距离是从i到k再到k到j\n        if (dp[i][k] + dp[k][j] < dp[i][j]) {\n          dp[i][j] = dp[i][k] + dp[k][j];\n          if (i == j && dp[i][j] < 0) {\n            /* 若发现负值圈，不能正确解决，返回错误标记 */\n            return {\n              distance: assertError,\n              path: assertError,\n            };\n          }\n          // 将k更新在i和j之间，表示从i到j必须要途径k节点\n          path[i][j] = k;\n        }\n      }\n    }\n  }\n  return {\n    distance: getShortestDistance,\n    path: getShortestPath,\n  };\n}\n\n\n可以看到，我们一直都在不断地去找顶点的序号，因此，使用邻接矩阵表示的话，这个过程是可以省略的，所以代码会更简洁一些。\n\n上述是对于动态规划的理论描述，如果有同学看起来觉得困难的话，不如先看下文，然后再回过头来看理论描述。\n\n弗洛伊德算法首先先求出任意两点A和B间的距离，然后两点之间加入一个新的点C，原来A和B的距离是否能够被A+C和B+C替换（这就好比把一段线段逐渐打成由几个线段组成的一个过程）。\n\n最外层的循环k其实控制的是对于开始节点i和结束节点j，加入新的节点的个数，随着节点不断地被加入，便可以不断的优化i到j之间的最短距离，最终解出两点之间的最短距离。\n\n比如我们求成都到北京的距离，首先，我们已知北京到西安，西安到成都，南京到北京，南京到广州，广州到成都等城市之间的距离。\n\n首先将北京和成都不存在邻接关系，因此两者之间的距离初始化为正无穷，假设现在我们加入深圳，对北京到成都的距离没有影响（别的城市距离有影响，但我们现在只阐述北京到成都，后续将不再赘述），接着加入南京，可以将北京到广州的距离更新为 50，紧接着，我们加入乌鲁木齐，对于北京到成都的距离没有影响，接着我们加入西安，此时北京到成都的距离可以更新为 1120，假设现在我们加入广州，成都到北京的距离可以更新为 100，后面，我们再加入香港，对于北京到成都的距离已经没有影响了，因此，北京到成都的距离就求解完毕了。\n\n由于这是一个动态的过程，每时每刻都在求以k个顶点为集合中的任意两点间距离，当所有的顶点都加入完毕的时候，就可以求得所有的任意两点间的距离。',normalizedContent:'# 最短路径\n\n最短路径问题，这个问题几乎是我们每天必定会接触到的问题了吧。\n\n当你打开高德地图，输入目的地，高德地图一下就可以给你计算出来了怎么走，甚至还能让你选条件，比如途经点，用时最短，里程最短等条件。我一直感叹其中的神奇，在我没有接触图这章的知识的时候，想破脑袋也不知道其中的原理，但是我从未放弃过要去搞明白计算机是怎么样解决这类问题的。\n\n曾经我有一个朋友，他是银行职员，当时正值炎炎夏日，他需要在一周内拜访成都市区几百家客户，他来求助我，是否可以帮忙写一个程序算一下怎么安排这些客户的拜访顺序，囿于当时我的水平有限，只能遗憾的告诉他我不会啊，真实心疼他。他的这个需求其实是结合了图的最短路径问题和最小生成树问题的场景。\n\n如果你掌握了本节内容，将来和朋友们出去玩儿的时候，编程求解旅行的规划，那应该可以狠狠地秀大家一把吧；\n\n如果你不仅掌握了本节内容，还掌握了后面将会介绍的最小生成树问题，将来某一天大家有类似我朋友这种极端的需求的时候，一定可以帮到他哟，这就是程序员的力量，代码的魅力，加油，拿下这节知识。\n\n\n# 无权图单源最短路\n\n无权图的单源最短路问题，跟我们的广度优先遍历的思路非常相似，我们从起点出发，依次操作当前节点的邻接点，若其还没有处理过，则处理，并且更新起点到这个点的距离，然后还要把这个点加到我们记录的一个路径数据集里面去。重复上述操作，直到处理完图中所有的点。\n\n我们以这个图为例：\n\n\n\n并且以如下表示方法表示图：\n\n/**\n * 边类\n */\nclass edge {\n  constructor(name) {\n    this.name = name;\n  }\n  /**\n   * 边的编号\n   */\n  name;\n  /**\n   * 起始点\n   * @type {vertex}\n   */\n  from;\n  /**\n   * 终止点\n   * @type {vertex}\n   */\n  to;\n}\n\n/**\n * 顶点类\n */\nclass vertex {\n  /**\n   * 城市名称\n   */\n  cityname;\n  /**\n   * 邻接点\n   */\n  siblings = [];\n  constructor(cityname) {\n    this.cityname = cityname;\n  }\n}\n\n/**\n * 图类\n */\nclass graph {\n  /**\n   * 顶点集合\n   * @type {vertex[]}\n   */\n  vertexlist = [];\n  /**\n   * 边集合\n   * @type {edge[]}\n   */\n  edgelist = [];\n  /**\n   * 向图中插入一个顶点\n   */\n  addvertex(v) {\n    this.vertexlist.push(v);\n  }\n  /**\n   * 增加边，连接from和to两个顶点\n   * @param {vertex} from\n   * @param {vertex} to\n   */\n  addedge(from, to) {\n    const name = `${from.cityname}至${to.cityname}`;\n    const edge = new edge(name);\n    this.edgelist.push(edge);\n    from.siblings.push(to);\n    to.siblings.push(from);\n  }\n}\n\n\n接着，根据上面的那个图，构建出我们想要的连接关系：\n\nconst g = new graph();\nconst beijing = new vertex("北京");\nconst nanjing = new vertex("南京");\nconst guangzhou = new vertex("广州");\nconst shenzhen = new vertex("深圳");\nconst hongkong = new vertex("香港");\nconst chengdu = new vertex("成都");\nconst xian = new vertex("西安");\nconst urumchi = new vertex("乌鲁木齐");\n/**\n * 将城市加入到图中\n */\ng.addvertex(beijing);\ng.addvertex(nanjing);\ng.addvertex(guangzhou);\ng.addvertex(shenzhen);\ng.addvertex(hongkong);\ng.addvertex(chengdu);\ng.addvertex(xian);\ng.addvertex(urumchi);\n/**\n * 建立连接关系\n */\ng.addedge(beijing, nanjing);\ng.addedge(beijing, xian);\ng.addedge(nanjing, guangzhou);\ng.addedge(guangzhou, shenzhen);\ng.addedge(guangzhou, hongkong);\ng.addedge(hongkong, shenzhen);\ng.addedge(chengdu, guangzhou);\ng.addedge(chengdu, xian);\ng.addedge(urumchi, xian);\ng.addedge(urumchi, beijing);\n\n\n那么，最短路径求解算法如下：\n\n/**\n * 单源无权图的最短路算法\n * @param {vertex} start\n * @param {vertex} end\n */\nfunction unweightedshortestpath(start, end) {\n  const queue = [];\n  /* 距离哈希表，用于存储开始顶点到任意节点的距离 */\n  const dist = new map();\n  /* 路径哈希表，用于存储开始顶点到任意节点所经过的顶点 */\n  const path = new map();\n  dist.set(start, 0);\n  queue.push(start);\n  while (queue.length > 0) {\n    let vertex = queue.shift();\n    for (let i = 0; i < vertex.siblings.length; i++) {\n      // 取出当前正在处理的顶点的邻接点进行处理\n      let adjoinvertex = vertex.siblings[i];\n      /* 若adjoinvertex未被访问过 */\n      if (typeof dist.get(adjoinvertex) === "undefined") {\n        /* 将这个点到start的距离更新 */\n        dist.set(adjoinvertex, dist.get(vertex) + 1);\n        /* 将这个点记录在s到adjoinvertex的路径上 */\n        path.set(adjoinvertex, vertex);\n        // 并且将当前邻接点入队\n        queue.push(adjoinvertex);\n      }\n    }\n  }\n  // 获取终点的最短路径长度\n  const distance = dist.get(end);\n  // 使用栈记住终点\n  const stack = [end];\n  let prevertex = path.get(end);\n  // 沿途处理从终点到起点所经过的路径\n  while (prevertex) {\n    stack.push(prevertex);\n    // 继续向上迭代，寻找经过的顶点\n    prevertex = path.get(prevertex);\n  }\n  // 经过逆序，得到了正确的路径\n  let via = "";\n  while (stack.length) {\n    const city = stack.pop();\n    via += "->" + city.cityname;\n  }\n  return { distance, path: via.replace(/(^->)|(->$)/g, "") };\n}\n\n\n假设我们想求出成都到北京的最短距离，并且需要求出是怎么样达到北京的，如下：\n\nconst { path, distance } = unweightedshortestpath(chengdu, beijing);\n// path 成都->西安->北京\n// distance 3\n\n\n下面，我们画图描述一下这个处理流程。\n\n首先，在开始时将成都入队，同时设置距离为0，因为我们设置了它的距离，其实际上就相当于之前我们在广度优先遍历节的时候所提到的标记当前的节点已经被处理的手段，一举两得。接着，我们把成都出队，准备处理它的邻接点。\n\n\n\n紧接着，我们把西安和广州入队\n\n\n\n接着，把西安出队，同时标记成都到西安的最短距离，然后将西安的邻接节点乌鲁木齐和北京入队。\n\n\n\n接着，把广州出队，同时标记成都到广州的最短距离，然后将广州的邻接节点深圳、香港和南京入队。\n\n\n\n接着，把乌鲁木齐出队，同时标记成都到乌鲁木齐的最短距离，然后把乌鲁木齐的邻接节点加入队列（虽然会将其邻接点加入队列，但是因为后面其实这些邻接点并不会重复处理，为了简便起见，我们在图上就不体现其邻接节点加入队列的过程）。\n\n乌鲁木齐到成都需要经过西安，已知成都到西安的距离，故可以求得成都到乌鲁木齐的距离。\n\n\n\n接着，把北京出队，同时标记成都到北京的最短距离，然后把北京的邻接节点加入队列，同理，邻接节点入队这个过程我们图上就没有体现了。\n\n北京到成都需要经过西安，已知成都到西安的距离，故可以求得成都到北京的距离。\n\n\n\n同理可以求得深圳、香港、南京的最短距离。\n\n即最终结果如下：\n\n\n\n因为我们在求解过程中把经过的路径已经计算出来了，类同于链表的原理，我们可以从终点倒推到起点，便可以求得经过的节点，因为这个是一个逆序的结果，所以我们需要使用栈再次将其逆序，即可求得最终的结果。\n\n不管是有向还是无向图，我们都可以使用上述算法求得从某个指定的开始节点到所有节点的最短路径。\n\n\n# 带权图单源最短路径算法\n\n对于这个问题，我们还是基于上面我们使用的那个城市相对位置的例子来阐述，不过，需要引入权重。\n\n\n\n因为增加了权重，上面的表示方法也有一定的调整：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n\n\n\nclass edge {\n  constructor(name, cost) {\n    this.name = name;\n    this.cost = cost;\n  }\n  /**\n   * 边的编号\n   */\n  name;\n  /**\n   * 起始点\n   * @type {vertex}\n   */\n  from;\n  /**\n   * 终止点\n   * @type {vertex}\n   */\n  to;\n  /**\n   * @type {number}\n   */\n  cost;\n}\n\nclass vertex {\n  constructor(cityname) {\n    this.cityname = cityname;\n  }\n  /**\n   * 城市名称\n   */\n  cityname;\n  /**\n   * 邻接边\n   */\n  edges = [];\n}\n\nclass graph {\n  /**\n   * 顶点列表\n   */\n  vertexlist = [];\n\n  addvertex(v) {\n    this.vertexlist.push(v);\n  }\n  /**\n   * 增加边\n   * @param {vertex} from\n   * @param {vertex} to\n   * @param {number} cost\n   */\n  addedge(from, to, cost) {\n    const into = new edge(`${from.cityname}至${to.cityname}`, cost);\n    const outside = new edge(`${to.cityname}至${from.cityname}`, cost);\n    // 建立两个城市的指向关系\n    from.edges.push(outside);\n    to.edges.push(into);\n  }\n}\n\n\n然后，初始化数据：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n\n\nconst g = new graph();\nconst beijing = new vertex("北京");\nconst nanjing = new vertex("南京");\nconst guangzhou = new vertex("广州");\nconst shenzhen = new vertex("深圳");\nconst hongkong = new vertex("香港");\nconst chengdu = new vertex("成都");\nconst xian = new vertex("西安");\nconst urumchi = new vertex("乌鲁木齐");\n\n/**\n * 将城市加入到图中\n */\ng.addvertex(beijing);\ng.addvertex(nanjing);\ng.addvertex(guangzhou);\ng.addvertex(shenzhen);\ng.addvertex(hongkong);\ng.addvertex(chengdu);\ng.addvertex(xian);\ng.addvertex(urumchi);\n/**\n * 建立连接关系\n */\ng.addedge(beijing, nanjing, 35);\ng.addedge(beijing, xian, 1000);\ng.addedge(nanjing, guangzhou, 15);\ng.addedge(guangzhou, shenzhen, 10);\ng.addedge(guangzhou, hongkong, 10);\ng.addedge(hongkong, shenzhen, 10);\ng.addedge(chengdu, guangzhou, 50);\ng.addedge(chengdu, xian, 120);\ng.addedge(urumchi, xian, 100);\ng.addedge(urumchi, beijing, 300);\n\n\n接下来是根据上面图的表示方法给出的对应求解的核心代码，也就是大名鼎鼎的迪杰斯特拉算法：\n\n/**\n * 在图中返回未被收录顶点中dist最小者\n * @param {graph} graph\n * @param {map<number, number>} distance\n * @param {map<vertex, boolean>} collected\n * @returns {vertex | null}\n */\nfunction findmindist(graph, distance, collected) {\n  /* 返回未被收录顶点中dist最小顶点 */\n  let minvertex;\n  let mindist = infinity;\n  for (let i = 0; i < graph.vertexlist.length; i++) {\n    const curvertex = graph.vertexlist[i];\n    /* 若curvertex未被收录，且dist.get(curvertex)更小 */\n    if (!collected.get(curvertex) && distance.get(curvertex) < mindist) {\n      /* 更新最小距离 */\n      mindist = distance.get(curvertex);\n      /* 更新对应顶点 */\n      minvertex = curvertex;\n    }\n  }\n  // 如果能够找到这样的顶点，则返回最小的距离，否则，这样的距离不存在\n  return mindist < infinity ? minvertex : null;\n}\n\n/**\n * 迪杰斯特拉算法求解最短路径\n * @param {graph} graph\n * @param {vertex} start\n * @returns\n */\nfunction dijkstra(graph, start) {\n  let collected = new map();\n  let distance = new map();\n  let path = new map();\n  /* 先将起点收入集合 */\n  distance.set(start, 0);\n  collected.set(start, true);\n  graph.vertexlist.foreach((vertex) => {\n    if (vertex === start) {\n      // 对start节点本身除外\n      return;\n    }\n    // 找到start节点的邻接点，如果当前节点存在出度指向起点，则证明当前节点是开始节点的邻接点\n    const neighboredge = vertex.edges.find((v) => v.to === start);\n    // 若存在连接的话，则按权重初试化，否则初始化为无穷大\n    if (neighboredge) {\n      distance.set(vertex, neighboredge.cost);\n      path.set(vertex, start);\n    } else {\n      distance.set(vertex, infinity);\n    }\n  });\n  while (true) {\n    /* vertex为未被收录顶点中distance最小者 */\n    let vertex = findmindist(graph, distance, collected);\n    /* 若这样的vertex不存在，流程结束 */\n    if (!vertex) {\n      break;\n    }\n    /* 收录vertex */\n    collected.set(vertex, true);\n    /* 遍历图中的每个顶点 */\n    for (let i = 0; i < graph.vertexlist.length; i++) {\n      let curvertex = graph.vertexlist[i];\n      /* 若curvertex是vertex的邻接点并且未被收录 */\n      const linkedge = curvertex.edges.find((edge) => edge.to === vertex);\n      if (!collected.get(curvertex) && linkedge) {\n        /* 若有负边 */\n        if (linkedge < 0) {\n          /* 不能正确解决，返回错误标记 */\n          return { distance: null, path: null };\n        }\n        /* 若收录vertex使得distance变小 */\n        if (distance.get(vertex) + linkedge.cost < distance.get(curvertex)) {\n          /* 更新dist */\n          distance.set(curvertex, distance.get(vertex) + linkedge.cost);\n          /* 更新start到curvertex的路径 */\n          path.set(curvertex, vertex);\n        }\n      }\n    }\n  }\n  return { distance, path };\n}\n\n/**\n * 根据迪杰斯特拉算法求解结果求最终的结果\n * @param {map<vertex, number>} distance\n * @param {map<vertex, vertex>} path\n * @param {vertex} destination\n */\nfunction getshortestpath(path, distance, destination) {\n  if (path === null || distance === null) {\n    return { cost: -1, path: null };\n  }\n  const stack = [destination];\n  let prevertex = path.get(destination);\n  while (prevertex) {\n    stack.push(prevertex);\n    prevertex = path.get(prevertex);\n  }\n  let via = "";\n  let cost = distance.get(destination);\n  while (stack.length) {\n    via += "->" + stack.pop().cityname;\n  }\n  return { path: via.replace(/(^->)|(->$)/g, ""), cost };\n}\n\n\n我们来分析一下迪杰斯特拉算法的求解过程：\n\n首先，将起始节点收录，然后找到它的所有邻接点，如果找的到邻接点的话，初始化该邻接点到起点的距离，并且将该邻接点更新在起始节点的路径上，西安和广州是成都的邻接点，因此可以得到如下图：\n\n\n\n接着，我们找到未收录节点中的最小的节点，经过查找，找到的是广州，因为发现成都到南京，香港，深圳的距离由原来的无穷大变成经过广州再到对应的城市，因此可以更新距离和路径，可以得到如下图：\n\n\n\n接着，继续找到未收录节点中的最小节点，经过查找，找到的是香港，因为发现成都到香港的距离可以保持不变，其邻接点深圳也是处理过的，因此，仅仅需要将香港收录，可以得到下图：\n\n\n\n接着，继续找到未收录节点中的最小节点，经过查找，找到的是深圳，和香港同理，因此可以得到下图：\n\n\n\n接着，我们找到未收录节点中的最小的节点，经过查找，找到的是南京，因为发现成都到北京的距离由原来的无穷大变成经过南京再到北京，因此可以更新距离和路径，可以得到如下图：\n\n\n\n接着，我们找到未收录节点中的最小的节点，经过查找，找到的是北京，因为发现成都到乌鲁木齐的距离由原来的无穷大变成经过北京再到乌鲁木齐，因此可以更新距离和路径，可以得到如下图：\n\n\n\n接着，我们找到未收录节点中的最小的节点，经过查找，找到的是乌鲁木齐，因为发现成都到西安的距离可以保持不变，因此可以不更新距离和路径，可以得到如下图：\n\n\n\n接着，我们找到未收录节点中的最小的节点，经过查找，找到的是西安，因为发现成都到乌鲁木齐的距离可以变得更小，因此可以更新成都到乌鲁木齐距离，并且把西安更新到成都到乌鲁木齐的路径上，可以得到如下图：\n\n\n\n到现在，我们已经把所有的顶点都收录完成了，因此，找不到未收录的最小顶点，退出循环，程序结束。\n\n分析了上面的流程，我们就可以写出迪杰斯特拉算法的伪代码了，如下：\n\n/* 单源有权最短路径算法 */\nfunction dijkstra(vertex) {\n  collected[vertex] = true;\n  for(图中所有顶点 v) {\n    if(当前 v 是 vertex的邻接点) {\n      distance[v] = vertex到v的权重\n      把 v 更新在 vertex的路径上\n    } else {\n      distance[v] = 无穷大\n    }\n  }\n  while(true) {\n    minvertex = 找出未收录顶点的最小者；\n    if(找不到这样的minvertex) {\n      break;\n    }\n    collected[minvertex] = true;\n    for(minvertex 的每个邻接点 neighborvertex) {\n      if(!collected[neighborvertex]) {\n        if(存在负值圈) {\n          return false;\n        }\n        if(distance[minvertex] + minvertex到neighborvertex的权重 < distance[neighborvertex]) {\n          distance[neighborvertex] = distance[neighborvertex] + minvertex到neighborvertex的权重\n          path[neighborvertex] = minvertex\n        }\n      }\n    }\n  }\n  return true;\n}\n\n\n可以看到的是，迪杰斯特拉算法还是基于广度优先的思想在做的，不过神奇的是却没有用到队列，是基于贪心算法的思想，对此有兴趣的同学可以自行查阅相关资料。\n\n需要注意的是，迪杰斯特拉算法是不能解决负值圈的问题的，就好比，你每在那个地方兜一下，不仅不花钱，别人还要倒给你钱，只要你不断兜圈子，那这儿的权重就会变成负无穷。\n\n还有一个需要大家注意的问题是，对于辅助函数findmindist，每次都找最小值，这个操作我们是否已经在哪儿见过了呀？很容易就联想到，可以引入最小堆来加快每次查找最小未收录节点的效率。\n\n和无权图的情况类似，不管是有向图还是无向图，都可以使用迪杰斯特拉算法进行求解。\n\n\n# 带权图多源最短路径算法\n\n迪杰斯特拉算法解决的是单源最短路径的问题，如何求多源最短路径呢，有的朋友会说，那直接把迪杰斯特拉算法对每个顶点都进行一次求解就可以了啊，这个确实是可以的，但是，还可以有更高明的算法，这就是接下来要阐述的弗洛伊德算法。\n\n不幸的消息又来了，弗洛伊德算法是基于动态规划思想的，在前文我们阐述kmp的时候提到过next数组的求解过程也是基于动态规划的，这是一个老大难问题，这方面比较小白的朋友，可以先尝试学习这门课程，然后再回过来看这篇博客较好。\n\n既然是基于动态规划，那么就一定是存在递推关系的，接下来就看一看这个递推关系是怎么建立的。\n\n令：dpk[i][j] = 路径 {i->{l<=k}->j}的最小长度，和迪杰斯特拉算法一样，这儿只是表示已经收进到集合中的当前编号小于等于k的顶点从i到j的最短路径。\n\n那么，dp0[i][j]，dp1[i][j]，... dpsize-1[i][j]给出了i到j真正的最短距离，size为图中的顶点个数。\n\n当 dpk-1[i][j]已经完成，递推到 dpk[i][j]时，存在下面两种情况：\n\n如果 k∈ 最短路径{i->{l<=k}->j}，则 dpk-1[i][j] = dpk[i][j]\n\n如果 k∈ 最短路径{i->{l<=k}->j}，则该路径必定由两段最短路径组成，即： dpk[i][j] = dpk-1[i][k] + dpk-1[k][i](最外层循环控制序列，内两层循环控制两点，所以在求 dpk[i][j]时，一定已经求出了 dpk-1[i][k] 和 dpk-1[k][i])\n\n如果使用邻接矩阵表示图的话，弗洛伊德算法代码看起来会比较简洁，但是我们依然使用上面的那种表示方法，那么实现就如下：\n\n/**\n * 弗洛伊德算法\n * @param {graph} graph\n */\nfunction floyd(graph) {\n  // 根据图中最大的顶点数初始化dp数组\n  let size = graph.vertexlist.length;\n  // 初始化无穷大，为了在日后的计算中将最短距离缩小，dp[i][j]的意义就是任意两点i和j之间的最短距离\n  const dp = array.from({\n    length: size,\n  }).map(() => {\n    return array.from({\n      length: size,\n    }).fill(infinity);\n  });\n  // 初始化为-1，代表两点之间不存在中间节点\n  const path = array.from({\n    length: size,\n  }).map(() => {\n    return array.from({\n      length: size,\n    }).fill(-1);\n  });\n  /**\n   * 定义一个求两点之间最短路径的函数\n   * @param {vertex} start\n   * @param {vertex} end\n   * @returns\n   */\n  const getshortestpath = (start, end) => {\n    const shortestpath = (i, j) => {\n      let k = path[i][j];\n      // 如果两点之间不存在中间节点\n      if (k < 0) {\n        return (\n          graph.vertexlist[i].cityname + "->" + graph.vertexlist[j].cityname\n        );\n      }\n      // 从i到k的路径\n      const leftvia = shortestpath(i, k);\n      // 从k到j的路径\n      const rightvia = shortestpath(k, j);\n      // 因为计算途径路径的时候，多算了一个k节点，因此，需要给它替换掉\n      const via = leftvia + "->" + rightvia.replace(/^[\\u4e00-\\u9fa5]+->/, "");\n      return via;\n    };\n    const i = graph.vertexlist.findindex((v) => v === start);\n    const j = graph.vertexlist.findindex((v) => v === end);\n    if (i < 0 || j < 0) {\n      return "";\n    }\n    return shortestpath(i, j);\n  };\n  /**\n   * 定义一个求两点之间最小化肥的函数\n   * @param {vertex} start\n   * @param {vertex} end\n   */\n  const getshortestdistance = (start, end) => {\n    const i = graph.vertexlist.findindex((v) => v === start);\n    const j = graph.vertexlist.findindex((v) => v === end);\n    return i >= 0 && j >= 0 ? dp[i][j] : null;\n  };\n  // 初始化dp的值，若两点之间存在边，则初始化为权重，若不存在边，则初始为无穷大\n  for (let i = 0; i < size; i++) {\n    // 将对角线初始化为0，因为不允许自回路\n    dp[i][i] = 0;\n    const v1 = graph.vertexlist[i];\n    // 将存在邻接点的点初始化为两点之间的权重，若不存在则初始化为无穷大\n    v1.edges.foreach((edge) => {\n      const j = graph.vertexlist.findindex((x) => x === edge.to);\n      dp[i][j] = edge.cost;\n    });\n  }\n  /**\n   * 错误断言函数\n   */\n  const asserterror = () => {\n    throw new error("存在负值圈，无法计算");\n  };\n  for (k = 0; k < size; k++) {\n    for (i = 0; i < size; i++) {\n      for (j = 0; j < size; j++) {\n        // 将下标为k的节点加入{i->{l<=k}->j}的集合中，如果从i到k的距离和k到j的距离比当前的小，则更新i到j的最短距离，并且i和j之间的最短距离是从i到k再到k到j\n        if (dp[i][k] + dp[k][j] < dp[i][j]) {\n          dp[i][j] = dp[i][k] + dp[k][j];\n          if (i == j && dp[i][j] < 0) {\n            /* 若发现负值圈，不能正确解决，返回错误标记 */\n            return {\n              distance: asserterror,\n              path: asserterror,\n            };\n          }\n          // 将k更新在i和j之间，表示从i到j必须要途径k节点\n          path[i][j] = k;\n        }\n      }\n    }\n  }\n  return {\n    distance: getshortestdistance,\n    path: getshortestpath,\n  };\n}\n\n\n可以看到，我们一直都在不断地去找顶点的序号，因此，使用邻接矩阵表示的话，这个过程是可以省略的，所以代码会更简洁一些。\n\n上述是对于动态规划的理论描述，如果有同学看起来觉得困难的话，不如先看下文，然后再回过头来看理论描述。\n\n弗洛伊德算法首先先求出任意两点a和b间的距离，然后两点之间加入一个新的点c，原来a和b的距离是否能够被a+c和b+c替换（这就好比把一段线段逐渐打成由几个线段组成的一个过程）。\n\n最外层的循环k其实控制的是对于开始节点i和结束节点j，加入新的节点的个数，随着节点不断地被加入，便可以不断的优化i到j之间的最短距离，最终解出两点之间的最短距离。\n\n比如我们求成都到北京的距离，首先，我们已知北京到西安，西安到成都，南京到北京，南京到广州，广州到成都等城市之间的距离。\n\n首先将北京和成都不存在邻接关系，因此两者之间的距离初始化为正无穷，假设现在我们加入深圳，对北京到成都的距离没有影响（别的城市距离有影响，但我们现在只阐述北京到成都，后续将不再赘述），接着加入南京，可以将北京到广州的距离更新为 50，紧接着，我们加入乌鲁木齐，对于北京到成都的距离没有影响，接着我们加入西安，此时北京到成都的距离可以更新为 1120，假设现在我们加入广州，成都到北京的距离可以更新为 100，后面，我们再加入香港，对于北京到成都的距离已经没有影响了，因此，北京到成都的距离就求解完毕了。\n\n由于这是一个动态的过程，每时每刻都在求以k个顶点为集合中的任意两点间距离，当所有的顶点都加入完毕的时候，就可以求得所有的任意两点间的距离。',charsets:{cjk:!0}},{title:"构建树",frontmatter:{},regularPath:"/data-structure/hash/buildTree.html",relativePath:"data-structure/hash/buildTree.md",key:"v-217dde16",path:"/data-structure/hash/buildTree.html",headers:[{level:2,title:"构建树",slug:"构建树",normalizedTitle:"构建树",charIndex:2},{level:3,title:"递归法",slug:"递归法",normalizedTitle:"递归法",charIndex:585},{level:3,title:"哈希法",slug:"哈希法",normalizedTitle:"哈希法",charIndex:1385}],headersStr:"构建树 递归法 哈希法",content:"# 构建树\n\n这是一个在实际开发中相当常见的一个需求了。\n\n有些时候，是因为后端直接返回树结构的话，序列化时i/o开销比较大，在高并发场景下，会使得服务器的效率降低，因此不得不让前端自行构建树型结构的数据。\n\n还有一种情况就比较搞笑了，这种情况一般出现在小公司，你的后端因为某些不可告人的秘密，告诉你只能给你返回数组。但是我们前端又必须需要一个树状结构。此时为了避免尴尬，前端可能会要求后端怎么样操作简单就怎么样约定数据格式了，然后前端按照相应的规格自己将其构建成树。\n\n一般，后端给到前端的数据是这样的，我就以文件列表的例子来举例。\n\n/**\n * 文件信息\n */\ninterface File {\n  /**\n   * 文件的ID，需要使用string类型，若使用number类型，当id特别大的时候，前端解析的结果将不正确\n   */\n  id: string;\n\n  /**\n   * 文件的父级ID, 可能不存在\n   */\n  pid: string | null;\n\n  /**\n   * 文件名\n   */\n  filename: string;\n\n  /**\n   * 文件类型，比如是文件还是文件夹\n   */\n  type: number;\n\n  /**\n   * 子文件列表\n   */\n  children?: File[];\n}\n\n\n\n# 递归法\n\n/**\n * 构建文件树\n * @param file 文件信息\n * @param file 文件列表信息\n */\nfunction buildTree(file: File, files: File[]) {\n  // 找到当前文件的子文件列表\n  let children = files.filter((fileEle: File) => {\n    return fileEle.pid === file.id;\n  });\n  // 递归的处理当前文件子文件列表的子文件\n  file.children =\n    children.length === 0\n      ? undefined\n      : children.map((subFile: File) => buildTree(subFile, files));\n  return file;\n}\n\n/**\n * 将文件列表转为文件树，并且返回根节点\n * @param files 文件列表\n */\nfunction build(files: File[]) {\n  // 构建结果\n  const roots = files\n    .filter((file) => {\n      // 这一步操作是为了找到所有的根节点\n      return file.pid === null;\n    })\n    .map((file) => {\n      // 对根节点的数据进行构建\n      return buildTree(file, files);\n    });\n  return roots;\n}\n\n\n递归法的时间复杂度为O(n)，并且还有一个额外的O(h)的空间复杂度（递归调用时的堆栈空间占用），而且这个是有一定的风险的，当数据量比较大的时候，JS 可能会出最大调用栈的报错。\n\n\n# 哈希法\n\n这个方案是有点儿取巧的一种做法了，因为其完美的利用了引用类型数据的特征，因为引用数据类型，大家都同时持有一块相同的内存区域，不同的人对它进行修改，都会在它的身上得到体现。\n\n这是我曾经偶然一次自己写代码时发现的，后来在论坛上发现了大佬们也是这样做的，心里面还稍稍的窃喜了一下。\n\n/**\n * 将文件列表转换成为哈希表\n * @param {File[]} files\n */\nfunction makeHashMap(files) {\n  const map = new Map();\n  files.forEach((file) => {\n    // 以ID为主键建立哈希映射\n    map.set(file.id, file);\n  });\n  return map;\n}\n\nfunction buildTree(files) {\n  // 将文件构建成哈希表，主要是为了后续的查找方便\n  const fileMap = makeHashMap(files);\n  const roots = [];\n  // 逐个的对每个文件增加子元素\n  files.forEach((file) => {\n    // 找父级文件，如果找不到的话，说明是根节点\n    const parentFile = fileMap.get(file.pid);\n    if (parentFile) {\n      if (!Array.isArray(parentFile.children)) {\n        parentFile.children = [file];\n      } else {\n        parentFile.children.push(file);\n      }\n    } else {\n      roots.push(file);\n    }\n  });\n  // 最后只需要找出根节点的文件列表即可完成构建\n  return roots;\n}\n\n\n哈希法，将文件列表建立哈希，时间复杂度为O(N)，空间复杂度是O(N)，在构建时一次遍历，时间复杂度为O(N)，申明了一个用于存根节点存储的数组，最坏情况下，全部都是根节点，空间复杂度是O(N)，因此，哈希法的时间复杂度为O(N)，空间复杂度是O(N)，完爆递归法，而且代码也简洁易懂，不用担心在数据量较大的时候爆栈的风险。",normalizedContent:"# 构建树\n\n这是一个在实际开发中相当常见的一个需求了。\n\n有些时候，是因为后端直接返回树结构的话，序列化时i/o开销比较大，在高并发场景下，会使得服务器的效率降低，因此不得不让前端自行构建树型结构的数据。\n\n还有一种情况就比较搞笑了，这种情况一般出现在小公司，你的后端因为某些不可告人的秘密，告诉你只能给你返回数组。但是我们前端又必须需要一个树状结构。此时为了避免尴尬，前端可能会要求后端怎么样操作简单就怎么样约定数据格式了，然后前端按照相应的规格自己将其构建成树。\n\n一般，后端给到前端的数据是这样的，我就以文件列表的例子来举例。\n\n/**\n * 文件信息\n */\ninterface file {\n  /**\n   * 文件的id，需要使用string类型，若使用number类型，当id特别大的时候，前端解析的结果将不正确\n   */\n  id: string;\n\n  /**\n   * 文件的父级id, 可能不存在\n   */\n  pid: string | null;\n\n  /**\n   * 文件名\n   */\n  filename: string;\n\n  /**\n   * 文件类型，比如是文件还是文件夹\n   */\n  type: number;\n\n  /**\n   * 子文件列表\n   */\n  children?: file[];\n}\n\n\n\n# 递归法\n\n/**\n * 构建文件树\n * @param file 文件信息\n * @param file 文件列表信息\n */\nfunction buildtree(file: file, files: file[]) {\n  // 找到当前文件的子文件列表\n  let children = files.filter((fileele: file) => {\n    return fileele.pid === file.id;\n  });\n  // 递归的处理当前文件子文件列表的子文件\n  file.children =\n    children.length === 0\n      ? undefined\n      : children.map((subfile: file) => buildtree(subfile, files));\n  return file;\n}\n\n/**\n * 将文件列表转为文件树，并且返回根节点\n * @param files 文件列表\n */\nfunction build(files: file[]) {\n  // 构建结果\n  const roots = files\n    .filter((file) => {\n      // 这一步操作是为了找到所有的根节点\n      return file.pid === null;\n    })\n    .map((file) => {\n      // 对根节点的数据进行构建\n      return buildtree(file, files);\n    });\n  return roots;\n}\n\n\n递归法的时间复杂度为o(n)，并且还有一个额外的o(h)的空间复杂度（递归调用时的堆栈空间占用），而且这个是有一定的风险的，当数据量比较大的时候，js 可能会出最大调用栈的报错。\n\n\n# 哈希法\n\n这个方案是有点儿取巧的一种做法了，因为其完美的利用了引用类型数据的特征，因为引用数据类型，大家都同时持有一块相同的内存区域，不同的人对它进行修改，都会在它的身上得到体现。\n\n这是我曾经偶然一次自己写代码时发现的，后来在论坛上发现了大佬们也是这样做的，心里面还稍稍的窃喜了一下。\n\n/**\n * 将文件列表转换成为哈希表\n * @param {file[]} files\n */\nfunction makehashmap(files) {\n  const map = new map();\n  files.foreach((file) => {\n    // 以id为主键建立哈希映射\n    map.set(file.id, file);\n  });\n  return map;\n}\n\nfunction buildtree(files) {\n  // 将文件构建成哈希表，主要是为了后续的查找方便\n  const filemap = makehashmap(files);\n  const roots = [];\n  // 逐个的对每个文件增加子元素\n  files.foreach((file) => {\n    // 找父级文件，如果找不到的话，说明是根节点\n    const parentfile = filemap.get(file.pid);\n    if (parentfile) {\n      if (!array.isarray(parentfile.children)) {\n        parentfile.children = [file];\n      } else {\n        parentfile.children.push(file);\n      }\n    } else {\n      roots.push(file);\n    }\n  });\n  // 最后只需要找出根节点的文件列表即可完成构建\n  return roots;\n}\n\n\n哈希法，将文件列表建立哈希，时间复杂度为o(n)，空间复杂度是o(n)，在构建时一次遍历，时间复杂度为o(n)，申明了一个用于存根节点存储的数组，最坏情况下，全部都是根节点，空间复杂度是o(n)，因此，哈希法的时间复杂度为o(n)，空间复杂度是o(n)，完爆递归法，而且代码也简洁易懂，不用担心在数据量较大的时候爆栈的风险。",charsets:{cjk:!0}},{title:"拓扑排序",frontmatter:{},regularPath:"/data-structure/graph/topology-sort.html",relativePath:"data-structure/graph/topology-sort.md",key:"v-76a57669",path:"/data-structure/graph/topology-sort.html",headers:[{level:2,title:"拓扑排序",slug:"拓扑排序",normalizedTitle:"拓扑排序",charIndex:2}],headersStr:"拓扑排序",content:"# 拓扑排序\n\n建设中，敬请期待...",normalizedContent:"# 拓扑排序\n\n建设中，敬请期待...",charsets:{cjk:!0}},{title:"深克隆",frontmatter:{},regularPath:"/data-structure/hash/deepClone.html",relativePath:"data-structure/hash/deepClone.md",key:"v-e036e756",path:"/data-structure/hash/deepClone.html",headers:[{level:2,title:"深克隆",slug:"深克隆",normalizedTitle:"深克隆",charIndex:2}],headersStr:"深克隆",content:'# 深克隆\n\n本文不介绍深克隆和浅克隆的区别，若对此有疑惑的朋友请自行查阅资料\n\n另外，本文主要是阐述哈希表的应用，给出的实现并没有完全考虑深克隆中各种可能的问题，如果对此感兴趣的朋友可以自行查阅lodash的源码。\n\n再者，在深拷贝中，我们使用哈希表，需要使用Map或者WeakMap，因为使用对象作为哈希表的话，无法用对象作为key。\n\n深拷贝的算法实现思路，最简单的就是递归了，把已经拷贝过的对象和新生成的对象映射加入到哈希表中去，并且递归拷贝的时候，要带上这个哈希表递归。需要注意一点就是，拷贝过程中，一旦新生成的对象产生，就需要建立映射，而不是，等拷贝完成再建立映射，否则就无法区分当前对象是否已经被拷贝了，出现最大调用堆栈报错。\n\n算法实现如下：\n\n/**\n * 使用深度优先深克隆对象\n * @param {Array<any> | object} obj\n * @param { Map<Array<any> | object, Array<any> | object> } map\n * @returns\n */\nfunction deepClone(obj, map = new Map()) {\n  // 如果已经拷贝过，则可以直接返回拷贝过的值，主要是为了防止循环引用\n  let cloneObj = map.get(obj);\n  if (typeof cloneObj !== "undefined") {\n    return cloneObj;\n  }\n  // 初始化拷贝的对象\n  cloneObj = Array.isArray(obj) ? [] : {};\n  // 建立已经拷贝的引用，不能再开始拷贝属性了再建立拷贝引用，否则将会导致递归最大调用栈的问题发生\n  map.set(obj, cloneObj);\n  // 对拷贝对象挨个赋值\n  for (let prop in obj) {\n    // 遇到对象，则递归拷贝\n    if (obj[prop] instanceof Object) {\n      cloneObj[prop] = deepClone(obj[prop], map);\n      // 拷贝完成后，还要将其加入引用Map中去\n      map.set(obj[prop], cloneObj[obj]);\n    } else {\n      cloneObj[prop] = obj[prop];\n    }\n  }\n  return cloneObj;\n}\n',normalizedContent:'# 深克隆\n\n本文不介绍深克隆和浅克隆的区别，若对此有疑惑的朋友请自行查阅资料\n\n另外，本文主要是阐述哈希表的应用，给出的实现并没有完全考虑深克隆中各种可能的问题，如果对此感兴趣的朋友可以自行查阅lodash的源码。\n\n再者，在深拷贝中，我们使用哈希表，需要使用map或者weakmap，因为使用对象作为哈希表的话，无法用对象作为key。\n\n深拷贝的算法实现思路，最简单的就是递归了，把已经拷贝过的对象和新生成的对象映射加入到哈希表中去，并且递归拷贝的时候，要带上这个哈希表递归。需要注意一点就是，拷贝过程中，一旦新生成的对象产生，就需要建立映射，而不是，等拷贝完成再建立映射，否则就无法区分当前对象是否已经被拷贝了，出现最大调用堆栈报错。\n\n算法实现如下：\n\n/**\n * 使用深度优先深克隆对象\n * @param {array<any> | object} obj\n * @param { map<array<any> | object, array<any> | object> } map\n * @returns\n */\nfunction deepclone(obj, map = new map()) {\n  // 如果已经拷贝过，则可以直接返回拷贝过的值，主要是为了防止循环引用\n  let cloneobj = map.get(obj);\n  if (typeof cloneobj !== "undefined") {\n    return cloneobj;\n  }\n  // 初始化拷贝的对象\n  cloneobj = array.isarray(obj) ? [] : {};\n  // 建立已经拷贝的引用，不能再开始拷贝属性了再建立拷贝引用，否则将会导致递归最大调用栈的问题发生\n  map.set(obj, cloneobj);\n  // 对拷贝对象挨个赋值\n  for (let prop in obj) {\n    // 遇到对象，则递归拷贝\n    if (obj[prop] instanceof object) {\n      cloneobj[prop] = deepclone(obj[prop], map);\n      // 拷贝完成后，还要将其加入引用map中去\n      map.set(obj[prop], cloneobj[obj]);\n    } else {\n      cloneobj[prop] = obj[prop];\n    }\n  }\n  return cloneobj;\n}\n',charsets:{cjk:!0}},{title:"哈希表的概念",frontmatter:{},regularPath:"/data-structure/hash/desc.html",relativePath:"data-structure/hash/desc.md",key:"v-9139b18a",path:"/data-structure/hash/desc.html",headers:[{level:2,title:"哈希表的概念",slug:"哈希表的概念",normalizedTitle:"哈希表的概念",charIndex:2},{level:2,title:"实际开发中的哈希表",slug:"实际开发中的哈希表",normalizedTitle:"实际开发中的哈希表",charIndex:421}],headersStr:"哈希表的概念 实际开发中的哈希表",content:"# 哈希表的概念\n\n散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。（copy 自百度百科）\n\n在实际的开发中，我们并不需要真正的去编写哈希函数，不会去实现关键字到地址的映射，或者知道怎么去处理哈希冲突这类操作。\n\n每当存储的每一个关键字，表中就会多加入用相应的内容，因此增加一条映射空间复杂度计为O(1)；每次我们对数据的访问是一次直接的常数运算，因此时间复杂度计为O(1)。\n\n因为哈希表的查找非常快速，所以在实际开发中我们经常用它空间换时间（现在的计算机的性能都非常可观的，因此，我们会更加追求程序的运行速度）降低程序的时间复杂度。比如我们会根据数据的唯一性标识建立映射关系，后面在需要用到这个数据的时候，直接用它的唯一性标识从哈希表中读取。\n\n\n# 实际开发中的哈希表\n\n在 JS 中，我们的对象本身就是一个哈希表，因此经常我们可以在代码中看到这样的代码.\n\nconst map = Object.create(null);\n\n\n在 JS 中，使用对象做哈希表存在一个问题，只能使用字符串或者Symbol作为key。\n\nES6 中引入了两个新的结构，Map和WeakMap，可以支持任意类型做 key。关于 ES 的语法的问题，我们不在这儿细讲，后面会在专门的专题细讲。\n\n关于哈希表没有什么特别多的概念可讲，因此，哈希表这一章节，我们主要是阐述其应用。",normalizedContent:"# 哈希表的概念\n\n散列表（hash table，也叫哈希表），是根据关键码值(key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。（copy 自百度百科）\n\n在实际的开发中，我们并不需要真正的去编写哈希函数，不会去实现关键字到地址的映射，或者知道怎么去处理哈希冲突这类操作。\n\n每当存储的每一个关键字，表中就会多加入用相应的内容，因此增加一条映射空间复杂度计为o(1)；每次我们对数据的访问是一次直接的常数运算，因此时间复杂度计为o(1)。\n\n因为哈希表的查找非常快速，所以在实际开发中我们经常用它空间换时间（现在的计算机的性能都非常可观的，因此，我们会更加追求程序的运行速度）降低程序的时间复杂度。比如我们会根据数据的唯一性标识建立映射关系，后面在需要用到这个数据的时候，直接用它的唯一性标识从哈希表中读取。\n\n\n# 实际开发中的哈希表\n\n在 js 中，我们的对象本身就是一个哈希表，因此经常我们可以在代码中看到这样的代码.\n\nconst map = object.create(null);\n\n\n在 js 中，使用对象做哈希表存在一个问题，只能使用字符串或者symbol作为key。\n\nes6 中引入了两个新的结构，map和weakmap，可以支持任意类型做 key。关于 es 的语法的问题，我们不在这儿细讲，后面会在专门的专题细讲。\n\n关于哈希表没有什么特别多的概念可讲，因此，哈希表这一章节，我们主要是阐述其应用。",charsets:{cjk:!0}},{title:"从链表中删去总和值为零的连续节点",frontmatter:{},regularPath:"/data-structure/hash/removeZero.html",relativePath:"data-structure/hash/removeZero.md",key:"v-49904405",path:"/data-structure/hash/removeZero.html",headers:[{level:2,title:"从链表中删去总和值为零的连续节点",slug:"从链表中删去总和值为零的连续节点",normalizedTitle:"从链表中删去总和值为零的连续节点",charIndex:2}],headersStr:"从链表中删去总和值为零的连续节点",content:"# 从链表中删去总和值为零的连续节点\n\n给你一个链表的头节点 head，请你编写代码，反复删去链表中由 总和值为 0 的连续节点组成的序列，直到不存在这样的序列为止。\n\n删除完毕后，请你返回最终结果链表的头节点。\n\n> 输入：head = [1,2,-3,3,1] 输出：[3,1] 提示：答案 [1,2,1] 也是正确的。\n> >\n> 输入：head = [1,2,3,-3,4] 输出：[1,2,4]\n\n这题难就难在我们操作的对象是个链表，如果是数组的话，一下就变得特别简单了，从第一个数开始出发，遇到 0 可以直接删除，或者总和为 0 的时候，也可以把之前累加的都删除掉。如果一直加到最后都没有和为 0 的结果，那么就从第二个出发，以此类推，直到遍历到最后一个数。\n\n关键是现在换成了链表，不过想一下，还是可以把一个链表变成像数组那样操作，那么自然而然就可以联系到用哈希表来解决这个问题。\n\n首先，先遍历链表建立哈希，得到一个类数组对象，接着开始遍历这个类数组对象，求和，如果遇到和为 0 了，就把之前的节点全部丢弃，对剩余的节点递归进行上述操作。\n\n算法实现如下：\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar removeZeroSumSublists = function (head) {\n  if (!head) {\n    return null;\n  }\n  let newHead = head;\n  let preNode = null;\n  // 根据链表生成映射\n  const posMap = makeHash(head);\n  for (let i = 0; posMap[i]; i++) {\n    let currentNode = posMap[i];\n    let node = currentNode;\n    let sum = 0;\n    // 对从当前节点开始到最后一个节点求和，若为0，则丢弃这期间的所有节点，并且递归的进行删除操作\n    while (node) {\n      sum += node.val;\n      if (sum == 0) {\n        if (preNode === null) {\n          head = node.next;\n        } else {\n          preNode.next = node.next;\n        }\n        return removeZeroSumSublists(head);\n      } else {\n        node = node.next;\n      }\n    }\n    // 没有和为0的连续节点，将当前节点保留下来\n    preNode = currentNode;\n  }\n\n  return newHead;\n};\n\n/**\n * 将链表生成类数组对象\n * @param {ListNode} head\n * @returns\n */\nvar makeHash = function (head) {\n  let node = head;\n  let map = Object.create(null);\n  let counter = 0;\n  while (node) {\n    map[counter] = node;\n    node = node.next;\n    counter++;\n  }\n  map.length = counter;\n  return map;\n};\n",normalizedContent:"# 从链表中删去总和值为零的连续节点\n\n给你一个链表的头节点 head，请你编写代码，反复删去链表中由 总和值为 0 的连续节点组成的序列，直到不存在这样的序列为止。\n\n删除完毕后，请你返回最终结果链表的头节点。\n\n> 输入：head = [1,2,-3,3,1] 输出：[3,1] 提示：答案 [1,2,1] 也是正确的。\n> >\n> 输入：head = [1,2,3,-3,4] 输出：[1,2,4]\n\n这题难就难在我们操作的对象是个链表，如果是数组的话，一下就变得特别简单了，从第一个数开始出发，遇到 0 可以直接删除，或者总和为 0 的时候，也可以把之前累加的都删除掉。如果一直加到最后都没有和为 0 的结果，那么就从第二个出发，以此类推，直到遍历到最后一个数。\n\n关键是现在换成了链表，不过想一下，还是可以把一个链表变成像数组那样操作，那么自然而然就可以联系到用哈希表来解决这个问题。\n\n首先，先遍历链表建立哈希，得到一个类数组对象，接着开始遍历这个类数组对象，求和，如果遇到和为 0 了，就把之前的节点全部丢弃，对剩余的节点递归进行上述操作。\n\n算法实现如下：\n\n/**\n * definition for singly-linked list.\n * function listnode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {listnode} head\n * @return {listnode}\n */\nvar removezerosumsublists = function (head) {\n  if (!head) {\n    return null;\n  }\n  let newhead = head;\n  let prenode = null;\n  // 根据链表生成映射\n  const posmap = makehash(head);\n  for (let i = 0; posmap[i]; i++) {\n    let currentnode = posmap[i];\n    let node = currentnode;\n    let sum = 0;\n    // 对从当前节点开始到最后一个节点求和，若为0，则丢弃这期间的所有节点，并且递归的进行删除操作\n    while (node) {\n      sum += node.val;\n      if (sum == 0) {\n        if (prenode === null) {\n          head = node.next;\n        } else {\n          prenode.next = node.next;\n        }\n        return removezerosumsublists(head);\n      } else {\n        node = node.next;\n      }\n    }\n    // 没有和为0的连续节点，将当前节点保留下来\n    prenode = currentnode;\n  }\n\n  return newhead;\n};\n\n/**\n * 将链表生成类数组对象\n * @param {listnode} head\n * @returns\n */\nvar makehash = function (head) {\n  let node = head;\n  let map = object.create(null);\n  let counter = 0;\n  while (node) {\n    map[counter] = node;\n    node = node.next;\n    counter++;\n  }\n  map.length = counter;\n  return map;\n};\n",charsets:{cjk:!0}},{title:"两数之和",frontmatter:{},regularPath:"/data-structure/hash/sum.html",relativePath:"data-structure/hash/sum.md",key:"v-649ccb56",path:"/data-structure/hash/sum.html",headers:[{level:2,title:"两数之和",slug:"两数之和",normalizedTitle:"两数之和",charIndex:2},{level:3,title:"朴素法",slug:"朴素法",normalizedTitle:"朴素法",charIndex:171},{level:3,title:"哈希法",slug:"哈希法",normalizedTitle:"哈希法",charIndex:546}],headersStr:"两数之和 朴素法 哈希法",content:'# 两数之和\n\n给定一个整数数组 nums  和一个整数目标值 target，请你在该数组中找出和为目标值 target 的那两个整数，并返回它们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n\n你可以按任意顺序返回答案。\n\n这应该是绝大部分人人生中的第一道 LeetCode 题吧\n\n\n# 朴素法\n\n朴素法的思路和选择排序的思路差不多，反正只要我找到了两个能够满足题目要求的组合就可以了，所以，算法的实现如下：\n\nvar twoSum = function (nums, target) {\n  if (nums.length < 2) {\n    return;\n  }\n  for (let i = 0; i < nums.length - 1; i++) {\n    for (let j = i + 1; j < nums.length; j++) {\n      if (nums[i] + nums[j] === target) {\n        return [i, j];\n      }\n    }\n  }\n};\n\n\n可以看到，朴素法的时间复杂度是O(n²)，因为没有用到额外的空间，所以空间复杂度为O(1)。\n\n\n# 哈希法\n\n这题能够使用哈希表进行解答的人一定是动过脑筋的人。\n\n首先遍历是肯定少不了的，在遍历的时候，我们既然知道当前的数字，也知道总和，那我们我们可以算出差值，如果这个差值在数组中存在，那么就可以得到结果，如果不存在，继续尝试。\n\n怎么样快速的检索一个东西是否存在，根据我们之前学过的理论，哈希表能够在O(1)的时间内检索，平衡二叉树和二分查找能够在O(log n)的时间内检索，二分查找肯定是搞不定的，二分查找必须要在有序的条件下才能使用，如果用平衡二叉树，我们还要根据其值的大小建立树，不仅非常麻烦，复杂度还不如哈希表，显然这题，用哈希表才比较符合场景。\n\nvar twoSum = function (nums, target) {\n  if (nums.length < 2) {\n    return;\n  }\n  // 根据值建立哈希映射\n  const map = Object.create(null);\n  nums.forEach((num, idx) => {\n    map[num] = idx;\n  });\n  for (let i = 0; i < nums.length; i++) {\n    let a = nums[i];\n    let b = target - a;\n    let otherIdx = map[b];\n    // 存在并且不是自己，自己跟自己肯定不行\n    if (typeof otherIdx !== "undefined" && otherIdx !== i) {\n      return [i, otherIdx];\n    }\n  }\n};\n\n\n建立哈希的时间复杂度是O(N)，空间复杂度是O(N)；\n\n循环查找的时间复杂度是O(N)；\n\n最终得时间复杂度是 2*O(N)，省略系数，得O(N)，空间复杂度是O(N)。',normalizedContent:'# 两数之和\n\n给定一个整数数组 nums  和一个整数目标值 target，请你在该数组中找出和为目标值 target 的那两个整数，并返回它们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n\n你可以按任意顺序返回答案。\n\n这应该是绝大部分人人生中的第一道 leetcode 题吧\n\n\n# 朴素法\n\n朴素法的思路和选择排序的思路差不多，反正只要我找到了两个能够满足题目要求的组合就可以了，所以，算法的实现如下：\n\nvar twosum = function (nums, target) {\n  if (nums.length < 2) {\n    return;\n  }\n  for (let i = 0; i < nums.length - 1; i++) {\n    for (let j = i + 1; j < nums.length; j++) {\n      if (nums[i] + nums[j] === target) {\n        return [i, j];\n      }\n    }\n  }\n};\n\n\n可以看到，朴素法的时间复杂度是o(n²)，因为没有用到额外的空间，所以空间复杂度为o(1)。\n\n\n# 哈希法\n\n这题能够使用哈希表进行解答的人一定是动过脑筋的人。\n\n首先遍历是肯定少不了的，在遍历的时候，我们既然知道当前的数字，也知道总和，那我们我们可以算出差值，如果这个差值在数组中存在，那么就可以得到结果，如果不存在，继续尝试。\n\n怎么样快速的检索一个东西是否存在，根据我们之前学过的理论，哈希表能够在o(1)的时间内检索，平衡二叉树和二分查找能够在o(log n)的时间内检索，二分查找肯定是搞不定的，二分查找必须要在有序的条件下才能使用，如果用平衡二叉树，我们还要根据其值的大小建立树，不仅非常麻烦，复杂度还不如哈希表，显然这题，用哈希表才比较符合场景。\n\nvar twosum = function (nums, target) {\n  if (nums.length < 2) {\n    return;\n  }\n  // 根据值建立哈希映射\n  const map = object.create(null);\n  nums.foreach((num, idx) => {\n    map[num] = idx;\n  });\n  for (let i = 0; i < nums.length; i++) {\n    let a = nums[i];\n    let b = target - a;\n    let otheridx = map[b];\n    // 存在并且不是自己，自己跟自己肯定不行\n    if (typeof otheridx !== "undefined" && otheridx !== i) {\n      return [i, otheridx];\n    }\n  }\n};\n\n\n建立哈希的时间复杂度是o(n)，空间复杂度是o(n)；\n\n循环查找的时间复杂度是o(n)；\n\n最终得时间复杂度是 2*o(n)，省略系数，得o(n)，空间复杂度是o(n)。',charsets:{cjk:!0}},{title:"深度优先搜索",frontmatter:{},regularPath:"/data-structure/graph/dfs.html",relativePath:"data-structure/graph/dfs.md",key:"v-9751b882",path:"/data-structure/graph/dfs.html",headers:[{level:2,title:"深度优先搜索",slug:"深度优先搜索",normalizedTitle:"深度优先搜索",charIndex:2},{level:3,title:"DFS 的标准范式",slug:"dfs-的标准范式",normalizedTitle:"dfs 的标准范式",charIndex:245},{level:3,title:"DFS 的应用",slug:"dfs-的应用",normalizedTitle:"dfs 的应用",charIndex:650}],headersStr:"深度优先搜索 DFS 的标准范式 DFS 的应用",content:'# 深度优先搜索\n\n深度优先搜索算法（英语：Depth-First-Search，简称 DFS）是一种用于遍历或搜索树或图的算法。其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个结点只能访问一次.\n\n比如下图展示的就是一个使用 DFS 遍历二叉树的过程：\n\n\n\n对于图的遍历来说，不管采用DFS还是BFS(Breadth First Search，简称 BFS)，都是可以的。\n\n注意事项\n\n必须在某些特定的情况下，比较BFS还是DFS两者的遍历效果才有意义。\n\n\n# DFS 的标准范式\n\nDFS每次都是在先按照特定的规则（比如从第一个邻接点处理到第 N 个邻接点），每遍历一个节点，将当前节点标记为已遍历，若不能再继续向下处理，则向上回溯，继续处理这个交叉路口的下一个分支，重复这个过程，直到所有的节点都被处理，则遍历完成。\n\nDFS 的伪代码实现如下：\n\nfunction DFS(v, visited) {\n  visited[v] = true;\n  for(v 的每个邻接点 w ) {\n    if(!visited[w]) {\n      DFS(w, visited);\n    }\n  }\n}\n\n\n为什么需要一个标记呢，因为图的关系是四通八达的，如果没有标记的话，就好比人迷失了方向，遍历将无法找到退出的出口，会出现最大堆栈调用的错误或死循环。一般我们这个标记的遍历会考虑使用哈希表，但是有些时候使用数组也可以，主要取决于你的图采用什么样的表示方法。\n\n\n# DFS 的应用\n\n# 拍平数组（flat）\n\n这题几乎是各大中小厂面试题的常客了。\n\n假设有这样的数组： [1,[2,3,[[4]]],[5],[[[[[6],7,8]]],9], 10]，请将其展平为[1,2,3,4,5,6,7,8,9,10]。\n\n主要有 3 种方法对数组进行拍平。\n\n首先是最朴素的算法，将数组toString，然后将其中的[和,]替换掉，然后再将数组转换回数字类型，这个算法有一定的局限性，但是在你实在想不起来怎么样用DFS处理这个问题的时候，也可以使用。\n\n为什么说这个方法有局限性呢，因为你toString注定了已知数据的类型必须是一样的，无法记录特值，并且如果数据源里面包含[或]，这个办法就歇菜，并且这个方法是无法指定拍平多少层的。\n\n/**\n * 拍平数组\n * @param {number[]} arr\n */\nfunction flat(arr) {\n  return arr\n    .toString()\n    .replace(/\\[|\\]/g, "")\n    .split(",")\n    .map((ele) => {\n      return Number.parseInt(ele);\n    });\n}\n\n\n说完了花里胡哨的操作，然后还是回到本质的东西，使用DFS拍平数组，并且支持拍平深度。\n\n/**\n * 拍平数组\n * @param {any[]} arr 源数据\n * @param {number} depth 指定拍平深度\n * @param {number} curDepth 当前的深度\n */\nfunction flat(arr/*,*depth = Infinity, curDepth = 1*/) {\n  const results = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (Array.isArray(arr[i]) /*&& curDepth < depth*/) {\n      results.push(...flat(arr[i]/*, depth, curDepth + 1)*/);\n    } else {\n      results.push(arr[i]);\n    }\n  }\n  return results;\n}\n\n\n上述使用的是push的方式flat。\n\n在有些时候，如果你写的过快，面试官还会问你有没有别更好的方法，稍微好一点儿的方法是使用reduce，如下：\n\n/**\n * 拍平数组\n * @param {any[]} arr\n * @returns\n */\nfunction flat(arr) {\n  return arr.reduce((preVal, curVal) => {\n    return Array.isArray(curVal)\n      ? preVal.concat(flat(curVal))\n      : preVal.concat(curVal);\n  }, []);\n}\n\n\n思维方式和上面的DFS一致，但是写法更简洁，需要注意的是，在reduce的时候，一定要提供默认参数[]。\n\n# 深拷贝对象\n\n在深拷贝的时候为了防止循环引用，把已经拷贝过的对象和新生成的对象映射加入到哈希表中去，并且递归拷贝的时候，要带上这个哈希表递归。需要注意一点就是，拷贝过程中，一旦新生成的对象产生，就需要建立映射，而不是，等拷贝完成再建立映射，否则就无法区分当前对象是否已经被拷贝了，出现最大调用堆栈报错。\n\n注意，在此处我实现的深拷贝并没有完整考虑所有的情况，如果对深拷贝感兴趣的同学，请移步 lodash 的源码参考其实现。\n\n/**\n * 使用深度优先深拷贝对象\n * @param {Array<any> | object} obj\n * @param { Map<Array<any> | object, Array<any> | object> } map\n * @returns\n */\nfunction deepClone(obj, map = new Map()) {\n  // 如果已经拷贝过，则可以直接返回拷贝过的值，主要是为了防止循环引用\n  let cloneObj = map.get(obj);\n  if (typeof cloneObj !== "undefined") {\n    return cloneObj;\n  }\n  // 初始化拷贝的对象\n  cloneObj = Array.isArray(obj) ? [] : {};\n  // 建立已经拷贝的引用，不能再开始拷贝属性了再建立拷贝引用，否则将会导致递归最大调用栈的问题发生\n  map.set(obj, cloneObj);\n  // 对拷贝对象挨个赋值\n  for (let prop in obj) {\n    // 遇到对象，则递归拷贝\n    if (obj[prop] instanceof Object) {\n      cloneObj[prop] = deepClone(obj[prop], map);\n      // 拷贝完成后，还要将其加入引用Map中去\n      map.set(obj[prop], cloneObj[obj]);\n    } else {\n      cloneObj[prop] = obj[prop];\n    }\n  }\n  return cloneObj;\n}\n\n\n# 迷宫问题\n\n这是华为的一道机考题。\n\n定义一个二维数组 N*M ，如 5 × 5 数组下所示：\n\n[\n  [0, 1, 0, 0, 0],\n  [0, 1, 1, 1, 0],\n  [0, 0, 0, 0, 0],\n  [0, 1, 1, 1, 0],\n  [0, 0, 0, 1, 0],\n];\n\n\n它表示一个迷宫，其中的 1 表示墙壁，0 表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的路线。入口点为[0,0],既第一格是可以走的路。\n\n输入两个整数，分别表示二维数组的行数，列数。再输入相应的数组，其中的 1 表示墙壁，0 表示可以走的路。数据保证有唯一解,不考虑有多解的情况，即迷宫只有一条通道。\n\n/**\n * 寻找迷宫的出路\n * @param {number[][]} matrix\n * @param {number} startX\n * @param {number} startY\n * @param {boolean[][]} visited\n */\nfunction findSolution(matrix, startX, startY, distX, distY, visited) {\n  // 如果遇到边界，或者当前节点已经被处理过，此路不通\n  if (!isEdge(matrix, startX, startY) || visited[startX][startY]) {\n    return [];\n  }\n  // 将当前节点标记为已处理\n  visited[startX][startY] = true;\n  // 如果遇到障碍物，此路不通\n  if (matrix[startX][startY] === 1) {\n    return [];\n  }\n  // 定义当前节点\n  let point = [startX, startY];\n  // 如果已经找到了出口\n  if (startX === distX && startY === distY) {\n    return [point];\n  }\n  let viaLeft = [],\n    viaRight = [],\n    viaTop = [],\n    viaBottom = [];\n  // 向左处理路径\n  if (isEdge(matrix, startX - 1, startY) && !visited[startX - 1][startY]) {\n    viaLeft = findSolution(matrix, startX - 1, startY, distX, distY, visited);\n  }\n  // 向右处理路径\n  if (isEdge(matrix, startX + 1, startY) && !visited[startX + 1][startY]) {\n    viaRight = findSolution(matrix, startX + 1, startY, distX, distY, visited);\n  }\n  // 向下处理路径\n  if (isEdge(matrix, startX, startY + 1) && !visited[startX][startY + 1]) {\n    viaBottom = findSolution(matrix, startX, startY + 1, distX, distY, visited);\n  }\n  // 向上处理路径\n  if (isEdge(matrix, startX, startY - 1) && !visited[startX][startY - 1]) {\n    viaTop = findSolution(matrix, startX, startY - 1, distX, distY, visited);\n  }\n  // 从有用的路径中选择一个返回\n  if (viaLeft.length) {\n    return [point, ...viaLeft];\n  } else if (viaRight.length) {\n    return [point, ...viaRight];\n  } else if (viaBottom.length) {\n    return [point, ...viaBottom];\n  } else if (viaTop.length) {\n    return [point, ...viaTop];\n  } else {\n    return [];\n  }\n}\n\n/**\n * 是否是边界\n * @param {number[][]} matrix\n * @param {number} x\n * @param {number} y\n */\nfunction isEdge(matrix, x, y) {\n  return Array.isArray(matrix[x]) && typeof matrix[x][y] !== "undefined";\n}\n\n/**\n * 从一个矩阵的左上角走到右下角\n * @param {number[][]} matrix\n */\nfunction findPath(matrix, distX, distY) {\n  // 生成一个标记数组，用于标记当前节点已处理\n  const visited = matrix.map((row) => {\n    return row.map(() => false);\n  });\n  const steps = findSolution(matrix, 0, 0, distX, distY, visited);\n  return steps;\n}\n\n\n关于 DFS 还有很多有趣的问题，我暂时就先为大家介绍这几种常见的用法，欢迎大家补充。',normalizedContent:'# 深度优先搜索\n\n深度优先搜索算法（英语：depth-first-search，简称 dfs）是一种用于遍历或搜索树或图的算法。其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个结点只能访问一次.\n\n比如下图展示的就是一个使用 dfs 遍历二叉树的过程：\n\n\n\n对于图的遍历来说，不管采用dfs还是bfs(breadth first search，简称 bfs)，都是可以的。\n\n注意事项\n\n必须在某些特定的情况下，比较bfs还是dfs两者的遍历效果才有意义。\n\n\n# dfs 的标准范式\n\ndfs每次都是在先按照特定的规则（比如从第一个邻接点处理到第 n 个邻接点），每遍历一个节点，将当前节点标记为已遍历，若不能再继续向下处理，则向上回溯，继续处理这个交叉路口的下一个分支，重复这个过程，直到所有的节点都被处理，则遍历完成。\n\ndfs 的伪代码实现如下：\n\nfunction dfs(v, visited) {\n  visited[v] = true;\n  for(v 的每个邻接点 w ) {\n    if(!visited[w]) {\n      dfs(w, visited);\n    }\n  }\n}\n\n\n为什么需要一个标记呢，因为图的关系是四通八达的，如果没有标记的话，就好比人迷失了方向，遍历将无法找到退出的出口，会出现最大堆栈调用的错误或死循环。一般我们这个标记的遍历会考虑使用哈希表，但是有些时候使用数组也可以，主要取决于你的图采用什么样的表示方法。\n\n\n# dfs 的应用\n\n# 拍平数组（flat）\n\n这题几乎是各大中小厂面试题的常客了。\n\n假设有这样的数组： [1,[2,3,[[4]]],[5],[[[[[6],7,8]]],9], 10]，请将其展平为[1,2,3,4,5,6,7,8,9,10]。\n\n主要有 3 种方法对数组进行拍平。\n\n首先是最朴素的算法，将数组tostring，然后将其中的[和,]替换掉，然后再将数组转换回数字类型，这个算法有一定的局限性，但是在你实在想不起来怎么样用dfs处理这个问题的时候，也可以使用。\n\n为什么说这个方法有局限性呢，因为你tostring注定了已知数据的类型必须是一样的，无法记录特值，并且如果数据源里面包含[或]，这个办法就歇菜，并且这个方法是无法指定拍平多少层的。\n\n/**\n * 拍平数组\n * @param {number[]} arr\n */\nfunction flat(arr) {\n  return arr\n    .tostring()\n    .replace(/\\[|\\]/g, "")\n    .split(",")\n    .map((ele) => {\n      return number.parseint(ele);\n    });\n}\n\n\n说完了花里胡哨的操作，然后还是回到本质的东西，使用dfs拍平数组，并且支持拍平深度。\n\n/**\n * 拍平数组\n * @param {any[]} arr 源数据\n * @param {number} depth 指定拍平深度\n * @param {number} curdepth 当前的深度\n */\nfunction flat(arr/*,*depth = infinity, curdepth = 1*/) {\n  const results = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (array.isarray(arr[i]) /*&& curdepth < depth*/) {\n      results.push(...flat(arr[i]/*, depth, curdepth + 1)*/);\n    } else {\n      results.push(arr[i]);\n    }\n  }\n  return results;\n}\n\n\n上述使用的是push的方式flat。\n\n在有些时候，如果你写的过快，面试官还会问你有没有别更好的方法，稍微好一点儿的方法是使用reduce，如下：\n\n/**\n * 拍平数组\n * @param {any[]} arr\n * @returns\n */\nfunction flat(arr) {\n  return arr.reduce((preval, curval) => {\n    return array.isarray(curval)\n      ? preval.concat(flat(curval))\n      : preval.concat(curval);\n  }, []);\n}\n\n\n思维方式和上面的dfs一致，但是写法更简洁，需要注意的是，在reduce的时候，一定要提供默认参数[]。\n\n# 深拷贝对象\n\n在深拷贝的时候为了防止循环引用，把已经拷贝过的对象和新生成的对象映射加入到哈希表中去，并且递归拷贝的时候，要带上这个哈希表递归。需要注意一点就是，拷贝过程中，一旦新生成的对象产生，就需要建立映射，而不是，等拷贝完成再建立映射，否则就无法区分当前对象是否已经被拷贝了，出现最大调用堆栈报错。\n\n注意，在此处我实现的深拷贝并没有完整考虑所有的情况，如果对深拷贝感兴趣的同学，请移步 lodash 的源码参考其实现。\n\n/**\n * 使用深度优先深拷贝对象\n * @param {array<any> | object} obj\n * @param { map<array<any> | object, array<any> | object> } map\n * @returns\n */\nfunction deepclone(obj, map = new map()) {\n  // 如果已经拷贝过，则可以直接返回拷贝过的值，主要是为了防止循环引用\n  let cloneobj = map.get(obj);\n  if (typeof cloneobj !== "undefined") {\n    return cloneobj;\n  }\n  // 初始化拷贝的对象\n  cloneobj = array.isarray(obj) ? [] : {};\n  // 建立已经拷贝的引用，不能再开始拷贝属性了再建立拷贝引用，否则将会导致递归最大调用栈的问题发生\n  map.set(obj, cloneobj);\n  // 对拷贝对象挨个赋值\n  for (let prop in obj) {\n    // 遇到对象，则递归拷贝\n    if (obj[prop] instanceof object) {\n      cloneobj[prop] = deepclone(obj[prop], map);\n      // 拷贝完成后，还要将其加入引用map中去\n      map.set(obj[prop], cloneobj[obj]);\n    } else {\n      cloneobj[prop] = obj[prop];\n    }\n  }\n  return cloneobj;\n}\n\n\n# 迷宫问题\n\n这是华为的一道机考题。\n\n定义一个二维数组 n*m ，如 5 × 5 数组下所示：\n\n[\n  [0, 1, 0, 0, 0],\n  [0, 1, 1, 1, 0],\n  [0, 0, 0, 0, 0],\n  [0, 1, 1, 1, 0],\n  [0, 0, 0, 1, 0],\n];\n\n\n它表示一个迷宫，其中的 1 表示墙壁，0 表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的路线。入口点为[0,0],既第一格是可以走的路。\n\n输入两个整数，分别表示二维数组的行数，列数。再输入相应的数组，其中的 1 表示墙壁，0 表示可以走的路。数据保证有唯一解,不考虑有多解的情况，即迷宫只有一条通道。\n\n/**\n * 寻找迷宫的出路\n * @param {number[][]} matrix\n * @param {number} startx\n * @param {number} starty\n * @param {boolean[][]} visited\n */\nfunction findsolution(matrix, startx, starty, distx, disty, visited) {\n  // 如果遇到边界，或者当前节点已经被处理过，此路不通\n  if (!isedge(matrix, startx, starty) || visited[startx][starty]) {\n    return [];\n  }\n  // 将当前节点标记为已处理\n  visited[startx][starty] = true;\n  // 如果遇到障碍物，此路不通\n  if (matrix[startx][starty] === 1) {\n    return [];\n  }\n  // 定义当前节点\n  let point = [startx, starty];\n  // 如果已经找到了出口\n  if (startx === distx && starty === disty) {\n    return [point];\n  }\n  let vialeft = [],\n    viaright = [],\n    viatop = [],\n    viabottom = [];\n  // 向左处理路径\n  if (isedge(matrix, startx - 1, starty) && !visited[startx - 1][starty]) {\n    vialeft = findsolution(matrix, startx - 1, starty, distx, disty, visited);\n  }\n  // 向右处理路径\n  if (isedge(matrix, startx + 1, starty) && !visited[startx + 1][starty]) {\n    viaright = findsolution(matrix, startx + 1, starty, distx, disty, visited);\n  }\n  // 向下处理路径\n  if (isedge(matrix, startx, starty + 1) && !visited[startx][starty + 1]) {\n    viabottom = findsolution(matrix, startx, starty + 1, distx, disty, visited);\n  }\n  // 向上处理路径\n  if (isedge(matrix, startx, starty - 1) && !visited[startx][starty - 1]) {\n    viatop = findsolution(matrix, startx, starty - 1, distx, disty, visited);\n  }\n  // 从有用的路径中选择一个返回\n  if (vialeft.length) {\n    return [point, ...vialeft];\n  } else if (viaright.length) {\n    return [point, ...viaright];\n  } else if (viabottom.length) {\n    return [point, ...viabottom];\n  } else if (viatop.length) {\n    return [point, ...viatop];\n  } else {\n    return [];\n  }\n}\n\n/**\n * 是否是边界\n * @param {number[][]} matrix\n * @param {number} x\n * @param {number} y\n */\nfunction isedge(matrix, x, y) {\n  return array.isarray(matrix[x]) && typeof matrix[x][y] !== "undefined";\n}\n\n/**\n * 从一个矩阵的左上角走到右下角\n * @param {number[][]} matrix\n */\nfunction findpath(matrix, distx, disty) {\n  // 生成一个标记数组，用于标记当前节点已处理\n  const visited = matrix.map((row) => {\n    return row.map(() => false);\n  });\n  const steps = findsolution(matrix, 0, 0, distx, disty, visited);\n  return steps;\n}\n\n\n关于 dfs 还有很多有趣的问题，我暂时就先为大家介绍这几种常见的用法，欢迎大家补充。',charsets:{cjk:!0}},{title:"算法和数据结构专题",frontmatter:{title:"算法和数据结构专题"},regularPath:"/data-structure/",relativePath:"data-structure/index.md",key:"v-65084bb4",path:"/data-structure/",headers:[{level:2,title:"1.算法好坏的衡量依据——复杂度",slug:"_1-算法好坏的衡量依据-复杂度",normalizedTitle:"1.算法好坏的衡量依据——复杂度",charIndex:2},{level:3,title:"时间复杂度",slug:"时间复杂度",normalizedTitle:"时间复杂度",charIndex:23},{level:3,title:"空间复杂度",slug:"空间复杂度",normalizedTitle:"空间复杂度",charIndex:1789},{level:2,title:"2.实际开发中常见的数据结构和算法",slug:"_2-实际开发中常见的数据结构和算法",normalizedTitle:"2.实际开发中常见的数据结构和算法",charIndex:2057}],headersStr:"1.算法好坏的衡量依据——复杂度 时间复杂度 空间复杂度 2.实际开发中常见的数据结构和算法",content:"# 1.算法好坏的衡量依据——复杂度\n\n\n# 时间复杂度\n\n算法的时间复杂度T(n)，是一个用于度量一个算法的运算时间的一个描述，本质是一个函数，根据这个函数能在不用具体的测试数据来测试的情况下，粗略地估计算法的执行效率，换句话讲时间复杂度表示的只是代码执行时间随数据规模增长的变化趋势。\n\n举个大家非常熟悉的冒泡排序的一个例子：\n\n/**\n * 对数组进行冒泡排序\n * @param {Array<number>} arr 需要进行排序的数组\n */\nfunction bubbleSort(arr) {\n  let temp = null;\n  // 外层循环变量i 用于控制参与排序数据的规模\n  for (let i = arr.length - 1; i >= 0; i--) {\n    // 定义标记，用于判断本轮是否参与交换\n    let flag = true;\n    // 内层循环用于把最“重”的元素下沉至非有序片段的最后一位\n    for (let j = 0; j < i; j++) {\n      // 注意冒泡排序是两两相邻的比较\n      if (arr[j] > arr[j + 1]) {\n        temp = arr[j];\n        arr[j] = arr[j + 1];\n        arr[j + 1] = temp;\n        // 如果交换了元素，还需要设置标记，若数组已经有序，可以提前终止排序，提升性能\n        flag = false;\n      }\n    }\n    // 如果说没有参与交换，则认为数组已经有序，则可以完成排序\n    if (flag) {\n      break;\n    }\n  }\n}\n\n\n举一个极端的例子，假设现在输入的数据是从大到小的，大家现在可以看到，上面的算法是对数据进行升序排序。\n\n对于程序里面的赋值，算术运算，位运算，数组寻址等操作，这是编程语言提供给我们的能力，我们已经无法提升它的速度了，所以这些操作都是常数级的操作。\n\n第一步: 把 0 这个位置上的数据挪动到最后一个位置上，需要进行 2*N 次交换\n\n第二步: 把 0 这个位置上的数据挪动到倒数第二个位置上，需要进行 2*N-1 次交换\n\n重复以上操作，\n\n第 N-1 步：把 0 这个位置交换到 1 这个位置上，需要执行 2 次操作\n\n根据高中学过的等差数列前 N 项和公式，我们可以得到一个粗略的结果为 a*N²+b*N+c，当 N 在特别大的时候，b*N + c 其实对结果的影响不大。\n\n而我们并不需要一个精确的次数，只是想得到一个描述其复杂度规模的指标，因此，系数 a 也可以省略。\n\n所以，最终我们推导出来，冒泡排序的算法时间复杂度是O(N²);\n\n下面是我在网上随便找的一个常见的时间复杂度的对比图，大家看一下，对不同的时间复杂度的规模有一个认识。\n\n\n\n所有常数级的操作都是O(1)，正常的一轮循环是O(n)，像二分查找，平衡二叉树，跳跃链表的查找，堆的插入，每次运算之后都会使得数据的规模减半，这类操作的复杂度是O(log n)，(至于这个O(log n)是怎么算出来的，举个例子：比如 2 的 10 次方是 1024，那么我们对 1024 进行减半得到一个新的值，然后再对这个新值减半，重复这个操作，到得到的数不能再继续减半为止，最多只能操作 10 次，因此求得二分查找的时间复杂度是O(log n))，像冒泡排序，选择排序,插入排序这类简单排序算法，都是简单的两个循环相叠加，这类操作的时间复杂度是O(n²)，比如像堆排序，归并排序，快速排序这类复杂的排序算法，由于里面有运用分治或折半查找思想的优化，这类排序算法的时间复杂度为 O(n*log n)。\n\n正常我们的实际开发中很少遇到O(n³)及以上复杂度的操作，如果出现了此类情况，请一定要检查一下自己的思维方式是否错误。因为我曾经刚毕业的时候，在有一次算股票的成交均线的时候，就把一个O(n)级别的复杂度计算写成了O(n的n次方)级别的计算，这种错误一旦在数据量比较大的时候，会严重影响用户使用的体验，如果用户无法忍受，怒删程序，会造成公司的活跃用户损失，那有可能会影响到你的绩效了哟。\n\n\n# 空间复杂度\n\n算法的空间复杂度 S(n)定义为该算法所耗费的存储空间，它也是问题规模 n 的函数，也是描述代码占用空间随数据规模增长的变化趋势。\n\n比如我们定义一个变量，这时计算机就会为我们开辟一个内存空间用于存储它。跟时间复杂度的计算类似，因为我们不同语言特定的数据类型占用的内存大小是明确的，我们是无法优化的。\n\n就比如，我们做一次哈希映射，我们需要建立起一个对这个数据的关系，这种操作就是O(1)，比如你需要将一个数组的数据都做一份映射，归并排序时需要额外开辟一个数组用于归并数据，那么此时我们的空间复杂度就是O(N)。\n\n\n# 2.实际开发中常见的数据结构和算法\n\n * 数组\n * 链表\n * 字符串\n * 队列\n * 栈\n * 堆（优先队列）\n * 树\n * 图\n * 哈希表\n * 排序\n * 查找",normalizedContent:"# 1.算法好坏的衡量依据——复杂度\n\n\n# 时间复杂度\n\n算法的时间复杂度t(n)，是一个用于度量一个算法的运算时间的一个描述，本质是一个函数，根据这个函数能在不用具体的测试数据来测试的情况下，粗略地估计算法的执行效率，换句话讲时间复杂度表示的只是代码执行时间随数据规模增长的变化趋势。\n\n举个大家非常熟悉的冒泡排序的一个例子：\n\n/**\n * 对数组进行冒泡排序\n * @param {array<number>} arr 需要进行排序的数组\n */\nfunction bubblesort(arr) {\n  let temp = null;\n  // 外层循环变量i 用于控制参与排序数据的规模\n  for (let i = arr.length - 1; i >= 0; i--) {\n    // 定义标记，用于判断本轮是否参与交换\n    let flag = true;\n    // 内层循环用于把最“重”的元素下沉至非有序片段的最后一位\n    for (let j = 0; j < i; j++) {\n      // 注意冒泡排序是两两相邻的比较\n      if (arr[j] > arr[j + 1]) {\n        temp = arr[j];\n        arr[j] = arr[j + 1];\n        arr[j + 1] = temp;\n        // 如果交换了元素，还需要设置标记，若数组已经有序，可以提前终止排序，提升性能\n        flag = false;\n      }\n    }\n    // 如果说没有参与交换，则认为数组已经有序，则可以完成排序\n    if (flag) {\n      break;\n    }\n  }\n}\n\n\n举一个极端的例子，假设现在输入的数据是从大到小的，大家现在可以看到，上面的算法是对数据进行升序排序。\n\n对于程序里面的赋值，算术运算，位运算，数组寻址等操作，这是编程语言提供给我们的能力，我们已经无法提升它的速度了，所以这些操作都是常数级的操作。\n\n第一步: 把 0 这个位置上的数据挪动到最后一个位置上，需要进行 2*n 次交换\n\n第二步: 把 0 这个位置上的数据挪动到倒数第二个位置上，需要进行 2*n-1 次交换\n\n重复以上操作，\n\n第 n-1 步：把 0 这个位置交换到 1 这个位置上，需要执行 2 次操作\n\n根据高中学过的等差数列前 n 项和公式，我们可以得到一个粗略的结果为 a*n²+b*n+c，当 n 在特别大的时候，b*n + c 其实对结果的影响不大。\n\n而我们并不需要一个精确的次数，只是想得到一个描述其复杂度规模的指标，因此，系数 a 也可以省略。\n\n所以，最终我们推导出来，冒泡排序的算法时间复杂度是o(n²);\n\n下面是我在网上随便找的一个常见的时间复杂度的对比图，大家看一下，对不同的时间复杂度的规模有一个认识。\n\n\n\n所有常数级的操作都是o(1)，正常的一轮循环是o(n)，像二分查找，平衡二叉树，跳跃链表的查找，堆的插入，每次运算之后都会使得数据的规模减半，这类操作的复杂度是o(log n)，(至于这个o(log n)是怎么算出来的，举个例子：比如 2 的 10 次方是 1024，那么我们对 1024 进行减半得到一个新的值，然后再对这个新值减半，重复这个操作，到得到的数不能再继续减半为止，最多只能操作 10 次，因此求得二分查找的时间复杂度是o(log n))，像冒泡排序，选择排序,插入排序这类简单排序算法，都是简单的两个循环相叠加，这类操作的时间复杂度是o(n²)，比如像堆排序，归并排序，快速排序这类复杂的排序算法，由于里面有运用分治或折半查找思想的优化，这类排序算法的时间复杂度为 o(n*log n)。\n\n正常我们的实际开发中很少遇到o(n³)及以上复杂度的操作，如果出现了此类情况，请一定要检查一下自己的思维方式是否错误。因为我曾经刚毕业的时候，在有一次算股票的成交均线的时候，就把一个o(n)级别的复杂度计算写成了o(n的n次方)级别的计算，这种错误一旦在数据量比较大的时候，会严重影响用户使用的体验，如果用户无法忍受，怒删程序，会造成公司的活跃用户损失，那有可能会影响到你的绩效了哟。\n\n\n# 空间复杂度\n\n算法的空间复杂度 s(n)定义为该算法所耗费的存储空间，它也是问题规模 n 的函数，也是描述代码占用空间随数据规模增长的变化趋势。\n\n比如我们定义一个变量，这时计算机就会为我们开辟一个内存空间用于存储它。跟时间复杂度的计算类似，因为我们不同语言特定的数据类型占用的内存大小是明确的，我们是无法优化的。\n\n就比如，我们做一次哈希映射，我们需要建立起一个对这个数据的关系，这种操作就是o(1)，比如你需要将一个数组的数据都做一份映射，归并排序时需要额外开辟一个数组用于归并数据，那么此时我们的空间复杂度就是o(n)。\n\n\n# 2.实际开发中常见的数据结构和算法\n\n * 数组\n * 链表\n * 字符串\n * 队列\n * 栈\n * 堆（优先队列）\n * 树\n * 图\n * 哈希表\n * 排序\n * 查找",charsets:{cjk:!0}},{title:"堆",frontmatter:{},regularPath:"/data-structure/heap/desc.html",relativePath:"data-structure/heap/desc.md",key:"v-2ef6a612",path:"/data-structure/heap/desc.html",headers:[{level:2,title:"堆",slug:"堆",normalizedTitle:"堆",charIndex:2},{level:2,title:"堆的操作",slug:"堆的操作",normalizedTitle:"堆的操作",charIndex:279},{level:3,title:"插入",slug:"插入",normalizedTitle:"插入",charIndex:302},{level:3,title:"调整和删除",slug:"调整和删除",normalizedTitle:"调整和删除",charIndex:611},{level:3,title:"构建",slug:"构建",normalizedTitle:"构建",charIndex:1227},{level:3,title:"带哨兵的堆的操作",slug:"带哨兵的堆的操作",normalizedTitle:"带哨兵的堆的操作",charIndex:3674},{level:2,title:"进阶",slug:"进阶",normalizedTitle:"进阶",charIndex:6236},{level:2,title:"应用场景",slug:"应用场景",normalizedTitle:"应用场景",charIndex:9786}],headersStr:"堆 堆的操作 插入 调整和删除 构建 带哨兵的堆的操作 进阶 应用场景",content:'# 堆\n\n堆(Heap)是一类特殊的数据结构，是最高效的优先级队列。\n\n堆通常是一个可以被看做一棵树的数组对象(即用数组实现的树).\n\n堆总是一棵完全二叉树。\n\n从堆的根节点到任意叶节点画路径，总能得到从小到大（最小堆）的顺序或者从大到小（最大堆）的顺序。\n\n由于堆是一颗完全二叉树，对于一个索引为 k 的节点，那么其左右儿子的索引则分别为 2k+1 和 2k+2（若存在）。\n\n最大堆\n\n最小堆\n\n不满足完全二叉树，所以不是堆（值为19的节点缺失右儿子）\n\n不是堆，堆一定满足从根节点画任意路径到一节点，其节点值总满足从大到小或者从小到大的顺序。\n\n\n# 堆的操作\n\n以下，我们就以最大堆为例，阐述堆的插入、删除、调整。\n\n\n# 插入\n\n因为堆中元素需要满足有序性，我们插入的值不一定就是这条路径中最小的，那么我们需要为元素找到合适的位置。 根据前文提到的堆的性质，我们可以确定当前节点的父节点所在位置是 i/2（对于 JavaScript 语言来说，需要向下取整）\n\n假设我们现在要在这个堆中插入 98。\n\n整个过程如下图所示：\n\n首先扩展堆的容量 沿着父节点一直比较，直到找到合适的位置，这一过程中 i 一直不断的往上提，因为每次我们每次都是 i/2，这是一个类似二分查找的操作。 最终找到了合适的位置 完成插入 对于了解过排序算法的同学，对于这个过程是否感觉有些似曾相识？没错，这个过程就是直接插入排序。\n\n\n# 调整和删除\n\n为什么我们会把调整和删除一起讨论呢，主要是为了避免编写重复的代码。\n\n假设，我们删除堆的一个元素，那么我们把数组下标为 0 的元素提出来，因为这个元素空出来了，相当于我们要把后面的元素往前挪动。但是 这儿可不能像数组那节说的那样挪动，否则会丢失顺序性。我们只能把最后一个元素交换到下标 0 的这个位置上来。然后重新调整堆。\n\n好了，首先，我们先把看看当前节点(假设当前节点所在位置为 i)有没有左儿子(有的话，即2*i<length)，如果有，那我们看看当前节点是否有右儿子(有的话，即2*i+1<length)，若有的话，我们从两个儿子中取一个比较大的节点跟当前节点的值比较，如果大的儿子节点值大于 i 节点，那么把儿子节点较大的那个值拷贝到位置 i 上。并且把这个值放到大的儿子节点的那个位置上，然后 i 指向儿子节点较大者的那个索引；如果父节点比儿子节点的值还大，说明本来就保持了这个有序性，则可以不用变动。\n\n因为我们刚才的操作其实是把影响下沉给了儿子节点，儿子节点现在不满足路径的顺序性质了，那么我们重复刚才的操作，直到调整到叶节点为止。\n\n这一系列的过程，大概如下图所示：\n\n首先准备删除 然后将节点值拷贝到根节点，然后把已经拷贝好值的节点拿掉； 因为子节点比跟节点的值大，所以，将子节点向上提，parent 指针指向被影响的儿子节点的位置 重复这个过程，直到把这个影响传递到叶节点，则完成调整。\n\n\n# 构建\n\n之前我们已经理解了怎么样以根节点 p 把一个被破坏了的堆还原。如何把一个数组调整成堆呢，我们首先知道一个数组的最后一个节点的，那么根据这个节点，可以推算出它的父节点。我们首先把它们俩调整成堆。接着，我们把这个父节点的左边兄弟节点调整成堆，然后再把父节点的左边的兄弟左边的兄弟节点调整成堆，重复这个操作，直到调整到数组的第 1 个节点，就可以使得我们整个数组调整为堆。这个过程是个线性的时间复杂度，具体推导，读者可自行查阅资料，本节不做具体分析。\n\n上述过程的算法实现如下：\n\n/*\n * 最大堆\n */\nclass Heap {\n  /**\n   * 定义一个存储数据的内存空间\n   */\n  _data = [];\n\n  get size() {\n    return this._data.length;\n  }\n\n  constructor(...nums) {\n    // 初始化数组元素\n    nums.forEach((v) => {\n      this._data.push(v);\n    });\n    this.buildHeap();\n  }\n\n  /**\n   * 获取堆顶的元素\n   */\n  getTop() {\n    return this._data[0];\n  }\n\n  /**\n   * 按断堆是否是空\n   */\n  isEmpty() {\n    return this._data.length === 0;\n  }\n\n  /**\n   * 向堆中插入一个合法值\n   * @param {number} val\n   */\n  insert(val) {\n    // 如果当前数组没有元素，直接插入即可\n    if (this._data.length === 0) {\n      this._data[0] = val;\n    } else {\n      // 让i指向当前新位置，因为没有哨兵的关系，最后一个元素是length - 1，所以新位置就是length\n      let i = this.size;\n      while (val > this._data[Math.floor(i / 2)] && i > 0) {\n        this._data[i] = this._data[Math.floor(i / 2)];\n        i = Math.floor(i / 2);\n      }\n      // 在合适的位置插入新的值\n      this._data[i] = val;\n    }\n  }\n\n  /**\n   * 获取堆中的最大元素\n   * @returns\n   */\n  deleteMax() {\n    if (this.isEmpty()) {\n      console.warn("can not delete max from empty heap");\n      return;\n    }\n    // 取出堆顶的元素\n    let minVal = this._data[0];\n    // 把堆最后的元素交换到堆顶去\n    let temp = this._data[this.size - 1];\n    this._data[0] = temp;\n    // JavaScript语言需要进行这一步，让数组的规模缩小，释放空间\n    this._data.length--;\n    // 将数组调整成堆\n    this.percDown(0);\n    return minVal;\n  }\n\n  /**\n   * 下滤：将堆中以堆data[p]为根的子堆调整为最小堆\n   * @param {number} p 根节点索引\n   */\n  percDown(p) {\n    // 如果当前堆元素小于1个，就不执行调整操作\n    if (this.size <= 1) {\n      return;\n    }\n    let parent, child;\n    /* 取出根结点存放的值 */\n    let temp = this._data[p];\n    for (parent = p; parent * 2 < this.size; parent = child) {\n      child = parent * 2;\n      /* 如果右儿子存在 child指向左右子结点的较大者 */\n      if (child + 1 < this.size && this._data[child + 1] > this._data[child]) {\n        child++;\n      }\n      /* 找到了合适位置 */\n      if (temp >= this._data[child]) {\n        break;\n      } else {\n        /* 下滤X */\n        this._data[parent] = this._data[child];\n      }\n    }\n    this._data[parent] = temp;\n  }\n\n  /**\n   * 构建最大堆\n   */\n  buildHeap() {\n    /* 调整data中的元素，使满足最小堆的有序性  */\n    /* 这里所有size个元素已经存在data[]中 */\n    /* 从最后一个结点的父节点开始，到根结点1 */\n    for (let i = Math.floor((this.size - 1) / 2); i >= 0; i--) {\n      this.percDown(i);\n    }\n  }\n}\n\n\n\n# 带哨兵的堆的操作\n\n# 哨兵\n\n在查找时，通过设置哨兵能够省去对一些边界条件的判断，减少比较次数，有利于提高程序的效率和健壮性。\n\n# 堆带哨兵和不带哨兵的区别\n\n * 不能在堆中插入大于哨兵的元素，否则哨兵失去意义还会给程序带来问题。\n * 对于索引为 k 的节点，左右儿子的下标索引也有变化，分别为 2k 和 2k+1(若存在)\n * 在堆的插入操作时，不需要判断 i 的下标大于 0，因为哨兵自带判断依据，也不需要判断堆内元素为空的情况。\n * 在删除堆的最大值之后，需要将最后一个节点的元素拷贝到下标为 1 的位置，而不是 0\n * 在下滤时，外层循环终止条件发生变化，需要取到length，原为[0，length-1]。\n * 在构建堆时，是从length/2开始到 1 结束\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n\n/*\n * 最大堆\n */\nclass Heap {\n  /**\n   * 定义哨兵的最大值，所有插入堆的元素都必须比这个值小\n   */\n  #MAX_VAL = 1000;\n\n  /**\n   * 定义一个存储数据的内存空间\n   */\n  #data = [];\n\n  /**\n   * 当前堆的元素个数\n   */\n  #size = 0;\n\n  constructor(...nums) {\n    // 设置哨兵\n    this.#data[0] = this.#MAX_VAL;\n    // 初始化数组元素\n    nums.forEach((v, i) => {\n      this.#data[i + 1] = v;\n      this.#size++;\n    });\n    this.buildHeap();\n  }\n\n  isEmpty() {\n    return this.#size === 0;\n  }\n\n  /**\n   * 向堆中插入一个合法值\n   * @param {number} val\n   */\n  insert(val) {\n    if (this.MAX_VAL <= val) {\n      throw `can not insert val bigger than ${this.#MAX_VAL}`;\n    }\n    // 堆的容量扩充1\n    this.#size++;\n    // 让i指向当前新位置\n    let i = this.#size;\n    // 因为有哨兵的关系，不需要添加约束条件 i > 0\n    while (this.#data[Math.floor(i / 2)] < val) {\n      this.#data[i] = this.#data[Math.floor(i / 2)];\n      i = Math.floor(i / 2);\n    }\n    this.#data[i] = val;\n  }\n\n  deleteMax() {\n    if (this.isEmpty()) {\n      console.warn("can not delete max from empty heap");\n      return;\n    }\n    // 取出堆顶的元素\n    let maxVal = this.#data[1];\n    // 取出堆最后一个元素 取出来之后则把堆的规模减小\n    let temp = this.#data[this.#size--];\n    this.#data[1] = temp;\n    this.percDown(1);\n    // JavaScript语言需要进行这一步，让数组的规模缩小，释放空间\n    this.#data.length--;\n    return maxVal;\n  }\n\n  /* 下滤：将堆中以堆data[p]为根的子堆调整为最大堆 */\n  percDown(p) {\n    let parent, child;\n    let temp = this.#data[p]; /* 取出根结点存放的值 */\n    // 虽然不带哨兵，但是因为外界传递的索引是预期的，所以还是只能按不带索引的计算方式计算\n    for (parent = p; parent * 2 <= this.#size; parent = child) {\n      child = parent * 2;\n      if (child != this.#size && this.#data[child] < this.#data[child + 1]) {\n        child++; /* child指向左右子结点的较大者 */\n      }\n      /* 找到了合适位置 */\n      if (temp >= this.#data[child]) {\n        break;\n      } else {\n        /* 下滤X */\n        this.#data[parent] = this.#data[child];\n      }\n    }\n    this.#data[parent] = temp;\n  }\n\n  /*----------- 建造最大堆 -----------*/\n  buildHeap() {\n    /* 调整data中的元素，使满足最大堆的有序性  */\n    /* 这里所有size个元素已经存在data[]中 */\n    /* 从最后一个结点的父节点开始，到根结点1 */\n    for (let i = Math.floor(this.#size / 2); i > 0; i--) {\n      this.percDown(i);\n    }\n  }\n}\n\n\n\n# 进阶\n\n在上述堆的代码实现中，我们可以看到，想控制一个堆的性质（最大堆还是最小堆），仅仅改变一下判断依据就好了。\n\n那么，上述的代码就可以进行抽象，我们将它封装成一个通用的堆，移植到成熟的代码库中去，这样就可以避免每次都复制粘贴代码了。\n\n/*\n * 抽象堆\n */\nclass Heap {\n  /**\n   * 定义一个存储数据的内存空间\n   */\n  _data = [];\n\n  /**\n   * 比较函数\n   */\n  _compare = null;\n\n  get size() {\n    return this._data.length;\n  }\n\n  _selfCompare = (compareVal, currentVal) => {\n    if (typeof this._compare !== "function") {\n      throw `cannot compare without a compare function`;\n    }\n    return this._compare(compareVal, currentVal);\n  };\n\n  /**\n   * 设置比较函数\n   * @param {(compareVal, currentVal) => boolean} compareFunc\n   */\n  setCompare(compareFunc) {\n    this._compare = compareFunc;\n  }\n\n  /**\n   * 获取堆顶的元素\n   */\n  getTop() {\n    return this._data[0];\n  }\n\n  /**\n   * 按断堆是否是空\n   */\n  isEmpty() {\n    return this._data.length === 0;\n  }\n\n  /**\n   * 向堆中插入一个合法值\n   * @param {number} val\n   */\n  insert(val) {\n    // 如果当前数组没有元素，直接插入即可\n    if (this._data.length === 0) {\n      this._data[0] = val;\n    } else {\n      // 让i指向当前新位置，因为没有哨兵的关系，最后一个元素是length - 1，所以新位置就是length\n      let i = this.size;\n      while (this._selfCompare(val, this._data[Math.floor(i / 2)]) && i > 0) {\n        this._data[i] = this._data[Math.floor(i / 2)];\n        i = Math.floor(i / 2);\n      }\n      // 在合适的位置插入新的值\n      this._data[i] = val;\n    }\n  }\n\n  /**\n   * 获取堆中的最值元素\n   * @returns\n   */\n  deleteTop() {\n    if (this.isEmpty()) {\n      console.warn("can not delete max from empty heap");\n      return;\n    }\n    // 取出堆顶的元素\n    let minVal = this._data[0];\n    let temp = this._data[this.size - 1];\n    this._data[0] = temp;\n    // JavaScript语言需要进行这一步，让数组的规模缩小，释放空间\n    this._data.length--;\n    // 如果当前堆里面还存在元素的话，将\n    this.percDown(0);\n    return minVal;\n  }\n\n  /**\n   * 下滤：将堆中以堆data[p]为根的子堆调整为最小堆\n   * @param {number} p 根节点索引\n   */\n  percDown(p) {\n    // 如果当前堆元素小于1个，就不执行调整操作\n    if (this.size <= 1) {\n      return;\n    }\n    let parent, child;\n    /* 取出根结点存放的值 */\n    let temp = this._data[p];\n    for (parent = p; parent * 2 < this.size; parent = child) {\n      child = parent * 2;\n      if (\n        child + 1 < this.size &&\n        this._selfCompare(this._data[child + 1], this._data[child])\n      ) {\n        child++; /* child指向左右子结点的较大者 最大堆 较小者 最小堆 */\n      }\n      /* 找到了合适位置 */\n      // 注意这儿一定要取得等号 temp <= this.#data[child] 最小堆 temp >= this.#data[child] 最大堆\n      if (this._selfCompare(temp, this._data[child])) {\n        break;\n      } else {\n        /* 下滤X */\n        this._data[parent] = this._data[child];\n      }\n    }\n    this._data[parent] = temp;\n  }\n\n  /**\n   * 构建最小堆\n   */\n  buildHeap() {\n    /* 调整data中的元素，使满足最小堆的有序性  */\n    /* 这里所有size个元素已经存在data[]中 */\n    /* 从最后一个结点的父节点开始，到根结点1 */\n    for (let i = Math.floor((this.size - 1) / 2); i >= 0; i--) {\n      this.percDown(i);\n    }\n  }\n}\n\nclass MinHeap extends Heap {\n  constructor() {\n    super();\n    this.setCompare((compareVal, currentVal) => {\n      return compareVal - currentVal <= 0;\n    });\n  }\n\n  getMin() {\n    return this.getTop();\n  }\n\n  deleteMin() {\n    return this.deleteTop();\n  }\n}\n\nclass MaxHeap extends Heap {\n  constructor() {\n    super();\n    this.setCompare((compareVal, currentVal) => {\n      return compareVal - currentVal >= 0;\n    });\n  }\n\n  getMax() {\n    return this.getTop();\n  }\n\n  deleteMax() {\n    return this.deleteTop();\n  }\n}\n\n\n如果堆的元素是个对象，我们可以手动设置比较函数，也可以达到相应的效果\n\n比如：\n\n// 假设我们将这个抽象堆封装至代码库中了\nimport { Heap } from "awesome-frontend-code";\nconst maxHeap = new Heap();\n// 现在需要根据学生的成绩建堆。\nmaxHeap.setCompare((compareStudent, currentStudent) => {\n  return compareStudent.score - currentStudent.score >= 0;\n});\n\n\n\n# 应用场景\n\n堆的应用场景比较模糊，但是我根据自己的实际体验和与朋友们的交流大致总结了 2 个场景：\n\n * 想让序列保持有序，但是又不想直接使用排序算法。\n * 动态的数据，无法每次数据改变都进行排序，但是最终却需要有序的序列。',normalizedContent:'# 堆\n\n堆(heap)是一类特殊的数据结构，是最高效的优先级队列。\n\n堆通常是一个可以被看做一棵树的数组对象(即用数组实现的树).\n\n堆总是一棵完全二叉树。\n\n从堆的根节点到任意叶节点画路径，总能得到从小到大（最小堆）的顺序或者从大到小（最大堆）的顺序。\n\n由于堆是一颗完全二叉树，对于一个索引为 k 的节点，那么其左右儿子的索引则分别为 2k+1 和 2k+2（若存在）。\n\n最大堆\n\n最小堆\n\n不满足完全二叉树，所以不是堆（值为19的节点缺失右儿子）\n\n不是堆，堆一定满足从根节点画任意路径到一节点，其节点值总满足从大到小或者从小到大的顺序。\n\n\n# 堆的操作\n\n以下，我们就以最大堆为例，阐述堆的插入、删除、调整。\n\n\n# 插入\n\n因为堆中元素需要满足有序性，我们插入的值不一定就是这条路径中最小的，那么我们需要为元素找到合适的位置。 根据前文提到的堆的性质，我们可以确定当前节点的父节点所在位置是 i/2（对于 javascript 语言来说，需要向下取整）\n\n假设我们现在要在这个堆中插入 98。\n\n整个过程如下图所示：\n\n首先扩展堆的容量 沿着父节点一直比较，直到找到合适的位置，这一过程中 i 一直不断的往上提，因为每次我们每次都是 i/2，这是一个类似二分查找的操作。 最终找到了合适的位置 完成插入 对于了解过排序算法的同学，对于这个过程是否感觉有些似曾相识？没错，这个过程就是直接插入排序。\n\n\n# 调整和删除\n\n为什么我们会把调整和删除一起讨论呢，主要是为了避免编写重复的代码。\n\n假设，我们删除堆的一个元素，那么我们把数组下标为 0 的元素提出来，因为这个元素空出来了，相当于我们要把后面的元素往前挪动。但是 这儿可不能像数组那节说的那样挪动，否则会丢失顺序性。我们只能把最后一个元素交换到下标 0 的这个位置上来。然后重新调整堆。\n\n好了，首先，我们先把看看当前节点(假设当前节点所在位置为 i)有没有左儿子(有的话，即2*i<length)，如果有，那我们看看当前节点是否有右儿子(有的话，即2*i+1<length)，若有的话，我们从两个儿子中取一个比较大的节点跟当前节点的值比较，如果大的儿子节点值大于 i 节点，那么把儿子节点较大的那个值拷贝到位置 i 上。并且把这个值放到大的儿子节点的那个位置上，然后 i 指向儿子节点较大者的那个索引；如果父节点比儿子节点的值还大，说明本来就保持了这个有序性，则可以不用变动。\n\n因为我们刚才的操作其实是把影响下沉给了儿子节点，儿子节点现在不满足路径的顺序性质了，那么我们重复刚才的操作，直到调整到叶节点为止。\n\n这一系列的过程，大概如下图所示：\n\n首先准备删除 然后将节点值拷贝到根节点，然后把已经拷贝好值的节点拿掉； 因为子节点比跟节点的值大，所以，将子节点向上提，parent 指针指向被影响的儿子节点的位置 重复这个过程，直到把这个影响传递到叶节点，则完成调整。\n\n\n# 构建\n\n之前我们已经理解了怎么样以根节点 p 把一个被破坏了的堆还原。如何把一个数组调整成堆呢，我们首先知道一个数组的最后一个节点的，那么根据这个节点，可以推算出它的父节点。我们首先把它们俩调整成堆。接着，我们把这个父节点的左边兄弟节点调整成堆，然后再把父节点的左边的兄弟左边的兄弟节点调整成堆，重复这个操作，直到调整到数组的第 1 个节点，就可以使得我们整个数组调整为堆。这个过程是个线性的时间复杂度，具体推导，读者可自行查阅资料，本节不做具体分析。\n\n上述过程的算法实现如下：\n\n/*\n * 最大堆\n */\nclass heap {\n  /**\n   * 定义一个存储数据的内存空间\n   */\n  _data = [];\n\n  get size() {\n    return this._data.length;\n  }\n\n  constructor(...nums) {\n    // 初始化数组元素\n    nums.foreach((v) => {\n      this._data.push(v);\n    });\n    this.buildheap();\n  }\n\n  /**\n   * 获取堆顶的元素\n   */\n  gettop() {\n    return this._data[0];\n  }\n\n  /**\n   * 按断堆是否是空\n   */\n  isempty() {\n    return this._data.length === 0;\n  }\n\n  /**\n   * 向堆中插入一个合法值\n   * @param {number} val\n   */\n  insert(val) {\n    // 如果当前数组没有元素，直接插入即可\n    if (this._data.length === 0) {\n      this._data[0] = val;\n    } else {\n      // 让i指向当前新位置，因为没有哨兵的关系，最后一个元素是length - 1，所以新位置就是length\n      let i = this.size;\n      while (val > this._data[math.floor(i / 2)] && i > 0) {\n        this._data[i] = this._data[math.floor(i / 2)];\n        i = math.floor(i / 2);\n      }\n      // 在合适的位置插入新的值\n      this._data[i] = val;\n    }\n  }\n\n  /**\n   * 获取堆中的最大元素\n   * @returns\n   */\n  deletemax() {\n    if (this.isempty()) {\n      console.warn("can not delete max from empty heap");\n      return;\n    }\n    // 取出堆顶的元素\n    let minval = this._data[0];\n    // 把堆最后的元素交换到堆顶去\n    let temp = this._data[this.size - 1];\n    this._data[0] = temp;\n    // javascript语言需要进行这一步，让数组的规模缩小，释放空间\n    this._data.length--;\n    // 将数组调整成堆\n    this.percdown(0);\n    return minval;\n  }\n\n  /**\n   * 下滤：将堆中以堆data[p]为根的子堆调整为最小堆\n   * @param {number} p 根节点索引\n   */\n  percdown(p) {\n    // 如果当前堆元素小于1个，就不执行调整操作\n    if (this.size <= 1) {\n      return;\n    }\n    let parent, child;\n    /* 取出根结点存放的值 */\n    let temp = this._data[p];\n    for (parent = p; parent * 2 < this.size; parent = child) {\n      child = parent * 2;\n      /* 如果右儿子存在 child指向左右子结点的较大者 */\n      if (child + 1 < this.size && this._data[child + 1] > this._data[child]) {\n        child++;\n      }\n      /* 找到了合适位置 */\n      if (temp >= this._data[child]) {\n        break;\n      } else {\n        /* 下滤x */\n        this._data[parent] = this._data[child];\n      }\n    }\n    this._data[parent] = temp;\n  }\n\n  /**\n   * 构建最大堆\n   */\n  buildheap() {\n    /* 调整data中的元素，使满足最小堆的有序性  */\n    /* 这里所有size个元素已经存在data[]中 */\n    /* 从最后一个结点的父节点开始，到根结点1 */\n    for (let i = math.floor((this.size - 1) / 2); i >= 0; i--) {\n      this.percdown(i);\n    }\n  }\n}\n\n\n\n# 带哨兵的堆的操作\n\n# 哨兵\n\n在查找时，通过设置哨兵能够省去对一些边界条件的判断，减少比较次数，有利于提高程序的效率和健壮性。\n\n# 堆带哨兵和不带哨兵的区别\n\n * 不能在堆中插入大于哨兵的元素，否则哨兵失去意义还会给程序带来问题。\n * 对于索引为 k 的节点，左右儿子的下标索引也有变化，分别为 2k 和 2k+1(若存在)\n * 在堆的插入操作时，不需要判断 i 的下标大于 0，因为哨兵自带判断依据，也不需要判断堆内元素为空的情况。\n * 在删除堆的最大值之后，需要将最后一个节点的元素拷贝到下标为 1 的位置，而不是 0\n * 在下滤时，外层循环终止条件发生变化，需要取到length，原为[0，length-1]。\n * 在构建堆时，是从length/2开始到 1 结束\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n\n/*\n * 最大堆\n */\nclass heap {\n  /**\n   * 定义哨兵的最大值，所有插入堆的元素都必须比这个值小\n   */\n  #max_val = 1000;\n\n  /**\n   * 定义一个存储数据的内存空间\n   */\n  #data = [];\n\n  /**\n   * 当前堆的元素个数\n   */\n  #size = 0;\n\n  constructor(...nums) {\n    // 设置哨兵\n    this.#data[0] = this.#max_val;\n    // 初始化数组元素\n    nums.foreach((v, i) => {\n      this.#data[i + 1] = v;\n      this.#size++;\n    });\n    this.buildheap();\n  }\n\n  isempty() {\n    return this.#size === 0;\n  }\n\n  /**\n   * 向堆中插入一个合法值\n   * @param {number} val\n   */\n  insert(val) {\n    if (this.max_val <= val) {\n      throw `can not insert val bigger than ${this.#max_val}`;\n    }\n    // 堆的容量扩充1\n    this.#size++;\n    // 让i指向当前新位置\n    let i = this.#size;\n    // 因为有哨兵的关系，不需要添加约束条件 i > 0\n    while (this.#data[math.floor(i / 2)] < val) {\n      this.#data[i] = this.#data[math.floor(i / 2)];\n      i = math.floor(i / 2);\n    }\n    this.#data[i] = val;\n  }\n\n  deletemax() {\n    if (this.isempty()) {\n      console.warn("can not delete max from empty heap");\n      return;\n    }\n    // 取出堆顶的元素\n    let maxval = this.#data[1];\n    // 取出堆最后一个元素 取出来之后则把堆的规模减小\n    let temp = this.#data[this.#size--];\n    this.#data[1] = temp;\n    this.percdown(1);\n    // javascript语言需要进行这一步，让数组的规模缩小，释放空间\n    this.#data.length--;\n    return maxval;\n  }\n\n  /* 下滤：将堆中以堆data[p]为根的子堆调整为最大堆 */\n  percdown(p) {\n    let parent, child;\n    let temp = this.#data[p]; /* 取出根结点存放的值 */\n    // 虽然不带哨兵，但是因为外界传递的索引是预期的，所以还是只能按不带索引的计算方式计算\n    for (parent = p; parent * 2 <= this.#size; parent = child) {\n      child = parent * 2;\n      if (child != this.#size && this.#data[child] < this.#data[child + 1]) {\n        child++; /* child指向左右子结点的较大者 */\n      }\n      /* 找到了合适位置 */\n      if (temp >= this.#data[child]) {\n        break;\n      } else {\n        /* 下滤x */\n        this.#data[parent] = this.#data[child];\n      }\n    }\n    this.#data[parent] = temp;\n  }\n\n  /*----------- 建造最大堆 -----------*/\n  buildheap() {\n    /* 调整data中的元素，使满足最大堆的有序性  */\n    /* 这里所有size个元素已经存在data[]中 */\n    /* 从最后一个结点的父节点开始，到根结点1 */\n    for (let i = math.floor(this.#size / 2); i > 0; i--) {\n      this.percdown(i);\n    }\n  }\n}\n\n\n\n# 进阶\n\n在上述堆的代码实现中，我们可以看到，想控制一个堆的性质（最大堆还是最小堆），仅仅改变一下判断依据就好了。\n\n那么，上述的代码就可以进行抽象，我们将它封装成一个通用的堆，移植到成熟的代码库中去，这样就可以避免每次都复制粘贴代码了。\n\n/*\n * 抽象堆\n */\nclass heap {\n  /**\n   * 定义一个存储数据的内存空间\n   */\n  _data = [];\n\n  /**\n   * 比较函数\n   */\n  _compare = null;\n\n  get size() {\n    return this._data.length;\n  }\n\n  _selfcompare = (compareval, currentval) => {\n    if (typeof this._compare !== "function") {\n      throw `cannot compare without a compare function`;\n    }\n    return this._compare(compareval, currentval);\n  };\n\n  /**\n   * 设置比较函数\n   * @param {(compareval, currentval) => boolean} comparefunc\n   */\n  setcompare(comparefunc) {\n    this._compare = comparefunc;\n  }\n\n  /**\n   * 获取堆顶的元素\n   */\n  gettop() {\n    return this._data[0];\n  }\n\n  /**\n   * 按断堆是否是空\n   */\n  isempty() {\n    return this._data.length === 0;\n  }\n\n  /**\n   * 向堆中插入一个合法值\n   * @param {number} val\n   */\n  insert(val) {\n    // 如果当前数组没有元素，直接插入即可\n    if (this._data.length === 0) {\n      this._data[0] = val;\n    } else {\n      // 让i指向当前新位置，因为没有哨兵的关系，最后一个元素是length - 1，所以新位置就是length\n      let i = this.size;\n      while (this._selfcompare(val, this._data[math.floor(i / 2)]) && i > 0) {\n        this._data[i] = this._data[math.floor(i / 2)];\n        i = math.floor(i / 2);\n      }\n      // 在合适的位置插入新的值\n      this._data[i] = val;\n    }\n  }\n\n  /**\n   * 获取堆中的最值元素\n   * @returns\n   */\n  deletetop() {\n    if (this.isempty()) {\n      console.warn("can not delete max from empty heap");\n      return;\n    }\n    // 取出堆顶的元素\n    let minval = this._data[0];\n    let temp = this._data[this.size - 1];\n    this._data[0] = temp;\n    // javascript语言需要进行这一步，让数组的规模缩小，释放空间\n    this._data.length--;\n    // 如果当前堆里面还存在元素的话，将\n    this.percdown(0);\n    return minval;\n  }\n\n  /**\n   * 下滤：将堆中以堆data[p]为根的子堆调整为最小堆\n   * @param {number} p 根节点索引\n   */\n  percdown(p) {\n    // 如果当前堆元素小于1个，就不执行调整操作\n    if (this.size <= 1) {\n      return;\n    }\n    let parent, child;\n    /* 取出根结点存放的值 */\n    let temp = this._data[p];\n    for (parent = p; parent * 2 < this.size; parent = child) {\n      child = parent * 2;\n      if (\n        child + 1 < this.size &&\n        this._selfcompare(this._data[child + 1], this._data[child])\n      ) {\n        child++; /* child指向左右子结点的较大者 最大堆 较小者 最小堆 */\n      }\n      /* 找到了合适位置 */\n      // 注意这儿一定要取得等号 temp <= this.#data[child] 最小堆 temp >= this.#data[child] 最大堆\n      if (this._selfcompare(temp, this._data[child])) {\n        break;\n      } else {\n        /* 下滤x */\n        this._data[parent] = this._data[child];\n      }\n    }\n    this._data[parent] = temp;\n  }\n\n  /**\n   * 构建最小堆\n   */\n  buildheap() {\n    /* 调整data中的元素，使满足最小堆的有序性  */\n    /* 这里所有size个元素已经存在data[]中 */\n    /* 从最后一个结点的父节点开始，到根结点1 */\n    for (let i = math.floor((this.size - 1) / 2); i >= 0; i--) {\n      this.percdown(i);\n    }\n  }\n}\n\nclass minheap extends heap {\n  constructor() {\n    super();\n    this.setcompare((compareval, currentval) => {\n      return compareval - currentval <= 0;\n    });\n  }\n\n  getmin() {\n    return this.gettop();\n  }\n\n  deletemin() {\n    return this.deletetop();\n  }\n}\n\nclass maxheap extends heap {\n  constructor() {\n    super();\n    this.setcompare((compareval, currentval) => {\n      return compareval - currentval >= 0;\n    });\n  }\n\n  getmax() {\n    return this.gettop();\n  }\n\n  deletemax() {\n    return this.deletetop();\n  }\n}\n\n\n如果堆的元素是个对象，我们可以手动设置比较函数，也可以达到相应的效果\n\n比如：\n\n// 假设我们将这个抽象堆封装至代码库中了\nimport { heap } from "awesome-frontend-code";\nconst maxheap = new heap();\n// 现在需要根据学生的成绩建堆。\nmaxheap.setcompare((comparestudent, currentstudent) => {\n  return comparestudent.score - currentstudent.score >= 0;\n});\n\n\n\n# 应用场景\n\n堆的应用场景比较模糊，但是我根据自己的实际体验和与朋友们的交流大致总结了 2 个场景：\n\n * 想让序列保持有序，但是又不想直接使用排序算法。\n * 动态的数据，无法每次数据改变都进行排序，但是最终却需要有序的序列。',charsets:{cjk:!0}},{title:"前 K 个高频元素",frontmatter:{},regularPath:"/data-structure/heap/topKFrequent.html",relativePath:"data-structure/heap/topKFrequent.md",key:"v-3b24155e",path:"/data-structure/heap/topKFrequent.html",headers:[{level:2,title:"前 K 个高频元素",slug:"前-k-个高频元素",normalizedTitle:"前 k 个高频元素",charIndex:2},{level:3,title:"思路分析",slug:"思路分析",normalizedTitle:"思路分析",charIndex:299},{level:3,title:"算法实现",slug:"算法实现",normalizedTitle:"算法实现",charIndex:993}],headersStr:"前 K 个高频元素 思路分析 算法实现",content:'# 前 K 个高频元素\n\n给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。\n\n> 输入: nums = [1,1,1,2,2,3], k = 2 输出: [1,2]\n> \n> 输入: nums = [1], k = 1 输出: [1]\n\n * 1 <= nums.length <= 105\n * k 的取值范围是 [1, 数组中不相同的元素的个数]\n * 题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的\n\n注意：你所设计算法的时间复杂度 必须 优于 O(n*log n) ，其中 n 是数组大小。\n\n\n# 思路分析\n\n首先，题目要求出现频率，那么，我们自然会想到建立哈希表，来统计每个整数出现的次数，在这儿，至少会有个遍历，那么这儿的时间复杂度是 O(n)，空间复杂度 O(n);\n\n接下来就是比较关键的问题了，频率求出来了，我们要求 TOP K，有个问题就是最快的排序算法至少是O(n*log n)，所以通过排序求肯定是无法满足性能要求的。那么，在这种想有序，但是又不能排序的场景下，我们自然而然会想到堆，但是是采用最大堆还是最小堆呢，我们要取的是前面 K 个，堆的大小是比数组小的，那必须是最小堆，因为这样你才能知道当前元素是否应该入堆。\n\n假设当前堆的内容还没有达到 K，随便加入内容，如果达到了，要判断一下当前堆顶的元素是比当前元素大还是小，如果比当前元素小，说明当前元素才应该进去，堆顶的元素应该丢弃，否则保持堆不动。\n\n因为堆内的元素在最终输出的时候是能保证有序性的，所以说，我们就遍历这个记录次数的对象(最坏情况是每个元素都只出现一次)，因此外层循环是 O(N)，堆在插入的时候，建堆的操作是基于二分查找的，所以其时间复杂度是 O(logK)，因为最多 K 个元素，因此空间复杂度是O(K)，因为两个套在一起使用的，所以时间复杂度是 O(N*logK)。\n\n最后再将堆里面的内容全部输出，这儿需要牵涉到堆的调整，已知数组能够在线性的时间复杂度内调整成堆，那么这儿的时间复杂度是O(K);\n\n总的时间复杂度就是O(K) + O(N*logK)，去掉小的O(K)，时间复杂度是O(N*logK); 空间复杂度是: O(K)+O(N)，去掉小的O(K)，空间复杂度是O(N)。\n\n\n# 算法实现\n\n/*\n * 抽象堆\n */\nclass Heap {\n  /**\n   * 定义一个存储数据的内存空间\n   */\n  _data = [];\n\n  /**\n   * 比较函数\n   */\n  _compare = null;\n\n  get size() {\n    return this._data.length;\n  }\n\n  constructor(...nums) {\n    // 初始化数组元素\n    nums.forEach((v) => {\n      this._data.push(v);\n    });\n    this.buildHeap();\n  }\n\n  _selfCompare = (compareVal, currentVal) => {\n    if(typeof this._compare !== \'function\') {\n      throw `cannot compare without a compare function`;\n    }\n    return this._compare(compareVal, currentVal);\n  };\n\n  /**\n   * 设置比较函数\n   * @param {(compareVal, currentVal) => boolean} compareFunc\n   */\n  setCompare(compareFunc) {\n    this._compare = compareFunc;\n  }\n\n  /**\n   * 获取堆顶的元素\n   */\n  getTop() {\n    return this._data[0];\n  }\n\n  /**\n   * 按断堆是否是空\n   */\n  isEmpty() {\n    return this._data.length === 0;\n  }\n\n  /**\n   * 向堆中插入一个合法值\n   * @param {number} val\n   */\n  insert(val) {\n    // 如果当前数组没有元素，直接插入即可\n    if (this._data.length === 0) {\n      this._data[0] = val;\n    } else {\n      // 让i指向当前新位置，因为没有哨兵的关系，最后一个元素是length - 1，所以新位置就是length\n      let i = this.size;\n      while (this._selfCompare(val, this._data[Math.floor(i / 2)]) && i > 0) {\n        this._data[i] = this._data[Math.floor(i / 2)];\n        i = Math.floor(i / 2);\n      }\n      // 在合适的位置插入新的值\n      this._data[i] = val;\n    }\n  }\n\n  /**\n   * 获取堆中的最小元素\n   * @returns\n   */\n  deleteMin() {\n    if (this.isEmpty()) {\n      console.warn("can not delete max from empty heap");\n      return;\n    }\n    // 取出堆顶的元素\n    let minVal = this._data[0];\n    let temp = this._data[this.size - 1];\n    this._data[0] = temp;\n    // JavaScript语言需要进行这一步，让数组的规模缩小，释放空间\n    this._data.length--;\n    // 如果当前堆里面还存在元素的话，将\n    this.percDown(0);\n    return minVal;\n  }\n\n  /**\n   * 下滤：将堆中以堆data[p]为根的子堆调整为最小堆\n   * @param {number} p 根节点索引\n   */\n  percDown(p) {\n    // 如果当前堆元素小于1个，就不执行调整操作\n    if (this.size <= 1) {\n      return;\n    }\n    let parent, child;\n    /* 取出根结点存放的值 */\n    let temp = this._data[p];\n    for (parent = p; parent * 2 < this.size; parent = child) {\n      child = parent * 2;\n      if (\n        child + 1 < this.size &&\n        this._selfCompare(this._data[child + 1], this._data[child])\n      ) {\n        child++; /* child指向左右子结点的较大者 最大堆 较小者 最小堆 */\n      }\n      /* 找到了合适位置 */\n      // 注意这儿一定要取得等号 temp <= this.#data[child] 最小堆 temp >= this.#data[child] 最大堆\n      if (this._selfCompare(temp, this._data[child])) {\n        break;\n      } else {\n        /* 下滤X */\n        this._data[parent] = this._data[child];\n      }\n    }\n    this._data[parent] = temp;\n  }\n\n  /**\n   * 构建最小堆\n   */\n  buildHeap() {\n    /* 调整data中的元素，使满足最小堆的有序性  */\n    /* 这里所有size个元素已经存在data[]中 */\n    /* 从最后一个结点的父节点开始，到根结点1 */\n    for (let i = Math.floor(this.size / 2); i > 0; i--) {\n      this.percDown(i);\n    }\n  }\n}\n\n\n/**\n * 求TOP K个高频元素\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar topKFrequent = function (nums, k) {\n  const map = Object.create(null);\n  // 建立出现频率的哈希表\n  nums.forEach((num) => {\n    if (typeof map[num] === "undefined") {\n      map[num] = 1;\n    } else {\n      map[num]++;\n    }\n  });\n  // 将哈希表转成出现频率数组\n  let frequentNumbers = [];\n  Object.entries(map).forEach(([prop, value]) => {\n    frequentNumbers.push({\n      prop: Number.parseInt(prop),\n      value,\n    });\n  });\n  let minHeap = new Heap();\n  minHeap.setCompare((compareVal, currentVal) => {\n    return currentVal.frequent - compareVal.frequent >=0;\n  });\n  // 遍历频率建立哈希\n  frequentNumbers.forEach(({ prop, value: frequent }) => {\n    if (minHeap.size < k) {\n      minHeap.insert({\n        prop,\n        frequent,\n      });\n    } else {\n      // 获取堆顶的最小值\n      let { frequent: minFrequent } = minHeap.getTop();\n      // 如果堆顶的小，说明当前元素才应该进堆，堆顶元素应该丢弃\n      if (minFrequent < frequent) {\n        minHeap.deleteMin();\n        minHeap.insert({\n          prop,\n          frequent,\n        });\n      }\n    }\n  });\n  // 依次输出堆顶元素\n  let results = [];\n  while (!minHeap.isEmpty()) {\n    let { prop } = minHeap.deleteMin();\n    results.push(prop);\n  }\n  return results;\n};\n\n\n# 算法复杂度\n\n时间复杂度：O(N*logK);\n\n空间复杂度：O(N)',normalizedContent:'# 前 k 个高频元素\n\n给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。\n\n> 输入: nums = [1,1,1,2,2,3], k = 2 输出: [1,2]\n> \n> 输入: nums = [1], k = 1 输出: [1]\n\n * 1 <= nums.length <= 105\n * k 的取值范围是 [1, 数组中不相同的元素的个数]\n * 题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的\n\n注意：你所设计算法的时间复杂度 必须 优于 o(n*log n) ，其中 n 是数组大小。\n\n\n# 思路分析\n\n首先，题目要求出现频率，那么，我们自然会想到建立哈希表，来统计每个整数出现的次数，在这儿，至少会有个遍历，那么这儿的时间复杂度是 o(n)，空间复杂度 o(n);\n\n接下来就是比较关键的问题了，频率求出来了，我们要求 top k，有个问题就是最快的排序算法至少是o(n*log n)，所以通过排序求肯定是无法满足性能要求的。那么，在这种想有序，但是又不能排序的场景下，我们自然而然会想到堆，但是是采用最大堆还是最小堆呢，我们要取的是前面 k 个，堆的大小是比数组小的，那必须是最小堆，因为这样你才能知道当前元素是否应该入堆。\n\n假设当前堆的内容还没有达到 k，随便加入内容，如果达到了，要判断一下当前堆顶的元素是比当前元素大还是小，如果比当前元素小，说明当前元素才应该进去，堆顶的元素应该丢弃，否则保持堆不动。\n\n因为堆内的元素在最终输出的时候是能保证有序性的，所以说，我们就遍历这个记录次数的对象(最坏情况是每个元素都只出现一次)，因此外层循环是 o(n)，堆在插入的时候，建堆的操作是基于二分查找的，所以其时间复杂度是 o(logk)，因为最多 k 个元素，因此空间复杂度是o(k)，因为两个套在一起使用的，所以时间复杂度是 o(n*logk)。\n\n最后再将堆里面的内容全部输出，这儿需要牵涉到堆的调整，已知数组能够在线性的时间复杂度内调整成堆，那么这儿的时间复杂度是o(k);\n\n总的时间复杂度就是o(k) + o(n*logk)，去掉小的o(k)，时间复杂度是o(n*logk); 空间复杂度是: o(k)+o(n)，去掉小的o(k)，空间复杂度是o(n)。\n\n\n# 算法实现\n\n/*\n * 抽象堆\n */\nclass heap {\n  /**\n   * 定义一个存储数据的内存空间\n   */\n  _data = [];\n\n  /**\n   * 比较函数\n   */\n  _compare = null;\n\n  get size() {\n    return this._data.length;\n  }\n\n  constructor(...nums) {\n    // 初始化数组元素\n    nums.foreach((v) => {\n      this._data.push(v);\n    });\n    this.buildheap();\n  }\n\n  _selfcompare = (compareval, currentval) => {\n    if(typeof this._compare !== \'function\') {\n      throw `cannot compare without a compare function`;\n    }\n    return this._compare(compareval, currentval);\n  };\n\n  /**\n   * 设置比较函数\n   * @param {(compareval, currentval) => boolean} comparefunc\n   */\n  setcompare(comparefunc) {\n    this._compare = comparefunc;\n  }\n\n  /**\n   * 获取堆顶的元素\n   */\n  gettop() {\n    return this._data[0];\n  }\n\n  /**\n   * 按断堆是否是空\n   */\n  isempty() {\n    return this._data.length === 0;\n  }\n\n  /**\n   * 向堆中插入一个合法值\n   * @param {number} val\n   */\n  insert(val) {\n    // 如果当前数组没有元素，直接插入即可\n    if (this._data.length === 0) {\n      this._data[0] = val;\n    } else {\n      // 让i指向当前新位置，因为没有哨兵的关系，最后一个元素是length - 1，所以新位置就是length\n      let i = this.size;\n      while (this._selfcompare(val, this._data[math.floor(i / 2)]) && i > 0) {\n        this._data[i] = this._data[math.floor(i / 2)];\n        i = math.floor(i / 2);\n      }\n      // 在合适的位置插入新的值\n      this._data[i] = val;\n    }\n  }\n\n  /**\n   * 获取堆中的最小元素\n   * @returns\n   */\n  deletemin() {\n    if (this.isempty()) {\n      console.warn("can not delete max from empty heap");\n      return;\n    }\n    // 取出堆顶的元素\n    let minval = this._data[0];\n    let temp = this._data[this.size - 1];\n    this._data[0] = temp;\n    // javascript语言需要进行这一步，让数组的规模缩小，释放空间\n    this._data.length--;\n    // 如果当前堆里面还存在元素的话，将\n    this.percdown(0);\n    return minval;\n  }\n\n  /**\n   * 下滤：将堆中以堆data[p]为根的子堆调整为最小堆\n   * @param {number} p 根节点索引\n   */\n  percdown(p) {\n    // 如果当前堆元素小于1个，就不执行调整操作\n    if (this.size <= 1) {\n      return;\n    }\n    let parent, child;\n    /* 取出根结点存放的值 */\n    let temp = this._data[p];\n    for (parent = p; parent * 2 < this.size; parent = child) {\n      child = parent * 2;\n      if (\n        child + 1 < this.size &&\n        this._selfcompare(this._data[child + 1], this._data[child])\n      ) {\n        child++; /* child指向左右子结点的较大者 最大堆 较小者 最小堆 */\n      }\n      /* 找到了合适位置 */\n      // 注意这儿一定要取得等号 temp <= this.#data[child] 最小堆 temp >= this.#data[child] 最大堆\n      if (this._selfcompare(temp, this._data[child])) {\n        break;\n      } else {\n        /* 下滤x */\n        this._data[parent] = this._data[child];\n      }\n    }\n    this._data[parent] = temp;\n  }\n\n  /**\n   * 构建最小堆\n   */\n  buildheap() {\n    /* 调整data中的元素，使满足最小堆的有序性  */\n    /* 这里所有size个元素已经存在data[]中 */\n    /* 从最后一个结点的父节点开始，到根结点1 */\n    for (let i = math.floor(this.size / 2); i > 0; i--) {\n      this.percdown(i);\n    }\n  }\n}\n\n\n/**\n * 求top k个高频元素\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar topkfrequent = function (nums, k) {\n  const map = object.create(null);\n  // 建立出现频率的哈希表\n  nums.foreach((num) => {\n    if (typeof map[num] === "undefined") {\n      map[num] = 1;\n    } else {\n      map[num]++;\n    }\n  });\n  // 将哈希表转成出现频率数组\n  let frequentnumbers = [];\n  object.entries(map).foreach(([prop, value]) => {\n    frequentnumbers.push({\n      prop: number.parseint(prop),\n      value,\n    });\n  });\n  let minheap = new heap();\n  minheap.setcompare((compareval, currentval) => {\n    return currentval.frequent - compareval.frequent >=0;\n  });\n  // 遍历频率建立哈希\n  frequentnumbers.foreach(({ prop, value: frequent }) => {\n    if (minheap.size < k) {\n      minheap.insert({\n        prop,\n        frequent,\n      });\n    } else {\n      // 获取堆顶的最小值\n      let { frequent: minfrequent } = minheap.gettop();\n      // 如果堆顶的小，说明当前元素才应该进堆，堆顶元素应该丢弃\n      if (minfrequent < frequent) {\n        minheap.deletemin();\n        minheap.insert({\n          prop,\n          frequent,\n        });\n      }\n    }\n  });\n  // 依次输出堆顶元素\n  let results = [];\n  while (!minheap.isempty()) {\n    let { prop } = minheap.deletemin();\n    results.push(prop);\n  }\n  return results;\n};\n\n\n# 算法复杂度\n\n时间复杂度：o(n*logk);\n\n空间复杂度：o(n)',charsets:{cjk:!0}},{title:"概念",frontmatter:{},regularPath:"/data-structure/list/array.html",relativePath:"data-structure/list/array.md",key:"v-7f8a6bd5",path:"/data-structure/list/array.html",headers:[{level:2,title:"概念",slug:"概念",normalizedTitle:"概念",charIndex:2},{level:2,title:"数组的遍历",slug:"数组的遍历",normalizedTitle:"数组的遍历",charIndex:352},{level:2,title:"数组的插入",slug:"数组的插入",normalizedTitle:"数组的插入",charIndex:516},{level:2,title:"数组的删除",slug:"数组的删除",normalizedTitle:"数组的删除",charIndex:1393},{level:2,title:"数组的扩容",slug:"数组的扩容",normalizedTitle:"数组的扩容",charIndex:2091},{level:2,title:"数组的应用",slug:"数组的应用",normalizedTitle:"数组的应用",charIndex:2509}],headersStr:"概念 数组的遍历 数组的插入 数组的删除 数组的扩容 数组的应用",content:'# 概念\n\n数组（Array）是有序的元素序列。 若将有限个类型相同的变量的集合命名，那么这个名称为数组名。组成数组的各个变量称为数组的分量，也称为数组的元素，有时也称为下标变量。用于区分数组的各个元素的数字编号称为下标。\n\n数组是在程序设计中，为了处理方便， 把具有相同类型的若干元素按有序的形式组织起来的一种形式。 这些有序排列的同类数据元素的集合称为数组。（以上内容 copy 自百度百科）\n\nJS 数组和其它强类型（如Java，C#等）语言的数组有非常大的区别。\n\n注意事项\n\nJS 的数组是可以自动增长的，而Java和C#的数组在初始化的时候就必须要申明其长度。\n\n因为这个差异，有些时候我们在讨论时间复杂度的时候就存在一定的差异，不过，我们通常还是以通用的数据结构定义为准进行讨论。\n\n\n# 数组的遍历\n\n时间复杂度为O(n)\n\n/**\n * 遍历数组\n * @param {number[]} arr\n */\nfunction visitArray(arr) {\n  for (let i = 0; i < arr.length; i++) {\n    console.log(arr[i]);\n  }\n}\n\n\n\n# 数组的插入\n\n首先，我们需要将插入的位置从数组中找到，这个操作的平均时间复杂度为O(n)，然后我们将数组的长度增加 1，并且把目标位置到数组最后一个位置的元素都依次向后错一位（给新插入的数据腾出空间呀），我们需要把后面的元素依次往前面挪动一位，这个操作的平均复杂度为O(n)，总的时间复杂度为2*O(n),但是我们在讨论复杂度时，其描述的是算法的规模，因此我们需要省略这个系数，所以，数组删除的平均时间复杂度为O(n)。 平均时间复杂度O(n)\n\n/**\n * 像数组中插入一个值\n * @param {number[]} arr\n * @param {number} insertBefore 指定插入的位置在这个元素之后，如果找不到，则插在末尾\n * @param {number} val 待插入的值\n */\nfunction insert(arr, insertBefore, val) {\n  let targetIdx = -1;\n  let length = arr.length;\n  arr.length++;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[targetIdx] === insertBefore) {\n      targetIdx = i;\n      break;\n    }\n  }\n  if (targetIdx === -1) {\n    // 直接插在末尾\n    arr[length] = val;\n    // 这个地方不需要操作js的length，数组length自己会增加\n    return;\n  }\n  // 必须是从后往前错一位\n  for (let i = arr.length; i > targetIdx; i--) {\n    // 将前面的元素拷贝给后面的元素\n    arr[i] = arr[i - 1];\n  }\n  // 在留出的空位上插入新元素\n  arr[targetIdx] = val;\n}\n\n\n\n# 数组的删除\n\n首先，我们需要将待删除的元素从数组中找到，这个操作的平均时间复杂度为O(n)，然后我们将这个位置的元素从数组中拿掉，当前这个位置便空出来了，我们需要把后面的元素依次往前面挪动一位，这个操作的平均复杂度为O(n)，总的时间复杂度为2*O(n),但是我们在讨论复杂度时，其描述的是算法的规模，因此我们需要省略这个系数，所以，数组删除的平均时间复杂度为O(n)。\n\n/**\n * 从数组中删除指定的元素\n * @param {number[] } arr 数据源\n * @param {number} target 待删除的值\n */\nfunction remove(arr, target) {\n  let targetIdx = -1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[targetIdx] === target) {\n      targetIdx = i;\n      break;\n    }\n  }\n  if (targetIdx === -1) {\n    console.warn("the target element can not exist in arr");\n    return;\n  }\n  // 依次将后面的元素向前拷贝\n  for (let i = targetIdx; i < arr.length; i++) {\n    arr[targetIdx] = arr[targetIdx + 1];\n  }\n  // 数组的长度-1\n  arr.length--;\n}\n\n\n\n# 数组的扩容\n\n本节只为阐述原理，实际开发中并不需要这个步骤，这个操作的时间复杂度为O(N)\n\n/**\n * 将数组扩容\n * @param {number[]} arr\n */\nfunction expandArray(arr) {\n  const len = arr.length\n  // 糟粕语法，实际开发中不要使用, 假设扩容两倍\n  const newArr = new Array(2 * len);\n  for(let i = 0;i<newArr.length;i++) {\n    // 将旧的数组的元素拷贝置新的数组上去，同时给新申请的空间初始化0，直接使用length初始化，数组在使用forEach等方法遍历时会跳过空元素\n    const ele = i < arr.length ? arr[i] : 0;\n    newArr[i] = ele;\n  }\n  return newArr;\n}\n\n\n\n# 数组的应用\n\n略',normalizedContent:'# 概念\n\n数组（array）是有序的元素序列。 若将有限个类型相同的变量的集合命名，那么这个名称为数组名。组成数组的各个变量称为数组的分量，也称为数组的元素，有时也称为下标变量。用于区分数组的各个元素的数字编号称为下标。\n\n数组是在程序设计中，为了处理方便， 把具有相同类型的若干元素按有序的形式组织起来的一种形式。 这些有序排列的同类数据元素的集合称为数组。（以上内容 copy 自百度百科）\n\njs 数组和其它强类型（如java，c#等）语言的数组有非常大的区别。\n\n注意事项\n\njs 的数组是可以自动增长的，而java和c#的数组在初始化的时候就必须要申明其长度。\n\n因为这个差异，有些时候我们在讨论时间复杂度的时候就存在一定的差异，不过，我们通常还是以通用的数据结构定义为准进行讨论。\n\n\n# 数组的遍历\n\n时间复杂度为o(n)\n\n/**\n * 遍历数组\n * @param {number[]} arr\n */\nfunction visitarray(arr) {\n  for (let i = 0; i < arr.length; i++) {\n    console.log(arr[i]);\n  }\n}\n\n\n\n# 数组的插入\n\n首先，我们需要将插入的位置从数组中找到，这个操作的平均时间复杂度为o(n)，然后我们将数组的长度增加 1，并且把目标位置到数组最后一个位置的元素都依次向后错一位（给新插入的数据腾出空间呀），我们需要把后面的元素依次往前面挪动一位，这个操作的平均复杂度为o(n)，总的时间复杂度为2*o(n),但是我们在讨论复杂度时，其描述的是算法的规模，因此我们需要省略这个系数，所以，数组删除的平均时间复杂度为o(n)。 平均时间复杂度o(n)\n\n/**\n * 像数组中插入一个值\n * @param {number[]} arr\n * @param {number} insertbefore 指定插入的位置在这个元素之后，如果找不到，则插在末尾\n * @param {number} val 待插入的值\n */\nfunction insert(arr, insertbefore, val) {\n  let targetidx = -1;\n  let length = arr.length;\n  arr.length++;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[targetidx] === insertbefore) {\n      targetidx = i;\n      break;\n    }\n  }\n  if (targetidx === -1) {\n    // 直接插在末尾\n    arr[length] = val;\n    // 这个地方不需要操作js的length，数组length自己会增加\n    return;\n  }\n  // 必须是从后往前错一位\n  for (let i = arr.length; i > targetidx; i--) {\n    // 将前面的元素拷贝给后面的元素\n    arr[i] = arr[i - 1];\n  }\n  // 在留出的空位上插入新元素\n  arr[targetidx] = val;\n}\n\n\n\n# 数组的删除\n\n首先，我们需要将待删除的元素从数组中找到，这个操作的平均时间复杂度为o(n)，然后我们将这个位置的元素从数组中拿掉，当前这个位置便空出来了，我们需要把后面的元素依次往前面挪动一位，这个操作的平均复杂度为o(n)，总的时间复杂度为2*o(n),但是我们在讨论复杂度时，其描述的是算法的规模，因此我们需要省略这个系数，所以，数组删除的平均时间复杂度为o(n)。\n\n/**\n * 从数组中删除指定的元素\n * @param {number[] } arr 数据源\n * @param {number} target 待删除的值\n */\nfunction remove(arr, target) {\n  let targetidx = -1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[targetidx] === target) {\n      targetidx = i;\n      break;\n    }\n  }\n  if (targetidx === -1) {\n    console.warn("the target element can not exist in arr");\n    return;\n  }\n  // 依次将后面的元素向前拷贝\n  for (let i = targetidx; i < arr.length; i++) {\n    arr[targetidx] = arr[targetidx + 1];\n  }\n  // 数组的长度-1\n  arr.length--;\n}\n\n\n\n# 数组的扩容\n\n本节只为阐述原理，实际开发中并不需要这个步骤，这个操作的时间复杂度为o(n)\n\n/**\n * 将数组扩容\n * @param {number[]} arr\n */\nfunction expandarray(arr) {\n  const len = arr.length\n  // 糟粕语法，实际开发中不要使用, 假设扩容两倍\n  const newarr = new array(2 * len);\n  for(let i = 0;i<newarr.length;i++) {\n    // 将旧的数组的元素拷贝置新的数组上去，同时给新申请的空间初始化0，直接使用length初始化，数组在使用foreach等方法遍历时会跳过空元素\n    const ele = i < arr.length ? arr[i] : 0;\n    newarr[i] = ele;\n  }\n  return newarr;\n}\n\n\n\n# 数组的应用\n\n略',charsets:{cjk:!0}},{title:"双向链表",frontmatter:{},regularPath:"/data-structure/list/doubleLinkedList.html",relativePath:"data-structure/list/doubleLinkedList.md",key:"v-57159cad",path:"/data-structure/list/doubleLinkedList.html",headers:[{level:2,title:"双向链表",slug:"双向链表",normalizedTitle:"双向链表",charIndex:2},{level:2,title:"双向链表的一般数据结构定义",slug:"双向链表的一般数据结构定义",normalizedTitle:"双向链表的一般数据结构定义",charIndex:127},{level:2,title:"应用场景",slug:"应用场景",normalizedTitle:"应用场景",charIndex:352}],headersStr:"双向链表 双向链表的一般数据结构定义 应用场景",content:"# 双向链表\n\n由于单向链表只知道后继节点，当我们需要向前查找的时候，是及其不便的，而双向链表相对于链表来说，多了一个前驱域，我们在操作的过程中就可以快速的找到当前节点的前驱节点。因为多了一个指针域的关系，所以双向链表的内存占用会稍稍的多一些。\n\n\n# 双向链表的一般数据结构定义\n\ninterface DoubleLinkedListNode<T> {\n  /**\n   * 链表的数据域\n   */\n  data: T;\n  /**\n   * 链表的后继节点域\n   */\n  next: DoubleLinkedListNode<T> | null;\n  /**\n   * 链表的前驱节点域\n   */\n  prev: DoubleLinkedListNode<T> | null;\n}\n\n\n\n# 应用场景\n\n实现自动扩容队列；\n\n实现自动扩容的栈；\n\nLRU-Cache等；\n\n编程技巧\n\n在任何想频繁的操作前驱节点时，都应该考虑使用双向链表；",normalizedContent:"# 双向链表\n\n由于单向链表只知道后继节点，当我们需要向前查找的时候，是及其不便的，而双向链表相对于链表来说，多了一个前驱域，我们在操作的过程中就可以快速的找到当前节点的前驱节点。因为多了一个指针域的关系，所以双向链表的内存占用会稍稍的多一些。\n\n\n# 双向链表的一般数据结构定义\n\ninterface doublelinkedlistnode<t> {\n  /**\n   * 链表的数据域\n   */\n  data: t;\n  /**\n   * 链表的后继节点域\n   */\n  next: doublelinkedlistnode<t> | null;\n  /**\n   * 链表的前驱节点域\n   */\n  prev: doublelinkedlistnode<t> | null;\n}\n\n\n\n# 应用场景\n\n实现自动扩容队列；\n\n实现自动扩容的栈；\n\nlru-cache等；\n\n编程技巧\n\n在任何想频繁的操作前驱节点时，都应该考虑使用双向链表；",charsets:{cjk:!0}},{frontmatter:{},regularPath:"/data-structure/list/lfu-cache.html",relativePath:"data-structure/list/lfu-cache.md",key:"v-c99dd316",path:"/data-structure/list/lfu-cache.html",headers:[{level:2,title:"算法介绍",slug:"算法介绍",normalizedTitle:"算法介绍",charIndex:2},{level:2,title:"思路分析",slug:"思路分析",normalizedTitle:"思路分析",charIndex:90},{level:2,title:"算法实现",slug:"算法实现",normalizedTitle:"算法实现",charIndex:282}],headersStr:"算法介绍 思路分析 算法实现",content:'# 算法介绍\n\n在阅读本文之前，请确保你已经掌握LRU，本文不会赘述前文所阐述过的的内容。\n\nLFU缓存算法是在LRU算法上的一个改进，对于缓存增加了一个权重的概念。\n\n\n\n\n# 思路分析\n\n在LRU算法的实现中，我们使用了双向链表，很明显，LFU也是需要使用双向链表的。\n\n但是有个问题，如何来管理权重呢？\n\n由于题目已经要求了算法复杂度，因此，这儿要不就是哈希表，要不就得是链表，如果使用哈希表的话，怎么知道各个权重缓存的关系呢，光用哈希表肯定搞不定，如果加上链表呢？\n\n把权重节点用链表串起来，然后链表的节点内存存储缓存内容，联想到曾经提到过的广义表的内容，算法实现的基本框架就已经成型了，如下图：\n\n\n\n如果能知道到权重的头结点和尾节点，并且能找到任意权重的子链表；如果能获取到对应权重的链表，并且能获取到任意缓存节点，那不就大功告成了吗？\n\n有了这个设计思路，一切都是手到擒来了，接下来，我们将所需要的数据结构定义出来：\n\n/**\n * 索引节点\n */\ninterface IndexedNode {\n  /**\n   * 索引节点的数据头节点\n   */\n  head: CacheNode | null;\n  /**\n   * 索引节点的数据尾节点\n   */\n  tail: CacheNode | null;\n  /**\n   * 索引节点的权重，为的是在删除和扩展的时候知道怎么移除怎么新增新的节点\n   */\n  weight: number;\n  /**\n   * 索引节点的前置节点\n   */\n  prev: IndexedNode | null;\n  /**\n   * 索引节点的后继节点\n   */\n  next: IndexedNode | null;\n}\n\n\n索引节点，即上图中橙色的节点。\n\n/**\n * 缓存节点\n */\ninterface CacheNode {\n  /**\n   * 缓存节点的Key\n   */\n  key: string;\n  /**\n   * 缓存节点的值\n   */\n  data: string;\n  /**\n   * 缓存节点的权重，为了知道它所在的权重节点\n   */\n  weight: number;\n  /**\n   * 缓存节点的前置节点\n   */\n  prev: CacheNode | null;\n  /**\n   * 缓存节点的后继节点\n   */\n  next: CacheNode | null;\n}\n\n\n数据节点，即上图中蓝色的节点。\n\n\n# 算法实现\n\n这个算法实现较为复杂，必须充分的理解面向对象编程的思想，合理的封装，以及职责的划分才能更好的理解这题。（在没有意识到这个问题之前，我不知道被绕晕了多少次）\n\n首先，构造函数的内容，需要定义缓存容量以及当前已缓存的数量，需要定义两个哈希表，用于以O(1)的复杂度在缓存节点中查找，一个用于查找权重，一个用于查找缓存节点。\n\n/**\n * @param {number} capacity\n */\nvar LFUCache = function (capacity) {\n  /**\n   * 缓存的容量\n   * @type {number}\n   */\n  this.capacity = capacity;\n  /**\n   * 缓存的节点数\n   * @type {number}\n   */\n  this.size = 0;\n  /**\n   * @type {Map<number, IndexedNode>}\n   */\n  this.indexedMap = new Map();\n  /**\n   * @type {Map<number, CacheNode>}\n   */\n  this.dataMap = new Map();\n  /**\n   * @type {IndexedNode | null}\n   */\n  this.startIndexedNode;\n  /**\n   * @type {IndexedNode | null}\n   */\n  this.endIndexedNode;\n};\n\n/**\n * 获取缓存\n * @param {number} key\n * @return {number}\n */\nLFUCache.prototype.get = function (key) {\n  // 如果数据不存在\n  if (this.capacity <= 0 || !this.dataMap.has(key)) {\n    return -1;\n  }\n  let dataNode = this.dataMap.get(key);\n  // 刷新数据的权重\n  this.refreshDataNodeWeight(dataNode);\n  return dataNode.data;\n};\n\n/**\n * 设置缓存\n * @param {number} key\n * @param {number} value\n * @return {void}\n */\nLFUCache.prototype.put = function (key, value) {\n  if (this.capacity === 0) {\n    console.warn("exceed the lfu cache capacity");\n    return;\n  }\n  // 尝试获取数据节点\n  let dataNode = this.dataMap.get(key);\n  // 如果数据节点不存在\n  if (!dataNode) {\n    // 创建数据节点\n    dataNode = {\n      key,\n      weight: 1,\n      data: value,\n      prev: null,\n      next: null,\n    };\n    // 如果已经超出了最大的容量的话，删除最久没有使用过的节点\n    if (this.size === this.capacity) {\n      this.eject();\n    } else {\n      // 否则直接将数量增加\n      this.size++;\n    }\n    // 获取权重为1的索引节点\n    let indexedNode = this.getOrCreateIndexedNodeIfNotExist(1);\n    // 确定索引节点已存在，向索引节点插入数据节点\n    this.insertIndexedNodeData(indexedNode, dataNode);\n  } else {\n    dataNode.data = value;\n    // 直接更新节点的权重\n    this.refreshDataNodeWeight(dataNode);\n  }\n};\n\n\n对于put操作来说，新来的节点有两种可能，一种是已经存在，那么它需要执行的操作就非常简单，只需要简单的刷新一下它的权重和更新值即可。\n\n对于一个不存在的节点来说，操作就有点儿复杂了。\n\n首先，肯定得初始化这个缓存节点，这个缓存节点的权重一定是 1(因为是新来的嘛)，那么，对于权重为 1 的权重节点是不一定存在的，我们要将这个缓存节点插入的话，首先得确保这个权重节点存在，所以，不存在的话就需要先创建，封装一个操作，避免每次都要去判断，如下：\n\n/**\n * 获取指定权重的节点，若不存在，则创建\n * @param {number} weight\n */\nLFUCache.prototype.getOrCreateIndexedNodeIfNotExist = function (weight) {\n  let indexedNode = this.indexedMap.get(weight);\n  // 如果现在的索引节点不存在\n  if (!indexedNode) {\n    indexedNode = {\n      weight,\n      head: null,\n      tail: null,\n      prev: null,\n      next: null,\n    };\n    this.insertIndexedNode(indexedNode);\n  }\n  return indexedNode;\n};\n\n\n创建成功了，我们就可以直接将缓存节点插入到权重节点中了吗？\n\n不，还不能，因为有容量的限制，假设当前缓存已经超限了的话，那么，得剔除一下权重最小，最远没有使用过的缓存节点。\n\n特别注意\n\n一定是要先剔除才能插入，因为新插入的缓存节点权重一定是 1，那么如果先插入，再剔除的话，那么一定总是剔除的刚才插入的节点。\n\n接着，来看我们之前所用到的，还没有实现的方法。\n\n首先是剔除，思路非常简单，因为持有权重链表的首尾节点，可以很容易的拿到最小权重的节点，它对应的这个链表，其尾节点一定是最久没有使用过的节点，那么其实现就如下所示了：\n\n/**\n * 删除缓存中权重最小并且最久没有使用过的节点\n */\nLFUCache.prototype.eject = function () {\n  // 获取到权重最小的尾节点\n  let tailNode = this.startIndexedNode.tail;\n  // 删除权重最小的尾节点\n  this.removeIndexedNodeData(this.startIndexedNode, tailNode);\n};\n\n\n接着，来看从权重链表中移除节点和从缓存链表中移除节点方法。\n\n对于权重链表的节点移除需要注意的是，它的删除可能会导致之前持有的权重链表的首尾节点改变，大概能够分为 3 种情况的删除。\n\n * 删除头结点\n * 删除尾节点\n * 删除中间节点\n\n/**\n * 删除indexedNode\n * @param {IndexedNode} indexedNode\n */\nLFUCache.prototype.removeIndexedNode = function (indexedNode) {\n  const isStart = this.startIndexedNode === indexedNode;\n  const isEnd = this.endIndexedNode === indexedNode;\n  // 只有一个节点\n  if (isStart && isEnd) {\n    this.endIndexedNode = this.startIndexedNode = null;\n  } else if (isStart) {\n    // 2个节点以上。删除头节点\n    const afterNode = this.startIndexedNode.next;\n    this.startIndexedNode.next = null;\n    afterNode.prev = null;\n    this.startIndexedNode = afterNode;\n  } else if (isEnd) {\n    // 2个节点以上，删除尾节点\n    const beforeNode = this.endIndexedNode.prev;\n    this.endIndexedNode.prev = null;\n    beforeNode.next = null;\n    this.endIndexedNode = beforeNode;\n  } else {\n    // 如果即不删除头节点，也不删除尾节点，至少是3个节点以上\n    const beforeNode = indexedNode.prev;\n    const afterNode = indexedNode.next;\n    indexedNode.prev = null;\n    indexedNode.next = null;\n    beforeNode.next = afterNode;\n    afterNode.prev = beforeNode;\n  }\n  const weight = indexedNode.weight;\n  this.indexedMap.delete(weight);\n};\n\n\n需要注意点的是，如果头尾节点都是同一个的话，删除之后将头尾节点都必须要指向空。\n\n接着是，删除权重节点关联的缓存链表的节点：\n\n/**\n * 删除indexedNode上的dataNode\n * @param {IndexedNode} indexedNode\n * @param {CacheNode} dataNode\n */\nLFUCache.prototype.removeIndexedNodeData = function (indexedNode, dataNode) {\n  if (!indexedNode || !dataNode) {\n    console.warn("indexed node or data node is null");\n    return;\n  }\n  const isStart = indexedNode.head === dataNode;\n  const isEnd = indexedNode.tail === dataNode;\n  if (isStart && isEnd) {\n    this.removeIndexedNode(indexedNode);\n  } else if (isStart) {\n    const afterNode = indexedNode.head.next;\n    indexedNode.head.next = null;\n    afterNode.prev = null;\n    indexedNode.head = afterNode;\n  } else if (isEnd) {\n    const beforeNode = indexedNode.tail.prev;\n    indexedNode.tail.prev = null;\n    beforeNode.next = null;\n    indexedNode.tail = beforeNode;\n  } else {\n    const beforeDataNode = dataNode.prev;\n    const afterDataNode = dataNode.next;\n    dataNode.prev = null;\n    dataNode.next = null;\n    beforeDataNode.next = afterDataNode;\n    afterDataNode.prev = beforeDataNode;\n  }\n  // 删除key上面的内容\n  const key = dataNode.key;\n  this.dataMap.delete(key);\n};\n\n\n需要考虑的情况和删除权重链表的节点操作类似。\n\n有删除，就有插入，分别是插入权重节点和插入权重节点上的缓存节点的操作。\n\n这两个操作是非常容易出错的，需要尤其小心，考虑的边界条件也多的多。\n\n/**\n * 将indexedNode插入在refNode之后\n * @param {IndexedNode} indexedNode\n * @param {IndexedNode | null} refNode\n */\nLFUCache.prototype.insertIndexedNode = function (indexedNode, refNode = null) {\n  const weight = indexedNode.weight;\n  this.indexedMap.set(weight, indexedNode);\n  // 如果当前表为空\n  if (!this.startIndexedNode && !this.endIndexedNode) {\n    this.startIndexedNode = this.endIndexedNode = indexedNode;\n    return;\n  }\n  // 如果参考节点不存在或者只有一个参考节点，说明当前其实只有一个节点，则直接插入在最后面\n  if (!refNode || (!refNode.next && !refNode.prev)) {\n    // 如果当前节点的索引比较大\n    if (indexedNode.weight < this.startIndexedNode.weight) {\n      indexedNode.next = this.startIndexedNode;\n      this.startIndexedNode.prev = indexedNode;\n      this.startIndexedNode = indexedNode;\n    } else {\n      this.endIndexedNode.next = indexedNode;\n      indexedNode.prev = this.endIndexedNode;\n      this.endIndexedNode = indexedNode;\n    }\n  } else {\n    const refNextNode = refNode.next;\n    // 说明不是最后一个节点\n    if (refNextNode) {\n      // 建立前驱节点的关系\n      refNode.next = indexedNode;\n      indexedNode.prev = refNode;\n      // 建立后继节点的关系\n      indexedNode.next = refNextNode;\n      refNextNode.prev = indexedNode;\n    } else {\n      // 建立前驱节点的关系\n      refNode.next = indexedNode;\n      indexedNode.prev = refNode;\n      this.endIndexedNode = indexedNode;\n    }\n  }\n};\n\n\n如果插入权重节点，之前一个都没有的话，那么直接插入就好。\n\n但问题就是如果之前有的话，你就要指定新来的权重节点插入的位置了，因此，我们引入一个参数叫做refNode。我们规定如果存在refNode的话，都将节点插入在这个节点之后。\n\n这儿有一个极其边界的条件，本来，只有一个权重节点，那么，新插入的节点就不能简单的只考虑直接插入在refNode的后面了，此时需要比较一下新插入的权重节点的权重，决定插入在其前还是后。\n\n在已知权重节点上插入新的缓存节点这个操作非常简单，因为我们之前已经学过了LRU，只需要将新来的节点都插在表头即可。\n\n/**\n * 向indexedNode上插入dataNode\n * @param {IndexedNode} indexedNode\n * @param {CacheNode} dataNode\n */\nLFUCache.prototype.insertIndexedNodeData = function (indexedNode, dataNode) {\n  if (!indexedNode || !dataNode) {\n    console.warn("num node or data node is null");\n    return;\n  }\n  if (indexedNode.head === null && indexedNode.tail === null) {\n    indexedNode.head = dataNode;\n    indexedNode.tail = dataNode;\n  } else {\n    // 将缓存节点插入在当前索引的最前端\n    dataNode.next = indexedNode.head;\n    indexedNode.head.prev = dataNode;\n    indexedNode.head = dataNode;\n  }\n  const key = dataNode.key;\n  this.dataMap.set(key, dataNode);\n};\n\n\n需要注意的就是，如果当前权重节点没有缓存节点都话，那么，头尾节点都必须指向新插入的缓存节点才行。\n\n到这儿，我们已经完成了万里长征的绝大部分了，最后来看一下更新操作。\n\n每次访问了缓存，都需要更新这个缓存的权重，这个操作非常容易理解，将当前缓存节点从原来的权重节点上拿掉，权重增加 1，在新的权重节点上加入。\n\n同样需要注意的问题就是新插入的权重节点是不一定存在的，因此需要确保存在才行，这就是为什么我们之前要封装获取指定权重节点的方法的理由。\n\n/**\n * 更新节点的权重\n * @param {CacheNode} dataNode\n */\nLFUCache.prototype.refreshDataNodeWeight = function (dataNode) {\n  const preKeyOfIndexed = dataNode.weight;\n  // 获取到之前的索引节点\n  let preIndexedNode = this.indexedMap.get(preKeyOfIndexed);\n  // 删除之前索引节点上的数据节点\n  this.removeIndexedNodeData(preIndexedNode, dataNode);\n  const nowKeyOfIndexed = ++dataNode.weight;\n  // 获取现在的索引节点\n  const nowIndexedNode = this.getOrCreateIndexedNodeIfNotExist(nowKeyOfIndexed);\n  // 确定索引节点存在，插入数据节点\n  this.insertIndexedNodeData(nowIndexedNode, dataNode);\n};\n\n\n以上就是LFU缓存的实现全过程，请各位朋友注意区别LRU。\n\n完整代码如下：\n\n/**\n * @param {number} capacity\n */\nvar LFUCache = function (capacity) {\n  /**\n   * 缓存的容量\n   * @type {number}\n   */\n  this.capacity = capacity;\n  /**\n   * 缓存的节点数\n   * @type {number}\n   */\n  this.size = 0;\n  /**\n   * @type {Map<number, IndexedNode>}\n   */\n  this.indexedMap = new Map();\n  /**\n   * @type {Map<number, CacheNode>}\n   */\n  this.dataMap = new Map();\n  /**\n   * @type {IndexedNode | null}\n   */\n  this.startIndexedNode;\n  /**\n   * @type {IndexedNode | null}\n   */\n  this.endIndexedNode;\n};\n\n/**\n * 获取缓存\n * @param {number} key\n * @return {number}\n */\nLFUCache.prototype.get = function (key) {\n  // 如果数据不存在\n  if (this.capacity <= 0 || !this.dataMap.has(key)) {\n    return -1;\n  }\n  let dataNode = this.dataMap.get(key);\n  // 刷新数据的权重\n  this.refreshDataNodeWeight(dataNode);\n  return dataNode.data;\n};\n\n/**\n * 设置缓存\n * @param {number} key\n * @param {number} value\n * @return {void}\n */\nLFUCache.prototype.put = function (key, value) {\n  if (this.capacity === 0) {\n    console.warn("exceed the lfu cache capacity");\n    return;\n  }\n  // 尝试获取数据节点\n  let dataNode = this.dataMap.get(key);\n  // 如果数据节点不存在\n  if (!dataNode) {\n    // 创建数据节点\n    dataNode = {\n      key,\n      weight: 1,\n      data: value,\n      prev: null,\n      next: null,\n    };\n    // 如果已经超出了最大的容量的话，删除最久没有使用过的节点\n    if (this.size === this.capacity) {\n      this.eject();\n    } else {\n      // 否则直接将数量增加\n      this.size++;\n    }\n    // 获取权重为1的索引节点\n    let indexedNode = this.getOrCreateIndexedNodeIfNotExist(1);\n    // 确定索引节点已存在，向索引节点插入数据节点\n    this.insertIndexedNodeData(indexedNode, dataNode);\n  } else {\n    dataNode.data = value;\n    // 直接更新节点的权重\n    this.refreshDataNodeWeight(dataNode);\n  }\n};\n\n/**\n * 删除缓存中权重最小并且最久没有使用过的节点\n */\nLFUCache.prototype.eject = function () {\n  // 获取到权重最小的尾节点\n  let tailNode = this.startIndexedNode.tail;\n  // 删除权重最小的尾节点\n  this.removeIndexedNodeData(this.startIndexedNode, tailNode);\n};\n\n/**\n * 更新节点的权重\n * @param {CacheNode} dataNode\n */\nLFUCache.prototype.refreshDataNodeWeight = function (dataNode) {\n  const preKeyOfIndexed = dataNode.weight;\n  // 获取到之前的索引节点\n  let preIndexedNode = this.indexedMap.get(preKeyOfIndexed);\n  // 删除之前索引节点上的数据节点\n  this.removeIndexedNodeData(preIndexedNode, dataNode);\n  const nowKeyOfIndexed = ++dataNode.weight;\n  // 获取现在的索引节点\n  const nowIndexedNode = this.getOrCreateIndexedNodeIfNotExist(nowKeyOfIndexed);\n  // 确定索引节点存在，插入数据节点\n  this.insertIndexedNodeData(nowIndexedNode, dataNode);\n};\n\n/**\n * 获取指定权重的节点，若不存在，则创建\n * @param {number} weight\n */\nLFUCache.prototype.getOrCreateIndexedNodeIfNotExist = function (weight) {\n  let indexedNode = this.indexedMap.get(weight);\n  // 如果现在的索引节点不存在\n  if (!indexedNode) {\n    indexedNode = {\n      weight,\n      head: null,\n      tail: null,\n      prev: null,\n      next: null,\n    };\n    this.insertIndexedNode(indexedNode);\n  }\n  return indexedNode;\n};\n\n/**\n * 删除indexedNode\n * @param {IndexedNode} indexedNode\n */\nLFUCache.prototype.removeIndexedNode = function (indexedNode) {\n  const isStart = this.startIndexedNode === indexedNode;\n  const isEnd = this.endIndexedNode === indexedNode;\n  // 只有一个节点\n  if (isStart && isEnd) {\n    this.endIndexedNode = this.startIndexedNode = null;\n  } else if (isStart) {\n    // 2个节点以上。删除头节点\n    const afterNode = this.startIndexedNode.next;\n    this.startIndexedNode.next = null;\n    afterNode.prev = null;\n    this.startIndexedNode = afterNode;\n  } else if (isEnd) {\n    // 2个节点以上，删除尾节点\n    const beforeNode = this.endIndexedNode.prev;\n    this.endIndexedNode.prev = null;\n    beforeNode.next = null;\n    this.endIndexedNode = beforeNode;\n  } else {\n    // 如果即不删除头节点，也不删除尾节点，至少是3个节点以上\n    const beforeNode = indexedNode.prev;\n    const afterNode = indexedNode.next;\n    indexedNode.prev = null;\n    indexedNode.next = null;\n    beforeNode.next = afterNode;\n    afterNode.prev = beforeNode;\n  }\n  const weight = indexedNode.weight;\n  this.indexedMap.delete(weight);\n};\n\n/**\n * 将indexedNode插入在refNode之后\n * @param {IndexedNode} indexedNode\n * @param {IndexedNode | null} refNode\n */\nLFUCache.prototype.insertIndexedNode = function (indexedNode, refNode = null) {\n  const weight = indexedNode.weight;\n  this.indexedMap.set(weight, indexedNode);\n  // 如果当前表为空\n  if (!this.startIndexedNode && !this.endIndexedNode) {\n    this.startIndexedNode = this.endIndexedNode = indexedNode;\n    return;\n  }\n  // 如果参考节点不存在或者只有一个参考节点，说明当前其实只有一个节点，则直接插入在最后面\n  if (!refNode || (!refNode.next && !refNode.prev)) {\n    // 如果当前节点的索引比较大\n    if (indexedNode.weight < this.startIndexedNode.weight) {\n      indexedNode.next = this.startIndexedNode;\n      this.startIndexedNode.prev = indexedNode;\n      this.startIndexedNode = indexedNode;\n    } else {\n      this.endIndexedNode.next = indexedNode;\n      indexedNode.prev = this.endIndexedNode;\n      this.endIndexedNode = indexedNode;\n    }\n  } else {\n    const refNextNode = refNode.next;\n    // 说明不是最后一个节点\n    if (refNextNode) {\n      // 建立前驱节点的关系\n      refNode.next = indexedNode;\n      indexedNode.prev = refNode;\n      // 建立后继节点的关系\n      indexedNode.next = refNextNode;\n      refNextNode.prev = indexedNode;\n    } else {\n      // 建立前驱节点的关系\n      refNode.next = indexedNode;\n      indexedNode.prev = refNode;\n      this.endIndexedNode = indexedNode;\n    }\n  }\n};\n\n/**\n * 删除indexedNode上的dataNode\n * @param {IndexedNode} indexedNode\n * @param {CacheNode} dataNode\n */\nLFUCache.prototype.removeIndexedNodeData = function (indexedNode, dataNode) {\n  if (!indexedNode || !dataNode) {\n    console.warn("indexed node or data node is null");\n    return;\n  }\n  const isStart = indexedNode.head === dataNode;\n  const isEnd = indexedNode.tail === dataNode;\n  if (isStart && isEnd) {\n    this.removeIndexedNode(indexedNode);\n  } else if (isStart) {\n    const afterNode = indexedNode.head.next;\n    indexedNode.head.next = null;\n    afterNode.prev = null;\n    indexedNode.head = afterNode;\n  } else if (isEnd) {\n    const beforeNode = indexedNode.tail.prev;\n    indexedNode.tail.prev = null;\n    beforeNode.next = null;\n    indexedNode.tail = beforeNode;\n  } else {\n    const beforeDataNode = dataNode.prev;\n    const afterDataNode = dataNode.next;\n    dataNode.prev = null;\n    dataNode.next = null;\n    beforeDataNode.next = afterDataNode;\n    afterDataNode.prev = beforeDataNode;\n  }\n  // 删除key上面的内容\n  const key = dataNode.key;\n  this.dataMap.delete(key);\n};\n\n/**\n * 向indexedNode上插入dataNode\n * @param {IndexedNode} indexedNode\n * @param {CacheNode} dataNode\n */\nLFUCache.prototype.insertIndexedNodeData = function (indexedNode, dataNode) {\n  if (!indexedNode || !dataNode) {\n    console.warn("num node or data node is null");\n    return;\n  }\n  if (indexedNode.head === null && indexedNode.tail === null) {\n    indexedNode.head = dataNode;\n    indexedNode.tail = dataNode;\n  } else {\n    // 将缓存节点插入在当前索引的最前端\n    dataNode.next = indexedNode.head;\n    indexedNode.head.prev = dataNode;\n    indexedNode.head = dataNode;\n  }\n  const key = dataNode.key;\n  this.dataMap.set(key, dataNode);\n};\n',normalizedContent:'# 算法介绍\n\n在阅读本文之前，请确保你已经掌握lru，本文不会赘述前文所阐述过的的内容。\n\nlfu缓存算法是在lru算法上的一个改进，对于缓存增加了一个权重的概念。\n\n\n\n\n# 思路分析\n\n在lru算法的实现中，我们使用了双向链表，很明显，lfu也是需要使用双向链表的。\n\n但是有个问题，如何来管理权重呢？\n\n由于题目已经要求了算法复杂度，因此，这儿要不就是哈希表，要不就得是链表，如果使用哈希表的话，怎么知道各个权重缓存的关系呢，光用哈希表肯定搞不定，如果加上链表呢？\n\n把权重节点用链表串起来，然后链表的节点内存存储缓存内容，联想到曾经提到过的广义表的内容，算法实现的基本框架就已经成型了，如下图：\n\n\n\n如果能知道到权重的头结点和尾节点，并且能找到任意权重的子链表；如果能获取到对应权重的链表，并且能获取到任意缓存节点，那不就大功告成了吗？\n\n有了这个设计思路，一切都是手到擒来了，接下来，我们将所需要的数据结构定义出来：\n\n/**\n * 索引节点\n */\ninterface indexednode {\n  /**\n   * 索引节点的数据头节点\n   */\n  head: cachenode | null;\n  /**\n   * 索引节点的数据尾节点\n   */\n  tail: cachenode | null;\n  /**\n   * 索引节点的权重，为的是在删除和扩展的时候知道怎么移除怎么新增新的节点\n   */\n  weight: number;\n  /**\n   * 索引节点的前置节点\n   */\n  prev: indexednode | null;\n  /**\n   * 索引节点的后继节点\n   */\n  next: indexednode | null;\n}\n\n\n索引节点，即上图中橙色的节点。\n\n/**\n * 缓存节点\n */\ninterface cachenode {\n  /**\n   * 缓存节点的key\n   */\n  key: string;\n  /**\n   * 缓存节点的值\n   */\n  data: string;\n  /**\n   * 缓存节点的权重，为了知道它所在的权重节点\n   */\n  weight: number;\n  /**\n   * 缓存节点的前置节点\n   */\n  prev: cachenode | null;\n  /**\n   * 缓存节点的后继节点\n   */\n  next: cachenode | null;\n}\n\n\n数据节点，即上图中蓝色的节点。\n\n\n# 算法实现\n\n这个算法实现较为复杂，必须充分的理解面向对象编程的思想，合理的封装，以及职责的划分才能更好的理解这题。（在没有意识到这个问题之前，我不知道被绕晕了多少次）\n\n首先，构造函数的内容，需要定义缓存容量以及当前已缓存的数量，需要定义两个哈希表，用于以o(1)的复杂度在缓存节点中查找，一个用于查找权重，一个用于查找缓存节点。\n\n/**\n * @param {number} capacity\n */\nvar lfucache = function (capacity) {\n  /**\n   * 缓存的容量\n   * @type {number}\n   */\n  this.capacity = capacity;\n  /**\n   * 缓存的节点数\n   * @type {number}\n   */\n  this.size = 0;\n  /**\n   * @type {map<number, indexednode>}\n   */\n  this.indexedmap = new map();\n  /**\n   * @type {map<number, cachenode>}\n   */\n  this.datamap = new map();\n  /**\n   * @type {indexednode | null}\n   */\n  this.startindexednode;\n  /**\n   * @type {indexednode | null}\n   */\n  this.endindexednode;\n};\n\n/**\n * 获取缓存\n * @param {number} key\n * @return {number}\n */\nlfucache.prototype.get = function (key) {\n  // 如果数据不存在\n  if (this.capacity <= 0 || !this.datamap.has(key)) {\n    return -1;\n  }\n  let datanode = this.datamap.get(key);\n  // 刷新数据的权重\n  this.refreshdatanodeweight(datanode);\n  return datanode.data;\n};\n\n/**\n * 设置缓存\n * @param {number} key\n * @param {number} value\n * @return {void}\n */\nlfucache.prototype.put = function (key, value) {\n  if (this.capacity === 0) {\n    console.warn("exceed the lfu cache capacity");\n    return;\n  }\n  // 尝试获取数据节点\n  let datanode = this.datamap.get(key);\n  // 如果数据节点不存在\n  if (!datanode) {\n    // 创建数据节点\n    datanode = {\n      key,\n      weight: 1,\n      data: value,\n      prev: null,\n      next: null,\n    };\n    // 如果已经超出了最大的容量的话，删除最久没有使用过的节点\n    if (this.size === this.capacity) {\n      this.eject();\n    } else {\n      // 否则直接将数量增加\n      this.size++;\n    }\n    // 获取权重为1的索引节点\n    let indexednode = this.getorcreateindexednodeifnotexist(1);\n    // 确定索引节点已存在，向索引节点插入数据节点\n    this.insertindexednodedata(indexednode, datanode);\n  } else {\n    datanode.data = value;\n    // 直接更新节点的权重\n    this.refreshdatanodeweight(datanode);\n  }\n};\n\n\n对于put操作来说，新来的节点有两种可能，一种是已经存在，那么它需要执行的操作就非常简单，只需要简单的刷新一下它的权重和更新值即可。\n\n对于一个不存在的节点来说，操作就有点儿复杂了。\n\n首先，肯定得初始化这个缓存节点，这个缓存节点的权重一定是 1(因为是新来的嘛)，那么，对于权重为 1 的权重节点是不一定存在的，我们要将这个缓存节点插入的话，首先得确保这个权重节点存在，所以，不存在的话就需要先创建，封装一个操作，避免每次都要去判断，如下：\n\n/**\n * 获取指定权重的节点，若不存在，则创建\n * @param {number} weight\n */\nlfucache.prototype.getorcreateindexednodeifnotexist = function (weight) {\n  let indexednode = this.indexedmap.get(weight);\n  // 如果现在的索引节点不存在\n  if (!indexednode) {\n    indexednode = {\n      weight,\n      head: null,\n      tail: null,\n      prev: null,\n      next: null,\n    };\n    this.insertindexednode(indexednode);\n  }\n  return indexednode;\n};\n\n\n创建成功了，我们就可以直接将缓存节点插入到权重节点中了吗？\n\n不，还不能，因为有容量的限制，假设当前缓存已经超限了的话，那么，得剔除一下权重最小，最远没有使用过的缓存节点。\n\n特别注意\n\n一定是要先剔除才能插入，因为新插入的缓存节点权重一定是 1，那么如果先插入，再剔除的话，那么一定总是剔除的刚才插入的节点。\n\n接着，来看我们之前所用到的，还没有实现的方法。\n\n首先是剔除，思路非常简单，因为持有权重链表的首尾节点，可以很容易的拿到最小权重的节点，它对应的这个链表，其尾节点一定是最久没有使用过的节点，那么其实现就如下所示了：\n\n/**\n * 删除缓存中权重最小并且最久没有使用过的节点\n */\nlfucache.prototype.eject = function () {\n  // 获取到权重最小的尾节点\n  let tailnode = this.startindexednode.tail;\n  // 删除权重最小的尾节点\n  this.removeindexednodedata(this.startindexednode, tailnode);\n};\n\n\n接着，来看从权重链表中移除节点和从缓存链表中移除节点方法。\n\n对于权重链表的节点移除需要注意的是，它的删除可能会导致之前持有的权重链表的首尾节点改变，大概能够分为 3 种情况的删除。\n\n * 删除头结点\n * 删除尾节点\n * 删除中间节点\n\n/**\n * 删除indexednode\n * @param {indexednode} indexednode\n */\nlfucache.prototype.removeindexednode = function (indexednode) {\n  const isstart = this.startindexednode === indexednode;\n  const isend = this.endindexednode === indexednode;\n  // 只有一个节点\n  if (isstart && isend) {\n    this.endindexednode = this.startindexednode = null;\n  } else if (isstart) {\n    // 2个节点以上。删除头节点\n    const afternode = this.startindexednode.next;\n    this.startindexednode.next = null;\n    afternode.prev = null;\n    this.startindexednode = afternode;\n  } else if (isend) {\n    // 2个节点以上，删除尾节点\n    const beforenode = this.endindexednode.prev;\n    this.endindexednode.prev = null;\n    beforenode.next = null;\n    this.endindexednode = beforenode;\n  } else {\n    // 如果即不删除头节点，也不删除尾节点，至少是3个节点以上\n    const beforenode = indexednode.prev;\n    const afternode = indexednode.next;\n    indexednode.prev = null;\n    indexednode.next = null;\n    beforenode.next = afternode;\n    afternode.prev = beforenode;\n  }\n  const weight = indexednode.weight;\n  this.indexedmap.delete(weight);\n};\n\n\n需要注意点的是，如果头尾节点都是同一个的话，删除之后将头尾节点都必须要指向空。\n\n接着是，删除权重节点关联的缓存链表的节点：\n\n/**\n * 删除indexednode上的datanode\n * @param {indexednode} indexednode\n * @param {cachenode} datanode\n */\nlfucache.prototype.removeindexednodedata = function (indexednode, datanode) {\n  if (!indexednode || !datanode) {\n    console.warn("indexed node or data node is null");\n    return;\n  }\n  const isstart = indexednode.head === datanode;\n  const isend = indexednode.tail === datanode;\n  if (isstart && isend) {\n    this.removeindexednode(indexednode);\n  } else if (isstart) {\n    const afternode = indexednode.head.next;\n    indexednode.head.next = null;\n    afternode.prev = null;\n    indexednode.head = afternode;\n  } else if (isend) {\n    const beforenode = indexednode.tail.prev;\n    indexednode.tail.prev = null;\n    beforenode.next = null;\n    indexednode.tail = beforenode;\n  } else {\n    const beforedatanode = datanode.prev;\n    const afterdatanode = datanode.next;\n    datanode.prev = null;\n    datanode.next = null;\n    beforedatanode.next = afterdatanode;\n    afterdatanode.prev = beforedatanode;\n  }\n  // 删除key上面的内容\n  const key = datanode.key;\n  this.datamap.delete(key);\n};\n\n\n需要考虑的情况和删除权重链表的节点操作类似。\n\n有删除，就有插入，分别是插入权重节点和插入权重节点上的缓存节点的操作。\n\n这两个操作是非常容易出错的，需要尤其小心，考虑的边界条件也多的多。\n\n/**\n * 将indexednode插入在refnode之后\n * @param {indexednode} indexednode\n * @param {indexednode | null} refnode\n */\nlfucache.prototype.insertindexednode = function (indexednode, refnode = null) {\n  const weight = indexednode.weight;\n  this.indexedmap.set(weight, indexednode);\n  // 如果当前表为空\n  if (!this.startindexednode && !this.endindexednode) {\n    this.startindexednode = this.endindexednode = indexednode;\n    return;\n  }\n  // 如果参考节点不存在或者只有一个参考节点，说明当前其实只有一个节点，则直接插入在最后面\n  if (!refnode || (!refnode.next && !refnode.prev)) {\n    // 如果当前节点的索引比较大\n    if (indexednode.weight < this.startindexednode.weight) {\n      indexednode.next = this.startindexednode;\n      this.startindexednode.prev = indexednode;\n      this.startindexednode = indexednode;\n    } else {\n      this.endindexednode.next = indexednode;\n      indexednode.prev = this.endindexednode;\n      this.endindexednode = indexednode;\n    }\n  } else {\n    const refnextnode = refnode.next;\n    // 说明不是最后一个节点\n    if (refnextnode) {\n      // 建立前驱节点的关系\n      refnode.next = indexednode;\n      indexednode.prev = refnode;\n      // 建立后继节点的关系\n      indexednode.next = refnextnode;\n      refnextnode.prev = indexednode;\n    } else {\n      // 建立前驱节点的关系\n      refnode.next = indexednode;\n      indexednode.prev = refnode;\n      this.endindexednode = indexednode;\n    }\n  }\n};\n\n\n如果插入权重节点，之前一个都没有的话，那么直接插入就好。\n\n但问题就是如果之前有的话，你就要指定新来的权重节点插入的位置了，因此，我们引入一个参数叫做refnode。我们规定如果存在refnode的话，都将节点插入在这个节点之后。\n\n这儿有一个极其边界的条件，本来，只有一个权重节点，那么，新插入的节点就不能简单的只考虑直接插入在refnode的后面了，此时需要比较一下新插入的权重节点的权重，决定插入在其前还是后。\n\n在已知权重节点上插入新的缓存节点这个操作非常简单，因为我们之前已经学过了lru，只需要将新来的节点都插在表头即可。\n\n/**\n * 向indexednode上插入datanode\n * @param {indexednode} indexednode\n * @param {cachenode} datanode\n */\nlfucache.prototype.insertindexednodedata = function (indexednode, datanode) {\n  if (!indexednode || !datanode) {\n    console.warn("num node or data node is null");\n    return;\n  }\n  if (indexednode.head === null && indexednode.tail === null) {\n    indexednode.head = datanode;\n    indexednode.tail = datanode;\n  } else {\n    // 将缓存节点插入在当前索引的最前端\n    datanode.next = indexednode.head;\n    indexednode.head.prev = datanode;\n    indexednode.head = datanode;\n  }\n  const key = datanode.key;\n  this.datamap.set(key, datanode);\n};\n\n\n需要注意的就是，如果当前权重节点没有缓存节点都话，那么，头尾节点都必须指向新插入的缓存节点才行。\n\n到这儿，我们已经完成了万里长征的绝大部分了，最后来看一下更新操作。\n\n每次访问了缓存，都需要更新这个缓存的权重，这个操作非常容易理解，将当前缓存节点从原来的权重节点上拿掉，权重增加 1，在新的权重节点上加入。\n\n同样需要注意的问题就是新插入的权重节点是不一定存在的，因此需要确保存在才行，这就是为什么我们之前要封装获取指定权重节点的方法的理由。\n\n/**\n * 更新节点的权重\n * @param {cachenode} datanode\n */\nlfucache.prototype.refreshdatanodeweight = function (datanode) {\n  const prekeyofindexed = datanode.weight;\n  // 获取到之前的索引节点\n  let preindexednode = this.indexedmap.get(prekeyofindexed);\n  // 删除之前索引节点上的数据节点\n  this.removeindexednodedata(preindexednode, datanode);\n  const nowkeyofindexed = ++datanode.weight;\n  // 获取现在的索引节点\n  const nowindexednode = this.getorcreateindexednodeifnotexist(nowkeyofindexed);\n  // 确定索引节点存在，插入数据节点\n  this.insertindexednodedata(nowindexednode, datanode);\n};\n\n\n以上就是lfu缓存的实现全过程，请各位朋友注意区别lru。\n\n完整代码如下：\n\n/**\n * @param {number} capacity\n */\nvar lfucache = function (capacity) {\n  /**\n   * 缓存的容量\n   * @type {number}\n   */\n  this.capacity = capacity;\n  /**\n   * 缓存的节点数\n   * @type {number}\n   */\n  this.size = 0;\n  /**\n   * @type {map<number, indexednode>}\n   */\n  this.indexedmap = new map();\n  /**\n   * @type {map<number, cachenode>}\n   */\n  this.datamap = new map();\n  /**\n   * @type {indexednode | null}\n   */\n  this.startindexednode;\n  /**\n   * @type {indexednode | null}\n   */\n  this.endindexednode;\n};\n\n/**\n * 获取缓存\n * @param {number} key\n * @return {number}\n */\nlfucache.prototype.get = function (key) {\n  // 如果数据不存在\n  if (this.capacity <= 0 || !this.datamap.has(key)) {\n    return -1;\n  }\n  let datanode = this.datamap.get(key);\n  // 刷新数据的权重\n  this.refreshdatanodeweight(datanode);\n  return datanode.data;\n};\n\n/**\n * 设置缓存\n * @param {number} key\n * @param {number} value\n * @return {void}\n */\nlfucache.prototype.put = function (key, value) {\n  if (this.capacity === 0) {\n    console.warn("exceed the lfu cache capacity");\n    return;\n  }\n  // 尝试获取数据节点\n  let datanode = this.datamap.get(key);\n  // 如果数据节点不存在\n  if (!datanode) {\n    // 创建数据节点\n    datanode = {\n      key,\n      weight: 1,\n      data: value,\n      prev: null,\n      next: null,\n    };\n    // 如果已经超出了最大的容量的话，删除最久没有使用过的节点\n    if (this.size === this.capacity) {\n      this.eject();\n    } else {\n      // 否则直接将数量增加\n      this.size++;\n    }\n    // 获取权重为1的索引节点\n    let indexednode = this.getorcreateindexednodeifnotexist(1);\n    // 确定索引节点已存在，向索引节点插入数据节点\n    this.insertindexednodedata(indexednode, datanode);\n  } else {\n    datanode.data = value;\n    // 直接更新节点的权重\n    this.refreshdatanodeweight(datanode);\n  }\n};\n\n/**\n * 删除缓存中权重最小并且最久没有使用过的节点\n */\nlfucache.prototype.eject = function () {\n  // 获取到权重最小的尾节点\n  let tailnode = this.startindexednode.tail;\n  // 删除权重最小的尾节点\n  this.removeindexednodedata(this.startindexednode, tailnode);\n};\n\n/**\n * 更新节点的权重\n * @param {cachenode} datanode\n */\nlfucache.prototype.refreshdatanodeweight = function (datanode) {\n  const prekeyofindexed = datanode.weight;\n  // 获取到之前的索引节点\n  let preindexednode = this.indexedmap.get(prekeyofindexed);\n  // 删除之前索引节点上的数据节点\n  this.removeindexednodedata(preindexednode, datanode);\n  const nowkeyofindexed = ++datanode.weight;\n  // 获取现在的索引节点\n  const nowindexednode = this.getorcreateindexednodeifnotexist(nowkeyofindexed);\n  // 确定索引节点存在，插入数据节点\n  this.insertindexednodedata(nowindexednode, datanode);\n};\n\n/**\n * 获取指定权重的节点，若不存在，则创建\n * @param {number} weight\n */\nlfucache.prototype.getorcreateindexednodeifnotexist = function (weight) {\n  let indexednode = this.indexedmap.get(weight);\n  // 如果现在的索引节点不存在\n  if (!indexednode) {\n    indexednode = {\n      weight,\n      head: null,\n      tail: null,\n      prev: null,\n      next: null,\n    };\n    this.insertindexednode(indexednode);\n  }\n  return indexednode;\n};\n\n/**\n * 删除indexednode\n * @param {indexednode} indexednode\n */\nlfucache.prototype.removeindexednode = function (indexednode) {\n  const isstart = this.startindexednode === indexednode;\n  const isend = this.endindexednode === indexednode;\n  // 只有一个节点\n  if (isstart && isend) {\n    this.endindexednode = this.startindexednode = null;\n  } else if (isstart) {\n    // 2个节点以上。删除头节点\n    const afternode = this.startindexednode.next;\n    this.startindexednode.next = null;\n    afternode.prev = null;\n    this.startindexednode = afternode;\n  } else if (isend) {\n    // 2个节点以上，删除尾节点\n    const beforenode = this.endindexednode.prev;\n    this.endindexednode.prev = null;\n    beforenode.next = null;\n    this.endindexednode = beforenode;\n  } else {\n    // 如果即不删除头节点，也不删除尾节点，至少是3个节点以上\n    const beforenode = indexednode.prev;\n    const afternode = indexednode.next;\n    indexednode.prev = null;\n    indexednode.next = null;\n    beforenode.next = afternode;\n    afternode.prev = beforenode;\n  }\n  const weight = indexednode.weight;\n  this.indexedmap.delete(weight);\n};\n\n/**\n * 将indexednode插入在refnode之后\n * @param {indexednode} indexednode\n * @param {indexednode | null} refnode\n */\nlfucache.prototype.insertindexednode = function (indexednode, refnode = null) {\n  const weight = indexednode.weight;\n  this.indexedmap.set(weight, indexednode);\n  // 如果当前表为空\n  if (!this.startindexednode && !this.endindexednode) {\n    this.startindexednode = this.endindexednode = indexednode;\n    return;\n  }\n  // 如果参考节点不存在或者只有一个参考节点，说明当前其实只有一个节点，则直接插入在最后面\n  if (!refnode || (!refnode.next && !refnode.prev)) {\n    // 如果当前节点的索引比较大\n    if (indexednode.weight < this.startindexednode.weight) {\n      indexednode.next = this.startindexednode;\n      this.startindexednode.prev = indexednode;\n      this.startindexednode = indexednode;\n    } else {\n      this.endindexednode.next = indexednode;\n      indexednode.prev = this.endindexednode;\n      this.endindexednode = indexednode;\n    }\n  } else {\n    const refnextnode = refnode.next;\n    // 说明不是最后一个节点\n    if (refnextnode) {\n      // 建立前驱节点的关系\n      refnode.next = indexednode;\n      indexednode.prev = refnode;\n      // 建立后继节点的关系\n      indexednode.next = refnextnode;\n      refnextnode.prev = indexednode;\n    } else {\n      // 建立前驱节点的关系\n      refnode.next = indexednode;\n      indexednode.prev = refnode;\n      this.endindexednode = indexednode;\n    }\n  }\n};\n\n/**\n * 删除indexednode上的datanode\n * @param {indexednode} indexednode\n * @param {cachenode} datanode\n */\nlfucache.prototype.removeindexednodedata = function (indexednode, datanode) {\n  if (!indexednode || !datanode) {\n    console.warn("indexed node or data node is null");\n    return;\n  }\n  const isstart = indexednode.head === datanode;\n  const isend = indexednode.tail === datanode;\n  if (isstart && isend) {\n    this.removeindexednode(indexednode);\n  } else if (isstart) {\n    const afternode = indexednode.head.next;\n    indexednode.head.next = null;\n    afternode.prev = null;\n    indexednode.head = afternode;\n  } else if (isend) {\n    const beforenode = indexednode.tail.prev;\n    indexednode.tail.prev = null;\n    beforenode.next = null;\n    indexednode.tail = beforenode;\n  } else {\n    const beforedatanode = datanode.prev;\n    const afterdatanode = datanode.next;\n    datanode.prev = null;\n    datanode.next = null;\n    beforedatanode.next = afterdatanode;\n    afterdatanode.prev = beforedatanode;\n  }\n  // 删除key上面的内容\n  const key = datanode.key;\n  this.datamap.delete(key);\n};\n\n/**\n * 向indexednode上插入datanode\n * @param {indexednode} indexednode\n * @param {cachenode} datanode\n */\nlfucache.prototype.insertindexednodedata = function (indexednode, datanode) {\n  if (!indexednode || !datanode) {\n    console.warn("num node or data node is null");\n    return;\n  }\n  if (indexednode.head === null && indexednode.tail === null) {\n    indexednode.head = datanode;\n    indexednode.tail = datanode;\n  } else {\n    // 将缓存节点插入在当前索引的最前端\n    datanode.next = indexednode.head;\n    indexednode.head.prev = datanode;\n    indexednode.head = datanode;\n  }\n  const key = datanode.key;\n  this.datamap.set(key, datanode);\n};\n',charsets:{cjk:!0}},{title:"链表",frontmatter:{},regularPath:"/data-structure/list/linkedList.html",relativePath:"data-structure/list/linkedList.md",key:"v-f3c1e4e2",path:"/data-structure/list/linkedList.html",headers:[{level:2,title:"链表",slug:"链表",normalizedTitle:"链表",charIndex:2},{level:2,title:"链表的一般数据结构定义",slug:"链表的一般数据结构定义",normalizedTitle:"链表的一般数据结构定义",charIndex:165},{level:2,title:"链表的操作",slug:"链表的操作",normalizedTitle:"链表的操作",charIndex:310},{level:3,title:"初始化",slug:"初始化",normalizedTitle:"初始化",charIndex:340},{level:3,title:"遍历",slug:"遍历",normalizedTitle:"遍历",charIndex:344},{level:3,title:"插入",slug:"插入",normalizedTitle:"插入",charIndex:541},{level:3,title:"查找",slug:"查找",normalizedTitle:"查找",charIndex:3605},{level:3,title:"删除",slug:"删除",normalizedTitle:"删除",charIndex:4208},{level:2,title:"结语",slug:"结语",normalizedTitle:"结语",charIndex:5064}],headersStr:"链表 链表的一般数据结构定义 链表的操作 初始化 遍历 插入 查找 删除 结语",content:'# 链表\n\n链表，是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。\n\n链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。\n\n一般我们说链表都是指的是单向链表。\n\n\n# 链表的一般数据结构定义\n\ninterface LinkedListNode<T> {\n  /**\n   * 链表的数据域\n   */\n  data: T;\n  /**\n   * 链表的后继节点域\n   */\n  next: LinkedListNode<T> | null;\n}\n\n\n\n# 链表的操作\n\n对于链表的操作，我个人感觉最重要的两个操作就是初始化和遍历。对于链表的操作有些同学喜欢在头放一个空节点，这是属于个人的编程习惯，而我一般不喜欢（可不是出于节约内存的想法哦，哈哈哈），因此，选择一个适合你的习惯即可。以下的所有代码实现均不包含空的头结点。\n\n\n# 初始化\n\n初始化，即把一堆数据构造成链表。对于链表的初始化一般有两种操作：即头插法和尾插法。 头插法：用一个变量指向已有链表的头结点，每次新来的节点都插在头结点的前面，再让这个变量指向新插入的节点，因此头插法构建出的链表数据的顺序和输入的顺序是相反的。\n\n头插法插入节点的过程：\n\n/**\n * 以头插法初始化链表\n * @param {Array<number>} arr 用于初始化链表的数据\n */\nfunction initialize(arr) {\n  // 如果图中第一步\n  let head = null;\n  // 此例中无用，仅用于阐述问题\n  let tail = null;\n  arr.forEach((val) => {\n    const node = createNode(val);\n    // 如果是空链表的话，直接让头结点指针指向第一个节点\n    if (head == null) {\n      // 如图第二步\n      head = node;\n      // 此例中无用，仅用于阐述问题\n      tail = node;\n    } else {\n      //先让新来的节点指向head节点，如图第三步\n      node.next = head;\n      // 再让head指针指向最新的节点，如图第四步\n      head = node;\n    }\n  });\n  return head;\n}\n\n\n尾插法：用一个变量指向已有链表的尾结点，每次新来的节点都插在尾结点的后面，再让这个变量指向新插入的尾结点，因此尾插法构建出的链表数据的顺序和输入的顺序是相同的。\n\n尾插法插入节点的过程：\n\n/**\n * 以尾插法初始化链表\n * @param {Array<number>} arr 用于初始化链表的数据\n */\nfunction initialize(arr) {\n  // 如图第一步\n  let head = null;\n  let tail = null;\n  arr.forEach((val) => {\n    const node = createNode(val);\n    if (head == null) {\n      // 如果是空链表的话，直接让头结点指针和尾结点指针指向第一个节点，对应图中第一步\n      head = node;\n      tail = node;\n    } else {\n      // 让尾结点的后继指针指向新来的节点, 如图第三步\n      tail.next = node;\n      // 让尾节点指针指向最后一个节点，如图第四步\n      tail = node;\n    }\n  });\n  return head;\n}\n\n\n我个人编程习惯喜欢用第二种，但是即使是使用头插法，你也可以多用一个变量来记住链表的尾结点，这样的好处就是如果某个时刻你需要在尾部插入的话，可以直接用尾节点指针而不用再去遍历了。\n\n\n# 遍历\n\n链表的遍历几乎可以说是一种标准范式了，这是对于链表一定得掌握的知识。对于单向链表，只要给头指针就可以完成遍历。\n\n编程技巧\n\n在遍历链表时，我们有时候会申明一个前驱节点，这样可以使得在遍历的过程中，既能找到当前节点，又可以找到当前节点的前驱节点，在某些时候非常好用，这也是一个必须掌握的编程技巧。\n\n需要注意的是在遍历链表的过程中不要修改头指针，因为一旦修改了头指针就找不回来了，万一需要用到头指针，那代码又得重新设计。\n\n链表遍历的复杂度为O(n);\n\n/**\n * 遍历链表\n * @param {Node<number>} head 链表头指针\n */\nfunction traverse(head) {\n  let node = head;\n  // pre在本例中无用，仅用于说明这是一种编程技巧\n  let pre = null;\n  // 如果当前节点指向空 （对于空链表，开始就直接指向空）\n  while (node) {\n    console.log(node);\n    // 让pre滞后，这样可以永远保证pre指向node的前一个节点（如果node是null,pre指向最后一个节点，如果node是第一个节点或者链表是空表，pre指向null）\n    pre = node;\n    node = node.next;\n  }\n}\n\n\n\n# 插入\n\n对于链表的操作操作一定要谨慎，否则容易丢失后继节点或者使得链表的节点指向表现非预期。\n\n我们演示一下在表中部插入节点的场景，其流程如下：\n\n伪代码描述即：newNode.next = node; pre.next = newNode; 这两行代码一定不能交换。\n\n链表插入的平均时间复杂度为：O(n);\n\n/**\n * 在链表中指定的K位置插入节点, 如果K小于1，则插在头部，如果K大于链表的长度，则直接插在尾部\n * @param {Node<number>} head 链表头\n * @param {number} val 节点值\n * @param {number} K 插入的位置,K为节点数,不是索引\n */\nfunction insert(head, val, K) {\n  const newNode = createNode(val);\n  // 如果需要插在头部的话\n  if (K < 1) {\n    newNode.next = head;\n    head = newNode;\n    return head;\n  }\n  let node = head;\n  // 申明一个空指针，因为其滞后node一个表结点，主要是用来记录上一个节点\n  let pre = null;\n  // 申明一个计数器，用于标记已经遍历的节点的个数\n  let counter = 0;\n  let inserted = false;\n  while (node) {\n    counter++;\n    // 如果找到了合适的插入位置，插入完成以后就没有继续循环的必要了\n    if (counter === K) {\n      // 必须先用一个临时变量将其记住，否则会丢失后继节点\n      let nextNode = node.next;\n      // 插入新的节点\n      node.next = newNode;\n      newNode.next = nextNode;\n      // 标记插入完成\n      inserted = true;\n      break;\n    }\n    // 先把当前这个节点记住，然后向后迭代\n    pre = node;\n    node = node.next;\n  }\n  // 如果已经插入了的哈，就不用再管什么事儿了\n  if (inserted) {\n    return head;\n  }\n  // 如果K大于等于链表的长度的话，就直接插在链表尾部即可\n  if (counter < K && pre) {\n    // 此刻的node已经是null了，而pre指针指向链表的最后一个节点\n    pre.next = newNode;\n  } else {\n    // 如果链表是空表，之前的循环一次都没有执行的，那么直接让head指向新来的节点即可\n    head = newNode;\n  }\n  return head;\n}\n\n\n\n# 查找\n\n查找主要分为按值查找或者按位置查找。 查找的思路和遍历类似。\n\n查找的平均算法复杂度为O(N)。\n\n/**\n * 根据索引查找链表节点\n * @param {Node<number>} head 链表头结点\n * @param {number} idx 目标索引\n */\nfunction findIndex(head, idx) {\n  let node = head;\n  let counter = 0;\n  // 找到表尾没有找到目标索引 或者 找到了目标索引 结束循环\n  while (node && counter < idx) {\n    counter++;\n    node = node.next;\n  }\n  return counter === idx ? node : null;\n}\n\n/**\n * 根据节点值查找节点\n * @param {Node<number>} head 链表头结点\n * @param {number} val 目标节点值\n */\nfunction find(head, val) {\n  let node = head;\n  // 找到节点值或遍历到链表结束，终止循环\n  while (node && node.val !== val) {\n    node = node.next;\n  }\n  return node;\n}\n\n\n\n# 删除\n\n链表的删除相对来说比较简单，直接拿掉特定节点即可，这一点，相对于数组来说有优势的，因为在数组删除元素后，需要把元素统统往前挪动一位，然后才能把 size 减少。\n\nWARNING\n\n当数据的每个单元是一个复杂结构的时候，这个拷贝时间的开销可是不能忽略的。\n\n链表节点的删除过程：\n\n/**\n * 从链表中删除值为val的节点\n * @param {Node<number>} head 链表的头结点\n * @param {number} val 待删除的值\n */\nfunction remove(head, val) {\n  if (!head) {\n    console.warn("can not remove element from empty linked list");\n    return;\n  }\n  let node = head;\n  let pre = null;\n  while (node) {\n    // 找到了目标节点，需要结束循环\n    if (node.value != val) {\n      break;\n    }\n    pre = node;\n    node = node.next;\n  }\n  // 如果pre存在的话，说明用户删除的不是头结点\n  if (pre) {\n    // 如图第二步\n    pre.next = node.next;\n    // 如图第三步\n    node.next = null;\n    node = null;\n  } else {\n    // 删除头结点时，首先得用临时变量把第二个节点先记下来（哪怕它不存在）\n    let nextHead = head.next;\n    // 解除头结点对第二个节点的引用\n    head.next = null;\n    // 让头结点指针指向下一个节点\n    head = nextHead;\n  }\n  return head;\n}\n\n\n\n# 结语\n\n链表相对于数组还有一个优势是在内存足够的前提下，其长度是可以无限增长的。链表在初始化的的时候无需知道表长，而数组必须确定表长（此性质不考虑 JavaScript 语言），对于其它语言来说（C#，Java 等）数组的扩容代价相对较大，首先需要向系统申请更长的连续空间（在某些情况下是可能申请不到的），然后需要把旧数据拷贝到新数组里面去，然后再将原来的数组释放，而在每个数据项比较大的情况下，这个拷贝时间是不能被忽略的。\n\n链表平均算法复杂度与数组的比较如下：\n\n操作            数组     链表\n随机访问          O(1)   O(N)\n插入(不考虑前置查找)   O(N)   O(1)\n查找            O(N)   O(N)\n删除(不考虑前置查找)   O(N)   O(1)\n\n但是如果需要对其数据进行排序的话，有些排序算法是不能直接用的，在实际开发中我们需要根据需求选择链表还是数组。\n\n常见的应用链表的场景，如流程引擎中编辑过程，如果使用数组的话，当用户频繁的更改关系，其操作变得相当笨重，而使用链表仅修改节点的前驱和 后继指针而已。\n\n还有在查找节，多层链表结合二分查找，可以实现高效的跳(跃)(链)表',normalizedContent:'# 链表\n\n链表，是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。\n\n链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。\n\n一般我们说链表都是指的是单向链表。\n\n\n# 链表的一般数据结构定义\n\ninterface linkedlistnode<t> {\n  /**\n   * 链表的数据域\n   */\n  data: t;\n  /**\n   * 链表的后继节点域\n   */\n  next: linkedlistnode<t> | null;\n}\n\n\n\n# 链表的操作\n\n对于链表的操作，我个人感觉最重要的两个操作就是初始化和遍历。对于链表的操作有些同学喜欢在头放一个空节点，这是属于个人的编程习惯，而我一般不喜欢（可不是出于节约内存的想法哦，哈哈哈），因此，选择一个适合你的习惯即可。以下的所有代码实现均不包含空的头结点。\n\n\n# 初始化\n\n初始化，即把一堆数据构造成链表。对于链表的初始化一般有两种操作：即头插法和尾插法。 头插法：用一个变量指向已有链表的头结点，每次新来的节点都插在头结点的前面，再让这个变量指向新插入的节点，因此头插法构建出的链表数据的顺序和输入的顺序是相反的。\n\n头插法插入节点的过程：\n\n/**\n * 以头插法初始化链表\n * @param {array<number>} arr 用于初始化链表的数据\n */\nfunction initialize(arr) {\n  // 如果图中第一步\n  let head = null;\n  // 此例中无用，仅用于阐述问题\n  let tail = null;\n  arr.foreach((val) => {\n    const node = createnode(val);\n    // 如果是空链表的话，直接让头结点指针指向第一个节点\n    if (head == null) {\n      // 如图第二步\n      head = node;\n      // 此例中无用，仅用于阐述问题\n      tail = node;\n    } else {\n      //先让新来的节点指向head节点，如图第三步\n      node.next = head;\n      // 再让head指针指向最新的节点，如图第四步\n      head = node;\n    }\n  });\n  return head;\n}\n\n\n尾插法：用一个变量指向已有链表的尾结点，每次新来的节点都插在尾结点的后面，再让这个变量指向新插入的尾结点，因此尾插法构建出的链表数据的顺序和输入的顺序是相同的。\n\n尾插法插入节点的过程：\n\n/**\n * 以尾插法初始化链表\n * @param {array<number>} arr 用于初始化链表的数据\n */\nfunction initialize(arr) {\n  // 如图第一步\n  let head = null;\n  let tail = null;\n  arr.foreach((val) => {\n    const node = createnode(val);\n    if (head == null) {\n      // 如果是空链表的话，直接让头结点指针和尾结点指针指向第一个节点，对应图中第一步\n      head = node;\n      tail = node;\n    } else {\n      // 让尾结点的后继指针指向新来的节点, 如图第三步\n      tail.next = node;\n      // 让尾节点指针指向最后一个节点，如图第四步\n      tail = node;\n    }\n  });\n  return head;\n}\n\n\n我个人编程习惯喜欢用第二种，但是即使是使用头插法，你也可以多用一个变量来记住链表的尾结点，这样的好处就是如果某个时刻你需要在尾部插入的话，可以直接用尾节点指针而不用再去遍历了。\n\n\n# 遍历\n\n链表的遍历几乎可以说是一种标准范式了，这是对于链表一定得掌握的知识。对于单向链表，只要给头指针就可以完成遍历。\n\n编程技巧\n\n在遍历链表时，我们有时候会申明一个前驱节点，这样可以使得在遍历的过程中，既能找到当前节点，又可以找到当前节点的前驱节点，在某些时候非常好用，这也是一个必须掌握的编程技巧。\n\n需要注意的是在遍历链表的过程中不要修改头指针，因为一旦修改了头指针就找不回来了，万一需要用到头指针，那代码又得重新设计。\n\n链表遍历的复杂度为o(n);\n\n/**\n * 遍历链表\n * @param {node<number>} head 链表头指针\n */\nfunction traverse(head) {\n  let node = head;\n  // pre在本例中无用，仅用于说明这是一种编程技巧\n  let pre = null;\n  // 如果当前节点指向空 （对于空链表，开始就直接指向空）\n  while (node) {\n    console.log(node);\n    // 让pre滞后，这样可以永远保证pre指向node的前一个节点（如果node是null,pre指向最后一个节点，如果node是第一个节点或者链表是空表，pre指向null）\n    pre = node;\n    node = node.next;\n  }\n}\n\n\n\n# 插入\n\n对于链表的操作操作一定要谨慎，否则容易丢失后继节点或者使得链表的节点指向表现非预期。\n\n我们演示一下在表中部插入节点的场景，其流程如下：\n\n伪代码描述即：newnode.next = node; pre.next = newnode; 这两行代码一定不能交换。\n\n链表插入的平均时间复杂度为：o(n);\n\n/**\n * 在链表中指定的k位置插入节点, 如果k小于1，则插在头部，如果k大于链表的长度，则直接插在尾部\n * @param {node<number>} head 链表头\n * @param {number} val 节点值\n * @param {number} k 插入的位置,k为节点数,不是索引\n */\nfunction insert(head, val, k) {\n  const newnode = createnode(val);\n  // 如果需要插在头部的话\n  if (k < 1) {\n    newnode.next = head;\n    head = newnode;\n    return head;\n  }\n  let node = head;\n  // 申明一个空指针，因为其滞后node一个表结点，主要是用来记录上一个节点\n  let pre = null;\n  // 申明一个计数器，用于标记已经遍历的节点的个数\n  let counter = 0;\n  let inserted = false;\n  while (node) {\n    counter++;\n    // 如果找到了合适的插入位置，插入完成以后就没有继续循环的必要了\n    if (counter === k) {\n      // 必须先用一个临时变量将其记住，否则会丢失后继节点\n      let nextnode = node.next;\n      // 插入新的节点\n      node.next = newnode;\n      newnode.next = nextnode;\n      // 标记插入完成\n      inserted = true;\n      break;\n    }\n    // 先把当前这个节点记住，然后向后迭代\n    pre = node;\n    node = node.next;\n  }\n  // 如果已经插入了的哈，就不用再管什么事儿了\n  if (inserted) {\n    return head;\n  }\n  // 如果k大于等于链表的长度的话，就直接插在链表尾部即可\n  if (counter < k && pre) {\n    // 此刻的node已经是null了，而pre指针指向链表的最后一个节点\n    pre.next = newnode;\n  } else {\n    // 如果链表是空表，之前的循环一次都没有执行的，那么直接让head指向新来的节点即可\n    head = newnode;\n  }\n  return head;\n}\n\n\n\n# 查找\n\n查找主要分为按值查找或者按位置查找。 查找的思路和遍历类似。\n\n查找的平均算法复杂度为o(n)。\n\n/**\n * 根据索引查找链表节点\n * @param {node<number>} head 链表头结点\n * @param {number} idx 目标索引\n */\nfunction findindex(head, idx) {\n  let node = head;\n  let counter = 0;\n  // 找到表尾没有找到目标索引 或者 找到了目标索引 结束循环\n  while (node && counter < idx) {\n    counter++;\n    node = node.next;\n  }\n  return counter === idx ? node : null;\n}\n\n/**\n * 根据节点值查找节点\n * @param {node<number>} head 链表头结点\n * @param {number} val 目标节点值\n */\nfunction find(head, val) {\n  let node = head;\n  // 找到节点值或遍历到链表结束，终止循环\n  while (node && node.val !== val) {\n    node = node.next;\n  }\n  return node;\n}\n\n\n\n# 删除\n\n链表的删除相对来说比较简单，直接拿掉特定节点即可，这一点，相对于数组来说有优势的，因为在数组删除元素后，需要把元素统统往前挪动一位，然后才能把 size 减少。\n\nwarning\n\n当数据的每个单元是一个复杂结构的时候，这个拷贝时间的开销可是不能忽略的。\n\n链表节点的删除过程：\n\n/**\n * 从链表中删除值为val的节点\n * @param {node<number>} head 链表的头结点\n * @param {number} val 待删除的值\n */\nfunction remove(head, val) {\n  if (!head) {\n    console.warn("can not remove element from empty linked list");\n    return;\n  }\n  let node = head;\n  let pre = null;\n  while (node) {\n    // 找到了目标节点，需要结束循环\n    if (node.value != val) {\n      break;\n    }\n    pre = node;\n    node = node.next;\n  }\n  // 如果pre存在的话，说明用户删除的不是头结点\n  if (pre) {\n    // 如图第二步\n    pre.next = node.next;\n    // 如图第三步\n    node.next = null;\n    node = null;\n  } else {\n    // 删除头结点时，首先得用临时变量把第二个节点先记下来（哪怕它不存在）\n    let nexthead = head.next;\n    // 解除头结点对第二个节点的引用\n    head.next = null;\n    // 让头结点指针指向下一个节点\n    head = nexthead;\n  }\n  return head;\n}\n\n\n\n# 结语\n\n链表相对于数组还有一个优势是在内存足够的前提下，其长度是可以无限增长的。链表在初始化的的时候无需知道表长，而数组必须确定表长（此性质不考虑 javascript 语言），对于其它语言来说（c#，java 等）数组的扩容代价相对较大，首先需要向系统申请更长的连续空间（在某些情况下是可能申请不到的），然后需要把旧数据拷贝到新数组里面去，然后再将原来的数组释放，而在每个数据项比较大的情况下，这个拷贝时间是不能被忽略的。\n\n链表平均算法复杂度与数组的比较如下：\n\n操作            数组     链表\n随机访问          o(1)   o(n)\n插入(不考虑前置查找)   o(n)   o(1)\n查找            o(n)   o(n)\n删除(不考虑前置查找)   o(n)   o(1)\n\n但是如果需要对其数据进行排序的话，有些排序算法是不能直接用的，在实际开发中我们需要根据需求选择链表还是数组。\n\n常见的应用链表的场景，如流程引擎中编辑过程，如果使用数组的话，当用户频繁的更改关系，其操作变得相当笨重，而使用链表仅修改节点的前驱和 后继指针而已。\n\n还有在查找节，多层链表结合二分查找，可以实现高效的跳(跃)(链)表',charsets:{cjk:!0}},{title:"合并 2 个有序数组",frontmatter:{},regularPath:"/data-structure/list/mergeArray.html",relativePath:"data-structure/list/mergeArray.md",key:"v-03d8873b",path:"/data-structure/list/mergeArray.html",headers:[{level:2,title:"合并 2 个有序数组",slug:"合并-2-个有序数组",normalizedTitle:"合并 2 个有序数组",charIndex:2},{level:3,title:"描述",slug:"描述",normalizedTitle:"描述",charIndex:17},{level:3,title:"思路分析",slug:"思路分析",normalizedTitle:"思路分析",charIndex:58},{level:3,title:"算法实现",slug:"算法实现",normalizedTitle:"算法实现",charIndex:256},{level:2,title:"合并 K 有序个数组",slug:"合并-k-有序个数组",normalizedTitle:"合并 k 有序个数组",charIndex:979},{level:3,title:"描述",slug:"描述-2",normalizedTitle:"描述",charIndex:17},{level:3,title:"思路分析",slug:"思路分析-2",normalizedTitle:"思路分析",charIndex:58},{level:3,title:"算法实现",slug:"算法实现-2",normalizedTitle:"算法实现",charIndex:256}],headersStr:"合并 2 个有序数组 描述 思路分析 算法实现 合并 K 有序个数组 描述 思路分析 算法实现",content:'# 合并 2 个有序数组\n\n\n# 描述\n\n给你 2 个不降序数组，合并之后得到的数组仍然保持不降序的性质。\n\n\n# 思路分析\n\n首先，我们需要需要一个新的数组存储合并之后的结果，因为 JS 的数组是自动扩容的，所以我们不需要考虑数组的容量问题。然后定义两个偏移变量，用于判断合并的进程。当这两个偏移量都在对应数组的范围内时，我们分别读取两个数组当前偏移位置的数据，把小的那个加入到结果中，同时对应的偏移量+1。当一个数组已经合并完成之后，另外一个数组可能还有内容，我只需要直接将其内容追加到结果中即可。\n\n\n# 算法实现\n\n/**\n * 合并2个有序数组\n * @param {number[]} arr1\n * @param {number[]} arr2\n */\nfunction merge(arr1, arr2) {\n  let offset1 = 0;\n  let offset2 = 0;\n  let offset = 0;\n  let newArr = [];\n  // 当两个数组都还没有处理完成的时候\n  while (offset1 < arr1.length && offset2 < arr2.length) {\n    let val1 = arr1[offset1];\n    let val2 = arr2[offset2];\n    if (val1 >= val2) {\n      newArr[offset++] = arr2[offset2++];\n    } else {\n      newArr[offset++] = arr1[offset1++];\n    }\n  }\n  /**\n   * 这两个while不可能同时成立，只有可能成立一个，将数组长度较大的剩余部分拷贝给新数组\n   */\n  while (offset1 < arr1.length) {\n    newArr[offset++] = arr1[offset1++];\n  }\n  while (offset2 < arr2.length) {\n    newArr[offset++] = arr2[offset2++];\n  }\n  return newArr;\n}\n\n\n请记住这个范式，在将来的归并排序中，我们还要用到它。\n\n\n# 合并 K 有序个数组\n\n\n# 描述\n\n给你 K 个不降序数组，合并之后得到的数组仍然保持不降序的性质。\n\n\n# 思路分析\n\n朴素法：每次从这个 K 数组中出一个最小的，如果当前数组为空则跳过，直到所有的数组都为空，即可完成合并。\n\n建堆法：每次从这个 K 个数组的第 i 中出一个数，将其插入到一个最小堆中，当第 i 个数组为空时，继续处理下一个数组，直到所有的数组都处理完成，然后将堆中的数组依次出堆，则可得到最后的结果。\n\n归并法：\n\n每次选两个数组进行归并，将本轮归并的结果添加到一个新数组中，然后对新数组再次归并，重复这个过程，直到得到的新数组为 1 个，则这最后的一个数组则是结果。\n\n\n# 算法实现\n\n# 建堆法的算法实现：\n\n朴素法效率较低，此处就不展示代码了，有兴趣的读者可以自行实现。\n\n# 建堆法的算法实现：\n\n/**\n * 抽象堆\n */\nclass Heap {\n  get count() {\n    return this.size;\n  }\n  /**\n   * 定义哨兵的最值，所有插入堆的元素都必须和这个值比较\n   */\n  SENTRY;\n\n  /**\n   * 定义一个存储数据的内存空间\n   */\n  data = [];\n\n  /**\n   * 当前堆的元素个数\n   */\n  size = 0;\n\n  /**\n   * 比较函数, 通过先前和当前元素的比较，决定是否将当前元素提置先前元素前\n   */\n  compare;\n\n  /**\n   * 自身用于比较的函数\n   * @param preVal 被比较的值\n   * @param curVal 当前值\n   */\n  selfCompare(preVal, curVal) {\n    return this.compare(preVal, curVal);\n  }\n\n  validInitParams() {\n    if (this.SENTRY === void 0) {\n      throw `can not insert queue before the sentry been set `;\n    }\n    if (this.compare === void 0) {\n      throw `can not insert queue before the compare callback been set `;\n    }\n  }\n\n  constructor(...initElements) {\n    // 初始化数组元素\n    initElements.forEach((v, i) => {\n      this.data[i + 1] = v;\n      this.size++;\n    });\n    this.buildHeap();\n  }\n\n  /**\n   * 设置哨兵元素\n   * @param sentryEle\n   */\n  setSentry(sentryEle) {\n    this.SENTRY = sentryEle;\n    this.data[0] = this.SENTRY;\n  }\n\n  /**\n   * 设置比较函数\n   * @param compareFunc 比较函数\n   */\n  setCompare(compareFunc) {\n    this.compare = compareFunc;\n  }\n\n  /**\n   * 获取堆中最小的元素\n   * @returns\n   */\n  getTop() {\n    if (this.size == 0) {\n      throw `can not get element from an empty heap`;\n    }\n    return this.data[1];\n  }\n\n  /**\n   * 判断堆是否为空\n   * @returns\n   */\n  isEmpty() {\n    return this.size === 0;\n  }\n\n  /**\n   * 向堆中插入一个合法值\n   * @param val\n   */\n  insertQueue(val) {\n    this.validInitParams();\n    if (this.selfCompare(this.SENTRY, val)) {\n      throw `can not insert val bigger or smaller than ${this.SENTRY}`;\n    }\n    // 堆的容量扩充1\n    this.size++;\n    // 让i指向当前新位置\n    let i = this.size;\n    // 因为有哨兵的关系，不需要添加约束条件 i > 0\n    // this.#data[Math.floor(i / 2)] > val\n    while (this.selfCompare(this.data[Math.floor(i / 2)], val)) {\n      this.data[i] = this.data[Math.floor(i / 2)];\n      i = Math.floor(i / 2);\n    }\n    this.data[i] = val;\n  }\n\n  /**\n   * 获取堆中的最小元素\n   * @returns {T}\n   */\n  deleteQueue() {\n    if (this.isEmpty()) {\n      throw "can not delete element from empty heap";\n    }\n    // 取出堆顶的元素\n    let firstVal = this.data[1];\n    let temp = this.data[this.size--];\n    this.data[1] = temp;\n    // JavaScript语言需要进行这一步，让数组的规模缩小，释放空间\n    this.data.length--;\n    this.percDown(1);\n    return firstVal;\n  }\n\n  /**\n   * 下滤：将堆中以堆data[p]为根的子堆调整为最小堆\n   * @param p 根节点索引\n   */\n  percDown(p) {\n    let parent, child;\n    let temp = this.data[p]; /* 取出根结点存放的值 */\n    for (parent = p; parent * 2 <= this.size; parent = child) {\n      child = parent * 2;\n      /* child指向左右子结点的较?者 */\n      if (child != this.size && this.selfCompare(this.data[child], this.data[child + 1])) {\n        child++;\n      }\n      /* 找到了合适位置 */\n      if (this.selfCompare(this.data[child], temp)) {\n        break;\n      } else {\n        /* 下滤X */\n        this.data[parent] = this.data[child];\n      }\n    }\n    this.data[parent] = temp;\n  }\n\n  /**\n   * 构建堆\n   */\n  buildHeap() {\n    /* 调整data中的元素，使满足最堆的有序性  */\n    /* 这里所有size个元素已经存在data[]中 */\n    /* 从最后一个结点的父节点开始，到根结点1 */\n    for (let i = Math.floor(this.size / 2); i > 0; i--) {\n      this.percDown(i);\n    }\n  }\n}\n\n/**\n * 堆元素为number的最小堆\n */\nclass SimpleMinHeap extends Heap {\n  constructor(...initElements) {\n    super(...initElements);\n    this.setSentry(-Infinity);\n    this.setCompare((preVal, curVal) => {\n      return preVal >= curVal;\n    });\n  }\n\n  deleteMin() {\n    return this.deleteQueue();\n  }\n\n  getMin() {\n    return this.getTop();\n  }\n}\n\n/**\n * 合并K个有序数组\n * @param {number[][]} arrs\n */\nfunction mergeKArray(arrs) {\n  let minHeap = new SimpleMinHeap();\n  let offset = 0;\n  while(offset < arrs.length) {\n    let currentArr = arrs[offset];\n    // 处理一个数组，直至为空\n    while(currentArr.length) {\n      const ele = currentArr.shift();\n      minHeap.insertQueue(ele);\n    }\n    offset++;\n  }\n  let newArr = [];\n  let idx = 0;\n  // 输出堆，得到最终结果\n  while(!minHeap.isEmpty()) {\n    const ele = minHeap.deleteMin();\n    newArr[idx++] = ele;\n  }\n  return newArr;\n}\n\n\n上述代码看起来比较长，主要是我们实现了一个堆（实际开发中，这是一个可以封装进成熟的代码库的操作，并不需要我们自己实现），但是其实大家只需要看关键的函数mergeKArray\n\n# 归并法的算法实现\n\n归并法我们需要把上面合并 2 个有序数组的代码 copy 过来进行一下简单的修改，因为在归并的过程中，有可能剩下的数组只有可能存在一个了。修改点非常简单，只需要在第二个数组上加上默认值即可。\n\n/**\n * 合并2个有序数组\n * @param {number[]} arr1\n * @param {number[]} arr2 可选参数，若不传递该参数，则相当于将原数组copy一份\n */\nfunction merge(arr1, arr2 = []) {\n  let offset1 = 0;\n  let offset2 = 0;\n  let offset = 0;\n  let newArr = [];\n  // 当两个数组都还没有处理完成的时候\n  while (offset1 < arr1.length && offset2 < arr2.length) {\n    let val1 = arr1[offset1];\n    let val2 = arr2[offset2];\n    if (val1 >= val2) {\n      newArr[offset++] = arr2[offset2++];\n    } else {\n      newArr[offset++] = arr1[offset1++];\n    }\n  }\n  /**\n   * 这两个while不可能同时成立，只有可能成立一个，将数组长度较大的剩余部分拷贝给新数组\n   */\n  while (offset1 < arr1.length) {\n    newArr[offset++] = arr1[offset1++];\n  }\n  while (offset2 < arr2.length) {\n    newArr[offset++] = arr2[offset2++];\n  }\n  return newArr;\n}\n\n/**\n * 合并K个有序数组\n * @param {number[][]} arrs\n */\nfunction mergeKArray(arrs) {\n  let mergedArr = arrs;\n  // 如果归并结果大于1，则需要继续进行归并\n  while (mergedArr.length > 1) {\n    // 本轮的归并结果\n    const mergePassArr = [];\n    for (let i = 0; i < mergedArr.length; i += 2) {\n      // 得到二路归并的结果\n      const newArr = merge(mergedArr[i], mergedArr[i + 1]);\n      mergePassArr.push(newArr);\n    }\n    // 将本轮的归并结果给最终的合并结果，使之可以继续下一轮归并\n    mergedArr = mergePassArr;\n  }\n  // 如果归并0个数组，则返回空，否则返回正常的归并结果\n  return mergedArr.length ? mergedArr[0] : [];\n}\n',normalizedContent:'# 合并 2 个有序数组\n\n\n# 描述\n\n给你 2 个不降序数组，合并之后得到的数组仍然保持不降序的性质。\n\n\n# 思路分析\n\n首先，我们需要需要一个新的数组存储合并之后的结果，因为 js 的数组是自动扩容的，所以我们不需要考虑数组的容量问题。然后定义两个偏移变量，用于判断合并的进程。当这两个偏移量都在对应数组的范围内时，我们分别读取两个数组当前偏移位置的数据，把小的那个加入到结果中，同时对应的偏移量+1。当一个数组已经合并完成之后，另外一个数组可能还有内容，我只需要直接将其内容追加到结果中即可。\n\n\n# 算法实现\n\n/**\n * 合并2个有序数组\n * @param {number[]} arr1\n * @param {number[]} arr2\n */\nfunction merge(arr1, arr2) {\n  let offset1 = 0;\n  let offset2 = 0;\n  let offset = 0;\n  let newarr = [];\n  // 当两个数组都还没有处理完成的时候\n  while (offset1 < arr1.length && offset2 < arr2.length) {\n    let val1 = arr1[offset1];\n    let val2 = arr2[offset2];\n    if (val1 >= val2) {\n      newarr[offset++] = arr2[offset2++];\n    } else {\n      newarr[offset++] = arr1[offset1++];\n    }\n  }\n  /**\n   * 这两个while不可能同时成立，只有可能成立一个，将数组长度较大的剩余部分拷贝给新数组\n   */\n  while (offset1 < arr1.length) {\n    newarr[offset++] = arr1[offset1++];\n  }\n  while (offset2 < arr2.length) {\n    newarr[offset++] = arr2[offset2++];\n  }\n  return newarr;\n}\n\n\n请记住这个范式，在将来的归并排序中，我们还要用到它。\n\n\n# 合并 k 有序个数组\n\n\n# 描述\n\n给你 k 个不降序数组，合并之后得到的数组仍然保持不降序的性质。\n\n\n# 思路分析\n\n朴素法：每次从这个 k 数组中出一个最小的，如果当前数组为空则跳过，直到所有的数组都为空，即可完成合并。\n\n建堆法：每次从这个 k 个数组的第 i 中出一个数，将其插入到一个最小堆中，当第 i 个数组为空时，继续处理下一个数组，直到所有的数组都处理完成，然后将堆中的数组依次出堆，则可得到最后的结果。\n\n归并法：\n\n每次选两个数组进行归并，将本轮归并的结果添加到一个新数组中，然后对新数组再次归并，重复这个过程，直到得到的新数组为 1 个，则这最后的一个数组则是结果。\n\n\n# 算法实现\n\n# 建堆法的算法实现：\n\n朴素法效率较低，此处就不展示代码了，有兴趣的读者可以自行实现。\n\n# 建堆法的算法实现：\n\n/**\n * 抽象堆\n */\nclass heap {\n  get count() {\n    return this.size;\n  }\n  /**\n   * 定义哨兵的最值，所有插入堆的元素都必须和这个值比较\n   */\n  sentry;\n\n  /**\n   * 定义一个存储数据的内存空间\n   */\n  data = [];\n\n  /**\n   * 当前堆的元素个数\n   */\n  size = 0;\n\n  /**\n   * 比较函数, 通过先前和当前元素的比较，决定是否将当前元素提置先前元素前\n   */\n  compare;\n\n  /**\n   * 自身用于比较的函数\n   * @param preval 被比较的值\n   * @param curval 当前值\n   */\n  selfcompare(preval, curval) {\n    return this.compare(preval, curval);\n  }\n\n  validinitparams() {\n    if (this.sentry === void 0) {\n      throw `can not insert queue before the sentry been set `;\n    }\n    if (this.compare === void 0) {\n      throw `can not insert queue before the compare callback been set `;\n    }\n  }\n\n  constructor(...initelements) {\n    // 初始化数组元素\n    initelements.foreach((v, i) => {\n      this.data[i + 1] = v;\n      this.size++;\n    });\n    this.buildheap();\n  }\n\n  /**\n   * 设置哨兵元素\n   * @param sentryele\n   */\n  setsentry(sentryele) {\n    this.sentry = sentryele;\n    this.data[0] = this.sentry;\n  }\n\n  /**\n   * 设置比较函数\n   * @param comparefunc 比较函数\n   */\n  setcompare(comparefunc) {\n    this.compare = comparefunc;\n  }\n\n  /**\n   * 获取堆中最小的元素\n   * @returns\n   */\n  gettop() {\n    if (this.size == 0) {\n      throw `can not get element from an empty heap`;\n    }\n    return this.data[1];\n  }\n\n  /**\n   * 判断堆是否为空\n   * @returns\n   */\n  isempty() {\n    return this.size === 0;\n  }\n\n  /**\n   * 向堆中插入一个合法值\n   * @param val\n   */\n  insertqueue(val) {\n    this.validinitparams();\n    if (this.selfcompare(this.sentry, val)) {\n      throw `can not insert val bigger or smaller than ${this.sentry}`;\n    }\n    // 堆的容量扩充1\n    this.size++;\n    // 让i指向当前新位置\n    let i = this.size;\n    // 因为有哨兵的关系，不需要添加约束条件 i > 0\n    // this.#data[math.floor(i / 2)] > val\n    while (this.selfcompare(this.data[math.floor(i / 2)], val)) {\n      this.data[i] = this.data[math.floor(i / 2)];\n      i = math.floor(i / 2);\n    }\n    this.data[i] = val;\n  }\n\n  /**\n   * 获取堆中的最小元素\n   * @returns {t}\n   */\n  deletequeue() {\n    if (this.isempty()) {\n      throw "can not delete element from empty heap";\n    }\n    // 取出堆顶的元素\n    let firstval = this.data[1];\n    let temp = this.data[this.size--];\n    this.data[1] = temp;\n    // javascript语言需要进行这一步，让数组的规模缩小，释放空间\n    this.data.length--;\n    this.percdown(1);\n    return firstval;\n  }\n\n  /**\n   * 下滤：将堆中以堆data[p]为根的子堆调整为最小堆\n   * @param p 根节点索引\n   */\n  percdown(p) {\n    let parent, child;\n    let temp = this.data[p]; /* 取出根结点存放的值 */\n    for (parent = p; parent * 2 <= this.size; parent = child) {\n      child = parent * 2;\n      /* child指向左右子结点的较?者 */\n      if (child != this.size && this.selfcompare(this.data[child], this.data[child + 1])) {\n        child++;\n      }\n      /* 找到了合适位置 */\n      if (this.selfcompare(this.data[child], temp)) {\n        break;\n      } else {\n        /* 下滤x */\n        this.data[parent] = this.data[child];\n      }\n    }\n    this.data[parent] = temp;\n  }\n\n  /**\n   * 构建堆\n   */\n  buildheap() {\n    /* 调整data中的元素，使满足最堆的有序性  */\n    /* 这里所有size个元素已经存在data[]中 */\n    /* 从最后一个结点的父节点开始，到根结点1 */\n    for (let i = math.floor(this.size / 2); i > 0; i--) {\n      this.percdown(i);\n    }\n  }\n}\n\n/**\n * 堆元素为number的最小堆\n */\nclass simpleminheap extends heap {\n  constructor(...initelements) {\n    super(...initelements);\n    this.setsentry(-infinity);\n    this.setcompare((preval, curval) => {\n      return preval >= curval;\n    });\n  }\n\n  deletemin() {\n    return this.deletequeue();\n  }\n\n  getmin() {\n    return this.gettop();\n  }\n}\n\n/**\n * 合并k个有序数组\n * @param {number[][]} arrs\n */\nfunction mergekarray(arrs) {\n  let minheap = new simpleminheap();\n  let offset = 0;\n  while(offset < arrs.length) {\n    let currentarr = arrs[offset];\n    // 处理一个数组，直至为空\n    while(currentarr.length) {\n      const ele = currentarr.shift();\n      minheap.insertqueue(ele);\n    }\n    offset++;\n  }\n  let newarr = [];\n  let idx = 0;\n  // 输出堆，得到最终结果\n  while(!minheap.isempty()) {\n    const ele = minheap.deletemin();\n    newarr[idx++] = ele;\n  }\n  return newarr;\n}\n\n\n上述代码看起来比较长，主要是我们实现了一个堆（实际开发中，这是一个可以封装进成熟的代码库的操作，并不需要我们自己实现），但是其实大家只需要看关键的函数mergekarray\n\n# 归并法的算法实现\n\n归并法我们需要把上面合并 2 个有序数组的代码 copy 过来进行一下简单的修改，因为在归并的过程中，有可能剩下的数组只有可能存在一个了。修改点非常简单，只需要在第二个数组上加上默认值即可。\n\n/**\n * 合并2个有序数组\n * @param {number[]} arr1\n * @param {number[]} arr2 可选参数，若不传递该参数，则相当于将原数组copy一份\n */\nfunction merge(arr1, arr2 = []) {\n  let offset1 = 0;\n  let offset2 = 0;\n  let offset = 0;\n  let newarr = [];\n  // 当两个数组都还没有处理完成的时候\n  while (offset1 < arr1.length && offset2 < arr2.length) {\n    let val1 = arr1[offset1];\n    let val2 = arr2[offset2];\n    if (val1 >= val2) {\n      newarr[offset++] = arr2[offset2++];\n    } else {\n      newarr[offset++] = arr1[offset1++];\n    }\n  }\n  /**\n   * 这两个while不可能同时成立，只有可能成立一个，将数组长度较大的剩余部分拷贝给新数组\n   */\n  while (offset1 < arr1.length) {\n    newarr[offset++] = arr1[offset1++];\n  }\n  while (offset2 < arr2.length) {\n    newarr[offset++] = arr2[offset2++];\n  }\n  return newarr;\n}\n\n/**\n * 合并k个有序数组\n * @param {number[][]} arrs\n */\nfunction mergekarray(arrs) {\n  let mergedarr = arrs;\n  // 如果归并结果大于1，则需要继续进行归并\n  while (mergedarr.length > 1) {\n    // 本轮的归并结果\n    const mergepassarr = [];\n    for (let i = 0; i < mergedarr.length; i += 2) {\n      // 得到二路归并的结果\n      const newarr = merge(mergedarr[i], mergedarr[i + 1]);\n      mergepassarr.push(newarr);\n    }\n    // 将本轮的归并结果给最终的合并结果，使之可以继续下一轮归并\n    mergedarr = mergepassarr;\n  }\n  // 如果归并0个数组，则返回空，否则返回正常的归并结果\n  return mergedarr.length ? mergedarr[0] : [];\n}\n',charsets:{cjk:!0}},{title:"算法介绍",frontmatter:{},regularPath:"/data-structure/list/lru-cache.html",relativePath:"data-structure/list/lru-cache.md",key:"v-7af007f5",path:"/data-structure/list/lru-cache.html",headers:[{level:2,title:"算法介绍",slug:"算法介绍",normalizedTitle:"算法介绍",charIndex:2},{level:2,title:"思路分析",slug:"思路分析",normalizedTitle:"思路分析",charIndex:258},{level:2,title:"算法实现",slug:"算法实现",normalizedTitle:"算法实现",charIndex:614},{level:2,title:"应用场景",slug:"应用场景",normalizedTitle:"应用场景",charIndex:3106}],headersStr:"算法介绍 思路分析 算法实现 应用场景",content:'# 算法介绍\n\nLRU是 Least Recently Used 的缩写，即最近最少使用，是一种常用的页面置换算法，选择最近最久未使用的页面予以淘汰。该算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 t，当须淘汰一个页面时，选择现有页面中其 t 值最大的，即最近最少使用的页面予以淘汰。（copy 自百度百科）\n\n听君一席话，如听君一席话，上述描述理解起来还挺费劲儿，我觉得简单点儿就是，每次访问缓存，都把当前访问节点的权重更新，如果新增内容且超出了容量，则删除权重最低的即可。\n\n\n# 思路分析\n\n由于缓存都是有频繁的访问（如果不频繁访问，那缓存就没有意义了）的，如何提高效率是一个值得商榷的事情。最好让我们的get和set都是O(1)，那是最好不过的了。\n\n可能做到吗？先思考一下拥有O(1)访问效率的数据结构有哪些：\n\n哈希表或数组在获取内容的时候访问效率为 O(1);链表在插入或删除时，如无前置查找，效率为O(1)。\n\n那我们即可构建一个链表，用一个哈希表记住链表上的每个节点，如果获取到节点，需要将缓存更新，则将其提到链表的最前面，如果新增内容超出了缓存的最大容量，只需要删除最后一个节点即可，并且把新来的节点插入到链表头部。\n\n考虑到在获取到链表中部的节点时，为了方便找前驱节点和后继节点，那么，我们得考虑使用双向链表。通过这样设计的话，我们get和set的效率都为O(1)。\n\n\n# 算法实现\n\n/**\n * @param {number} capacity\n */\nvar LRUCache = function (capacity) {\n  if (capacity <= 0) {\n    console.error("the LRUCache capacity must bigger than zero");\n  }\n  this.capacity = capacity;\n  this.size = 0;\n  /**\n   * @type { Map<any, DoubleLinkedListNode> }\n   */\n  this.mapping = new Map();\n  /**\n   * @type { DoubleLinkedListNode | null }\n   */\n  this.head = null;\n  /**\n   * @type { DoubleLinkedListNode | null }\n   */\n  this.tail = null;\n};\n\n/**\n * 刷新链表节点\n * @param {DoubleLinkedListNode} node\n * @returns\n */\nLRUCache.prototype.refresh = function (node) {\n  if (!node) {\n    console.warn("failed to refresh cache node");\n    return;\n  }\n  let prevNode = node.prev;\n  let nextNode = node.next;\n  // 如果不存在前驱节点，说明当前节点就是最近使用过的节点，无需刷新\n  if (!prevNode) {\n    // this.head = node;\n    return;\n  }\n  // 如果不存在后继节点，说明当前节点就是最后一个节点，直接提到最前面去\n  if (!nextNode) {\n    prevNode.next = null;\n    this.tail = prevNode;\n    node.next = this.head;\n    this.head.prev = node;\n    this.head = node;\n  }\n  // 如果同时存在前驱和后继节点\n  if (prevNode && nextNode) {\n    // 把原来的两个节点接到一起\n    prevNode.next = nextNode;\n    nextNode.prev = prevNode;\n    // 然后把当前这个节点提到最前面去\n    node.next = this.head;\n    this.head.prev = node;\n    node.prev = null;\n    this.head = node;\n  }\n};\n\n/**\n * @param {any} key\n * @return {number}\n */\nLRUCache.prototype.get = function (key) {\n  let node = this.mapping.get(key);\n  if (!node) {\n    return -1;\n  }\n  // 刷新节点\n  this.refresh(node);\n  return node.val;\n};\n\n/**\n * @param {any} key\n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function (key, value) {\n  let oldNode = this.mapping.get(key);\n  // 旧节点不存在\n  if (!oldNode) {\n    const newNode = this.createNode(key, value);\n    // 设置新值\n    this.mapping.set(key, newNode);\n    if (this.size === 0) {\n      this.head = newNode;\n      this.tail = newNode;\n    } else {\n      newNode.next = this.head;\n      this.head.prev = newNode;\n      this.head = newNode;\n    }\n    this.size++;\n    if (this.size > this.capacity) {\n      let oldKey = this.tail.key;\n      this.mapping.delete(oldKey);\n      // 解开最后一个节点\n      let preTail = this.tail.prev;\n      preTail.next = null;\n      this.tail.prev = null;\n      this.tail = preTail;\n      this.size--;\n    }\n  } else {\n    oldNode.val = value;\n    this.refresh(oldNode);\n  }\n};\n\n/**\n * 创建一个链表节点\n * @param {number} val\n * @returns {Node}\n */\nLRUCache.prototype.createNode = function (key, val) {\n  return {\n    prev: null,\n    next: null,\n    val,\n    key,\n  };\n};\n\n\n\n# 应用场景\n\n在 vue 中KeepAlive组件对于缓存实例数的控制就是用的 LRUCache;\n\n在 Vvu 使用SSR时，页面缓存也可以使用 LRUCache 算法；\n\n对于实际开发中，我们可以使用更成熟的第三方库，如lru-cache库，仓库地址。',normalizedContent:'# 算法介绍\n\nlru是 least recently used 的缩写，即最近最少使用，是一种常用的页面置换算法，选择最近最久未使用的页面予以淘汰。该算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 t，当须淘汰一个页面时，选择现有页面中其 t 值最大的，即最近最少使用的页面予以淘汰。（copy 自百度百科）\n\n听君一席话，如听君一席话，上述描述理解起来还挺费劲儿，我觉得简单点儿就是，每次访问缓存，都把当前访问节点的权重更新，如果新增内容且超出了容量，则删除权重最低的即可。\n\n\n# 思路分析\n\n由于缓存都是有频繁的访问（如果不频繁访问，那缓存就没有意义了）的，如何提高效率是一个值得商榷的事情。最好让我们的get和set都是o(1)，那是最好不过的了。\n\n可能做到吗？先思考一下拥有o(1)访问效率的数据结构有哪些：\n\n哈希表或数组在获取内容的时候访问效率为 o(1);链表在插入或删除时，如无前置查找，效率为o(1)。\n\n那我们即可构建一个链表，用一个哈希表记住链表上的每个节点，如果获取到节点，需要将缓存更新，则将其提到链表的最前面，如果新增内容超出了缓存的最大容量，只需要删除最后一个节点即可，并且把新来的节点插入到链表头部。\n\n考虑到在获取到链表中部的节点时，为了方便找前驱节点和后继节点，那么，我们得考虑使用双向链表。通过这样设计的话，我们get和set的效率都为o(1)。\n\n\n# 算法实现\n\n/**\n * @param {number} capacity\n */\nvar lrucache = function (capacity) {\n  if (capacity <= 0) {\n    console.error("the lrucache capacity must bigger than zero");\n  }\n  this.capacity = capacity;\n  this.size = 0;\n  /**\n   * @type { map<any, doublelinkedlistnode> }\n   */\n  this.mapping = new map();\n  /**\n   * @type { doublelinkedlistnode | null }\n   */\n  this.head = null;\n  /**\n   * @type { doublelinkedlistnode | null }\n   */\n  this.tail = null;\n};\n\n/**\n * 刷新链表节点\n * @param {doublelinkedlistnode} node\n * @returns\n */\nlrucache.prototype.refresh = function (node) {\n  if (!node) {\n    console.warn("failed to refresh cache node");\n    return;\n  }\n  let prevnode = node.prev;\n  let nextnode = node.next;\n  // 如果不存在前驱节点，说明当前节点就是最近使用过的节点，无需刷新\n  if (!prevnode) {\n    // this.head = node;\n    return;\n  }\n  // 如果不存在后继节点，说明当前节点就是最后一个节点，直接提到最前面去\n  if (!nextnode) {\n    prevnode.next = null;\n    this.tail = prevnode;\n    node.next = this.head;\n    this.head.prev = node;\n    this.head = node;\n  }\n  // 如果同时存在前驱和后继节点\n  if (prevnode && nextnode) {\n    // 把原来的两个节点接到一起\n    prevnode.next = nextnode;\n    nextnode.prev = prevnode;\n    // 然后把当前这个节点提到最前面去\n    node.next = this.head;\n    this.head.prev = node;\n    node.prev = null;\n    this.head = node;\n  }\n};\n\n/**\n * @param {any} key\n * @return {number}\n */\nlrucache.prototype.get = function (key) {\n  let node = this.mapping.get(key);\n  if (!node) {\n    return -1;\n  }\n  // 刷新节点\n  this.refresh(node);\n  return node.val;\n};\n\n/**\n * @param {any} key\n * @param {number} value\n * @return {void}\n */\nlrucache.prototype.put = function (key, value) {\n  let oldnode = this.mapping.get(key);\n  // 旧节点不存在\n  if (!oldnode) {\n    const newnode = this.createnode(key, value);\n    // 设置新值\n    this.mapping.set(key, newnode);\n    if (this.size === 0) {\n      this.head = newnode;\n      this.tail = newnode;\n    } else {\n      newnode.next = this.head;\n      this.head.prev = newnode;\n      this.head = newnode;\n    }\n    this.size++;\n    if (this.size > this.capacity) {\n      let oldkey = this.tail.key;\n      this.mapping.delete(oldkey);\n      // 解开最后一个节点\n      let pretail = this.tail.prev;\n      pretail.next = null;\n      this.tail.prev = null;\n      this.tail = pretail;\n      this.size--;\n    }\n  } else {\n    oldnode.val = value;\n    this.refresh(oldnode);\n  }\n};\n\n/**\n * 创建一个链表节点\n * @param {number} val\n * @returns {node}\n */\nlrucache.prototype.createnode = function (key, val) {\n  return {\n    prev: null,\n    next: null,\n    val,\n    key,\n  };\n};\n\n\n\n# 应用场景\n\n在 vue 中keepalive组件对于缓存实例数的控制就是用的 lrucache;\n\n在 vvu 使用ssr时，页面缓存也可以使用 lrucache 算法；\n\n对于实际开发中，我们可以使用更成熟的第三方库，如lru-cache库，仓库地址。',charsets:{cjk:!0}},{title:"队列",frontmatter:{},regularPath:"/data-structure/queue/desc.html",relativePath:"data-structure/queue/desc.md",key:"v-ea677b16",path:"/data-structure/queue/desc.html",headers:[{level:2,title:"队列",slug:"队列",normalizedTitle:"队列",charIndex:2},{level:2,title:"队列的通用数组实现",slug:"队列的通用数组实现",normalizedTitle:"队列的通用数组实现",charIndex:179},{level:2,title:"队列的通用链表实现",slug:"队列的通用链表实现",normalizedTitle:"队列的通用链表实现",charIndex:936},{level:2,title:"在 JavaScript 中使用队列",slug:"在-javascript-中使用队列",normalizedTitle:"在 javascript 中使用队列",charIndex:2469},{level:2,title:"队列的复杂度问题",slug:"队列的复杂度问题",normalizedTitle:"队列的复杂度问题",charIndex:2766},{level:2,title:"队列的应用",slug:"队列的应用",normalizedTitle:"队列的应用",charIndex:3091}],headersStr:"队列 队列的通用数组实现 队列的通用链表实现 在 JavaScript 中使用队列 队列的复杂度问题 队列的应用",content:'# 队列\n\n队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。（copy 自百度百科）\n\n由于每次我们要么从队尾插入元素，要么从队首删除元素，因此，队列具备一个重要的性质：\n\n先入先出。\n\n\n# 队列的通用数组实现\n\n/**\n * 队列类\n */\nclass Queue<T> {\n  private data: T[] = [];\n\n  get size(): number {\n    return this.data.length;\n  }\n\n  /**\n   * 入队一个元素\n   * @param ele\n   */\n  public enqueue(ele: T) {\n    // 我们把数组的尾作为队首，数组的头作为队尾\n    this.data.length++;\n    for (let i = this.data.length - 1; i >= 1; i--) {\n      this.data[i] = this.data[i - 1];\n    }\n    this.data[0] = ele;\n  }\n\n  /**\n   * 出队一个元素\n   */\n  public dequeue() {\n    if (this.isEmpty()) {\n      throw new Error("can not dequeue from an empty queue");\n    }\n    let len = this.size;\n    // 获取数组中最后一个元素\n    let ele = this.data[len - 1];\n    // 将数组的长度递减\n    this.data.length--;\n    return ele;\n  }\n\n  /**\n   * 队列是否为空\n   * @returns\n   */\n  public isEmpty() {\n    return this.data.length === 0;\n  }\n}\n\n\n\n# 队列的通用链表实现\n\n/**\n * 队列元素的节点元素定义，必须使用双向链表，便于我们查找前驱和后继元素\n */\ninterface LinkedListNode<T> {\n  next: LinkedListNode<T> | null;\n  prev: LinkedListNode<T> | null;\n  data: T;\n}\n\nclass Queue<T> {\n  /**\n   * 链表的头结点\n   */\n  private head: LinkedListNode<T> | null = null;\n\n  /**\n   * 链表的尾节点\n   */\n  private tail: LinkedListNode<T> | null = null;\n\n  private length = 0;\n\n  public get size() {\n    return this.length;\n  }\n\n  /**\n   * 入队一个元素\n   * @param ele\n   */\n  public enqueue(ele: T) {\n    const newNode: LinkedListNode<T> = {\n      next: null,\n      prev: null,\n      data: ele,\n    };\n    // 队列长度增加\n    this.length++;\n    // 如果一个元素都没有，直接让head和tail都指向这个节点\n    if (this.head === null) {\n      this.head = this.tail = newNode;\n    } else {\n      // 如果存在多个元素，让尾指针指向新来的节点\n      this.tail!.next = newNode;\n      // 新来的节点指向队尾指针\n      newNode.prev = this.tail;\n      // 让队尾指针指向新来的节点\n      this.tail = newNode;\n    }\n  }\n\n  /**\n   * 出队一个元素\n   */\n  public dequeue() {\n    if (this.isEmpty()) {\n      throw new Error("can not dequeue from an empty queue");\n    }\n    // 获取到头节点的后继节点\n    let head = this.head!.next;\n    // 队列中的元素\n    let ele = this.head!.data;\n    // 解开第一个节点的后继节点\n    this.head!.next = null;\n    // 解开第一个节点的后继节点的前驱节点\n    head!.prev = null;\n    // 让队首元素指向新的队首元素\n    this.head = head;\n    // 队列长度递减\n    this.length--;\n    // 将链表指针置空，若队列空\n    if(this.length == 0) {\n      this.head = null;\n      this.tail = null;\n    }\n    return ele;\n  }\n\n  /**\n   * 队列是否为空\n   * @returns\n   */\n  public isEmpty() {\n    return this.length === 0;\n  }\n}\n\n\n\n# 在 JavaScript 中使用队列\n\nJS 的数组同时具备栈和队列的特性，假设我们每次仅使用数组的unshift和push方法，数组即队列。\n\nconst queue = [];\nqueue.push(1); //[1]\nqueue.push(12); //[1, 12]\nqueue.push(123); //[1, 12, 123]\n\nlet front = queue.unshift() // front 为1\nfront = queue.unshift() // front为12\nfront = queue.unshift() // front为123, 此时队列已空\n\n\n\n# 队列的复杂度问题\n\n对于 JavaScript 来说，如果使用数组实现队列，我们的入队操作看起来是O(1)，为什么要说“看起来”呢，因为对于 JS 来说数组长度是可变的，我们只是执行了一个数组的基本操作，并没有什么遍历之类的操作。但是对于如C#，Java这类语言，数组在初始化的时候，必须首先确定数组的长度，假如你一直不停的入队，但是此刻数组已经没有空间容纳新来的内容了，此刻，我们便需要进行扩容，即申请一个更大的连续内存空间，然后把旧数组的内容拷贝到这块内容上来，此刻便会有一个O(n)的时间复杂度。\n\n如果使用链表实现，由于我们每次的操作总是队首或队尾元素，链表的增删操作的时间复杂度为O(1)，因此，这个实现在实际开发中有重要的意义。\n\n\n# 队列的应用\n\n在前端面试中，我们被问的最多的便是 JavaScript 的事件队列，这便是队列的实际应用场景之一，同类应用还有消息队列。\n\n另外，在广度优先搜索中，我们也需要使用队列。',normalizedContent:'# 队列\n\n队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。（copy 自百度百科）\n\n由于每次我们要么从队尾插入元素，要么从队首删除元素，因此，队列具备一个重要的性质：\n\n先入先出。\n\n\n# 队列的通用数组实现\n\n/**\n * 队列类\n */\nclass queue<t> {\n  private data: t[] = [];\n\n  get size(): number {\n    return this.data.length;\n  }\n\n  /**\n   * 入队一个元素\n   * @param ele\n   */\n  public enqueue(ele: t) {\n    // 我们把数组的尾作为队首，数组的头作为队尾\n    this.data.length++;\n    for (let i = this.data.length - 1; i >= 1; i--) {\n      this.data[i] = this.data[i - 1];\n    }\n    this.data[0] = ele;\n  }\n\n  /**\n   * 出队一个元素\n   */\n  public dequeue() {\n    if (this.isempty()) {\n      throw new error("can not dequeue from an empty queue");\n    }\n    let len = this.size;\n    // 获取数组中最后一个元素\n    let ele = this.data[len - 1];\n    // 将数组的长度递减\n    this.data.length--;\n    return ele;\n  }\n\n  /**\n   * 队列是否为空\n   * @returns\n   */\n  public isempty() {\n    return this.data.length === 0;\n  }\n}\n\n\n\n# 队列的通用链表实现\n\n/**\n * 队列元素的节点元素定义，必须使用双向链表，便于我们查找前驱和后继元素\n */\ninterface linkedlistnode<t> {\n  next: linkedlistnode<t> | null;\n  prev: linkedlistnode<t> | null;\n  data: t;\n}\n\nclass queue<t> {\n  /**\n   * 链表的头结点\n   */\n  private head: linkedlistnode<t> | null = null;\n\n  /**\n   * 链表的尾节点\n   */\n  private tail: linkedlistnode<t> | null = null;\n\n  private length = 0;\n\n  public get size() {\n    return this.length;\n  }\n\n  /**\n   * 入队一个元素\n   * @param ele\n   */\n  public enqueue(ele: t) {\n    const newnode: linkedlistnode<t> = {\n      next: null,\n      prev: null,\n      data: ele,\n    };\n    // 队列长度增加\n    this.length++;\n    // 如果一个元素都没有，直接让head和tail都指向这个节点\n    if (this.head === null) {\n      this.head = this.tail = newnode;\n    } else {\n      // 如果存在多个元素，让尾指针指向新来的节点\n      this.tail!.next = newnode;\n      // 新来的节点指向队尾指针\n      newnode.prev = this.tail;\n      // 让队尾指针指向新来的节点\n      this.tail = newnode;\n    }\n  }\n\n  /**\n   * 出队一个元素\n   */\n  public dequeue() {\n    if (this.isempty()) {\n      throw new error("can not dequeue from an empty queue");\n    }\n    // 获取到头节点的后继节点\n    let head = this.head!.next;\n    // 队列中的元素\n    let ele = this.head!.data;\n    // 解开第一个节点的后继节点\n    this.head!.next = null;\n    // 解开第一个节点的后继节点的前驱节点\n    head!.prev = null;\n    // 让队首元素指向新的队首元素\n    this.head = head;\n    // 队列长度递减\n    this.length--;\n    // 将链表指针置空，若队列空\n    if(this.length == 0) {\n      this.head = null;\n      this.tail = null;\n    }\n    return ele;\n  }\n\n  /**\n   * 队列是否为空\n   * @returns\n   */\n  public isempty() {\n    return this.length === 0;\n  }\n}\n\n\n\n# 在 javascript 中使用队列\n\njs 的数组同时具备栈和队列的特性，假设我们每次仅使用数组的unshift和push方法，数组即队列。\n\nconst queue = [];\nqueue.push(1); //[1]\nqueue.push(12); //[1, 12]\nqueue.push(123); //[1, 12, 123]\n\nlet front = queue.unshift() // front 为1\nfront = queue.unshift() // front为12\nfront = queue.unshift() // front为123, 此时队列已空\n\n\n\n# 队列的复杂度问题\n\n对于 javascript 来说，如果使用数组实现队列，我们的入队操作看起来是o(1)，为什么要说“看起来”呢，因为对于 js 来说数组长度是可变的，我们只是执行了一个数组的基本操作，并没有什么遍历之类的操作。但是对于如c#，java这类语言，数组在初始化的时候，必须首先确定数组的长度，假如你一直不停的入队，但是此刻数组已经没有空间容纳新来的内容了，此刻，我们便需要进行扩容，即申请一个更大的连续内存空间，然后把旧数组的内容拷贝到这块内容上来，此刻便会有一个o(n)的时间复杂度。\n\n如果使用链表实现，由于我们每次的操作总是队首或队尾元素，链表的增删操作的时间复杂度为o(1)，因此，这个实现在实际开发中有重要的意义。\n\n\n# 队列的应用\n\n在前端面试中，我们被问的最多的便是 javascript 的事件队列，这便是队列的实际应用场景之一，同类应用还有消息队列。\n\n另外，在广度优先搜索中，我们也需要使用队列。',charsets:{cjk:!0}},{title:"冒泡排序",frontmatter:{},regularPath:"/data-structure/sort/bubbleSort.html",relativePath:"data-structure/sort/bubbleSort.md",key:"v-45875829",path:"/data-structure/sort/bubbleSort.html",headers:[{level:2,title:"冒泡排序",slug:"冒泡排序",normalizedTitle:"冒泡排序",charIndex:2},{level:3,title:"排序过程",slug:"排序过程",normalizedTitle:"排序过程",charIndex:92},{level:3,title:"算法实现",slug:"算法实现",normalizedTitle:"算法实现",charIndex:101},{level:3,title:"复杂度与稳定性",slug:"复杂度与稳定性",normalizedTitle:"复杂度与稳定性",charIndex:769}],headersStr:"冒泡排序 排序过程 算法实现 复杂度与稳定性",content:"# 冒泡排序\n\n冒泡排序每轮循环把最重（取决于你对重的定义）的元素下沉到有序片段的前一位，无序数据片段规模递减 1，有序数据片段规模递增 1，直到所有的元素都有序则完成排序。\n\n\n# 排序过程\n\n\n# 算法实现\n\n/**\n * 对数组进行冒泡排序\n * @param {Array<number>} arr 需要进行排序的数组\n */\nfunction bubbleSort(arr) {\n  let temp = null;\n  // 外层循环变量i 用于控制参与排序数据的规模\n  for (let i = arr.length - 1; i >= 0; i--) {\n    // 定义标记，用于判断本轮是否参与交换\n    let flag = true;\n    // 内层循环用于把最“重”的元素下沉至非有序片段的最后一位\n    for (let j = 0; j < i; j++) {\n      // 注意冒泡排序是两两相邻的比较\n      if (arr[j] > arr[j + 1]) {\n        temp = arr[j];\n        arr[j] = arr[j + 1];\n        arr[j + 1] = temp;\n        // 如果交换了元素，还需要设置标记，若数组已经有序，可以提前终止排序，提升性能\n        flag = false;\n      }\n    }\n    // 如果说没有参与交换，则认为数组已经有序，则可以完成排序\n    if (flag) {\n      break;\n    }\n  }\n}\n\n\n需要注意的是冒泡排序在排序过程中，下沉元素时，是和相邻的元素进行比较，请注意区分选择排序，如果数据已经有序，需要提前终止排序。\n\n\n# 复杂度与稳定性\n\n冒泡排序的时间复杂度是O(n²)，是稳定的排序算法。",normalizedContent:"# 冒泡排序\n\n冒泡排序每轮循环把最重（取决于你对重的定义）的元素下沉到有序片段的前一位，无序数据片段规模递减 1，有序数据片段规模递增 1，直到所有的元素都有序则完成排序。\n\n\n# 排序过程\n\n\n# 算法实现\n\n/**\n * 对数组进行冒泡排序\n * @param {array<number>} arr 需要进行排序的数组\n */\nfunction bubblesort(arr) {\n  let temp = null;\n  // 外层循环变量i 用于控制参与排序数据的规模\n  for (let i = arr.length - 1; i >= 0; i--) {\n    // 定义标记，用于判断本轮是否参与交换\n    let flag = true;\n    // 内层循环用于把最“重”的元素下沉至非有序片段的最后一位\n    for (let j = 0; j < i; j++) {\n      // 注意冒泡排序是两两相邻的比较\n      if (arr[j] > arr[j + 1]) {\n        temp = arr[j];\n        arr[j] = arr[j + 1];\n        arr[j + 1] = temp;\n        // 如果交换了元素，还需要设置标记，若数组已经有序，可以提前终止排序，提升性能\n        flag = false;\n      }\n    }\n    // 如果说没有参与交换，则认为数组已经有序，则可以完成排序\n    if (flag) {\n      break;\n    }\n  }\n}\n\n\n需要注意的是冒泡排序在排序过程中，下沉元素时，是和相邻的元素进行比较，请注意区分选择排序，如果数据已经有序，需要提前终止排序。\n\n\n# 复杂度与稳定性\n\n冒泡排序的时间复杂度是o(n²)，是稳定的排序算法。",charsets:{cjk:!0}},{title:"AVL 树",frontmatter:{},regularPath:"/data-structure/search/avlTree.html",relativePath:"data-structure/search/avlTree.md",key:"v-42bdb895",path:"/data-structure/search/avlTree.html",headers:[{level:2,title:"AVL 树",slug:"avl-树",normalizedTitle:"avl 树",charIndex:2},{level:3,title:"AVL 树的节点定义",slug:"avl-树的节点定义",normalizedTitle:"avl 树的节点定义",charIndex:165},{level:3,title:"AVL 树的旋转",slug:"avl-树的旋转",normalizedTitle:"avl 树的旋转",charIndex:450},{level:3,title:"AVL 树旋转代码的实现",slug:"avl-树旋转代码的实现",normalizedTitle:"avl 树旋转代码的实现",charIndex:2194},{level:3,title:"AVL 树的插入",slug:"avl-树的插入",normalizedTitle:"avl 树的插入",charIndex:4171},{level:3,title:"AVL 树的删除",slug:"avl-树的删除",normalizedTitle:"avl 树的删除",charIndex:6074},{level:3,title:"复杂度分析",slug:"复杂度分析",normalizedTitle:"复杂度分析",charIndex:9587}],headersStr:"AVL 树 AVL 树的节点定义 AVL 树的旋转 AVL 树旋转代码的实现 AVL 树的插入 AVL 树的删除 复杂度分析",content:"# AVL 树\n\nAVL树是一颗自平衡二叉搜索树。在AVL树中任何节点的两个子树的高度最大差为 1，所以它也被称为高度平衡树。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。AVL树得名于它的发明者G. M. Adelson-Velsky和E. M. Landis。\n\n在阅读本文之前，请确保你已熟知二叉搜索树。\n\n\n# AVL 树的节点定义\n\n因为AVL树需要根据树高对树进行平衡性的调整，所以在树的节点上需要增加一个height域。\n\n/**\n * AVL树节点\n */\ninterface AVLTreeNode<T> {\n  /**\n   * 左子树\n   */\n  left: AVLTreeNode<T> | null;\n  /**\n   * 右子树\n   */\n  right: AVLTreeNode<T> | null;\n  /**\n   * 节点值\n   */\n  val: T;\n  /**\n   * 树高\n   */\n  height: number;\n}\n\n\n\n# AVL 树的旋转\n\n\n\n在上文我们提到在AVL树中，任何节点的两个子树的高度最大差为 1，那么，其实除开左子树或右子树上多出来的那个节点（后文我们就把它称之为孤儿节点，上图中值为 1 的节点，或值为 5 的节点），别的部分也是平衡的；\n\n如红框里圈出来的：\n\n\n\n对于节点 3，左子树高度 1，右子树高度 2，平衡因子 -1；\n\n对于节点 2，左子树高度 0，右子树高度 0，平衡因子 0；\n\n对于节点 4，左子树高度 0，右子树高度 1，平衡因子 1；\n\n对于节点 5，左右子树高度 0，平衡因子 0；\n\n因此，为了便于理解后面的几个旋转，我们就可以把问题抽象成这样：\n\n孤儿节点为左子结点：\n\n\n\n孤儿节点为右子结点：\n\n\n\n# LL 旋转\n\n若孤儿节点为左子节点（L），在其左子结点(L)上插入 C子树（还是因为任何节点的两个子树的高度最大差为 1的特征，C是可以有子节点的，后续不再赘述）：\n\n\n\n对于节点A，左子树的高度为 2，右子树高度为 0，平衡因子为-2，节点B的左子树高度 1，右子树 0，平衡因子-1；节点C的左右子树都是 0，平衡因子 0。\n\n那么，我们只需要把它调整为CBA的顺序即可。即：\n\n\n\n这就是LL旋转，即右旋。因为节点A也可能有右子树，B节点也可能有右子树。那么，B节点的右子树是要比A节点的右子树小的，所以A节点的右子树保持不动，将B的右子树挂在A节点的左子树上，若 C有左右子节点，则保持不动即可。\n\n即：\n\n\n\n# RR 旋转：\n\n若孤儿节点为右子节点（R），在其右子结点(R)上插入 C子树：\n\n\n\n对于节点A，左子树的高度为 0，右子树高度为 2，平衡因子为 2，节点B的左子树高度 0，右子树 1，平衡因子 1；节点C的左右子树都是 0，平衡因子 0。\n\n那么，我们只需要把它调整为ABC的顺序即可。即：\n\n\n\n这就是RR旋转，即左旋。因为节点A也可能有左子树，B节点也可能有左子树。那么，B节点的左子树是要比A节点的左子树大的，所以A节点的左子树保持不动，将B的左子树挂在A节点的右子树上，若C有左右子树，则保持不动即可。\n\n即：\n\n\n\n# LR 旋转\n\n若孤儿节点为左子节点（L），在其右子结点(R)上插入 C子树：\n\n\n\n对于节点A，左子树的高度为 2，右子树高度为 0，平衡因子为-2，节点B的左子树高度 0，右子树 1，平衡因子 1；节点C的左右子树都是 0，平衡因子 0。\n\n我们需要把它调整为CBA的顺序。\n\n那么，首先得把C提节点上去，即：\n\n\n\n接着，我们把C再次向上提，把A往右下压，即：\n\n\n\n同理，上述情况节点A可能有右子树，节点B可能有左子树，其实是保持不变的，但若C有左右子树，可以确定的是C的左右子树都是小于A的，C 的左右子树都是大于B的，那么C的左子树可以放在B的右子树上，C的右子树可以放在A的左子树上，即：\n\n\n\n可以看到，LR旋转，是先对节点 B进行了一次RR旋转（先左旋），再对 A 进行一次LL旋转（再右旋）。\n\n# RL 旋转\n\n若孤儿节点为右子节点（R），在其左子结点(L)上插入 C子树：\n\n\n\n对于节点A，右子树的高度为 2，左子树高度为 0，平衡因子为 2，节点B的左子树高度 1，右子树 0，平衡因子 -1；节点C的左右子树都是 0，平衡因子 0。\n\n我们需要把它调整为ACB的顺序。\n\n那么，首先得把C提上去，即：\n\n\n\n接着，我们把C再次向上提，把A往左下压，即：\n\n\n\n同理，上述情况节点A可能有左子树，节点B可能有右子树，其实是保持不变的，但若C有左右子树，可以确定的是C的左右子树都是大于A的，但C的左子树一定是小于B的，那么C的左子树可以放在B的左子树上，C的右子树可以放在A的右子树上，即：\n\n\n\n可以看到，RL旋转，是先对节点 B进行了一次LL旋转（先右旋），再对 A 进行一次RR旋转（再左旋）。\n\n这儿有个易混淆的点大家需要关注一下，LL旋转是右旋，RR旋转是左旋，对于LR旋转和RL旋转的旋转过程取决于你怎么解读L和R了，比如你将LR旋转解读为LL旋转+RR旋转，先进行的是RR旋转，再进行LL旋转，如果你将LR旋转解读为左旋和右旋，则先左旋，再右旋。\n\n\n# AVL 树旋转代码的实现\n\n首先定义一个获取树高的辅助函数\n\n/**\n * 获取以treeNode为根节点的树的高度\n * @param {AVLTreeNode<number>} treeNode\n */\nfunction getHeight(treeNode) {\n  return treeNode ? treeNode.height : 0;\n}\n\n\n# LL 旋转\n\n上面的旋转流程，我们已经阐述的很清楚了，因为是LL旋转，那么A是必须有一个左节点B的（因为我们现在插入的是C子树），把B往右上拽，把A往右下压，然后B成为了新树的根节点，重新更新一下左右子树的高度即可，现在B的左子树是B本来的左子树（即上述流程中的C），B的右子树则是调整之后以A节点为根节点的子树。A节点的左右子树没有变化，重新处理一下它的左右子树即可。\n\n/**\n * LL单旋\n * @param {AVLTreeNode<number>} A\n * @returns {AVLTreeNode<number>}\n */\nfunction singleLeftRotation(A) {\n  /* 注意：A必须有一个左子结点B */\n  let B = A.left;\n  // 注意： 一定要先把B的右子树挂在A的左边\n  A.left = B.right;\n  B.right = A;\n  /* 将A与B做左单旋，更新A与B的高度，返回新的根结点B */\n  A.height = Math.max(this.getHeight(A.left), this.getHeight(A.right)) + 1;\n  B.height = Math.max(this.getHeight(B.left), this.getHeight(A)) + 1;\n  return B;\n}\n\n\n# LR 旋转\n\n在上述流程中，我们是先对B和C进行了一次RR旋转，B即A.left，把A-(左)>B-(右)>C变成了A-(左)>C-(左)>B，然后再对A执行一次LL旋转即完成了LR旋转。\n\n/**\n * LR旋转\n * @param {AVLTreeNode<number>} A\n * @returns {AVLTreeNode<number>}\n */\nfunction doubleLeftRightRotation(A) {\n  /* 注意：A必须有一个左子结点B，且B必须有一个右子结点C */\n  /* 将A、B与C做两次单旋，返回新的根结点C */\n  /* 将B与C做右单旋，C被返回 */\n  A.left = this.singleRightRotation(A.left);\n  /* 将A与C做左单旋，C被返回 */\n  return this.singleLeftRotation(A);\n}\n\n\n# RR 旋转\n\n流程和LL旋转类似，此处不再赘述。\n\n/**\n * RR单旋\n * @param {AVLTreeNode<number>} A\n */\nfunction singleRightRotation(A) {\n  /* 注意：A必须有一个左子结点B */\n  /* 将A与B做左单旋，更新A与B的高度，返回新的根结点B */\n  let B = A.right;\n  // 注意： 一定要先把B的左子树挂在A的右边\n  A.right = B.left;\n  // A的右子树的左子树\n  B.left = A;\n  A.height = Math.max(this.getHeight(A.left), this.getHeight(A.right)) + 1;\n  B.height = Math.max(this.getHeight(B.right), this.getHeight(A)) + 1;\n  return B;\n}\n\n\n# RL 旋转\n\n流程和LR旋转类似，此处不再赘述。\n\n/**\n * 右左旋转\n * @param {AVLTreeNode<number>} A\n * @returns {AVLTreeNode<number>}\n */\nfunction doubleRightLeftRotation(A) {\n  /* 注意：A必须有一个右子结点B，且B必须有一个左子结点C */\n  /* 将A、B与C做两次单旋，返回新的根结点C */\n  /* 将B与C做左单旋，C被返回 */\n  A.right = this.singleLeftRotation(A.right);\n  /* 将A与C做右单旋，C被返回 */\n  return this.singleRightRotation(A);\n}\n\n\n\n# AVL 树的插入\n\nAVL树的插入原理和二叉搜索树的原理类似，只不过每次再插入完成之后，需要进行旋转的调整。\n\n基本流程如下：\n\n首先，如果树空，则插入新结点，更新树高，并且返回；\n\n若树不为空，判断插入值和当前根节点的值的大小，若比当前根节点的值大，则沿着左子树递归，否则，沿着右子树递归（本文不考虑二叉树中存在重复值）。\n\n在已经确定好了是在左还是右子树上插入之后，插入完成，此时，因为我们的插入操作影响到了树高，可能需要进行旋转调整，若左右子树高度绝对值等于 2（我才懒得去记谁减去谁呢），说明当前树已经不再是AVL树了，需要调整。\n\n如果我们是插在当前根节点的左子树上的，那么，肯定是左旋，至于是LL旋转还是LR旋转呢，这就要取决于我们是插入在左子树的左边还是右边的，因此，我们可以通过val < treeNode.left.val知道是插入在左边还是右边。如果这个条件成立，说明是插入在左子树的左边，则执行LL旋转，否则执行LR旋转。\n\n掌握左子树的插入之后，在右子树上的操作就变得简单了，此处不再赘述。\n\n/**\n * 插入子节点\n * @param {number} val\n */\nfunction insert(val) {\n  this.root = this._insert(this.root, val);\n}\n\n/**\n * 插入子节点\n * @param {AVLTreeNode<number>} treeNode\n * @param {number} val\n * @returns {AVLTreeNode<number>}\n */\nfunction _insert(treeNode, val) {\n  /* 将X插入AVL树treeNode中，并且返回调整后的AVL树 */\n  if (!treeNode) {\n    /* 若插入空树，则新建包含一个结点的树 */\n    treeNode = {\n      val: val,\n      height: 0,\n      left: null,\n      right: null,\n    };\n  } else if (val < treeNode.val) {\n    /* 插入treeNode的左子树 */\n    treeNode.left = this._insert(treeNode.left, val);\n    /* 如果需要旋旋 */\n    if (this.getHeight(treeNode.left) - this.getHeight(treeNode.right) === 2) {\n      if (val < treeNode.left.val) {\n        /* 左单旋 */\n        treeNode = this.singleLeftRotation(treeNode);\n      } else {\n        /* 左-右双旋 */\n        treeNode = this.doubleLeftRightRotation(treeNode);\n      }\n    }\n  } else if (val > treeNode.val) {\n    /* 插入treeNode的右子树 */\n    treeNode.right = this._insert(treeNode.right, val);\n    /* 如果需要右旋 */\n    if (this.getHeight(treeNode.left) - this.getHeight(treeNode.right) === -2) {\n      if (val > treeNode.right.val) {\n        /* 右单旋 */\n        treeNode = this.singleRightRotation(treeNode);\n      } else {\n        /* 右-左双旋 */\n        treeNode = this.doubleRightLeftRotation(treeNode);\n      }\n    }\n  }\n  /* 更新树高 */\n  treeNode.height =\n    Math.max(this.getHeight(treeNode.left), this.getHeight(treeNode.right)) + 1;\n  return treeNode;\n}\n\n\n\n# AVL 树的删除\n\nAVL树的删除操作，是插入操作的逆过程，我们以递归实现为思路，首先删除操作必须是基于一个二叉搜索树的删除， 如果当前是空树，则无法删除，如果当前根节点的值比待删除值大，则沿着左子树递归删除，反之则沿着右子树递归删除；如果当前根节点的值待删除值相同，则说明这个节点就是要删除的值，此时，就要看当前节点是一个什么样的情况了，如果它同时具有左右儿子，那么，我们可以从它的右子树里面找一个最小值（左子树里面找一个最大值也可以），然后把找到的最值节点拷贝到当前这个位置上，并且从当前节点的子树开始，递归的去删除它的最值（如果你之前是用的是右子树的最小值，就从右子树出发删除最小值，使用左子树的最大值同理），最后我们的问题始终转换为删除不同时具有左右子节点的问题。如果当前节点没有左右儿子，直接把treeNode指针标记为空即可，如果当前节点只有左儿子，那么直接用当前节点的左儿子指针覆盖treeNode指针即可，如果当前节点只有右儿子，那么直接用当前节点的右儿子指针覆盖treeNode指针即可，\n\n因为我们删除了树的节点，影响到了高度，所以现在需要根据树高进行旋转调整。\n\n比如现在你删除了右子树上面的节点，若是影响了树的高度的话（左右子树高度差大于等于 2），我们即需要进行左旋转，至于是LL旋转还是LR旋转，得取决于当前左子树的左右子树的高度，如果左子树的左子树树高大于等于左子树的右子树树高，说明左边高，则进行LL旋转，否则LR旋转。（分不清这儿的同学可以看一下上文旋转操作的图示）。\n\n下图表示的是删除A的右子节点之后，其中B的左子树树高大于等于B的左子树的树高（取得等于的时候是B的右子树存在时），这种情况下进行的是LL旋转。\n\n\n\n下图表示的是删除A的右子节点之后，其中B的右子树树高，大于B的左子树的树高，这种情况下进行的是LR旋转。\n\n\n\n当删除节点是某个节点的左叶子节点的情况时上面两种情况差不多，就不再赘述。\n\n当这些操作都进行完毕之后，千万别忘了更新树高。\n\n一次删除，可能需要多次回溯才可能最终使树变得平衡，因为我们使用的是递归算法，当递归调用退栈的时候，将会根据左右子树的高度决定是否进行旋转调整。\n\n/**\n * 在AVL树中查找最小值\n * @param {AVLTreeNode<number>} treeNode\n * @returns\n */\nfunction findMin(treeNode) {\n  let minTreeNode = null;\n  while (treeNode) {\n    minTreeNode = treeNode;\n    treeNode = treeNode.left;\n  }\n  return minTreeNode;\n}\n\n/**\n * 删除子节点\n * @param {number} val\n */\nfunction delete(val) {\n  this.root = this._delete(this.root, val);\n}\n\n/**\n * 辅助函数：删除子节点\n * @param {AVLTreeNode<number>} treeNode\n * @param {number} delVal\n * @returns\n */\nfunction _delete(treeNode, delVal) {\n  if (treeNode === null) {\n    // 空树，无法删除\n    return null;\n  } else if (delVal < treeNode.val) {\n    // val 位于左子树，其实就是相当于右子树的插入，所以在调整的时候，执行右旋\n    treeNode.left = this._delete(treeNode.left, delVal);\n    // 更新树高\n    treeNode.height =\n      Math.max(\n        this.getHeight(treeNode.left),\n        this.getHeight(treeNode.right)\n      ) + 1;\n    if (\n      Math.abs(\n        this.getHeight(treeNode.right) - this.getHeight(treeNode.left)\n      ) === 2\n    ) {\n      // 在回溯时，仍然有可能有调整子树的需求\n      if (\n        this.getHeight(treeNode.right.right) >=\n        this.getHeight(treeNode.right.left)\n      ) {\n        treeNode = this.singleRightRotation(treeNode);\n      } else {\n        treeNode = this.doubleLeftRightRotation(treeNode);\n      }\n    }\n  } else if (delVal > treeNode.val) {\n    // val 位于右子树删除，其实就是相当于是左子树插入\n    treeNode.right = this._delete(treeNode.right, delVal);\n    // 更新树高\n    treeNode.height =\n      Math.max(\n        this.getHeight(treeNode.left),\n        this.getHeight(treeNode.right)\n      ) + 1;\n    if (\n      Math.abs(\n        this.getHeight(treeNode.left) - this.getHeight(treeNode.right)\n      ) === 2\n    ) {\n      // 在回溯时，仍然有可能有调整子树的需求\n      if (\n        this.getHeight(treeNode.left.left) >=\n        this.getHeight(treeNode.left.right)\n      ) {\n        treeNode = this.singleLeftRotation(treeNode);\n      } else {\n        treeNode = this.doubleLeftRightRotation(treeNode);\n      }\n    }\n  } else if (treeNode.left && treeNode.right) {\n    /* 如果待删除节点同时存在左右儿子节点 */\n    // 找到右子树的最小节点\n    let rightSubTreeMinNode = this.findMin(treeNode.right);\n    // 用右子树上的最小节点替换当前值，然后再从当前右子树触发，递归的删除右子树上的最小值。\n    treeNode.val = rightSubTreeMinNode.val;\n    treeNode.right = this._delete(treeNode.right, treeNode.val);\n  } else {\n    /* 如果待删除节点只有左儿子节点，那么把它的左儿子直接赋值给它自己，相当于移除了待删除节点 */\n    if (treeNode.right === null) {\n      treeNode = treeNode.left;\n    } else if (treeNode.left === null) {\n      /* 如果待删除节点只有右儿子节点，那么把它的右儿子直接赋值给它自己，相当于移除了待删除节点 */\n      treeNode = treeNode.right;\n    } else {\n      /* 如果待删除节点没有左右儿子节点，直接赋值为空，相当于移除了待删除节点 */\n      treeNode = null;\n    }\n  }\n  return treeNode;\n}\n\n\n\n# 复杂度分析\n\nAVL树的完整代码如下：\n\n/**\n * 平衡二叉树的实现\n */\nclass AVLTree {\n  /**\n   * 根节点\n   * @type {AVLTreeNode<number> | null}\n   */\n  root = null;\n\n  /**\n   * 获取以treeNode为根节点的树高\n   * @param {AVLTreeNode<number>} treeNode\n   */\n  getHeight(treeNode) {\n    return treeNode ? treeNode.height : 0;\n  }\n\n  /**\n   * 左单旋\n   * @param {AVLTreeNode<number>} A\n   * @returns {AVLTreeNode<number>}\n   */\n  singleLeftRotation(A) {\n    /* 注意：A必须有一个左子结点B */\n    /* 将A与B做左单旋，更新A与B的高度，返回新的根结点B */\n    // 当前树节点的左子树\n    let B = A.left;\n    // 注意： 一定要先把B的右子树挂在A的左边\n    A.left = B.right;\n    B.right = A;\n    A.height = Math.max(this.getHeight(A.left), this.getHeight(A.right)) + 1;\n    B.height = Math.max(this.getHeight(B.left), this.getHeight(A)) + 1;\n    return B;\n  }\n\n  /**\n   * 右单旋\n   * @param {AVLTreeNode<number>} A\n   */\n  singleRightRotation(A) {\n    /* 注意：A必须有一个左子结点B */\n    /* 将A与B做左单旋，更新A与B的高度，返回新的根结点B */\n    let B = A.right;\n    // 注意： 一定要先把B的左子树挂在A的右边\n    A.right = B.left;\n    // A的右子树的左子树\n    B.left = A;\n    A.height = Math.max(this.getHeight(A.left), this.getHeight(A.right)) + 1;\n    B.height = Math.max(this.getHeight(B.right), this.getHeight(A)) + 1;\n    return B;\n  }\n\n  /**\n   * 左右旋转\n   * @param {AVLTreeNode<number>} A\n   * @returns {AVLTreeNode<number>}\n   */\n  doubleLeftRightRotation(A) {\n    /* 注意：A必须有一个左子结点B，且B必须有一个右子结点C */\n    /* 将A、B与C做两次单旋，返回新的根结点C */\n    /* 将B与C做右单旋，C被返回 */\n    A.left = this.singleRightRotation(A.left);\n    /* 将A与C做左单旋，C被返回 */\n    return this.singleLeftRotation(A);\n  }\n\n  /**\n   * 右左旋转\n   * @param {AVLTreeNode<number>} A\n   * @returns {AVLTreeNode<number>}\n   */\n  doubleRightLeftRotation(A) {\n    /* 注意：A必须有一个右子结点B，且B必须有一个左子结点C */\n    /* 将A、B与C做两次单旋，返回新的根结点C */\n    /* 将B与C做左单旋，C被返回 */\n    A.right = this.singleLeftRotation(A.right);\n    /* 将A与C做右单旋，C被返回 */\n    return this.singleRightRotation(A);\n  }\n\n  /**\n   * 查找指定值是否在二叉搜索树中存在\n   * @param {number} val\n   * @returns {AVLTreeNode<number>}\n   */\n  find(val) {\n    return this._find(val, this.root);\n  }\n\n  /**\n   * 查找辅助函数\n   * @param {number} val\n   * @param {AVLTreeNode<number>} treeNode\n   */\n  _find(val, treeNode) {\n    let node = treeNode;\n    while (node) {\n      if (node.val == val) {\n        break;\n      } else if (node.val > val) {\n        // 沿着左子树查找\n        node = node.left;\n      } else if (node.val < val) {\n        // 沿着右子树查找\n        node = node.right;\n      }\n    }\n    return node;\n  }\n\n  /**\n   * 在AVL树中查找最小值\n   * @param {AVLTreeNode<number>} treeNode\n   * @returns\n   */\n  findMin(treeNode) {\n    let minTreeNode = null;\n    while (treeNode) {\n      minTreeNode = treeNode;\n      treeNode = treeNode.left;\n    }\n    return minTreeNode;\n  }\n\n  /**\n   * 插入子节点\n   * @param {number} val\n   */\n  insert(val) {\n    this.root = this._insert(this.root, val);\n  }\n\n  /**\n   * 删除子节点\n   * @param {number} val\n   */\n  delete(val) {\n    this.root = this._delete(this.root, val);\n  }\n\n  /**\n   * 辅助函数：删除子节点\n   * @param {AVLTreeNode<number>} treeNode\n   * @param {number} delVal\n   * @returns\n   */\n  _delete(treeNode, delVal) {\n    if (treeNode === null) {\n      // 空树，无法删除\n      return null;\n    } else if (delVal < treeNode.val) {\n      // val 位于左子树，其实就是相当于右子树的插入，所以在调整的时候，执行右旋\n      treeNode.left = this._delete(treeNode.left, delVal);\n      // 更新树高\n      treeNode.height =\n        Math.max(\n          this.getHeight(treeNode.left),\n          this.getHeight(treeNode.right)\n        ) + 1;\n      if (\n        Math.abs(\n          this.getHeight(treeNode.right) - this.getHeight(treeNode.left)\n        ) === 2\n      ) {\n        if (\n          this.getHeight(treeNode.right.right) >=\n          this.getHeight(treeNode.right.left)\n        ) {\n          treeNode = this.singleRightRotation(treeNode);\n        } else {\n          treeNode = this.doubleLeftRightRotation(treeNode);\n        }\n      }\n    } else if (delVal > treeNode.val) {\n      // val 位于右子树删除，其实就是相当于是左子树插入\n      treeNode.right = this._delete(treeNode.right, delVal);\n      // 更新树高\n      treeNode.height =\n        Math.max(\n          this.getHeight(treeNode.left),\n          this.getHeight(treeNode.right)\n        ) + 1;\n      if (\n        Math.abs(\n          this.getHeight(treeNode.left) - this.getHeight(treeNode.right)\n        ) === 2\n      ) {\n        if (\n          this.getHeight(treeNode.left.left) >=\n          this.getHeight(treeNode.left.right)\n        ) {\n          treeNode = this.singleLeftRotation(treeNode);\n        } else {\n          treeNode = this.doubleLeftRightRotation(treeNode);\n        }\n      }\n    } else if (treeNode.left && treeNode.right) {\n      /* 如果待删除节点同时存在左右儿子节点 */\n      // 找到右子树的最小节点\n      let rightSubTreeMinNode = this.findMin(treeNode.right);\n      // 用右子树上的最小节点替换当前值，然后再从当前右子树触发，递归的删除右子树上的最小值。\n      treeNode.val = rightSubTreeMinNode.val;\n      treeNode.right = this._delete(treeNode.right, treeNode.val);\n    } else {\n      /* 如果待删除节点只有左儿子节点，那么把它的左儿子直接赋值给它自己，相当于移除了待删除节点 */\n      if (treeNode.right === null) {\n        treeNode = treeNode.left;\n      } else if (treeNode.left === null) {\n        /* 如果待删除节点只有右儿子节点，那么把它的右儿子直接赋值给它自己，相当于移除了待删除节点 */\n        treeNode = treeNode.right;\n      } else {\n        /* 如果待删除节点没有左右儿子节点，直接赋值为空，相当于移除了待删除节点 */\n        treeNode = null;\n      }\n    }\n    return treeNode;\n  }\n\n  /**\n   * 辅助函数：插入子节点\n   * @param {AVLTreeNode<number>} treeNode\n   * @param {number} val\n   * @returns {AVLTreeNode<number>}\n   */\n  _insert(treeNode, val) {\n    /* 将X插入AVL树treeNode中，并且返回调整后的AVL树 */\n    if (!treeNode) {\n      /* 若插入空树，则新建包含一个结点的树 */\n      treeNode = {\n        val: val,\n        height: 0,\n        left: null,\n        right: null,\n      };\n    } else if (val < treeNode.val) {\n      /* 插入treeNode的左子树 */\n      treeNode.left = this._insert(treeNode.left, val);\n      /* 如果需要左旋 */\n      if (\n        Math.abs(\n          this.getHeight(treeNode.left) - this.getHeight(treeNode.right)\n        ) === 2\n      ) {\n        if (val < treeNode.left.val) {\n          /* 左单旋 */\n          treeNode = this.singleLeftRotation(treeNode);\n        } else {\n          /* 左-右双旋 */\n          treeNode = this.doubleLeftRightRotation(treeNode);\n        }\n      }\n    } else if (val > treeNode.val) {\n      /* 插入treeNode的右子树 */\n      treeNode.right = this._insert(treeNode.right, val);\n      /* 如果需要右旋 */\n      if (\n        Math.abs(\n          this.getHeight(treeNode.left) - this.getHeight(treeNode.right)\n        ) === 2\n      ) {\n        if (val > treeNode.right.val) {\n          /* 右单旋 */\n          treeNode = this.singleRightRotation(treeNode);\n        } else {\n          /* 右-左双旋 */\n          treeNode = this.doubleRightLeftRotation(treeNode);\n        }\n      }\n    }\n    /* 更新树高 */\n    treeNode.height =\n      Math.max(this.getHeight(treeNode.left), this.getHeight(treeNode.right)) +\n      1;\n    return treeNode;\n  }\n}\n\n\nAVL树的插入和删除时间复杂度都是O(log n)，具体的分析过程，有兴趣的同学请参考相应的论文资料。",normalizedContent:"# avl 树\n\navl树是一颗自平衡二叉搜索树。在avl树中任何节点的两个子树的高度最大差为 1，所以它也被称为高度平衡树。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。avl树得名于它的发明者g. m. adelson-velsky和e. m. landis。\n\n在阅读本文之前，请确保你已熟知二叉搜索树。\n\n\n# avl 树的节点定义\n\n因为avl树需要根据树高对树进行平衡性的调整，所以在树的节点上需要增加一个height域。\n\n/**\n * avl树节点\n */\ninterface avltreenode<t> {\n  /**\n   * 左子树\n   */\n  left: avltreenode<t> | null;\n  /**\n   * 右子树\n   */\n  right: avltreenode<t> | null;\n  /**\n   * 节点值\n   */\n  val: t;\n  /**\n   * 树高\n   */\n  height: number;\n}\n\n\n\n# avl 树的旋转\n\n\n\n在上文我们提到在avl树中，任何节点的两个子树的高度最大差为 1，那么，其实除开左子树或右子树上多出来的那个节点（后文我们就把它称之为孤儿节点，上图中值为 1 的节点，或值为 5 的节点），别的部分也是平衡的；\n\n如红框里圈出来的：\n\n\n\n对于节点 3，左子树高度 1，右子树高度 2，平衡因子 -1；\n\n对于节点 2，左子树高度 0，右子树高度 0，平衡因子 0；\n\n对于节点 4，左子树高度 0，右子树高度 1，平衡因子 1；\n\n对于节点 5，左右子树高度 0，平衡因子 0；\n\n因此，为了便于理解后面的几个旋转，我们就可以把问题抽象成这样：\n\n孤儿节点为左子结点：\n\n\n\n孤儿节点为右子结点：\n\n\n\n# ll 旋转\n\n若孤儿节点为左子节点（l），在其左子结点(l)上插入 c子树（还是因为任何节点的两个子树的高度最大差为 1的特征，c是可以有子节点的，后续不再赘述）：\n\n\n\n对于节点a，左子树的高度为 2，右子树高度为 0，平衡因子为-2，节点b的左子树高度 1，右子树 0，平衡因子-1；节点c的左右子树都是 0，平衡因子 0。\n\n那么，我们只需要把它调整为cba的顺序即可。即：\n\n\n\n这就是ll旋转，即右旋。因为节点a也可能有右子树，b节点也可能有右子树。那么，b节点的右子树是要比a节点的右子树小的，所以a节点的右子树保持不动，将b的右子树挂在a节点的左子树上，若 c有左右子节点，则保持不动即可。\n\n即：\n\n\n\n# rr 旋转：\n\n若孤儿节点为右子节点（r），在其右子结点(r)上插入 c子树：\n\n\n\n对于节点a，左子树的高度为 0，右子树高度为 2，平衡因子为 2，节点b的左子树高度 0，右子树 1，平衡因子 1；节点c的左右子树都是 0，平衡因子 0。\n\n那么，我们只需要把它调整为abc的顺序即可。即：\n\n\n\n这就是rr旋转，即左旋。因为节点a也可能有左子树，b节点也可能有左子树。那么，b节点的左子树是要比a节点的左子树大的，所以a节点的左子树保持不动，将b的左子树挂在a节点的右子树上，若c有左右子树，则保持不动即可。\n\n即：\n\n\n\n# lr 旋转\n\n若孤儿节点为左子节点（l），在其右子结点(r)上插入 c子树：\n\n\n\n对于节点a，左子树的高度为 2，右子树高度为 0，平衡因子为-2，节点b的左子树高度 0，右子树 1，平衡因子 1；节点c的左右子树都是 0，平衡因子 0。\n\n我们需要把它调整为cba的顺序。\n\n那么，首先得把c提节点上去，即：\n\n\n\n接着，我们把c再次向上提，把a往右下压，即：\n\n\n\n同理，上述情况节点a可能有右子树，节点b可能有左子树，其实是保持不变的，但若c有左右子树，可以确定的是c的左右子树都是小于a的，c 的左右子树都是大于b的，那么c的左子树可以放在b的右子树上，c的右子树可以放在a的左子树上，即：\n\n\n\n可以看到，lr旋转，是先对节点 b进行了一次rr旋转（先左旋），再对 a 进行一次ll旋转（再右旋）。\n\n# rl 旋转\n\n若孤儿节点为右子节点（r），在其左子结点(l)上插入 c子树：\n\n\n\n对于节点a，右子树的高度为 2，左子树高度为 0，平衡因子为 2，节点b的左子树高度 1，右子树 0，平衡因子 -1；节点c的左右子树都是 0，平衡因子 0。\n\n我们需要把它调整为acb的顺序。\n\n那么，首先得把c提上去，即：\n\n\n\n接着，我们把c再次向上提，把a往左下压，即：\n\n\n\n同理，上述情况节点a可能有左子树，节点b可能有右子树，其实是保持不变的，但若c有左右子树，可以确定的是c的左右子树都是大于a的，但c的左子树一定是小于b的，那么c的左子树可以放在b的左子树上，c的右子树可以放在a的右子树上，即：\n\n\n\n可以看到，rl旋转，是先对节点 b进行了一次ll旋转（先右旋），再对 a 进行一次rr旋转（再左旋）。\n\n这儿有个易混淆的点大家需要关注一下，ll旋转是右旋，rr旋转是左旋，对于lr旋转和rl旋转的旋转过程取决于你怎么解读l和r了，比如你将lr旋转解读为ll旋转+rr旋转，先进行的是rr旋转，再进行ll旋转，如果你将lr旋转解读为左旋和右旋，则先左旋，再右旋。\n\n\n# avl 树旋转代码的实现\n\n首先定义一个获取树高的辅助函数\n\n/**\n * 获取以treenode为根节点的树的高度\n * @param {avltreenode<number>} treenode\n */\nfunction getheight(treenode) {\n  return treenode ? treenode.height : 0;\n}\n\n\n# ll 旋转\n\n上面的旋转流程，我们已经阐述的很清楚了，因为是ll旋转，那么a是必须有一个左节点b的（因为我们现在插入的是c子树），把b往右上拽，把a往右下压，然后b成为了新树的根节点，重新更新一下左右子树的高度即可，现在b的左子树是b本来的左子树（即上述流程中的c），b的右子树则是调整之后以a节点为根节点的子树。a节点的左右子树没有变化，重新处理一下它的左右子树即可。\n\n/**\n * ll单旋\n * @param {avltreenode<number>} a\n * @returns {avltreenode<number>}\n */\nfunction singleleftrotation(a) {\n  /* 注意：a必须有一个左子结点b */\n  let b = a.left;\n  // 注意： 一定要先把b的右子树挂在a的左边\n  a.left = b.right;\n  b.right = a;\n  /* 将a与b做左单旋，更新a与b的高度，返回新的根结点b */\n  a.height = math.max(this.getheight(a.left), this.getheight(a.right)) + 1;\n  b.height = math.max(this.getheight(b.left), this.getheight(a)) + 1;\n  return b;\n}\n\n\n# lr 旋转\n\n在上述流程中，我们是先对b和c进行了一次rr旋转，b即a.left，把a-(左)>b-(右)>c变成了a-(左)>c-(左)>b，然后再对a执行一次ll旋转即完成了lr旋转。\n\n/**\n * lr旋转\n * @param {avltreenode<number>} a\n * @returns {avltreenode<number>}\n */\nfunction doubleleftrightrotation(a) {\n  /* 注意：a必须有一个左子结点b，且b必须有一个右子结点c */\n  /* 将a、b与c做两次单旋，返回新的根结点c */\n  /* 将b与c做右单旋，c被返回 */\n  a.left = this.singlerightrotation(a.left);\n  /* 将a与c做左单旋，c被返回 */\n  return this.singleleftrotation(a);\n}\n\n\n# rr 旋转\n\n流程和ll旋转类似，此处不再赘述。\n\n/**\n * rr单旋\n * @param {avltreenode<number>} a\n */\nfunction singlerightrotation(a) {\n  /* 注意：a必须有一个左子结点b */\n  /* 将a与b做左单旋，更新a与b的高度，返回新的根结点b */\n  let b = a.right;\n  // 注意： 一定要先把b的左子树挂在a的右边\n  a.right = b.left;\n  // a的右子树的左子树\n  b.left = a;\n  a.height = math.max(this.getheight(a.left), this.getheight(a.right)) + 1;\n  b.height = math.max(this.getheight(b.right), this.getheight(a)) + 1;\n  return b;\n}\n\n\n# rl 旋转\n\n流程和lr旋转类似，此处不再赘述。\n\n/**\n * 右左旋转\n * @param {avltreenode<number>} a\n * @returns {avltreenode<number>}\n */\nfunction doublerightleftrotation(a) {\n  /* 注意：a必须有一个右子结点b，且b必须有一个左子结点c */\n  /* 将a、b与c做两次单旋，返回新的根结点c */\n  /* 将b与c做左单旋，c被返回 */\n  a.right = this.singleleftrotation(a.right);\n  /* 将a与c做右单旋，c被返回 */\n  return this.singlerightrotation(a);\n}\n\n\n\n# avl 树的插入\n\navl树的插入原理和二叉搜索树的原理类似，只不过每次再插入完成之后，需要进行旋转的调整。\n\n基本流程如下：\n\n首先，如果树空，则插入新结点，更新树高，并且返回；\n\n若树不为空，判断插入值和当前根节点的值的大小，若比当前根节点的值大，则沿着左子树递归，否则，沿着右子树递归（本文不考虑二叉树中存在重复值）。\n\n在已经确定好了是在左还是右子树上插入之后，插入完成，此时，因为我们的插入操作影响到了树高，可能需要进行旋转调整，若左右子树高度绝对值等于 2（我才懒得去记谁减去谁呢），说明当前树已经不再是avl树了，需要调整。\n\n如果我们是插在当前根节点的左子树上的，那么，肯定是左旋，至于是ll旋转还是lr旋转呢，这就要取决于我们是插入在左子树的左边还是右边的，因此，我们可以通过val < treenode.left.val知道是插入在左边还是右边。如果这个条件成立，说明是插入在左子树的左边，则执行ll旋转，否则执行lr旋转。\n\n掌握左子树的插入之后，在右子树上的操作就变得简单了，此处不再赘述。\n\n/**\n * 插入子节点\n * @param {number} val\n */\nfunction insert(val) {\n  this.root = this._insert(this.root, val);\n}\n\n/**\n * 插入子节点\n * @param {avltreenode<number>} treenode\n * @param {number} val\n * @returns {avltreenode<number>}\n */\nfunction _insert(treenode, val) {\n  /* 将x插入avl树treenode中，并且返回调整后的avl树 */\n  if (!treenode) {\n    /* 若插入空树，则新建包含一个结点的树 */\n    treenode = {\n      val: val,\n      height: 0,\n      left: null,\n      right: null,\n    };\n  } else if (val < treenode.val) {\n    /* 插入treenode的左子树 */\n    treenode.left = this._insert(treenode.left, val);\n    /* 如果需要旋旋 */\n    if (this.getheight(treenode.left) - this.getheight(treenode.right) === 2) {\n      if (val < treenode.left.val) {\n        /* 左单旋 */\n        treenode = this.singleleftrotation(treenode);\n      } else {\n        /* 左-右双旋 */\n        treenode = this.doubleleftrightrotation(treenode);\n      }\n    }\n  } else if (val > treenode.val) {\n    /* 插入treenode的右子树 */\n    treenode.right = this._insert(treenode.right, val);\n    /* 如果需要右旋 */\n    if (this.getheight(treenode.left) - this.getheight(treenode.right) === -2) {\n      if (val > treenode.right.val) {\n        /* 右单旋 */\n        treenode = this.singlerightrotation(treenode);\n      } else {\n        /* 右-左双旋 */\n        treenode = this.doublerightleftrotation(treenode);\n      }\n    }\n  }\n  /* 更新树高 */\n  treenode.height =\n    math.max(this.getheight(treenode.left), this.getheight(treenode.right)) + 1;\n  return treenode;\n}\n\n\n\n# avl 树的删除\n\navl树的删除操作，是插入操作的逆过程，我们以递归实现为思路，首先删除操作必须是基于一个二叉搜索树的删除， 如果当前是空树，则无法删除，如果当前根节点的值比待删除值大，则沿着左子树递归删除，反之则沿着右子树递归删除；如果当前根节点的值待删除值相同，则说明这个节点就是要删除的值，此时，就要看当前节点是一个什么样的情况了，如果它同时具有左右儿子，那么，我们可以从它的右子树里面找一个最小值（左子树里面找一个最大值也可以），然后把找到的最值节点拷贝到当前这个位置上，并且从当前节点的子树开始，递归的去删除它的最值（如果你之前是用的是右子树的最小值，就从右子树出发删除最小值，使用左子树的最大值同理），最后我们的问题始终转换为删除不同时具有左右子节点的问题。如果当前节点没有左右儿子，直接把treenode指针标记为空即可，如果当前节点只有左儿子，那么直接用当前节点的左儿子指针覆盖treenode指针即可，如果当前节点只有右儿子，那么直接用当前节点的右儿子指针覆盖treenode指针即可，\n\n因为我们删除了树的节点，影响到了高度，所以现在需要根据树高进行旋转调整。\n\n比如现在你删除了右子树上面的节点，若是影响了树的高度的话（左右子树高度差大于等于 2），我们即需要进行左旋转，至于是ll旋转还是lr旋转，得取决于当前左子树的左右子树的高度，如果左子树的左子树树高大于等于左子树的右子树树高，说明左边高，则进行ll旋转，否则lr旋转。（分不清这儿的同学可以看一下上文旋转操作的图示）。\n\n下图表示的是删除a的右子节点之后，其中b的左子树树高大于等于b的左子树的树高（取得等于的时候是b的右子树存在时），这种情况下进行的是ll旋转。\n\n\n\n下图表示的是删除a的右子节点之后，其中b的右子树树高，大于b的左子树的树高，这种情况下进行的是lr旋转。\n\n\n\n当删除节点是某个节点的左叶子节点的情况时上面两种情况差不多，就不再赘述。\n\n当这些操作都进行完毕之后，千万别忘了更新树高。\n\n一次删除，可能需要多次回溯才可能最终使树变得平衡，因为我们使用的是递归算法，当递归调用退栈的时候，将会根据左右子树的高度决定是否进行旋转调整。\n\n/**\n * 在avl树中查找最小值\n * @param {avltreenode<number>} treenode\n * @returns\n */\nfunction findmin(treenode) {\n  let mintreenode = null;\n  while (treenode) {\n    mintreenode = treenode;\n    treenode = treenode.left;\n  }\n  return mintreenode;\n}\n\n/**\n * 删除子节点\n * @param {number} val\n */\nfunction delete(val) {\n  this.root = this._delete(this.root, val);\n}\n\n/**\n * 辅助函数：删除子节点\n * @param {avltreenode<number>} treenode\n * @param {number} delval\n * @returns\n */\nfunction _delete(treenode, delval) {\n  if (treenode === null) {\n    // 空树，无法删除\n    return null;\n  } else if (delval < treenode.val) {\n    // val 位于左子树，其实就是相当于右子树的插入，所以在调整的时候，执行右旋\n    treenode.left = this._delete(treenode.left, delval);\n    // 更新树高\n    treenode.height =\n      math.max(\n        this.getheight(treenode.left),\n        this.getheight(treenode.right)\n      ) + 1;\n    if (\n      math.abs(\n        this.getheight(treenode.right) - this.getheight(treenode.left)\n      ) === 2\n    ) {\n      // 在回溯时，仍然有可能有调整子树的需求\n      if (\n        this.getheight(treenode.right.right) >=\n        this.getheight(treenode.right.left)\n      ) {\n        treenode = this.singlerightrotation(treenode);\n      } else {\n        treenode = this.doubleleftrightrotation(treenode);\n      }\n    }\n  } else if (delval > treenode.val) {\n    // val 位于右子树删除，其实就是相当于是左子树插入\n    treenode.right = this._delete(treenode.right, delval);\n    // 更新树高\n    treenode.height =\n      math.max(\n        this.getheight(treenode.left),\n        this.getheight(treenode.right)\n      ) + 1;\n    if (\n      math.abs(\n        this.getheight(treenode.left) - this.getheight(treenode.right)\n      ) === 2\n    ) {\n      // 在回溯时，仍然有可能有调整子树的需求\n      if (\n        this.getheight(treenode.left.left) >=\n        this.getheight(treenode.left.right)\n      ) {\n        treenode = this.singleleftrotation(treenode);\n      } else {\n        treenode = this.doubleleftrightrotation(treenode);\n      }\n    }\n  } else if (treenode.left && treenode.right) {\n    /* 如果待删除节点同时存在左右儿子节点 */\n    // 找到右子树的最小节点\n    let rightsubtreeminnode = this.findmin(treenode.right);\n    // 用右子树上的最小节点替换当前值，然后再从当前右子树触发，递归的删除右子树上的最小值。\n    treenode.val = rightsubtreeminnode.val;\n    treenode.right = this._delete(treenode.right, treenode.val);\n  } else {\n    /* 如果待删除节点只有左儿子节点，那么把它的左儿子直接赋值给它自己，相当于移除了待删除节点 */\n    if (treenode.right === null) {\n      treenode = treenode.left;\n    } else if (treenode.left === null) {\n      /* 如果待删除节点只有右儿子节点，那么把它的右儿子直接赋值给它自己，相当于移除了待删除节点 */\n      treenode = treenode.right;\n    } else {\n      /* 如果待删除节点没有左右儿子节点，直接赋值为空，相当于移除了待删除节点 */\n      treenode = null;\n    }\n  }\n  return treenode;\n}\n\n\n\n# 复杂度分析\n\navl树的完整代码如下：\n\n/**\n * 平衡二叉树的实现\n */\nclass avltree {\n  /**\n   * 根节点\n   * @type {avltreenode<number> | null}\n   */\n  root = null;\n\n  /**\n   * 获取以treenode为根节点的树高\n   * @param {avltreenode<number>} treenode\n   */\n  getheight(treenode) {\n    return treenode ? treenode.height : 0;\n  }\n\n  /**\n   * 左单旋\n   * @param {avltreenode<number>} a\n   * @returns {avltreenode<number>}\n   */\n  singleleftrotation(a) {\n    /* 注意：a必须有一个左子结点b */\n    /* 将a与b做左单旋，更新a与b的高度，返回新的根结点b */\n    // 当前树节点的左子树\n    let b = a.left;\n    // 注意： 一定要先把b的右子树挂在a的左边\n    a.left = b.right;\n    b.right = a;\n    a.height = math.max(this.getheight(a.left), this.getheight(a.right)) + 1;\n    b.height = math.max(this.getheight(b.left), this.getheight(a)) + 1;\n    return b;\n  }\n\n  /**\n   * 右单旋\n   * @param {avltreenode<number>} a\n   */\n  singlerightrotation(a) {\n    /* 注意：a必须有一个左子结点b */\n    /* 将a与b做左单旋，更新a与b的高度，返回新的根结点b */\n    let b = a.right;\n    // 注意： 一定要先把b的左子树挂在a的右边\n    a.right = b.left;\n    // a的右子树的左子树\n    b.left = a;\n    a.height = math.max(this.getheight(a.left), this.getheight(a.right)) + 1;\n    b.height = math.max(this.getheight(b.right), this.getheight(a)) + 1;\n    return b;\n  }\n\n  /**\n   * 左右旋转\n   * @param {avltreenode<number>} a\n   * @returns {avltreenode<number>}\n   */\n  doubleleftrightrotation(a) {\n    /* 注意：a必须有一个左子结点b，且b必须有一个右子结点c */\n    /* 将a、b与c做两次单旋，返回新的根结点c */\n    /* 将b与c做右单旋，c被返回 */\n    a.left = this.singlerightrotation(a.left);\n    /* 将a与c做左单旋，c被返回 */\n    return this.singleleftrotation(a);\n  }\n\n  /**\n   * 右左旋转\n   * @param {avltreenode<number>} a\n   * @returns {avltreenode<number>}\n   */\n  doublerightleftrotation(a) {\n    /* 注意：a必须有一个右子结点b，且b必须有一个左子结点c */\n    /* 将a、b与c做两次单旋，返回新的根结点c */\n    /* 将b与c做左单旋，c被返回 */\n    a.right = this.singleleftrotation(a.right);\n    /* 将a与c做右单旋，c被返回 */\n    return this.singlerightrotation(a);\n  }\n\n  /**\n   * 查找指定值是否在二叉搜索树中存在\n   * @param {number} val\n   * @returns {avltreenode<number>}\n   */\n  find(val) {\n    return this._find(val, this.root);\n  }\n\n  /**\n   * 查找辅助函数\n   * @param {number} val\n   * @param {avltreenode<number>} treenode\n   */\n  _find(val, treenode) {\n    let node = treenode;\n    while (node) {\n      if (node.val == val) {\n        break;\n      } else if (node.val > val) {\n        // 沿着左子树查找\n        node = node.left;\n      } else if (node.val < val) {\n        // 沿着右子树查找\n        node = node.right;\n      }\n    }\n    return node;\n  }\n\n  /**\n   * 在avl树中查找最小值\n   * @param {avltreenode<number>} treenode\n   * @returns\n   */\n  findmin(treenode) {\n    let mintreenode = null;\n    while (treenode) {\n      mintreenode = treenode;\n      treenode = treenode.left;\n    }\n    return mintreenode;\n  }\n\n  /**\n   * 插入子节点\n   * @param {number} val\n   */\n  insert(val) {\n    this.root = this._insert(this.root, val);\n  }\n\n  /**\n   * 删除子节点\n   * @param {number} val\n   */\n  delete(val) {\n    this.root = this._delete(this.root, val);\n  }\n\n  /**\n   * 辅助函数：删除子节点\n   * @param {avltreenode<number>} treenode\n   * @param {number} delval\n   * @returns\n   */\n  _delete(treenode, delval) {\n    if (treenode === null) {\n      // 空树，无法删除\n      return null;\n    } else if (delval < treenode.val) {\n      // val 位于左子树，其实就是相当于右子树的插入，所以在调整的时候，执行右旋\n      treenode.left = this._delete(treenode.left, delval);\n      // 更新树高\n      treenode.height =\n        math.max(\n          this.getheight(treenode.left),\n          this.getheight(treenode.right)\n        ) + 1;\n      if (\n        math.abs(\n          this.getheight(treenode.right) - this.getheight(treenode.left)\n        ) === 2\n      ) {\n        if (\n          this.getheight(treenode.right.right) >=\n          this.getheight(treenode.right.left)\n        ) {\n          treenode = this.singlerightrotation(treenode);\n        } else {\n          treenode = this.doubleleftrightrotation(treenode);\n        }\n      }\n    } else if (delval > treenode.val) {\n      // val 位于右子树删除，其实就是相当于是左子树插入\n      treenode.right = this._delete(treenode.right, delval);\n      // 更新树高\n      treenode.height =\n        math.max(\n          this.getheight(treenode.left),\n          this.getheight(treenode.right)\n        ) + 1;\n      if (\n        math.abs(\n          this.getheight(treenode.left) - this.getheight(treenode.right)\n        ) === 2\n      ) {\n        if (\n          this.getheight(treenode.left.left) >=\n          this.getheight(treenode.left.right)\n        ) {\n          treenode = this.singleleftrotation(treenode);\n        } else {\n          treenode = this.doubleleftrightrotation(treenode);\n        }\n      }\n    } else if (treenode.left && treenode.right) {\n      /* 如果待删除节点同时存在左右儿子节点 */\n      // 找到右子树的最小节点\n      let rightsubtreeminnode = this.findmin(treenode.right);\n      // 用右子树上的最小节点替换当前值，然后再从当前右子树触发，递归的删除右子树上的最小值。\n      treenode.val = rightsubtreeminnode.val;\n      treenode.right = this._delete(treenode.right, treenode.val);\n    } else {\n      /* 如果待删除节点只有左儿子节点，那么把它的左儿子直接赋值给它自己，相当于移除了待删除节点 */\n      if (treenode.right === null) {\n        treenode = treenode.left;\n      } else if (treenode.left === null) {\n        /* 如果待删除节点只有右儿子节点，那么把它的右儿子直接赋值给它自己，相当于移除了待删除节点 */\n        treenode = treenode.right;\n      } else {\n        /* 如果待删除节点没有左右儿子节点，直接赋值为空，相当于移除了待删除节点 */\n        treenode = null;\n      }\n    }\n    return treenode;\n  }\n\n  /**\n   * 辅助函数：插入子节点\n   * @param {avltreenode<number>} treenode\n   * @param {number} val\n   * @returns {avltreenode<number>}\n   */\n  _insert(treenode, val) {\n    /* 将x插入avl树treenode中，并且返回调整后的avl树 */\n    if (!treenode) {\n      /* 若插入空树，则新建包含一个结点的树 */\n      treenode = {\n        val: val,\n        height: 0,\n        left: null,\n        right: null,\n      };\n    } else if (val < treenode.val) {\n      /* 插入treenode的左子树 */\n      treenode.left = this._insert(treenode.left, val);\n      /* 如果需要左旋 */\n      if (\n        math.abs(\n          this.getheight(treenode.left) - this.getheight(treenode.right)\n        ) === 2\n      ) {\n        if (val < treenode.left.val) {\n          /* 左单旋 */\n          treenode = this.singleleftrotation(treenode);\n        } else {\n          /* 左-右双旋 */\n          treenode = this.doubleleftrightrotation(treenode);\n        }\n      }\n    } else if (val > treenode.val) {\n      /* 插入treenode的右子树 */\n      treenode.right = this._insert(treenode.right, val);\n      /* 如果需要右旋 */\n      if (\n        math.abs(\n          this.getheight(treenode.left) - this.getheight(treenode.right)\n        ) === 2\n      ) {\n        if (val > treenode.right.val) {\n          /* 右单旋 */\n          treenode = this.singlerightrotation(treenode);\n        } else {\n          /* 右-左双旋 */\n          treenode = this.doublerightleftrotation(treenode);\n        }\n      }\n    }\n    /* 更新树高 */\n    treenode.height =\n      math.max(this.getheight(treenode.left), this.getheight(treenode.right)) +\n      1;\n    return treenode;\n  }\n}\n\n\navl树的插入和删除时间复杂度都是o(log n)，具体的分析过程，有兴趣的同学请参考相应的论文资料。",charsets:{cjk:!0}},{title:"跳表(跳跃链表)",frontmatter:{},regularPath:"/data-structure/search/skipList.html",relativePath:"data-structure/search/skipList.md",key:"v-79b9b1d7",path:"/data-structure/search/skipList.html",headers:[{level:2,title:"跳表(跳跃链表)",slug:"跳表-跳跃链表",normalizedTitle:"跳表(跳跃链表)",charIndex:2},{level:3,title:"查找辅助函数",slug:"查找辅助函数",normalizedTitle:"查找辅助函数",charIndex:877},{level:3,title:"查找",slug:"查找",normalizedTitle:"查找",charIndex:76},{level:3,title:"插入",slug:"插入",normalizedTitle:"插入",charIndex:27},{level:3,title:"删除",slug:"删除",normalizedTitle:"删除",charIndex:30},{level:3,title:"结语",slug:"结语",normalizedTitle:"结语",charIndex:4541}],headersStr:"跳表(跳跃链表) 查找辅助函数 查找 插入 删除 结语",content:'# 跳表(跳跃链表)\n\n在前文，我们有介绍链表，链表的插入和删除是较为高效的，因为只需要修改前驱和后继指针，但是链表无法做到像数组那样的随机化访问，每次查找的平均算法复杂度为O(N)，这是链表的一个比较大的缺点。\n\n跳跃链表，简称跳表，在原有的有序链表上面增加了多级索引，通过索引来实现快速查找，是一个随机化的数据结构，实质就是一种可以进行二分查找的有序链表，是在 O(log*n)时间内完成增加、删除、搜索操作的数据结构。\n\n跳表相比于堆与AVL树(或红黑树)，其功能与性能相当，但跳表的代码长度相较下更短，其设计思想与链表相似。\n\n跳表不仅能提高搜索性能，同时也可以提高插入和删除操作的性能。\n\n最底层是原始的链表，接着根据生成的随机数决定是否继续向上生成当前节点的后继节点，直到把它的最大层都填满(以 4 层举例)，大致如下图：\n\n\n\n第一个节点是哨兵节点，跳表的节点就像鳞次栉比的山峰，不同的山峰之间的相同层上就是建立的引用关系，用来加快查找的速度。\n\n需要注意的是，比如对于图中的节点3，并不是说它的next指针数组的长度为 1，而依然是 4 层，只不过，除了最底层的内容以外，其余都存的是null，我们在查找时，某层就会忽略这个节点，这样就实现了跳跃。\n\n因此，可以采用如下方式来表示跳表中的节点：\n\nclass ListNode {\n  /**\n   * @type {number}\n   */\n  val = -1;\n  /**\n   * @type {ListNode[]}\n   */\n  next = [];\n  /**\n   * @param {number} val\n   * @param {number} level\n   */\n  constructor(val, level) {\n    this.val = val;\n    // 初始化指定高度的数组\n    this.next = Array.from({\n      length: level,\n    }).fill(null);\n  }\n}\n\n\n\n# 查找辅助函数\n\n因为跳表是基于二分查找的，在查找的过程中，我们总是从最上层查找到最下层的，我们需要把每次的位置记下来，这样不管是查找， 插入，删除都可以很方便的使用这个路径。\n\n这节我们先不详细阐述辅助函数，同学们可以看完插入节之后再回头来看这节的内容。\n\n/**\n * 查找辅助函数，记录从上至下查找路径\n * @param {number} target\n */\nfunction find(target) {\n  let path = Array.from({\n    length: this.level,\n  }).fill(null);\n  // 从头节点开始遍历每一层，p最开始就是头结点\n  let p = this.head;\n  for (let i = this.level - 1; i >= 0; i--) {\n    // 从上层往下层找\n    while (p.next[i] && p.next[i].val < target) {\n      // 如果当前层 i 的 next 不为空，且它的值小于 target，则 p 往后走指向这一层 p 的 next，下层的p就从这一层的p开始\n      p = p.next[i];\n    }\n    // 退出 while 时说明找到了第 i 层小于 target 的最大节点就是 p\n    path[i] = p;\n  }\n  return path;\n}\n\n\n\n# 查找\n\n上面的查找辅助函数我们并没有给出运行过程，因为需要结合着一个操作来解释它才更好描述。\n\n比如，现在跳表的存储如上图所示，查找一个存在的情况，假设要查找22。\n\n首先，从head的最顶层开始查找，向后找到节点7，接着找，发现已经到末尾，因此，路径的第一层节点可以确定为节点7。\n\n接着，从head的第二层开始查找，这次，我们要直接从节点7开始向后找，发现下一节点为37，但是37大于22，因此，路径的第 2 层的节点可以确定为节点7。\n\n然后，从head的第三层开始查找，这次，我们要直接从节点7开始向后找，发现下一节点为19，接着往后找，发现下一节点是37，但是37大于22，因此，路径的第 3 层的节点可以确定为节点19。\n\n最后，从head的最后一层开始查找，这次，我们要直接从19开始向后找，发现下一节点为22，但是22等于22，因此，路径的第 4 层的节点可以确定为节点19。\n\n有同学可能会问，为什么19后面就一定是22呢？，因为这个跳表里面的节点太少，不太好理解，假设有很多节点，比如19后面有20，21，循环是要遇到大于等于22的才会停止的。\n\n比如，现在跳表的存储如表示方法节所描述所示，查找一个不存在的情况，假设要查找23。\n\n首先，从head的最顶层开始查找，向后找到7，接着找，发现已经到末尾，因此，路径的第一层节点可以确定为节点7。\n\n接着，从head的第二层开始查找，这次，我们要直接从7开始向后找，发现下一节点为37，但是37大于22，因此，路径的第 2 层的节点可以确定为节点7。\n\n然后，从head的第三层开始查找，这次，我们要直接从7开始向后找，发现下一节点为19，接着往后找，发现下一节点是37，但是37大于22，因此，路径的第 3 层的节点可以确定为节点19。\n\n最后，从head的最后一层开始查找，这次，我们要直接从19开始向后找，发现下一节点为22，但是22小于23，接着向后查找，发现下一节点是37，37大于23，因此，路径的第 4 层的节点可以确定为节点22。\n\n因为节点22的下一节点是33，因此可以得知，23在表中不存在。\n\n上述的查找过程，大致如下图所示：\n\n\n\n/**\n * 查找元素\n * @param {number} target\n * @returns\n */\nfunction search(target) {\n  // 先找到每一层 i 小于目标值 target 的最大节点 path[i]\n  let path = this.find(target);\n  // 因为最下层【0】的节点是全的，所以只需要判断 target 是否在第 0 层即可，而 path[0] 正好就是小于 target 的最大节点，如果 path[0]->next[0] 的值不是 target 说明没有这个元素\n  let p = path[0].next[0];\n  return p != null && p.val == target;\n}\n\n\n在明白查找过程之后，大家再回过头来看我们的find函数就一目了然了。如果你掌握了跳表的查找，那么恭喜你，整个跳表的知识点你已经掌握了 80%了。\n\n\n# 插入\n\n对于插入操作，我们需要根据随机数据来决定当前节点的高度。下文以0.5为分界线，若超过的话，我们就不断的建立后继指针，否则就在某层提前结束。这是一个跟单链表类似的操作。\n\n首先，find辅助函数已经找到了每层的节点，那么对于每层的节点，即path[i]，我们可以直接将新创建的节点加入到链表中。\n\n即：\n\n// 创建一个新的节点\nlet node = new ListNode(num, this.level);\n// 将对应层的next指针指向path的next指针的对应层\nnode.next[i] = path[i].next[i];\n// 将path的next指针指向node\npath[i].next[i] = node;\n/**\n * node.next = path.next\n * path.next = node\n */\n\n\n如果看着比较迷糊的同学，你可以先不考虑i这个变量对插入操作的影响，先将其抽象为普通的链表插入来理解，如代码中的注释所示，抽象流程如下：\n\n\n\n随机数即控制了我们要建立多少层的关联，因此整个插入流程如下图所示：\n\n\n\n/**\n * 插入元素\n * @param {number} num\n */\nfunction add(num) {\n  // 先找到每一层 i 小于目标值 target 的最大节点 path[i]\n  let path = this.find(num);\n  // 创建要插入的新节点\n  let node = new ListNode(num, this.level);\n  for (let i = 0; i < this.level; i++) {\n    // 遍历每一层，从下往上插入新节点\n    // 这两步就是单链表的插入\n    node.next[i] = path[i].next[i];\n    path[i].next[i] = node;\n    // 每一层有 50% 的概率不插入新节点\n    if (Math.random() > 0.5) {\n      break;\n    }\n  }\n}\n\n\n\n# 删除\n\n删除操作也相对比较简单，首先，我们需要确定待删除的值在跳表中是否存在，为什么我们不直接调用查找函数而是要调用辅助函数呢，这是因为我们需要知道待删除节点的前驱节点。\n\n比如，现在要删除节点22，经过前置查找，我们能确定下来节点22的前置指针，接着，就可以直接对每层的指针进行删除。\n\n需要注意的是，待删除节点可能不是每层都有的，我们在删除的时候，必须从底层删至上层，发现当前层为空的话，就可提前结束循环了。\n\n/**\n * 删除元素\n * @param {number} num\n * @returns\n */\nfunction remove(num) {\n  // 先找到每一层 i 小于目标值 target 的最大节点 path[i]\n  let path = this.find(num);\n  // 先判断 num 是否存在，不存在直接返回 false\n  // 第 0 层存储的是全部节点，所以只需要判断 path[0]->next[0]（第 0 层小于 num 的最大节点的在第 0 层的 next） 是不是 num 即可\n  let p = path[0].next[0];\n  if (!p || p.val != num) {\n    console.warn("要删除的值不存在!");\n    return false;\n  }\n  // 否则删除每一层的 num，如果 path[i]->next[i] == p 说明第 i 层存在 p\n  for (let i = 0; i < this.level && path[i].next[i] === p; i++) {\n    // 单链表删除\n    path[i].next[i] = p.next[i];\n  }\n  p = null; // 删除节点 p，防止内存泄漏\n  return true;\n}\n\n\n\n# 结语\n\n跳表也是典型的空间换时间的应用场景，在大名鼎鼎的Redis中，就使用了跳表。\n\n# 时间复杂度\n\n跳表的查询、删除、插入的时间复杂度近似O(log*n)，其证明过程非常复杂，具体的分析过程超出了本文的讨论范畴，有兴趣的同学可以参考原始论文。\n\n# 空间复杂度\n\nO(level*n)，和层数以及节点数相关，每个节点最大的开销就是存储在每一层的next。\n\n跳表的完整实现如下：\n\nclass ListNode {\n  /**\n   * @type {number}\n   */\n  val = -1;\n  /**\n   * @type {ListNode[]}\n   */\n  next = [];\n  /**\n   * @param {number} val\n   * @param {number} level\n   */\n  constructor(val, level) {\n    this.val = val;\n    // 初始化指定高度的数组\n    this.next = Array.from({\n      length: level,\n    }).fill(null);\n  }\n}\n\nclass SkipList {\n  /**\n   * 最大层数\n   * @type {number}\n   */\n  level = 8;\n  /**\n   * 头结点\n   * @type {ListNode | null}\n   */\n  head = null;\n\n  constructor() {\n    this.head = new ListNode(-1, this.level);\n  }\n  /**\n   * 查找辅助函数，记录从上至下查找路径\n   * @param {number} target\n   */\n  find(target) {\n    let path = Array.from({\n      length: this.level,\n    }).fill(null);\n    // 从头节点开始遍历每一层\n    let p = this.head;\n    for (let i = this.level - 1; i >= 0; i--) {\n      // 从上层往下层找\n      while (p.next[i] && p.next[i].val < target) {\n        // 如果当前层 i 的 next 不为空，且它的值小于 target，则 p 往后走指向这一层 p 的 next\n        p = p.next[i];\n      }\n      // 退出 while 时说明找到了第 i 层小于 target 的最大节点就是 p\n      path[i] = p;\n    }\n    return path;\n  }\n  /**\n   * 查找元素\n   * @param {number} target\n   * @returns\n   */\n  search(target) {\n    // 先找到每一层 i 小于目标值 target 的最大节点 path[i]\n    let path = this.find(target);\n    // 因为最下层【0】的节点是全的，所以只需要判断 target 是否在第 0 层即可，而 path[0] 正好就是小于 target 的最大节点，如果 path[0]->next[0] 的值不是 target 说明没有这个元素\n    let p = path[0].next[0];\n    return p != null && p.val == target;\n  }\n\n  /**\n   * 插入元素\n   * @param {number} num\n   */\n  add(num) {\n    // 先找到每一层 i 小于目标值 target 的最大节点 path[i]\n    let path = this.find(num);\n    // 创建要插入的新节点\n    let node = new ListNode(num, this.level);\n    for (let i = 0; i < this.level; i++) {\n      // 遍历每一层，从下往上插入新节点\n      // 这两步就是单链表的插入\n      node.next[i] = path[i].next[i];\n      path[i].next[i] = node;\n      // 每一层有 50% 的概率不插入新节点\n      if (Math.random() > 0.5) {\n        break;\n      }\n    }\n  }\n  /**\n   * 删除元素\n   * @param {number} num\n   * @returns\n   */\n  remove(num) {\n    // 先找到每一层 i 小于目标值 target 的最大节点 path[i]\n    let path = this.find(num);\n    // 先判断 num 是否存在，不存在直接返回 false\n    // 第 0 层存储的是全部节点，所以只需要判断 path[0]->next[0]（第 0 层小于 num 的最大节点的在第 0 层的 next） 是不是 num 即可\n    let p = path[0].next[0];\n    if (!p || p.val != num) {\n      console.warn("要删除的值不存在!");\n      return false;\n    }\n    // 否则删除每一层的 num，如果 path[i]->next[i] == p 说明第 i 层存在 p\n    for (let i = 0; i < this.level && path[i].next[i] == p; i++) {\n      // 单链表删除\n      path[i].next[i] = p.next[i];\n    }\n    // 删除节点 p，防止内存泄漏\n    p = null;\n    return true;\n  }\n}\n',normalizedContent:'# 跳表(跳跃链表)\n\n在前文，我们有介绍链表，链表的插入和删除是较为高效的，因为只需要修改前驱和后继指针，但是链表无法做到像数组那样的随机化访问，每次查找的平均算法复杂度为o(n)，这是链表的一个比较大的缺点。\n\n跳跃链表，简称跳表，在原有的有序链表上面增加了多级索引，通过索引来实现快速查找，是一个随机化的数据结构，实质就是一种可以进行二分查找的有序链表，是在 o(log*n)时间内完成增加、删除、搜索操作的数据结构。\n\n跳表相比于堆与avl树(或红黑树)，其功能与性能相当，但跳表的代码长度相较下更短，其设计思想与链表相似。\n\n跳表不仅能提高搜索性能，同时也可以提高插入和删除操作的性能。\n\n最底层是原始的链表，接着根据生成的随机数决定是否继续向上生成当前节点的后继节点，直到把它的最大层都填满(以 4 层举例)，大致如下图：\n\n\n\n第一个节点是哨兵节点，跳表的节点就像鳞次栉比的山峰，不同的山峰之间的相同层上就是建立的引用关系，用来加快查找的速度。\n\n需要注意的是，比如对于图中的节点3，并不是说它的next指针数组的长度为 1，而依然是 4 层，只不过，除了最底层的内容以外，其余都存的是null，我们在查找时，某层就会忽略这个节点，这样就实现了跳跃。\n\n因此，可以采用如下方式来表示跳表中的节点：\n\nclass listnode {\n  /**\n   * @type {number}\n   */\n  val = -1;\n  /**\n   * @type {listnode[]}\n   */\n  next = [];\n  /**\n   * @param {number} val\n   * @param {number} level\n   */\n  constructor(val, level) {\n    this.val = val;\n    // 初始化指定高度的数组\n    this.next = array.from({\n      length: level,\n    }).fill(null);\n  }\n}\n\n\n\n# 查找辅助函数\n\n因为跳表是基于二分查找的，在查找的过程中，我们总是从最上层查找到最下层的，我们需要把每次的位置记下来，这样不管是查找， 插入，删除都可以很方便的使用这个路径。\n\n这节我们先不详细阐述辅助函数，同学们可以看完插入节之后再回头来看这节的内容。\n\n/**\n * 查找辅助函数，记录从上至下查找路径\n * @param {number} target\n */\nfunction find(target) {\n  let path = array.from({\n    length: this.level,\n  }).fill(null);\n  // 从头节点开始遍历每一层，p最开始就是头结点\n  let p = this.head;\n  for (let i = this.level - 1; i >= 0; i--) {\n    // 从上层往下层找\n    while (p.next[i] && p.next[i].val < target) {\n      // 如果当前层 i 的 next 不为空，且它的值小于 target，则 p 往后走指向这一层 p 的 next，下层的p就从这一层的p开始\n      p = p.next[i];\n    }\n    // 退出 while 时说明找到了第 i 层小于 target 的最大节点就是 p\n    path[i] = p;\n  }\n  return path;\n}\n\n\n\n# 查找\n\n上面的查找辅助函数我们并没有给出运行过程，因为需要结合着一个操作来解释它才更好描述。\n\n比如，现在跳表的存储如上图所示，查找一个存在的情况，假设要查找22。\n\n首先，从head的最顶层开始查找，向后找到节点7，接着找，发现已经到末尾，因此，路径的第一层节点可以确定为节点7。\n\n接着，从head的第二层开始查找，这次，我们要直接从节点7开始向后找，发现下一节点为37，但是37大于22，因此，路径的第 2 层的节点可以确定为节点7。\n\n然后，从head的第三层开始查找，这次，我们要直接从节点7开始向后找，发现下一节点为19，接着往后找，发现下一节点是37，但是37大于22，因此，路径的第 3 层的节点可以确定为节点19。\n\n最后，从head的最后一层开始查找，这次，我们要直接从19开始向后找，发现下一节点为22，但是22等于22，因此，路径的第 4 层的节点可以确定为节点19。\n\n有同学可能会问，为什么19后面就一定是22呢？，因为这个跳表里面的节点太少，不太好理解，假设有很多节点，比如19后面有20，21，循环是要遇到大于等于22的才会停止的。\n\n比如，现在跳表的存储如表示方法节所描述所示，查找一个不存在的情况，假设要查找23。\n\n首先，从head的最顶层开始查找，向后找到7，接着找，发现已经到末尾，因此，路径的第一层节点可以确定为节点7。\n\n接着，从head的第二层开始查找，这次，我们要直接从7开始向后找，发现下一节点为37，但是37大于22，因此，路径的第 2 层的节点可以确定为节点7。\n\n然后，从head的第三层开始查找，这次，我们要直接从7开始向后找，发现下一节点为19，接着往后找，发现下一节点是37，但是37大于22，因此，路径的第 3 层的节点可以确定为节点19。\n\n最后，从head的最后一层开始查找，这次，我们要直接从19开始向后找，发现下一节点为22，但是22小于23，接着向后查找，发现下一节点是37，37大于23，因此，路径的第 4 层的节点可以确定为节点22。\n\n因为节点22的下一节点是33，因此可以得知，23在表中不存在。\n\n上述的查找过程，大致如下图所示：\n\n\n\n/**\n * 查找元素\n * @param {number} target\n * @returns\n */\nfunction search(target) {\n  // 先找到每一层 i 小于目标值 target 的最大节点 path[i]\n  let path = this.find(target);\n  // 因为最下层【0】的节点是全的，所以只需要判断 target 是否在第 0 层即可，而 path[0] 正好就是小于 target 的最大节点，如果 path[0]->next[0] 的值不是 target 说明没有这个元素\n  let p = path[0].next[0];\n  return p != null && p.val == target;\n}\n\n\n在明白查找过程之后，大家再回过头来看我们的find函数就一目了然了。如果你掌握了跳表的查找，那么恭喜你，整个跳表的知识点你已经掌握了 80%了。\n\n\n# 插入\n\n对于插入操作，我们需要根据随机数据来决定当前节点的高度。下文以0.5为分界线，若超过的话，我们就不断的建立后继指针，否则就在某层提前结束。这是一个跟单链表类似的操作。\n\n首先，find辅助函数已经找到了每层的节点，那么对于每层的节点，即path[i]，我们可以直接将新创建的节点加入到链表中。\n\n即：\n\n// 创建一个新的节点\nlet node = new listnode(num, this.level);\n// 将对应层的next指针指向path的next指针的对应层\nnode.next[i] = path[i].next[i];\n// 将path的next指针指向node\npath[i].next[i] = node;\n/**\n * node.next = path.next\n * path.next = node\n */\n\n\n如果看着比较迷糊的同学，你可以先不考虑i这个变量对插入操作的影响，先将其抽象为普通的链表插入来理解，如代码中的注释所示，抽象流程如下：\n\n\n\n随机数即控制了我们要建立多少层的关联，因此整个插入流程如下图所示：\n\n\n\n/**\n * 插入元素\n * @param {number} num\n */\nfunction add(num) {\n  // 先找到每一层 i 小于目标值 target 的最大节点 path[i]\n  let path = this.find(num);\n  // 创建要插入的新节点\n  let node = new listnode(num, this.level);\n  for (let i = 0; i < this.level; i++) {\n    // 遍历每一层，从下往上插入新节点\n    // 这两步就是单链表的插入\n    node.next[i] = path[i].next[i];\n    path[i].next[i] = node;\n    // 每一层有 50% 的概率不插入新节点\n    if (math.random() > 0.5) {\n      break;\n    }\n  }\n}\n\n\n\n# 删除\n\n删除操作也相对比较简单，首先，我们需要确定待删除的值在跳表中是否存在，为什么我们不直接调用查找函数而是要调用辅助函数呢，这是因为我们需要知道待删除节点的前驱节点。\n\n比如，现在要删除节点22，经过前置查找，我们能确定下来节点22的前置指针，接着，就可以直接对每层的指针进行删除。\n\n需要注意的是，待删除节点可能不是每层都有的，我们在删除的时候，必须从底层删至上层，发现当前层为空的话，就可提前结束循环了。\n\n/**\n * 删除元素\n * @param {number} num\n * @returns\n */\nfunction remove(num) {\n  // 先找到每一层 i 小于目标值 target 的最大节点 path[i]\n  let path = this.find(num);\n  // 先判断 num 是否存在，不存在直接返回 false\n  // 第 0 层存储的是全部节点，所以只需要判断 path[0]->next[0]（第 0 层小于 num 的最大节点的在第 0 层的 next） 是不是 num 即可\n  let p = path[0].next[0];\n  if (!p || p.val != num) {\n    console.warn("要删除的值不存在!");\n    return false;\n  }\n  // 否则删除每一层的 num，如果 path[i]->next[i] == p 说明第 i 层存在 p\n  for (let i = 0; i < this.level && path[i].next[i] === p; i++) {\n    // 单链表删除\n    path[i].next[i] = p.next[i];\n  }\n  p = null; // 删除节点 p，防止内存泄漏\n  return true;\n}\n\n\n\n# 结语\n\n跳表也是典型的空间换时间的应用场景，在大名鼎鼎的redis中，就使用了跳表。\n\n# 时间复杂度\n\n跳表的查询、删除、插入的时间复杂度近似o(log*n)，其证明过程非常复杂，具体的分析过程超出了本文的讨论范畴，有兴趣的同学可以参考原始论文。\n\n# 空间复杂度\n\no(level*n)，和层数以及节点数相关，每个节点最大的开销就是存储在每一层的next。\n\n跳表的完整实现如下：\n\nclass listnode {\n  /**\n   * @type {number}\n   */\n  val = -1;\n  /**\n   * @type {listnode[]}\n   */\n  next = [];\n  /**\n   * @param {number} val\n   * @param {number} level\n   */\n  constructor(val, level) {\n    this.val = val;\n    // 初始化指定高度的数组\n    this.next = array.from({\n      length: level,\n    }).fill(null);\n  }\n}\n\nclass skiplist {\n  /**\n   * 最大层数\n   * @type {number}\n   */\n  level = 8;\n  /**\n   * 头结点\n   * @type {listnode | null}\n   */\n  head = null;\n\n  constructor() {\n    this.head = new listnode(-1, this.level);\n  }\n  /**\n   * 查找辅助函数，记录从上至下查找路径\n   * @param {number} target\n   */\n  find(target) {\n    let path = array.from({\n      length: this.level,\n    }).fill(null);\n    // 从头节点开始遍历每一层\n    let p = this.head;\n    for (let i = this.level - 1; i >= 0; i--) {\n      // 从上层往下层找\n      while (p.next[i] && p.next[i].val < target) {\n        // 如果当前层 i 的 next 不为空，且它的值小于 target，则 p 往后走指向这一层 p 的 next\n        p = p.next[i];\n      }\n      // 退出 while 时说明找到了第 i 层小于 target 的最大节点就是 p\n      path[i] = p;\n    }\n    return path;\n  }\n  /**\n   * 查找元素\n   * @param {number} target\n   * @returns\n   */\n  search(target) {\n    // 先找到每一层 i 小于目标值 target 的最大节点 path[i]\n    let path = this.find(target);\n    // 因为最下层【0】的节点是全的，所以只需要判断 target 是否在第 0 层即可，而 path[0] 正好就是小于 target 的最大节点，如果 path[0]->next[0] 的值不是 target 说明没有这个元素\n    let p = path[0].next[0];\n    return p != null && p.val == target;\n  }\n\n  /**\n   * 插入元素\n   * @param {number} num\n   */\n  add(num) {\n    // 先找到每一层 i 小于目标值 target 的最大节点 path[i]\n    let path = this.find(num);\n    // 创建要插入的新节点\n    let node = new listnode(num, this.level);\n    for (let i = 0; i < this.level; i++) {\n      // 遍历每一层，从下往上插入新节点\n      // 这两步就是单链表的插入\n      node.next[i] = path[i].next[i];\n      path[i].next[i] = node;\n      // 每一层有 50% 的概率不插入新节点\n      if (math.random() > 0.5) {\n        break;\n      }\n    }\n  }\n  /**\n   * 删除元素\n   * @param {number} num\n   * @returns\n   */\n  remove(num) {\n    // 先找到每一层 i 小于目标值 target 的最大节点 path[i]\n    let path = this.find(num);\n    // 先判断 num 是否存在，不存在直接返回 false\n    // 第 0 层存储的是全部节点，所以只需要判断 path[0]->next[0]（第 0 层小于 num 的最大节点的在第 0 层的 next） 是不是 num 即可\n    let p = path[0].next[0];\n    if (!p || p.val != num) {\n      console.warn("要删除的值不存在!");\n      return false;\n    }\n    // 否则删除每一层的 num，如果 path[i]->next[i] == p 说明第 i 层存在 p\n    for (let i = 0; i < this.level && path[i].next[i] == p; i++) {\n      // 单链表删除\n      path[i].next[i] = p.next[i];\n    }\n    // 删除节点 p，防止内存泄漏\n    p = null;\n    return true;\n  }\n}\n',charsets:{cjk:!0}},{frontmatter:{},regularPath:"/data-structure/sort/",relativePath:"data-structure/sort/index.md",key:"v-bb0e9124",path:"/data-structure/sort/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{title:"桶排序",frontmatter:{},regularPath:"/data-structure/sort/bucketSort.html",relativePath:"data-structure/sort/bucketSort.md",key:"v-390e2f26",path:"/data-structure/sort/bucketSort.html",headers:[{level:2,title:"桶排序",slug:"桶排序",normalizedTitle:"桶排序",charIndex:2},{level:3,title:"排序过程",slug:"排序过程",normalizedTitle:"排序过程",charIndex:163},{level:3,title:"算法实现",slug:"算法实现",normalizedTitle:"算法实现",charIndex:583},{level:3,title:"复杂度与稳定性",slug:"复杂度与稳定性",normalizedTitle:"复杂度与稳定性",charIndex:1084}],headersStr:"桶排序 排序过程 算法实现 复杂度与稳定性",content:"# 桶排序\n\n桶排序的思路与之前提到过的排序算法的思路都不同，之前提到的排序算法都是基于数值的大小比较进行排序的，而桶排序是基于基准进行排序，因此每个基准就可以看做一个桶。\n\n桶排序的基准的计算，其作用就相当于快排中划分，已经把大量数据分割成了基本有序的数据块(桶)。然后只需要对桶中的少量数据做先进的比较排序即可。\n\n\n# 排序过程\n\n举个大家都经历过的例子，某些大学会限制大一参加英语四级考试的名额，假设现在需要对大一新生的英语成绩进行排序，选取英语成绩位于前50%的学生允许参加大一上学期的英语四级考试。\n\n一般来说一个大学的新生一般都是一万人左右，如果直接用基于比较的排序算法也不会特别的耗时间，但是通过观察可以知道的是，这些学生的成绩有个显著的特点，它们都是在[0-150]之间，也就是说，我们可以申明151个数组，每个数组（即桶）保存对应分数学生的英语成绩。最后，我们再将排序之后的数据导回至原来的数据中则完成排序。可以看到的是，由于我们的桶是远远小于数组的量级的，在排序的时候我们会使用一轮循环遍历数据，最后将排序之后的数据导回去需要一轮循环。其时间复杂度是线性的，约为O(N)（需要注意的是此处把成绩插入到对应的桶中是不需要再进行排序的，所以时间复杂度可以表示为O(N)），可以看到这个例子的算法时间复杂度是已经超过了基于比较的排序算法的。\n\n\n# 算法实现\n\n/**\n * 桶排序\n * @param {number[]} arr\n */\nfunction bucketSort(arr) {\n  /* 申明桶 */\n  const buckets = Array.from({\n    length: 151,\n  }).map(() => {\n    return [];\n  });\n  /* 按分值划分桶 */\n  for (let i = 0; i < arr.length; i++) {\n    const score = arr[i];\n    buckets[score].push(score);\n  }\n  /* 将桶中的数据导回至原数组 */\n  let offset = 0;\n  while (buckets.length) {\n    const bucket = buckets.shift();\n    while (bucket.length) {\n      const score = bucket.shift();\n      arr[offset++] = score;\n    }\n  }\n}\n\n\n\n# 复杂度与稳定性\n\n假设数据有N项，排序过程中分配M个桶，桶排序的平均时间复杂度为线性的 O(N+C)，其中 C=N*(logN-logM)。如果相对于同样的N，桶数量M越大，其效率越高，最好的时间复杂度达到O(N)。空间复杂度为O(N+M)。",normalizedContent:"# 桶排序\n\n桶排序的思路与之前提到过的排序算法的思路都不同，之前提到的排序算法都是基于数值的大小比较进行排序的，而桶排序是基于基准进行排序，因此每个基准就可以看做一个桶。\n\n桶排序的基准的计算，其作用就相当于快排中划分，已经把大量数据分割成了基本有序的数据块(桶)。然后只需要对桶中的少量数据做先进的比较排序即可。\n\n\n# 排序过程\n\n举个大家都经历过的例子，某些大学会限制大一参加英语四级考试的名额，假设现在需要对大一新生的英语成绩进行排序，选取英语成绩位于前50%的学生允许参加大一上学期的英语四级考试。\n\n一般来说一个大学的新生一般都是一万人左右，如果直接用基于比较的排序算法也不会特别的耗时间，但是通过观察可以知道的是，这些学生的成绩有个显著的特点，它们都是在[0-150]之间，也就是说，我们可以申明151个数组，每个数组（即桶）保存对应分数学生的英语成绩。最后，我们再将排序之后的数据导回至原来的数据中则完成排序。可以看到的是，由于我们的桶是远远小于数组的量级的，在排序的时候我们会使用一轮循环遍历数据，最后将排序之后的数据导回去需要一轮循环。其时间复杂度是线性的，约为o(n)（需要注意的是此处把成绩插入到对应的桶中是不需要再进行排序的，所以时间复杂度可以表示为o(n)），可以看到这个例子的算法时间复杂度是已经超过了基于比较的排序算法的。\n\n\n# 算法实现\n\n/**\n * 桶排序\n * @param {number[]} arr\n */\nfunction bucketsort(arr) {\n  /* 申明桶 */\n  const buckets = array.from({\n    length: 151,\n  }).map(() => {\n    return [];\n  });\n  /* 按分值划分桶 */\n  for (let i = 0; i < arr.length; i++) {\n    const score = arr[i];\n    buckets[score].push(score);\n  }\n  /* 将桶中的数据导回至原数组 */\n  let offset = 0;\n  while (buckets.length) {\n    const bucket = buckets.shift();\n    while (bucket.length) {\n      const score = bucket.shift();\n      arr[offset++] = score;\n    }\n  }\n}\n\n\n\n# 复杂度与稳定性\n\n假设数据有n项，排序过程中分配m个桶，桶排序的平均时间复杂度为线性的 o(n+c)，其中 c=n*(logn-logm)。如果相对于同样的n，桶数量m越大，其效率越高，最好的时间复杂度达到o(n)。空间复杂度为o(n+m)。",charsets:{cjk:!0}},{title:"排序算法的比较与总结",frontmatter:{},regularPath:"/data-structure/sort/compare.html",relativePath:"data-structure/sort/compare.md",key:"v-162bf415",path:"/data-structure/sort/compare.html",headers:[{level:2,title:"排序算法的比较与总结",slug:"排序算法的比较与总结",normalizedTitle:"排序算法的比较与总结",charIndex:2},{level:3,title:"规范",slug:"规范",normalizedTitle:"规范",charIndex:17},{level:3,title:"排序算法的稳定性",slug:"排序算法的稳定性",normalizedTitle:"排序算法的稳定性",charIndex:94},{level:3,title:"复杂度、稳定性与额外占用空间比较",slug:"复杂度、稳定性与额外占用空间比较",normalizedTitle:"复杂度、稳定性与额外占用空间比较",charIndex:1175},{level:3,title:"时间比较",slug:"时间比较",normalizedTitle:"时间比较",charIndex:1722}],headersStr:"排序算法的比较与总结 规范 排序算法的稳定性 复杂度、稳定性与额外占用空间比较 时间比较",content:"# 排序算法的比较与总结\n\n\n# 规范\n\n排序算法必须原地排序，不能修改数组的引用，只能修改数组内容\n\n排序算法必须向外界提供统一的接口，仅接收一个数组作为参数，不返回任何内容；\n\n\n# 排序算法的稳定性\n\n这是一个我们经常提到，但是却又没有怎么留意的问题。什么是排序算法的稳定性呢，就比如现在我们有一堆手牌， 假设，我现在手里面按顺序有梅花6，红桃A，方块6，红桃2，黑桃5。我们按点数大小（Ace视为 1 点）从小到大进行排序，此时，有两个数值相同的 6，如果说，当我们的排序算法完成之后，梅花6还是排在方块6之前的话，那么我们就可以说这个排序算法是稳定的。什么时候我们才会考虑稳定性呢？就拿刚才的例子举例，我们希望当数值相同时，扑克的花色按最初的相对顺序排列，这时候就需要用一个稳定的排序算法。\n\n比如，现在我们要选出优秀的学生参与奥赛班，我们对学生进行一次摸底考试，根据学生的的成绩排序，然后再根据学生的年纪进行排序，我们就可以选出相同成绩下年级较小的同学参赛，若排序算法不稳定的话，则会导致我们用年龄再次排序时就达不到预期的效果了。如果只是单纯的对成绩排序，那么就不会再有什么想通数组的初始顺序的问题了，所以，系统为我们实现的排序方法，当你在对数字进行排序的时候，一般会采用不稳定的，对对象进行排序的时候，会采用稳定的算法。\n\n但是排序算法的稳定性并不是绝对的，这取决于你写的排序算法的判别条件，众所周知，插入排序是稳定的排序算法，但是假设我们把代码写成这样：\n\n\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n/**\n * 对数组进行插入排序\n * @param {Array<number>} arr 需要进行排序的数组\n */\nfunction insertionSort(arr) {\n  // 默认认为第一个元素已经有序\n  for (let i = 1; i < arr.length; i++) {\n    let j = i;\n    let cur = arr[i];\n    //向前找合适的插入位置，退出条件有两种可能，1、找到了合适的插入位置；2、找到了头了\n    while (j > 0 && arr[j - 1] >= cur) {\n      // 在每次查找插入位置的时候，都将当前元素向后挪一位。\n      arr[j] = arr[j - 1];\n      j--;\n    }\n    arr[j] = cur;\n  }\n}\n\n\n如果我们把向前插入的条件写成arr[j - 1] >= cur，那么很明显当方块6进行插入的时候，它一定会跑到梅花6的前面去，变成了不稳定的排序算法了。\n\n因此，排序算法的稳定性其实还是一个相对的概念，如果你只要举得出例子证明它，那么它就是稳定或者不稳定的。\n\n\n# 复杂度、稳定性与额外占用空间比较\n\n排序算法名称   平均算法复杂度                     是否稳定   是否额外空间复杂度\n冒泡排序     O(N²)                       是      否\n选择排序     O(N²)                       是      否\n插入排序     O(N²)                       是      否\n希尔排序     O(N*logN)                   否      否\n快速排序     O(N*logN)                   否      否\n归并排序     O(N*logN)                   是      是，O(N)\n堆排序      O(N*logN)                   否      否\n桶排序      O(N+C)，其中 C=N*(logN-logM)   是      是，O(N+M)，N 为数据的数量级，M 为桶的数量级\n基数排序     O(P(N+B))                   是      是，O(N+M)，N 为数据的数量级，M 为桶的数量级\n\n\n# 时间比较\n\n我们各类的语言底层（如 JS 的Array.prototype.sort）提供的排序算法就是根据不同排序算法的稳定性、时间复杂度、空间复杂度差异，根据待排数据的性质，在三者之间进行取舍，从而实现更加高效的排序算法。\n\n为了让大家直观的体验不同排序算法的差异，我对这些排序算法在 LeetCode 上都依次进行了提交（同一个排序算法 3 次提交，对结果取最接近平均值的那组数据），然后将结果进行了统计，结果如下：\n\n排序算法名称                       执行用时      执行用时击败所有提交区间   内存消耗      内存消耗击败所有提交区间   是否稳定\n冒泡排序                         6036ms    10.62%         50.7MB    89.30%         是\n选择排序                         7100 ms   6.86%          50.7 MB   86.00%         是\n插入排序                         1508 ms   39.15%         50.8 MB   85.80%         是\n希尔排序                         108 ms    95.09%         50.8 MB   85.80%         是\n朴素快速排序                       1512 ms   39.06%         57.5 MB   37.14%         否\n三元取中快速排序                     112 ms    91.57%         50.8 MB   83.76%         否\n归并排序（递归版）                    620 ms    48.71%         54.2 MB   49.68%         是\n归并排序（非递归版）                   120 ms    83.46%         51.6 MB   63.65%         是\n堆排序                          108 ms    95.09%         50.5 MB   93.77%         否\n桶排序（采用了 10 个桶，每个桶采用直接插入排序）   4140 ms   17.98%         61.4MB    11.93%         是\n基数排序                         108ms     23.01%         57.6MB    8.21%          是\n程序内置排序函数（以 JS 为例）            108 ms    95.09%         50.6 MB   92.65%         不讨论\n\n最后通过这个表格验证了我们的结论，因为语言底层的排序算法通过对不同对数据环境下的数据采用了符合场景的排序算法，速度是最快的。（在 LeetCode 上提交各种排序算法的我，那个小丑竟然是我自己）。有的同学可能会说我学排序算法学了个寂寞，不如直接就用语言提供的排序算法就好啊，其实我们学习是为了掌握理论，为的知道其底层原理，便于解决各种生产中的 bug，是对能力的一种培养。再者，面试官再问你各种排序算法，你心里面也有个谱了吧。",normalizedContent:"# 排序算法的比较与总结\n\n\n# 规范\n\n排序算法必须原地排序，不能修改数组的引用，只能修改数组内容\n\n排序算法必须向外界提供统一的接口，仅接收一个数组作为参数，不返回任何内容；\n\n\n# 排序算法的稳定性\n\n这是一个我们经常提到，但是却又没有怎么留意的问题。什么是排序算法的稳定性呢，就比如现在我们有一堆手牌， 假设，我现在手里面按顺序有梅花6，红桃a，方块6，红桃2，黑桃5。我们按点数大小（ace视为 1 点）从小到大进行排序，此时，有两个数值相同的 6，如果说，当我们的排序算法完成之后，梅花6还是排在方块6之前的话，那么我们就可以说这个排序算法是稳定的。什么时候我们才会考虑稳定性呢？就拿刚才的例子举例，我们希望当数值相同时，扑克的花色按最初的相对顺序排列，这时候就需要用一个稳定的排序算法。\n\n比如，现在我们要选出优秀的学生参与奥赛班，我们对学生进行一次摸底考试，根据学生的的成绩排序，然后再根据学生的年纪进行排序，我们就可以选出相同成绩下年级较小的同学参赛，若排序算法不稳定的话，则会导致我们用年龄再次排序时就达不到预期的效果了。如果只是单纯的对成绩排序，那么就不会再有什么想通数组的初始顺序的问题了，所以，系统为我们实现的排序方法，当你在对数字进行排序的时候，一般会采用不稳定的，对对象进行排序的时候，会采用稳定的算法。\n\n但是排序算法的稳定性并不是绝对的，这取决于你写的排序算法的判别条件，众所周知，插入排序是稳定的排序算法，但是假设我们把代码写成这样：\n\n\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n/**\n * 对数组进行插入排序\n * @param {array<number>} arr 需要进行排序的数组\n */\nfunction insertionsort(arr) {\n  // 默认认为第一个元素已经有序\n  for (let i = 1; i < arr.length; i++) {\n    let j = i;\n    let cur = arr[i];\n    //向前找合适的插入位置，退出条件有两种可能，1、找到了合适的插入位置；2、找到了头了\n    while (j > 0 && arr[j - 1] >= cur) {\n      // 在每次查找插入位置的时候，都将当前元素向后挪一位。\n      arr[j] = arr[j - 1];\n      j--;\n    }\n    arr[j] = cur;\n  }\n}\n\n\n如果我们把向前插入的条件写成arr[j - 1] >= cur，那么很明显当方块6进行插入的时候，它一定会跑到梅花6的前面去，变成了不稳定的排序算法了。\n\n因此，排序算法的稳定性其实还是一个相对的概念，如果你只要举得出例子证明它，那么它就是稳定或者不稳定的。\n\n\n# 复杂度、稳定性与额外占用空间比较\n\n排序算法名称   平均算法复杂度                     是否稳定   是否额外空间复杂度\n冒泡排序     o(n²)                       是      否\n选择排序     o(n²)                       是      否\n插入排序     o(n²)                       是      否\n希尔排序     o(n*logn)                   否      否\n快速排序     o(n*logn)                   否      否\n归并排序     o(n*logn)                   是      是，o(n)\n堆排序      o(n*logn)                   否      否\n桶排序      o(n+c)，其中 c=n*(logn-logm)   是      是，o(n+m)，n 为数据的数量级，m 为桶的数量级\n基数排序     o(p(n+b))                   是      是，o(n+m)，n 为数据的数量级，m 为桶的数量级\n\n\n# 时间比较\n\n我们各类的语言底层（如 js 的array.prototype.sort）提供的排序算法就是根据不同排序算法的稳定性、时间复杂度、空间复杂度差异，根据待排数据的性质，在三者之间进行取舍，从而实现更加高效的排序算法。\n\n为了让大家直观的体验不同排序算法的差异，我对这些排序算法在 leetcode 上都依次进行了提交（同一个排序算法 3 次提交，对结果取最接近平均值的那组数据），然后将结果进行了统计，结果如下：\n\n排序算法名称                       执行用时      执行用时击败所有提交区间   内存消耗      内存消耗击败所有提交区间   是否稳定\n冒泡排序                         6036ms    10.62%         50.7mb    89.30%         是\n选择排序                         7100 ms   6.86%          50.7 mb   86.00%         是\n插入排序                         1508 ms   39.15%         50.8 mb   85.80%         是\n希尔排序                         108 ms    95.09%         50.8 mb   85.80%         是\n朴素快速排序                       1512 ms   39.06%         57.5 mb   37.14%         否\n三元取中快速排序                     112 ms    91.57%         50.8 mb   83.76%         否\n归并排序（递归版）                    620 ms    48.71%         54.2 mb   49.68%         是\n归并排序（非递归版）                   120 ms    83.46%         51.6 mb   63.65%         是\n堆排序                          108 ms    95.09%         50.5 mb   93.77%         否\n桶排序（采用了 10 个桶，每个桶采用直接插入排序）   4140 ms   17.98%         61.4mb    11.93%         是\n基数排序                         108ms     23.01%         57.6mb    8.21%          是\n程序内置排序函数（以 js 为例）            108 ms    95.09%         50.6 mb   92.65%         不讨论\n\n最后通过这个表格验证了我们的结论，因为语言底层的排序算法通过对不同对数据环境下的数据采用了符合场景的排序算法，速度是最快的。（在 leetcode 上提交各种排序算法的我，那个小丑竟然是我自己）。有的同学可能会说我学排序算法学了个寂寞，不如直接就用语言提供的排序算法就好啊，其实我们学习是为了掌握理论，为的知道其底层原理，便于解决各种生产中的 bug，是对能力的一种培养。再者，面试官再问你各种排序算法，你心里面也有个谱了吧。",charsets:{cjk:!0}},{title:"堆排序",frontmatter:{},regularPath:"/data-structure/sort/heapSort.html",relativePath:"data-structure/sort/heapSort.md",key:"v-ce31282e",path:"/data-structure/sort/heapSort.html",headers:[{level:2,title:"堆排序",slug:"堆排序",normalizedTitle:"堆排序",charIndex:2},{level:3,title:"排序过程",slug:"排序过程",normalizedTitle:"排序过程",charIndex:124},{level:3,title:"算法实现",slug:"算法实现",normalizedTitle:"算法实现",charIndex:133},{level:3,title:"复杂度与稳定性",slug:"复杂度与稳定性",normalizedTitle:"复杂度与稳定性",charIndex:1402}],headersStr:"堆排序 排序过程 算法实现 复杂度与稳定性",content:"# 堆排序\n\n将数组片段在线性的时间内调整成最大（小）堆，取出堆顶的元素和数组无序片段的最后一个元素进行交换，有序片段规模增加 1，无序片段规模减少 1，再将剩余的无序片段元素调整成最大（小）堆，重复这个操作，直到无序片段为空则完成排序。\n\n\n# 排序过程\n\n\n# 算法实现\n\n/**\n * 将长度为length的数组片段以p为根节点构建最大堆\n * @param {Array<number>} arr 需要进行排序的数组\n * @param {number} p 根节点\n * @param {number} length 数组片段的长度\n */\nfunction percDown(arr, p, length) {\n  let temp = arr[p];\n  let child, parent;\n  // 从p节点开始，如果parent*2等于length的话，说明堆已经越界，无需进行循环\n  for (parent = p; parent * 2 < length; parent = child) {\n    // 找到左儿子节点所在的索引\n    child = parent * 2;\n    // 右儿子存在,并且右儿子比左儿子大，则取右儿子\n    if (child + 1 < length && arr[child] < arr[child + 1]) {\n      child++;\n    }\n    // 如果待插入的值比当前这个位置大或者相等，则说明这个位置就是可以插入的位置,不能再继续下滤了，因此退出循环\n    if (temp >= arr[child]) {\n      break;\n    } else {\n      // 把大的值向上提\n      arr[parent] = arr[child];\n    }\n    // 节点下滤\n  }\n  // 把元素放在合适的位置\n  arr[parent] = temp;\n}\n\n/**\n * 对数组进行堆排序\n * @param {Array<number>} arr 需要进行排序的数组\n */\nfunction heapSort(arr) {\n  // 因为在没有哨兵时，对于父节点为i的节点，其左右儿子分别是 2i+1, 2i+2，那我们可以根据最后一个元素算出，最后一个元素的父节点是 Math.floor(arr.length / 2)\n  // 从最后一个元素的父元素开始，在线性的时间内将数组调整成最大堆,\n  for (let i = Math.floor(arr.length / 2); i >= 0; i--) {\n    percDown(arr, i, arr.length);\n  }\n  for (let i = arr.length - 1; i >= 0; i--) {\n    // 取出堆顶的第一个元素\n    let temp = arr[0];\n    // 将无序片段最后一个元素交换到堆顶\n    arr[0] = arr[i];\n    arr[i] = temp;\n    // 继续将长度为i的元素片段，以0为根节点，调整成最大堆\n    percDown(arr, 0, i);\n    // 最后无序片段的规模递减\n  }\n}\n\n\n\n# 复杂度与稳定性\n\n堆排序是不稳定的排序算法；\n\n定理: 堆排序处理 N 个不同元素的随机排列的平均比较次数是 2N*logN-O(N*log(logN))\n\n堆排序的复杂度可以写成 O(N*logN)，而且比这个复杂度要比 O(N*logN)略好一些。\n\n平均算法复杂度：O(N*logN)，无额外的空间复杂度",normalizedContent:"# 堆排序\n\n将数组片段在线性的时间内调整成最大（小）堆，取出堆顶的元素和数组无序片段的最后一个元素进行交换，有序片段规模增加 1，无序片段规模减少 1，再将剩余的无序片段元素调整成最大（小）堆，重复这个操作，直到无序片段为空则完成排序。\n\n\n# 排序过程\n\n\n# 算法实现\n\n/**\n * 将长度为length的数组片段以p为根节点构建最大堆\n * @param {array<number>} arr 需要进行排序的数组\n * @param {number} p 根节点\n * @param {number} length 数组片段的长度\n */\nfunction percdown(arr, p, length) {\n  let temp = arr[p];\n  let child, parent;\n  // 从p节点开始，如果parent*2等于length的话，说明堆已经越界，无需进行循环\n  for (parent = p; parent * 2 < length; parent = child) {\n    // 找到左儿子节点所在的索引\n    child = parent * 2;\n    // 右儿子存在,并且右儿子比左儿子大，则取右儿子\n    if (child + 1 < length && arr[child] < arr[child + 1]) {\n      child++;\n    }\n    // 如果待插入的值比当前这个位置大或者相等，则说明这个位置就是可以插入的位置,不能再继续下滤了，因此退出循环\n    if (temp >= arr[child]) {\n      break;\n    } else {\n      // 把大的值向上提\n      arr[parent] = arr[child];\n    }\n    // 节点下滤\n  }\n  // 把元素放在合适的位置\n  arr[parent] = temp;\n}\n\n/**\n * 对数组进行堆排序\n * @param {array<number>} arr 需要进行排序的数组\n */\nfunction heapsort(arr) {\n  // 因为在没有哨兵时，对于父节点为i的节点，其左右儿子分别是 2i+1, 2i+2，那我们可以根据最后一个元素算出，最后一个元素的父节点是 math.floor(arr.length / 2)\n  // 从最后一个元素的父元素开始，在线性的时间内将数组调整成最大堆,\n  for (let i = math.floor(arr.length / 2); i >= 0; i--) {\n    percdown(arr, i, arr.length);\n  }\n  for (let i = arr.length - 1; i >= 0; i--) {\n    // 取出堆顶的第一个元素\n    let temp = arr[0];\n    // 将无序片段最后一个元素交换到堆顶\n    arr[0] = arr[i];\n    arr[i] = temp;\n    // 继续将长度为i的元素片段，以0为根节点，调整成最大堆\n    percdown(arr, 0, i);\n    // 最后无序片段的规模递减\n  }\n}\n\n\n\n# 复杂度与稳定性\n\n堆排序是不稳定的排序算法；\n\n定理: 堆排序处理 n 个不同元素的随机排列的平均比较次数是 2n*logn-o(n*log(logn))\n\n堆排序的复杂度可以写成 o(n*logn)，而且比这个复杂度要比 o(n*logn)略好一些。\n\n平均算法复杂度：o(n*logn)，无额外的空间复杂度",charsets:{cjk:!0}},{title:"插入排序",frontmatter:{},regularPath:"/data-structure/sort/insertionSort.html",relativePath:"data-structure/sort/insertionSort.md",key:"v-6e866b56",path:"/data-structure/sort/insertionSort.html",headers:[{level:2,title:"插入排序",slug:"插入排序",normalizedTitle:"插入排序",charIndex:2},{level:3,title:"排序过程",slug:"排序过程",normalizedTitle:"排序过程",charIndex:117},{level:3,title:"算法实现",slug:"算法实现",normalizedTitle:"算法实现",charIndex:126},{level:3,title:"复杂度与稳定性",slug:"复杂度与稳定性",normalizedTitle:"复杂度与稳定性",charIndex:516}],headersStr:"插入排序 排序过程 算法实现 复杂度与稳定性",content:"# 插入排序\n\n取出从无序序列中的第一个元素，有序片段的规模加 1，在有序片段中找到该元素合适的插入位置进行插入，无序片段的规模减 1，下次又从无序片段的第一个元素开始排序，重复这个操作直到无序片段长度为 0， 则完成排序。\n\n\n# 排序过程\n\n\n# 算法实现\n\n/**\n * 对数组进行插入排序\n * @param {Array<number>} arr 需要进行排序的数组\n */\nfunction insertionSort(arr) {\n  // 默认认为第一个元素已经有序\n  for (let i = 1; i < arr.length; i++) {\n    let j = i;\n    let cur = arr[i];\n    //向前找合适的插入位置，退出条件有两种可能，1、找到了合适的插入位置；2、找到了头了\n    while (j > 0 && arr[j - 1] > cur) {\n      // 在每次查找插入位置的时候，都将当前元素向后挪一位。\n      arr[j] = arr[j - 1];\n      j--;\n    }\n    arr[j] = cur;\n  }\n}\n\n\n\n# 复杂度与稳定性\n\n插入排序的时间复杂度是O(n²)，是稳定的排序算法。",normalizedContent:"# 插入排序\n\n取出从无序序列中的第一个元素，有序片段的规模加 1，在有序片段中找到该元素合适的插入位置进行插入，无序片段的规模减 1，下次又从无序片段的第一个元素开始排序，重复这个操作直到无序片段长度为 0， 则完成排序。\n\n\n# 排序过程\n\n\n# 算法实现\n\n/**\n * 对数组进行插入排序\n * @param {array<number>} arr 需要进行排序的数组\n */\nfunction insertionsort(arr) {\n  // 默认认为第一个元素已经有序\n  for (let i = 1; i < arr.length; i++) {\n    let j = i;\n    let cur = arr[i];\n    //向前找合适的插入位置，退出条件有两种可能，1、找到了合适的插入位置；2、找到了头了\n    while (j > 0 && arr[j - 1] > cur) {\n      // 在每次查找插入位置的时候，都将当前元素向后挪一位。\n      arr[j] = arr[j - 1];\n      j--;\n    }\n    arr[j] = cur;\n  }\n}\n\n\n\n# 复杂度与稳定性\n\n插入排序的时间复杂度是o(n²)，是稳定的排序算法。",charsets:{cjk:!0}},{title:"基数排序",frontmatter:{},regularPath:"/data-structure/sort/radixSort.html",relativePath:"data-structure/sort/radixSort.md",key:"v-1fd34c35",path:"/data-structure/sort/radixSort.html",headers:[{level:2,title:"基数排序",slug:"基数排序",normalizedTitle:"基数排序",charIndex:2},{level:3,title:"排序过程(以LSD为例)",slug:"排序过程-以lsd为例",normalizedTitle:"排序过程(以lsd为例)",charIndex:201},{level:3,title:"算法实现",slug:"算法实现",normalizedTitle:"算法实现",charIndex:404},{level:3,title:"复杂度与稳定性",slug:"复杂度与稳定性",normalizedTitle:"复杂度与稳定性",charIndex:4609}],headersStr:"基数排序 排序过程(以LSD为例) 算法实现 复杂度与稳定性",content:"# 基数排序\n\n桶排序有一定的使用局限，假设有N=10个整数，每个数值在0到999之间（M有1000个不同的值），如果还是按照桶排序的做法的话，将需要1000个桶，这是非常浪费性能的。通过观察可以发现，这些数的位数都是0-9，可以建立10个桶，然后用每位数字做关键字利用桶排序的思路对其进行排序。\n\n基数排序可以算的上是在桶排序上的一种扩展，以待排数据的各位上的数据作为索引，以减少桶的数量。\n\n\n# 排序过程(以LSD为例)\n\n第一步：将待排序数据构建成链表\n\n第二步：依次摘取出链表的节点，从这个节点的数据的右边取出的第一位数字作为key，根据key的值将数据插入到对应key的桶中\n\n第三步：将桶中非空的链表重新构建成新的链表\n\n第四步：重复第二步的过程，取节点的数据的倒数第二位的数字作为key，若数据长度不够，则视为0。\n\n...\n\n第N步：将桶中的非空链表导依次回至原数组中，完成排序。\n\n\n# 算法实现\n\n最高位优先(Most Significant Digit first)法，简称 MSD 法：先按 k[1]（从左到右第一位） 排序分组，同一组中记录，关键码 k[1] 相等，再对各组按 k[2] 排序分成子组，之后，对后面的关键码继续这样的排序分组，直到按最次位关键码 k[d] 对各子组排序后。再将各组连接起来，便得到一个有序序列。\n\n最低位优先(Least Significant Digit first)法，简称 LSD 法：先从 k[d]（从右到左第一位） 开始排序，再对 k[d-1] 进行排序，依次重复，直到对 k[1] 排序后便得到一个有序序列。\n\n# LSD 算法实现\n\n/**\n * 次位优先基数排序\n * @param {number[]} arr\n */\nfunction LSDRadixSort(arr) {\n  /* 假设元素最多有MaxDigit个关键字，基数全是同样的Radix */\n  const MaxDigit = 3;\n  const Radix = 10;\n\n  /**\n   * 获取第offset位数的数数字\n   * @param {number} num\n   * @param {number} offset\n   * @returns\n   */\n  function getDigit(num, offset) {\n    let d, i;\n    for (i = 1; i <= offset; i++) {\n      d = num % Radix;\n      num = Number.parseInt(num / Radix);\n    }\n    return d;\n  }\n\n  /* 初始化每个桶为空链表 */\n  let buckets = Array.from({\n    length: Radix,\n  }).map(() => {\n    return {\n      head: null,\n      tail: null,\n    };\n  });\n  let list = null;\n\n  /* 将原始序列逆序存入初始链表List */\n  for (let i = 0; i < arr.length; i++) {\n    const node = {\n      value: arr[i],\n      next: list,\n    };\n    if (list === null) {\n      list = node;\n    } else {\n      node.next = list;\n      list = node;\n    }\n  }\n\n  /* 下面开始排序 */\n  /* 对数据的每一位循环处理 */\n  for (let pass = 1; pass <= MaxDigit; pass++) {\n    /* 下面是分配的过程 */\n    let node = list;\n    while (node) {\n      /* 获得当前元素的当前位数字 */\n      let Di = getDigit(node.value, pass);\n      /* 将node从list中摘除 */\n      let nextNode = node.next;\n      node.next = null;\n      /* 将node插入buckets[Di]号桶尾 */\n      if (buckets[Di].head == null) {\n        buckets[Di].head = buckets[Di].tail = node;\n      } else {\n        buckets[Di].tail.next = node;\n        buckets[Di].tail = node;\n      }\n      node = nextNode;\n    }\n    /* 下面是收集的过程 */\n    list = null;\n    /* 将每个桶的元素顺序收集入list */\n    for (let digit = Radix - 1; digit >= 0; digit--) {\n      /* 如果桶不为空 */\n      if (buckets[digit].head) {\n        /* 整桶插入list表头 */\n        buckets[digit].tail.next = list;\n        list = buckets[digit].head;\n        /* 清空桶 */\n        buckets[digit].head = buckets[digit].tail = null;\n      }\n    }\n  }\n  /* 将list导回arr */\n  let node = list;\n  let offset = 0;\n  while (node) {\n    arr[offset++] = node.value;\n    node = node.next;\n  }\n}\n\n\n# MSD 算法实现\n\nMSD算法实现采用的是递归方式进行实现的，可以看出，当处理到最后一位数的时候，待排序数据则一定是完成排序的，因此，只需要把它导回至原数组即可。\n\n/**\n * 主位优先基数排序\n * @param {number[]} arr\n */\nfunction MSDRadixSort(arr) {\n  /* 假设元素最多有MaxDigit个关键字，基数全是同样的Radix */\n  const MaxDigit = 3;\n  const Radix = 10;\n\n  function getDigit(num, offset) {\n    /* 默认次位D=1, 主位D<=MaxDigit */\n    let d, i;\n    for (i = 1; i <= offset; i++) {\n      d = num % Radix;\n      num = Number.parseInt(num / Radix);\n    }\n    return d;\n  }\n\n  function MSD(arr, left, right, D) {\n    /* 核心递归函数: 对arr[left]...arr[right]的第D位数进行排序 */\n    /* 初始化每个桶为空链表 */\n    let buckets = Array.from({\n      length: Radix,\n    }).map(() => {\n      return {\n        head: null,\n        tail: null,\n      };\n    });\n    let list = null;\n    /* 递归终止条件 */\n    if (D == 0) {\n      return;\n    }\n    /* 将原始序列逆序存入初始链表List */\n    for (let i = left; i <= right; i++) {\n      const node = {\n        val: arr[i],\n        next: list,\n      };\n      if (list === null) {\n        list = node;\n      } else {\n        node.next = list;\n        list = node;\n      }\n    }\n    /* 下面是分配的过程，以头插法分配 */\n    let node = list;\n    while (node) {\n      /* 获得当前元素的当前位数字 */\n      let Di = getDigit(node.val, D);\n      /* 从list中摘除 */\n      let nextNode = node.next;\n      node.next = null;\n      /* 插入buckets[Di]号桶 */\n      if (buckets[Di].head == null) {\n        buckets[Di].head = buckets[Di].tail = node;\n      } else {\n        node.next = buckets[Di].head;\n        buckets[Di].head = node;\n      }\n      node = nextNode;\n    }\n\n    /* 下面是收集的过程 */\n    /* i, j记录当前要处理的arr[]的左右端下标 */\n    let i = left,\n      j = i;\n    for (let digit = 0; digit < Radix; digit++) {\n      /* 对于每个桶 */\n      if (buckets[digit].head) {\n        /* 将非空的桶整桶倒入arr[], 递归排序 */\n        let node = buckets[digit].head;\n        while (node) {\n          arr[j++] = node.val;\n          node = node.next;\n        }\n        /* 递归对该桶数据排序, 位数减1 */\n        MSD(arr, i, j - 1, D - 1);\n        /* 为下一个桶对应的arr[]左端 */\n        i = j;\n      }\n    }\n  }\n\n  MSD(arr, 0, arr.length - 1, MaxDigit);\n}\n\n\n\n# 复杂度与稳定性\n\n基数排序是稳定的排序算法。\n\n基数排序的时间复杂度为 O(P(N+B))，其中P是最大数据关键字的位数，B是桶的量级，可以看出，当最大关键字的位数和桶的个数在比较小的时候，基数排序的时间复杂度是线性的。空间复杂度为O(N+B)，其中B是桶的量级。",normalizedContent:"# 基数排序\n\n桶排序有一定的使用局限，假设有n=10个整数，每个数值在0到999之间（m有1000个不同的值），如果还是按照桶排序的做法的话，将需要1000个桶，这是非常浪费性能的。通过观察可以发现，这些数的位数都是0-9，可以建立10个桶，然后用每位数字做关键字利用桶排序的思路对其进行排序。\n\n基数排序可以算的上是在桶排序上的一种扩展，以待排数据的各位上的数据作为索引，以减少桶的数量。\n\n\n# 排序过程(以lsd为例)\n\n第一步：将待排序数据构建成链表\n\n第二步：依次摘取出链表的节点，从这个节点的数据的右边取出的第一位数字作为key，根据key的值将数据插入到对应key的桶中\n\n第三步：将桶中非空的链表重新构建成新的链表\n\n第四步：重复第二步的过程，取节点的数据的倒数第二位的数字作为key，若数据长度不够，则视为0。\n\n...\n\n第n步：将桶中的非空链表导依次回至原数组中，完成排序。\n\n\n# 算法实现\n\n最高位优先(most significant digit first)法，简称 msd 法：先按 k[1]（从左到右第一位） 排序分组，同一组中记录，关键码 k[1] 相等，再对各组按 k[2] 排序分成子组，之后，对后面的关键码继续这样的排序分组，直到按最次位关键码 k[d] 对各子组排序后。再将各组连接起来，便得到一个有序序列。\n\n最低位优先(least significant digit first)法，简称 lsd 法：先从 k[d]（从右到左第一位） 开始排序，再对 k[d-1] 进行排序，依次重复，直到对 k[1] 排序后便得到一个有序序列。\n\n# lsd 算法实现\n\n/**\n * 次位优先基数排序\n * @param {number[]} arr\n */\nfunction lsdradixsort(arr) {\n  /* 假设元素最多有maxdigit个关键字，基数全是同样的radix */\n  const maxdigit = 3;\n  const radix = 10;\n\n  /**\n   * 获取第offset位数的数数字\n   * @param {number} num\n   * @param {number} offset\n   * @returns\n   */\n  function getdigit(num, offset) {\n    let d, i;\n    for (i = 1; i <= offset; i++) {\n      d = num % radix;\n      num = number.parseint(num / radix);\n    }\n    return d;\n  }\n\n  /* 初始化每个桶为空链表 */\n  let buckets = array.from({\n    length: radix,\n  }).map(() => {\n    return {\n      head: null,\n      tail: null,\n    };\n  });\n  let list = null;\n\n  /* 将原始序列逆序存入初始链表list */\n  for (let i = 0; i < arr.length; i++) {\n    const node = {\n      value: arr[i],\n      next: list,\n    };\n    if (list === null) {\n      list = node;\n    } else {\n      node.next = list;\n      list = node;\n    }\n  }\n\n  /* 下面开始排序 */\n  /* 对数据的每一位循环处理 */\n  for (let pass = 1; pass <= maxdigit; pass++) {\n    /* 下面是分配的过程 */\n    let node = list;\n    while (node) {\n      /* 获得当前元素的当前位数字 */\n      let di = getdigit(node.value, pass);\n      /* 将node从list中摘除 */\n      let nextnode = node.next;\n      node.next = null;\n      /* 将node插入buckets[di]号桶尾 */\n      if (buckets[di].head == null) {\n        buckets[di].head = buckets[di].tail = node;\n      } else {\n        buckets[di].tail.next = node;\n        buckets[di].tail = node;\n      }\n      node = nextnode;\n    }\n    /* 下面是收集的过程 */\n    list = null;\n    /* 将每个桶的元素顺序收集入list */\n    for (let digit = radix - 1; digit >= 0; digit--) {\n      /* 如果桶不为空 */\n      if (buckets[digit].head) {\n        /* 整桶插入list表头 */\n        buckets[digit].tail.next = list;\n        list = buckets[digit].head;\n        /* 清空桶 */\n        buckets[digit].head = buckets[digit].tail = null;\n      }\n    }\n  }\n  /* 将list导回arr */\n  let node = list;\n  let offset = 0;\n  while (node) {\n    arr[offset++] = node.value;\n    node = node.next;\n  }\n}\n\n\n# msd 算法实现\n\nmsd算法实现采用的是递归方式进行实现的，可以看出，当处理到最后一位数的时候，待排序数据则一定是完成排序的，因此，只需要把它导回至原数组即可。\n\n/**\n * 主位优先基数排序\n * @param {number[]} arr\n */\nfunction msdradixsort(arr) {\n  /* 假设元素最多有maxdigit个关键字，基数全是同样的radix */\n  const maxdigit = 3;\n  const radix = 10;\n\n  function getdigit(num, offset) {\n    /* 默认次位d=1, 主位d<=maxdigit */\n    let d, i;\n    for (i = 1; i <= offset; i++) {\n      d = num % radix;\n      num = number.parseint(num / radix);\n    }\n    return d;\n  }\n\n  function msd(arr, left, right, d) {\n    /* 核心递归函数: 对arr[left]...arr[right]的第d位数进行排序 */\n    /* 初始化每个桶为空链表 */\n    let buckets = array.from({\n      length: radix,\n    }).map(() => {\n      return {\n        head: null,\n        tail: null,\n      };\n    });\n    let list = null;\n    /* 递归终止条件 */\n    if (d == 0) {\n      return;\n    }\n    /* 将原始序列逆序存入初始链表list */\n    for (let i = left; i <= right; i++) {\n      const node = {\n        val: arr[i],\n        next: list,\n      };\n      if (list === null) {\n        list = node;\n      } else {\n        node.next = list;\n        list = node;\n      }\n    }\n    /* 下面是分配的过程，以头插法分配 */\n    let node = list;\n    while (node) {\n      /* 获得当前元素的当前位数字 */\n      let di = getdigit(node.val, d);\n      /* 从list中摘除 */\n      let nextnode = node.next;\n      node.next = null;\n      /* 插入buckets[di]号桶 */\n      if (buckets[di].head == null) {\n        buckets[di].head = buckets[di].tail = node;\n      } else {\n        node.next = buckets[di].head;\n        buckets[di].head = node;\n      }\n      node = nextnode;\n    }\n\n    /* 下面是收集的过程 */\n    /* i, j记录当前要处理的arr[]的左右端下标 */\n    let i = left,\n      j = i;\n    for (let digit = 0; digit < radix; digit++) {\n      /* 对于每个桶 */\n      if (buckets[digit].head) {\n        /* 将非空的桶整桶倒入arr[], 递归排序 */\n        let node = buckets[digit].head;\n        while (node) {\n          arr[j++] = node.val;\n          node = node.next;\n        }\n        /* 递归对该桶数据排序, 位数减1 */\n        msd(arr, i, j - 1, d - 1);\n        /* 为下一个桶对应的arr[]左端 */\n        i = j;\n      }\n    }\n  }\n\n  msd(arr, 0, arr.length - 1, maxdigit);\n}\n\n\n\n# 复杂度与稳定性\n\n基数排序是稳定的排序算法。\n\n基数排序的时间复杂度为 o(p(n+b))，其中p是最大数据关键字的位数，b是桶的量级，可以看出，当最大关键字的位数和桶的个数在比较小的时候，基数排序的时间复杂度是线性的。空间复杂度为o(n+b)，其中b是桶的量级。",charsets:{cjk:!0}},{title:"快速排序",frontmatter:{},regularPath:"/data-structure/sort/quickSort.html",relativePath:"data-structure/sort/quickSort.md",key:"v-0e9221d6",path:"/data-structure/sort/quickSort.html",headers:[{level:2,title:"快速排序",slug:"快速排序",normalizedTitle:"快速排序",charIndex:2},{level:3,title:"排序过程",slug:"排序过程",normalizedTitle:"排序过程",charIndex:210},{level:3,title:"算法实现",slug:"算法实现",normalizedTitle:"算法实现",charIndex:219},{level:3,title:"复杂度与稳定性",slug:"复杂度与稳定性",normalizedTitle:"复杂度与稳定性",charIndex:2970}],headersStr:"快速排序 排序过程 算法实现 复杂度与稳定性",content:"# 快速排序\n\n若数组片段的长度大于 1，则随机从数组片段中取出一个元素作为主元(pivot)，将数组分为两份 A,B，这个位置之前的为一份(A)，这个位置之后的为一份(B)，将 A 中所有比 pivot 大的元素全部放到 B 中，将 B 中比 pivot 小的元素全部放大 A 中，然后分别递归的对数组片段 A 和 B 分别重复这个过程，直到所有的元素都有序即完成排序。\n\n快速排序是基于分治思想的排序算法。\n\n\n# 排序过程\n\n\n# 算法实现\n\n# 朴素法\n\n朴素法虽然比较好理解，也比较好记忆，但是实际上并不快，因为每次都简单的按特定的规则选取主元，如果主元的选择情况并不好的话，那我们的快速排序算法就跟冒泡排序差不多了。\n\n/**\n * 对数组片段进行快速排序\n * @param {Array<number>} arr 需要进行排序的数组\n * @param {number} left 待排序数组片段的开始索引\n * @param {number} right 待排序数组片段的结束索引\n */\nfunction _quickSort(arr, left, right) {\n  // 如果数组片段的长度小于或者等于1，无需进行排序\n  if (left >= right) {\n    return;\n  }\n  // 随机取一个元素作为主元\n  let pivot = arr[left];\n  let i = left;\n  let j = right;\n  while (i < j) {\n    // 从数组片段右侧找比主元小的元素\n    while (i < j && arr[j] > pivot) {\n      j--;\n    }\n    // 说明此刻已经找到了比主元小的元素\n    if (i < j) {\n      arr[i] = arr[j];\n      // 缩小规模\n      i++;\n    }\n    // 从数组片段左侧找比主元大的元素\n    while (i < j && arr[i] < pivot) {\n      i++;\n    }\n    // 说明找到了比主元大的元素\n    if (i < j) {\n      arr[j] = arr[i];\n      j--;\n    }\n  }\n  // 当退出循环的时候，i == j, 此刻这个位置之前所有的元素都比主元小，这个位置之后的所有元素都比主元大，这个位置就是我们存放主元的位置\n  arr[i] = pivot;\n  // 递归的对左半部分元素进行快速排序\n  _quickSort(arr, left, i - 1);\n  // 递归的对右半部分元素进行快速排序\n  _quickSort(arr, i + 1, right);\n}\n\n/**\n * 对数组进行快速排序\n * @param {Array<number>} arr 需要进行排序的数组\n */\nfunction quickSort(arr) {\n  _quickSort(arr, 0, arr.length - 1);\n}\n\n\n# 三元取中法\n\n/**\n * 定义数据的规模，如果少于这个量，则用简单排序，否则使用快速排序\n */\nconst N = 50;\n/**\n * 定义直接插入排序的方法，此直接插入排序方法和普通的插入排序有区别，因为是针对数组的某一个片段进行排序，因此需要引入一个offset偏移量参数\n * @param {Array} arr 待排序数组\n * @param {Number} offset 初始偏移量\n * @param {Number} length 待排序片段的总长度\n */\nfunction _insertionSort(arr, offset, length) {\n  let temp, i;\n  for (let p = offset + 1; p < offset + length; p++) {\n    temp = arr[p];\n    for (i = p; i > offset && temp < arr[i - 1]; i--) {\n      arr[i] = arr[i - 1];\n    }\n    arr[i] = temp;\n  }\n}\n\n/**\n * 三元取中法获取主元\n */\nfunction _mediant3(arr, left, right) {\n  let center = Math.floor((left + right) / 2);\n  if (arr[left] > arr[right]) {\n    _swap(arr, left, right);\n  }\n\n  if (arr[left] > arr[center]) {\n    _swap(arr, left, center);\n  }\n\n  if (arr[center] > arr[right]) {\n    _swap(arr, right, center);\n  }\n  // 并且把主元藏在数组片段的倒数第二位\n  _swap(arr, right - 1, center);\n  return arr[right - 1];\n}\n\n/**\n * 交换数组中的2个元素\n */\nfunction _swap(arr, i, j) {\n  let temp = arr[j];\n  arr[j] = arr[i];\n  arr[i] = temp;\n}\n\n/**\n * 对数组片段进行快速排序\n */\nfunction _quickSort(arr, left, right) {\n  // 数据片段的长度\n  let len = right - left + 1;\n  // 如果数据规模少于它，则使用简单排序\n  if (len <= N) {\n    _insertionSort(arr, left, len);\n  } else {\n    // 使用三元法获取主元\n    let pivot = _mediant3(arr, left, right);\n    let i = left;\n    let j = right - 1;\n    while (true) {\n      while (arr[--j] > pivot);\n      while (arr[++i] < pivot);\n      if (i >= j) {\n        break;\n      }\n      _swap(arr, i, j);\n    }\n    _swap(arr, i, right - 1);\n    _quickSort(arr, left, i - 1);\n    _quickSort(arr, i + 1, right);\n  }\n}\n\n/**\n * 对数组进行快速排序\n */\nfunction quickSort(arr) {\n  _quickSort(arr, 0, arr.length - 1);\n}\n\n\n\n# 复杂度与稳定性\n\n快速排序是不稳定的排序算法\n\n平均算法时间复杂度：O(n*logn),最坏：O(N²)",normalizedContent:"# 快速排序\n\n若数组片段的长度大于 1，则随机从数组片段中取出一个元素作为主元(pivot)，将数组分为两份 a,b，这个位置之前的为一份(a)，这个位置之后的为一份(b)，将 a 中所有比 pivot 大的元素全部放到 b 中，将 b 中比 pivot 小的元素全部放大 a 中，然后分别递归的对数组片段 a 和 b 分别重复这个过程，直到所有的元素都有序即完成排序。\n\n快速排序是基于分治思想的排序算法。\n\n\n# 排序过程\n\n\n# 算法实现\n\n# 朴素法\n\n朴素法虽然比较好理解，也比较好记忆，但是实际上并不快，因为每次都简单的按特定的规则选取主元，如果主元的选择情况并不好的话，那我们的快速排序算法就跟冒泡排序差不多了。\n\n/**\n * 对数组片段进行快速排序\n * @param {array<number>} arr 需要进行排序的数组\n * @param {number} left 待排序数组片段的开始索引\n * @param {number} right 待排序数组片段的结束索引\n */\nfunction _quicksort(arr, left, right) {\n  // 如果数组片段的长度小于或者等于1，无需进行排序\n  if (left >= right) {\n    return;\n  }\n  // 随机取一个元素作为主元\n  let pivot = arr[left];\n  let i = left;\n  let j = right;\n  while (i < j) {\n    // 从数组片段右侧找比主元小的元素\n    while (i < j && arr[j] > pivot) {\n      j--;\n    }\n    // 说明此刻已经找到了比主元小的元素\n    if (i < j) {\n      arr[i] = arr[j];\n      // 缩小规模\n      i++;\n    }\n    // 从数组片段左侧找比主元大的元素\n    while (i < j && arr[i] < pivot) {\n      i++;\n    }\n    // 说明找到了比主元大的元素\n    if (i < j) {\n      arr[j] = arr[i];\n      j--;\n    }\n  }\n  // 当退出循环的时候，i == j, 此刻这个位置之前所有的元素都比主元小，这个位置之后的所有元素都比主元大，这个位置就是我们存放主元的位置\n  arr[i] = pivot;\n  // 递归的对左半部分元素进行快速排序\n  _quicksort(arr, left, i - 1);\n  // 递归的对右半部分元素进行快速排序\n  _quicksort(arr, i + 1, right);\n}\n\n/**\n * 对数组进行快速排序\n * @param {array<number>} arr 需要进行排序的数组\n */\nfunction quicksort(arr) {\n  _quicksort(arr, 0, arr.length - 1);\n}\n\n\n# 三元取中法\n\n/**\n * 定义数据的规模，如果少于这个量，则用简单排序，否则使用快速排序\n */\nconst n = 50;\n/**\n * 定义直接插入排序的方法，此直接插入排序方法和普通的插入排序有区别，因为是针对数组的某一个片段进行排序，因此需要引入一个offset偏移量参数\n * @param {array} arr 待排序数组\n * @param {number} offset 初始偏移量\n * @param {number} length 待排序片段的总长度\n */\nfunction _insertionsort(arr, offset, length) {\n  let temp, i;\n  for (let p = offset + 1; p < offset + length; p++) {\n    temp = arr[p];\n    for (i = p; i > offset && temp < arr[i - 1]; i--) {\n      arr[i] = arr[i - 1];\n    }\n    arr[i] = temp;\n  }\n}\n\n/**\n * 三元取中法获取主元\n */\nfunction _mediant3(arr, left, right) {\n  let center = math.floor((left + right) / 2);\n  if (arr[left] > arr[right]) {\n    _swap(arr, left, right);\n  }\n\n  if (arr[left] > arr[center]) {\n    _swap(arr, left, center);\n  }\n\n  if (arr[center] > arr[right]) {\n    _swap(arr, right, center);\n  }\n  // 并且把主元藏在数组片段的倒数第二位\n  _swap(arr, right - 1, center);\n  return arr[right - 1];\n}\n\n/**\n * 交换数组中的2个元素\n */\nfunction _swap(arr, i, j) {\n  let temp = arr[j];\n  arr[j] = arr[i];\n  arr[i] = temp;\n}\n\n/**\n * 对数组片段进行快速排序\n */\nfunction _quicksort(arr, left, right) {\n  // 数据片段的长度\n  let len = right - left + 1;\n  // 如果数据规模少于它，则使用简单排序\n  if (len <= n) {\n    _insertionsort(arr, left, len);\n  } else {\n    // 使用三元法获取主元\n    let pivot = _mediant3(arr, left, right);\n    let i = left;\n    let j = right - 1;\n    while (true) {\n      while (arr[--j] > pivot);\n      while (arr[++i] < pivot);\n      if (i >= j) {\n        break;\n      }\n      _swap(arr, i, j);\n    }\n    _swap(arr, i, right - 1);\n    _quicksort(arr, left, i - 1);\n    _quicksort(arr, i + 1, right);\n  }\n}\n\n/**\n * 对数组进行快速排序\n */\nfunction quicksort(arr) {\n  _quicksort(arr, 0, arr.length - 1);\n}\n\n\n\n# 复杂度与稳定性\n\n快速排序是不稳定的排序算法\n\n平均算法时间复杂度：o(n*logn),最坏：o(n²)",charsets:{cjk:!0}},{title:"归并排序",frontmatter:{},regularPath:"/data-structure/sort/mergeSort.html",relativePath:"data-structure/sort/mergeSort.md",key:"v-1696c5b5",path:"/data-structure/sort/mergeSort.html",headers:[{level:2,title:"归并排序",slug:"归并排序",normalizedTitle:"归并排序",charIndex:2},{level:3,title:"排序过程",slug:"排序过程",normalizedTitle:"排序过程",charIndex:75},{level:3,title:"算法实现",slug:"算法实现",normalizedTitle:"算法实现",charIndex:84},{level:3,title:"复杂度与稳定性",slug:"复杂度与稳定性",normalizedTitle:"复杂度与稳定性",charIndex:3680}],headersStr:"归并排序 排序过程 算法实现 复杂度与稳定性",content:"# 归并排序\n\n将数组划分为若干个片段，然后不断的合并两个有序片段，得到新的结果，再在这个结果上重复此操作，直到这些片段最终合并成整个数组。\n\n\n# 排序过程\n\n\n# 算法实现\n\n在使用递归实现归并排序时，注意我们最后一次性的传递临时数组到排序函数里面去，不要在排序函数内部申请数组进行结果的保存，因为外界传入只会处理一次，而内部申请，每个片段你都需要申请和释放空间，在数据量比较大的时候，性能不佳。\n\n# 递归实现\n\n/**\n * 对数组片段进行合并\n * @param {Array<number>} arr 需要进行合并的数组片段\n * @param {number} leftStart 待合并数组片段1的开始索引\n * @param {number} rightStart 待合并数组片段2的开始索引\n * @param {number} rightEnd 待合并数组片段2的结束索引\n * @param {Array<number>} tempArr 临时数组，用于记录合并有序序列\n */\nfunction _merge(arr, leftStart, rightStart, rightEnd, tempArr) {\n  // 计算出序列的总长度，用于日后将临时数组中的数据导入到数组中\n  let length = rightEnd - leftStart + 1;\n  // 计算出序列1结束的位置\n  let leftEnd = rightStart - 1;\n  // 记录序列的开始位置\n  let pos = leftStart;\n  while (leftStart <= leftEnd && rightStart <= rightEnd) {\n    // 将数组中的元素按特定的规则复制到临时数组里面去\n    if (arr[leftStart] >= arr[rightStart]) {\n      tempArr[pos++] = arr[rightStart++];\n    } else {\n      tempArr[pos++] = arr[leftStart++];\n    }\n  }\n\n  // 两个while不可能同时成立，只拷贝较长的部分\n  while (leftStart <= leftEnd) {\n    tempArr[pos++] = arr[leftStart++];\n  }\n\n  while (rightStart <= rightEnd) {\n    tempArr[pos++] = arr[rightStart++];\n  }\n\n  // 因为最后合并完成之后pos指向的是最后一个元素的下一位，因此，需要将其减1\n  for (let i = pos - 1, k = 0; k < length; k++, i--) {\n    // 将临时数组的数据导入到真实数组里面去\n    arr[i] = tempArr[i];\n  }\n}\n\n/**\n * 对数组片段进行归并排序\n * @param {Array<number>} arr 需要进行排序的数组\n * @param {number} left 待排序数组片段的开始索引\n * @param {number} right 待排序数组片段的结束索引\n */\nfunction _mergeSort(arr, left, right) {\n  if (left >= right) {\n    return;\n  }\n  let center = Math.floor((left + right) / 2);\n  let tempArr = [];\n  // 递归的对左半部分进行归并排序\n  _mergeSort(arr, left, center);\n  // 递归的对右半部分进行归并排序\n  _mergeSort(arr, center + 1, right);\n  // 合并两个有序数组\n  _merge(arr, left, center + 1, right, tempArr);\n}\n\n/**\n * 对数组进行归并排序\n * @param {Array<number>} arr 需要进行排序的数组\n */\nfunction mergeSort(arr) {\n  _mergeSort(arr, 0, arr.length - 1);\n}\n\n\n# 非递归实现\n\n本例中，在_merge函数中并没有进行把临时数组导回至原数组的操作，在while循环中，巧妙地利用了临时数据已经被排序过的特点，下次排序直接利用它，并且再把排序的数据导回至原数组，减少了数组元素的拷贝次数。\n\n/**\n * 合并两个有序片段，存到tmpArr中\n * @param {Array<number>} arr\n * @param {number} leftStart\n * @param {number} rightStart\n * @param {number} rightEnd\n * @param {Array<number>} tmpArr\n */\nfunction _merge(arr, leftStart, rightStart, rightEnd, tmpArr) {\n  let pos = leftStart;\n  let leftEnd = rightStart - 1;\n  while (leftStart <= leftEnd && rightStart <= rightEnd) {\n    if (arr[leftStart] >= arr[rightStart]) {\n      tmpArr[pos++] = arr[rightStart++];\n    } else {\n      tmpArr[pos++] = arr[leftStart++];\n    }\n  }\n  while (leftStart <= leftEnd) {\n    tmpArr[pos++] = arr[leftStart++];\n  }\n  while (rightStart <= rightEnd) {\n    tmpArr[pos++] = arr[rightStart++];\n  }\n}\n\n/**\n * 一次归并两个有序片段\n * @param {Array<number>} arr 待排序数组\n * @param {number} sliceSize 每个块的长度\n * @param {Array<number>} tmpArr 临时数组\n */\nfunction _mergePass(arr, sliceSize, tmpArr) {\n  let i = 0;\n  // 只合并到倒数第二或者倒数第一个块之前的块\n  while (i <= arr.length - 2 * sliceSize) {\n    /* 两两归并相邻有序子列 */\n    _merge(arr, i, i + sliceSize, i + 2 * sliceSize - 1, tmpArr);\n    // 每次跨2个序列块\n    i += 2 * sliceSize;\n  }\n  if (i + sliceSize < arr.length) {\n    /* 说明刚好，当前chunk数是 2倍块数的整数倍 归并最后2个子列*/\n    _merge(arr, i, i + sliceSize, arr.length - 1, tmpArr);\n  } else {\n    /* 还差点儿，直接把最后只剩1个子序列导到临时数组即可 */\n    for (let j = i; j < arr.length; j++) {\n      tmpArr[j] = arr[j];\n    }\n  }\n}\n\n/**\n * 归并排序 非递归实现\n * @param {Array<number>} arr\n */\nfunction mergeSort(arr) {\n  /* 初始化子序列长度*/\n  let slice = 1;\n  let tmpArr = [];\n  /**\n   * 块的size从1增长到length\n   */\n  while (slice < arr.length) {\n    // 一轮归并\n    _mergePass(arr, slice, tmpArr);\n    slice *= 2;\n    /* 翻滚两次，这个地方不仅在排序，还完成了把tmpArr的内容导回至arr的事儿, 如果原数据已经有序，仅完成导回操作。*/\n    _mergePass(tmpArr, slice, arr);\n    slice *= 2;\n  }\n}\n\n\n\n# 复杂度与稳定性\n\n归并排序是稳定的排序算法；\n\n平均算法时间复杂度: O(N*logN)，空间复杂度: O(N)\n\n归并排序的缺点就是因为有额外的空间复杂度。\n\n我们各类的语言底层（如 JS 的Array.prototype.sort）提供的排序算法就是根据不同排序算法的稳定性、时间复杂度、空间复杂度差异，根据待排数据的性质，在三者之间进行取舍，从而实现更加高效的排序算法。",normalizedContent:"# 归并排序\n\n将数组划分为若干个片段，然后不断的合并两个有序片段，得到新的结果，再在这个结果上重复此操作，直到这些片段最终合并成整个数组。\n\n\n# 排序过程\n\n\n# 算法实现\n\n在使用递归实现归并排序时，注意我们最后一次性的传递临时数组到排序函数里面去，不要在排序函数内部申请数组进行结果的保存，因为外界传入只会处理一次，而内部申请，每个片段你都需要申请和释放空间，在数据量比较大的时候，性能不佳。\n\n# 递归实现\n\n/**\n * 对数组片段进行合并\n * @param {array<number>} arr 需要进行合并的数组片段\n * @param {number} leftstart 待合并数组片段1的开始索引\n * @param {number} rightstart 待合并数组片段2的开始索引\n * @param {number} rightend 待合并数组片段2的结束索引\n * @param {array<number>} temparr 临时数组，用于记录合并有序序列\n */\nfunction _merge(arr, leftstart, rightstart, rightend, temparr) {\n  // 计算出序列的总长度，用于日后将临时数组中的数据导入到数组中\n  let length = rightend - leftstart + 1;\n  // 计算出序列1结束的位置\n  let leftend = rightstart - 1;\n  // 记录序列的开始位置\n  let pos = leftstart;\n  while (leftstart <= leftend && rightstart <= rightend) {\n    // 将数组中的元素按特定的规则复制到临时数组里面去\n    if (arr[leftstart] >= arr[rightstart]) {\n      temparr[pos++] = arr[rightstart++];\n    } else {\n      temparr[pos++] = arr[leftstart++];\n    }\n  }\n\n  // 两个while不可能同时成立，只拷贝较长的部分\n  while (leftstart <= leftend) {\n    temparr[pos++] = arr[leftstart++];\n  }\n\n  while (rightstart <= rightend) {\n    temparr[pos++] = arr[rightstart++];\n  }\n\n  // 因为最后合并完成之后pos指向的是最后一个元素的下一位，因此，需要将其减1\n  for (let i = pos - 1, k = 0; k < length; k++, i--) {\n    // 将临时数组的数据导入到真实数组里面去\n    arr[i] = temparr[i];\n  }\n}\n\n/**\n * 对数组片段进行归并排序\n * @param {array<number>} arr 需要进行排序的数组\n * @param {number} left 待排序数组片段的开始索引\n * @param {number} right 待排序数组片段的结束索引\n */\nfunction _mergesort(arr, left, right) {\n  if (left >= right) {\n    return;\n  }\n  let center = math.floor((left + right) / 2);\n  let temparr = [];\n  // 递归的对左半部分进行归并排序\n  _mergesort(arr, left, center);\n  // 递归的对右半部分进行归并排序\n  _mergesort(arr, center + 1, right);\n  // 合并两个有序数组\n  _merge(arr, left, center + 1, right, temparr);\n}\n\n/**\n * 对数组进行归并排序\n * @param {array<number>} arr 需要进行排序的数组\n */\nfunction mergesort(arr) {\n  _mergesort(arr, 0, arr.length - 1);\n}\n\n\n# 非递归实现\n\n本例中，在_merge函数中并没有进行把临时数组导回至原数组的操作，在while循环中，巧妙地利用了临时数据已经被排序过的特点，下次排序直接利用它，并且再把排序的数据导回至原数组，减少了数组元素的拷贝次数。\n\n/**\n * 合并两个有序片段，存到tmparr中\n * @param {array<number>} arr\n * @param {number} leftstart\n * @param {number} rightstart\n * @param {number} rightend\n * @param {array<number>} tmparr\n */\nfunction _merge(arr, leftstart, rightstart, rightend, tmparr) {\n  let pos = leftstart;\n  let leftend = rightstart - 1;\n  while (leftstart <= leftend && rightstart <= rightend) {\n    if (arr[leftstart] >= arr[rightstart]) {\n      tmparr[pos++] = arr[rightstart++];\n    } else {\n      tmparr[pos++] = arr[leftstart++];\n    }\n  }\n  while (leftstart <= leftend) {\n    tmparr[pos++] = arr[leftstart++];\n  }\n  while (rightstart <= rightend) {\n    tmparr[pos++] = arr[rightstart++];\n  }\n}\n\n/**\n * 一次归并两个有序片段\n * @param {array<number>} arr 待排序数组\n * @param {number} slicesize 每个块的长度\n * @param {array<number>} tmparr 临时数组\n */\nfunction _mergepass(arr, slicesize, tmparr) {\n  let i = 0;\n  // 只合并到倒数第二或者倒数第一个块之前的块\n  while (i <= arr.length - 2 * slicesize) {\n    /* 两两归并相邻有序子列 */\n    _merge(arr, i, i + slicesize, i + 2 * slicesize - 1, tmparr);\n    // 每次跨2个序列块\n    i += 2 * slicesize;\n  }\n  if (i + slicesize < arr.length) {\n    /* 说明刚好，当前chunk数是 2倍块数的整数倍 归并最后2个子列*/\n    _merge(arr, i, i + slicesize, arr.length - 1, tmparr);\n  } else {\n    /* 还差点儿，直接把最后只剩1个子序列导到临时数组即可 */\n    for (let j = i; j < arr.length; j++) {\n      tmparr[j] = arr[j];\n    }\n  }\n}\n\n/**\n * 归并排序 非递归实现\n * @param {array<number>} arr\n */\nfunction mergesort(arr) {\n  /* 初始化子序列长度*/\n  let slice = 1;\n  let tmparr = [];\n  /**\n   * 块的size从1增长到length\n   */\n  while (slice < arr.length) {\n    // 一轮归并\n    _mergepass(arr, slice, tmparr);\n    slice *= 2;\n    /* 翻滚两次，这个地方不仅在排序，还完成了把tmparr的内容导回至arr的事儿, 如果原数据已经有序，仅完成导回操作。*/\n    _mergepass(tmparr, slice, arr);\n    slice *= 2;\n  }\n}\n\n\n\n# 复杂度与稳定性\n\n归并排序是稳定的排序算法；\n\n平均算法时间复杂度: o(n*logn)，空间复杂度: o(n)\n\n归并排序的缺点就是因为有额外的空间复杂度。\n\n我们各类的语言底层（如 js 的array.prototype.sort）提供的排序算法就是根据不同排序算法的稳定性、时间复杂度、空间复杂度差异，根据待排数据的性质，在三者之间进行取舍，从而实现更加高效的排序算法。",charsets:{cjk:!0}},{title:"选择排序",frontmatter:{},regularPath:"/data-structure/sort/selectionSort.html",relativePath:"data-structure/sort/selectionSort.md",key:"v-1a0d3835",path:"/data-structure/sort/selectionSort.html",headers:[{level:2,title:"选择排序",slug:"选择排序",normalizedTitle:"选择排序",charIndex:2},{level:3,title:"排序过程",slug:"排序过程",normalizedTitle:"排序过程",charIndex:86},{level:3,title:"算法实现",slug:"算法实现",normalizedTitle:"算法实现",charIndex:95},{level:3,title:"复杂度与稳定性",slug:"复杂度与稳定性",normalizedTitle:"复杂度与稳定性",charIndex:506}],headersStr:"选择排序 排序过程 算法实现 复杂度与稳定性",content:"# 选择排序\n\n从无序片段中找到最值所在的位置，将无序片段的第一个元素与最值元素进行交换，有序片段规模递增 1，无序片段规模递减 1，直到所有元素有序则完成排序。\n\n\n# 排序过程\n\n\n# 算法实现\n\n/**\n * 对数组进行选择排序\n * @param {Array<number>} arr 需要进行排序的数组\n */\nfunction selectionSort(arr) {\n  let temp = null;\n  for (let i = 0; i < arr.length; i++) {\n    // 假设无序片段的第一个元素是最值，从后面的序列中找一个最值与其交换\n    for (let j = i + 1; j < arr.length; j++) {\n      if (arr[j] < arr[i]) {\n        temp = arr[j];\n        arr[j] = arr[i];\n        arr[i] = temp;\n      }\n    }\n  }\n}\n\n\n需要注意的是，选择排序排在排序时，不是和相邻元素进行交换的，注意和冒泡排序的区别\n\n\n# 复杂度与稳定性\n\n选择排序的时间复杂度是O(n²)，是稳定的排序算法。",normalizedContent:"# 选择排序\n\n从无序片段中找到最值所在的位置，将无序片段的第一个元素与最值元素进行交换，有序片段规模递增 1，无序片段规模递减 1，直到所有元素有序则完成排序。\n\n\n# 排序过程\n\n\n# 算法实现\n\n/**\n * 对数组进行选择排序\n * @param {array<number>} arr 需要进行排序的数组\n */\nfunction selectionsort(arr) {\n  let temp = null;\n  for (let i = 0; i < arr.length; i++) {\n    // 假设无序片段的第一个元素是最值，从后面的序列中找一个最值与其交换\n    for (let j = i + 1; j < arr.length; j++) {\n      if (arr[j] < arr[i]) {\n        temp = arr[j];\n        arr[j] = arr[i];\n        arr[i] = temp;\n      }\n    }\n  }\n}\n\n\n需要注意的是，选择排序排在排序时，不是和相邻元素进行交换的，注意和冒泡排序的区别\n\n\n# 复杂度与稳定性\n\n选择排序的时间复杂度是o(n²)，是稳定的排序算法。",charsets:{cjk:!0}},{title:"希尔排序",frontmatter:{},regularPath:"/data-structure/sort/shellSort.html",relativePath:"data-structure/sort/shellSort.md",key:"v-f36ef296",path:"/data-structure/sort/shellSort.html",headers:[{level:2,title:"希尔排序",slug:"希尔排序",normalizedTitle:"希尔排序",charIndex:2},{level:3,title:"排序过程",slug:"排序过程",normalizedTitle:"排序过程",charIndex:391},{level:3,title:"算法实现",slug:"算法实现",normalizedTitle:"算法实现",charIndex:400},{level:3,title:"复杂度与稳定性",slug:"复杂度与稳定性",normalizedTitle:"复杂度与稳定性",charIndex:862}],headersStr:"希尔排序 排序过程 算法实现 复杂度与稳定性",content:"# 希尔排序\n\n希尔排序的思路是消除数组中的逆序对，是在插入排序算法上的改良，其根据一定的规则选取增量序列 D(k)·D(k-1)·D(k-2)···1，增量序列的最后一项必须是 1,分别以对 D(k)至 1 为间距对数组进行插入排序(因为采取了对 D(k-1)为间距的插入排序之后并不会使得 D(k)为间距进行插入排序之后的结果变坏这是希尔排序的理论基础)，此刻数组会变得大致有序，最后再进行一次（间距 D 为 1）插入排序，从而使得数组有序。\n\n用通俗易懂的语言描述就是，举个例子，我先对数组使用一次 4 （D(k)）为间距的插入排序，得到一个结果，在这个结果上以 2(即 D(k-1), 这个间距完成之后，并不会让之前 4 为间距的插入排序的结果变坏) 为间距再进行一次插入排序，又的到一个结果，最后，我对数组使用一次纯粹(因为间隔是 1，所以说它纯粹)的插入排序。\n\n\n# 排序过程\n\n\n# 算法实现\n\n/**\n * 对数组进行希尔排序\n * @param {Array<number>} arr 需要进行排序的数组\n */\nfunction shellSort(arr) {\n  // 选取 N/2->N/4->N/8->···->1的增量序列\n  for (let D = Math.floor(arr.length / 2); D >= 1; D = Math.floor(D / 2)) {\n    // 以间距D对数组进行插入排序\n    for (let i = D; i < arr.length; i++) {\n      let cur = arr[i];\n      let j = i;\n      // 注意这儿需要取到等于\n      while (j >= D && arr[j - D] > cur) {\n        arr[j] = arr[j - D];\n        j -= D;\n      }\n      arr[j] = cur;\n    }\n  }\n}\n\n\n\n# 复杂度与稳定性\n\n希尔排序的时间复杂度是O(n*logn)，是不稳定的排序算法。\n\n希尔排序的算法复杂度的分析是个世纪难题，其算法的时间复杂度跟你选择的增量序列有关系，有兴趣的朋友可以自行了解这部分的内容。",normalizedContent:"# 希尔排序\n\n希尔排序的思路是消除数组中的逆序对，是在插入排序算法上的改良，其根据一定的规则选取增量序列 d(k)·d(k-1)·d(k-2)···1，增量序列的最后一项必须是 1,分别以对 d(k)至 1 为间距对数组进行插入排序(因为采取了对 d(k-1)为间距的插入排序之后并不会使得 d(k)为间距进行插入排序之后的结果变坏这是希尔排序的理论基础)，此刻数组会变得大致有序，最后再进行一次（间距 d 为 1）插入排序，从而使得数组有序。\n\n用通俗易懂的语言描述就是，举个例子，我先对数组使用一次 4 （d(k)）为间距的插入排序，得到一个结果，在这个结果上以 2(即 d(k-1), 这个间距完成之后，并不会让之前 4 为间距的插入排序的结果变坏) 为间距再进行一次插入排序，又的到一个结果，最后，我对数组使用一次纯粹(因为间隔是 1，所以说它纯粹)的插入排序。\n\n\n# 排序过程\n\n\n# 算法实现\n\n/**\n * 对数组进行希尔排序\n * @param {array<number>} arr 需要进行排序的数组\n */\nfunction shellsort(arr) {\n  // 选取 n/2->n/4->n/8->···->1的增量序列\n  for (let d = math.floor(arr.length / 2); d >= 1; d = math.floor(d / 2)) {\n    // 以间距d对数组进行插入排序\n    for (let i = d; i < arr.length; i++) {\n      let cur = arr[i];\n      let j = i;\n      // 注意这儿需要取到等于\n      while (j >= d && arr[j - d] > cur) {\n        arr[j] = arr[j - d];\n        j -= d;\n      }\n      arr[j] = cur;\n    }\n  }\n}\n\n\n\n# 复杂度与稳定性\n\n希尔排序的时间复杂度是o(n*logn)，是不稳定的排序算法。\n\n希尔排序的算法复杂度的分析是个世纪难题，其算法的时间复杂度跟你选择的增量序列有关系，有兴趣的朋友可以自行了解这部分的内容。",charsets:{cjk:!0}},{title:"栈",frontmatter:{},regularPath:"/data-structure/stack/desc.html",relativePath:"data-structure/stack/desc.md",key:"v-3feaf1d5",path:"/data-structure/stack/desc.html",headers:[{level:2,title:"栈",slug:"栈",normalizedTitle:"栈",charIndex:2},{level:2,title:"栈的通用数组实现",slug:"栈的通用数组实现",normalizedTitle:"栈的通用数组实现",charIndex:205},{level:2,title:"栈的通用链表实现（使用 TypeScript ）",slug:"栈的通用链表实现-使用-typescript",normalizedTitle:"栈的通用链表实现（使用 typescript ）",charIndex:978},{level:2,title:"栈的复杂度问题",slug:"栈的复杂度问题",normalizedTitle:"栈的复杂度问题",charIndex:2431},{level:2,title:"在 JavaScript 中使用栈",slug:"在-javascript-中使用栈",normalizedTitle:"在 javascript 中使用栈",charIndex:2752},{level:2,title:"栈的应用",slug:"栈的应用",normalizedTitle:"栈的应用",charIndex:3024}],headersStr:"栈 栈的通用数组实现 栈的通用链表实现（使用 TypeScript ） 栈的复杂度问题 在 JavaScript 中使用栈 栈的应用",content:'# 栈\n\n栈（stack）又名堆栈，它是一种运算受限的线性表。限定仅在表尾进行插入和删除操作的线性表。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。(copy 自百度百科)\n\n因此，栈具备一个重要的性质：后入先出。\n\n\n\n\n# 栈的通用数组实现\n\nclass Stack<T> {\n  private data: T[] = [];\n\n  get size(): number {\n    return this.data.length;\n  }\n\n  /* 获取栈顶元素 */\n  get top(): T | null {\n    return this.isEmpty() ? null : this.data[this.size-1];\n  }\n\n  /**\n   * 压栈\n   * @param ele\n   */\n  push(ele: T) {\n    let length = this.data.length;\n    // 让数组长度增加\n    this.data.length++;\n    // 将新加入的元素放在最后面\n    this.data[length] = ele;\n  }\n\n  /**\n   * 退栈\n   * @returns\n   */\n  pop() {\n    if (this.isEmpty()) {\n      throw new Error("can\'t pop from an empty stack");\n    }\n    let length = this.data.length;\n    // 取出最后一个元素\n    let ele = this.data[length - 1];\n    // 数组长度-1\n    this.data.length--;\n    return ele;\n  }\n\n  /**\n   * 判断栈是否为空\n   * @returns\n   */\n  isEmpty() {\n    return this.data.length === 0;\n  }\n}\n\n\n\n# 栈的通用链表实现（使用 TypeScript ）\n\n/**\n * 栈的节点元素定义，必须使用双向链表，便于我们查找前驱和后继元素\n */\ninterface LinkedListNode<T> {\n  next: LinkedListNode<T> | null;\n  prev: LinkedListNode<T> | null;\n  data: T;\n}\n\nclass Stack<T> {\n  /**\n   * 链表的头结点\n   */\n  private head: LinkedListNode<T> | null = null;\n\n  private length = 0;\n\n  public get size() {\n    return this.length;\n  }\n  /* 获取栈顶元素 */\n  public get top(): T | null {\n    return this.isEmpty() ? null : this.head!.data;\n  }\n\n  /**\n   * 压栈\n   * @param ele\n   */\n  public push(ele: T) {\n    const newNode: LinkedListNode<T> = {\n      next: null,\n      prev: null,\n      data: ele,\n    };\n    // 栈长度增加\n    this.length++;\n    // 如果一个元素都没有，直接让head指向这个节点\n    if (this.head === null) {\n      this.head = newNode;\n    } else {\n      newNode.next = this.head;\n      this.head.prev = newNode;\n      // 让原本的头指针指向新来的节点\n      this.head = newNode;\n    }\n  }\n\n  /**\n   * 退栈\n   */\n  public pop() {\n    if (this.isEmpty()) {\n      throw new Error("can not pop from an empty stack");\n    }\n    // 获取到头节点的后继节点\n    let head = this.head!.next;\n    // 栈中的元素\n    let ele = this.head!.data;\n    if (head) {\n      // 解开第一个节点的后继节点\n      this.head!.next = null;\n      // 解开第一个节点的后继节点的前驱节点\n      head.prev = null;\n      // 让栈首元素指向新的栈首元素\n      this.head = head;\n    } else {\n      this.head = null;\n    }\n    // 栈长度递减\n    this.length--;\n    return ele;\n  }\n\n  /**\n   * 栈是否为空\n   * @returns\n   */\n  public isEmpty() {\n    return this.length === 0;\n  }\n}\n\n\n\n\n\n# 栈的复杂度问题\n\n对于 JavaScript 来说，如果使用数组实现栈，我们的入栈操作看起来是O(1)，为什么要说“看起来”呢，因为对于 JS 来说数组长度是可变的，我们只是执行了一个数组的基本操作，并没有什么遍历之类的操作。但是对于如C#，Java这类语言，数组在初始化的时候，必须首先确定数组的长度，假如你一直不停的入栈，但是此刻数组已经没有空间容纳新来的内容了，此刻，我们便需要进行扩容，即申请一个更大的连续内存空间，然后把旧数组的内容拷贝到这块内容上来，此刻便会有一个O(n)的时间复杂度。\n\n如果使用链表实现，由于我们每次的操作总是顶端的元素，链表的增删操作的时间复杂度为O(1)，因此，这个实现在实际开发中有重要的意义。\n\n\n# 在 JavaScript 中使用栈\n\nJS 的数组同时具备栈和队列的特性，假设我们每次仅使用数组的push和pop方法，数组即栈。\n\nconst queue = [];\nqueue.push(1); //[1]\nqueue.push(12); //[1, 12]\nqueue.push(123); //[1, 12, 123]\n\nlet tail = queue.pop() // tail 为123\ntail = queue.pop() // tail为12\ntail = queue.pop() // tail为1, 此时栈已空\n\n\n\n# 栈的应用\n\n系统的堆栈就是栈的应用场景之一；\n\n在深度优先搜索中，我们也需要使用栈用来记住返回的路径；\n\n在我们需要逆序的场景时，我们也需要使用栈，如无权图的单源最短路问题。\n\n在词法分析时，我们也需要栈，如babel将我们写在 vue 组件中 template 的内容解析为AST；',normalizedContent:'# 栈\n\n栈（stack）又名堆栈，它是一种运算受限的线性表。限定仅在表尾进行插入和删除操作的线性表。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。(copy 自百度百科)\n\n因此，栈具备一个重要的性质：后入先出。\n\n\n\n\n# 栈的通用数组实现\n\nclass stack<t> {\n  private data: t[] = [];\n\n  get size(): number {\n    return this.data.length;\n  }\n\n  /* 获取栈顶元素 */\n  get top(): t | null {\n    return this.isempty() ? null : this.data[this.size-1];\n  }\n\n  /**\n   * 压栈\n   * @param ele\n   */\n  push(ele: t) {\n    let length = this.data.length;\n    // 让数组长度增加\n    this.data.length++;\n    // 将新加入的元素放在最后面\n    this.data[length] = ele;\n  }\n\n  /**\n   * 退栈\n   * @returns\n   */\n  pop() {\n    if (this.isempty()) {\n      throw new error("can\'t pop from an empty stack");\n    }\n    let length = this.data.length;\n    // 取出最后一个元素\n    let ele = this.data[length - 1];\n    // 数组长度-1\n    this.data.length--;\n    return ele;\n  }\n\n  /**\n   * 判断栈是否为空\n   * @returns\n   */\n  isempty() {\n    return this.data.length === 0;\n  }\n}\n\n\n\n# 栈的通用链表实现（使用 typescript ）\n\n/**\n * 栈的节点元素定义，必须使用双向链表，便于我们查找前驱和后继元素\n */\ninterface linkedlistnode<t> {\n  next: linkedlistnode<t> | null;\n  prev: linkedlistnode<t> | null;\n  data: t;\n}\n\nclass stack<t> {\n  /**\n   * 链表的头结点\n   */\n  private head: linkedlistnode<t> | null = null;\n\n  private length = 0;\n\n  public get size() {\n    return this.length;\n  }\n  /* 获取栈顶元素 */\n  public get top(): t | null {\n    return this.isempty() ? null : this.head!.data;\n  }\n\n  /**\n   * 压栈\n   * @param ele\n   */\n  public push(ele: t) {\n    const newnode: linkedlistnode<t> = {\n      next: null,\n      prev: null,\n      data: ele,\n    };\n    // 栈长度增加\n    this.length++;\n    // 如果一个元素都没有，直接让head指向这个节点\n    if (this.head === null) {\n      this.head = newnode;\n    } else {\n      newnode.next = this.head;\n      this.head.prev = newnode;\n      // 让原本的头指针指向新来的节点\n      this.head = newnode;\n    }\n  }\n\n  /**\n   * 退栈\n   */\n  public pop() {\n    if (this.isempty()) {\n      throw new error("can not pop from an empty stack");\n    }\n    // 获取到头节点的后继节点\n    let head = this.head!.next;\n    // 栈中的元素\n    let ele = this.head!.data;\n    if (head) {\n      // 解开第一个节点的后继节点\n      this.head!.next = null;\n      // 解开第一个节点的后继节点的前驱节点\n      head.prev = null;\n      // 让栈首元素指向新的栈首元素\n      this.head = head;\n    } else {\n      this.head = null;\n    }\n    // 栈长度递减\n    this.length--;\n    return ele;\n  }\n\n  /**\n   * 栈是否为空\n   * @returns\n   */\n  public isempty() {\n    return this.length === 0;\n  }\n}\n\n\n\n\n\n# 栈的复杂度问题\n\n对于 javascript 来说，如果使用数组实现栈，我们的入栈操作看起来是o(1)，为什么要说“看起来”呢，因为对于 js 来说数组长度是可变的，我们只是执行了一个数组的基本操作，并没有什么遍历之类的操作。但是对于如c#，java这类语言，数组在初始化的时候，必须首先确定数组的长度，假如你一直不停的入栈，但是此刻数组已经没有空间容纳新来的内容了，此刻，我们便需要进行扩容，即申请一个更大的连续内存空间，然后把旧数组的内容拷贝到这块内容上来，此刻便会有一个o(n)的时间复杂度。\n\n如果使用链表实现，由于我们每次的操作总是顶端的元素，链表的增删操作的时间复杂度为o(1)，因此，这个实现在实际开发中有重要的意义。\n\n\n# 在 javascript 中使用栈\n\njs 的数组同时具备栈和队列的特性，假设我们每次仅使用数组的push和pop方法，数组即栈。\n\nconst queue = [];\nqueue.push(1); //[1]\nqueue.push(12); //[1, 12]\nqueue.push(123); //[1, 12, 123]\n\nlet tail = queue.pop() // tail 为123\ntail = queue.pop() // tail为12\ntail = queue.pop() // tail为1, 此时栈已空\n\n\n\n# 栈的应用\n\n系统的堆栈就是栈的应用场景之一；\n\n在深度优先搜索中，我们也需要使用栈用来记住返回的路径；\n\n在我们需要逆序的场景时，我们也需要使用栈，如无权图的单源最短路问题。\n\n在词法分析时，我们也需要栈，如babel将我们写在 vue 组件中 template 的内容解析为ast；',charsets:{cjk:!0}},{title:"栈的应用之 DFS",frontmatter:{},regularPath:"/data-structure/stack/dfs.html",relativePath:"data-structure/stack/dfs.md",key:"v-5428026a",path:"/data-structure/stack/dfs.html",headers:[{level:2,title:"栈的应用之 DFS",slug:"栈的应用之-dfs",normalizedTitle:"栈的应用之 dfs",charIndex:2},{level:3,title:"先序遍历二叉树",slug:"先序遍历二叉树",normalizedTitle:"先序遍历二叉树",charIndex:52},{level:3,title:"DFS 遍历 N-叉树",slug:"dfs-遍历-n-叉树",normalizedTitle:"dfs 遍历 n-叉树",charIndex:643}],headersStr:"栈的应用之 DFS 先序遍历二叉树 DFS 遍历 N-叉树",content:'# 栈的应用之 DFS\n\n在 DFS 中，如果我们不用递归，需要自己用一个栈来模拟系统的堆栈。\n\n\n# 先序遍历二叉树\n\n/**\n * 先序非递归遍历二叉树\n * @param {TreeNode<number>} tree\n */\nfunction treePreOrder(tree) {\n  if (!tree) {\n    console.log("empty tree!");\n    return;\n  }\n  // 定义一个栈用于模拟系统提供的堆栈\n  let stack = [];\n  // 让node指向树的跟节点，准备开始遍历\n  let node = tree;\n  // 如果树不空，或者栈中还有内容，则应该继续进行遍历\n  while (stack.length > 0 || node) {\n    // 如果node节点不为空的话，不断的向左压栈，直到为空\n    while (node) {\n      stack.push(node);\n      console.log(node.data);\n      node = node.left;\n    }\n    // 向左走到头了，若当前栈中还有内容，则从栈中取出一个内容，从当前内容的右子树继续遍历\n    if (stack.length > 0) {\n      node = stack.pop();\n      node = node.right;\n    }\n  }\n}\n\n\n\n# DFS 遍历 N-叉树\n\n/**\n * N叉树非递归深度优先遍历\n * @param { NTreeNode<number>[] } treeNodes\n */\nfunction dfsVisit(treeNodes) {\n  if (!Array.isArray(treeNodes) || treeNodes.length === 0) {\n    console.warn("treeNodes empty");\n    return;\n  }\n  let stack = [];\n  // 用来记住每个节点的下一个兄弟节点\n  let nextSiblingMap = new Map();\n  // 建立下一个兄弟节点的关系\n  for (let i = 0; i < treeNodes.length; i++) {\n    const curNode = treeNodes[i];\n    const nextNode = treeNodes[i + 1] || null;\n    nextSiblingMap.set(curNode, nextNode);\n  }\n  let treeNode = treeNodes[0];\n  while (stack.length || treeNode) {\n    // 当节点为空时，说明已经迭代到最叶节点了，退出循环\n    while (treeNode) {\n      console.log(treeNode.data);\n      stack.push(treeNode);\n      let subNodes = Array.isArray(treeNode.children) ? treeNode.children : [];\n      // 每一层都建立下一个兄弟节点的关系\n      for (let k = 0; k < subNodes.length; k++) {\n        const curNode = subNodes[k];\n        const nextNode = subNodes[k + 1] || null;\n        nextSiblingMap.set(curNode, nextNode);\n      }\n      // 下滤节点\n      treeNode = subNodes[0] || null;\n    }\n    if (stack.length) {\n      treeNode = stack.pop();\n      // 根据当前节点到map里面找当前节点的下一个兄弟节点\n      let nextSiblingNode = nextSiblingMap.get(treeNode);\n      if (nextSiblingNode) {\n        treeNode = nextSiblingNode;\n      } else {\n        // 如果没有下一个兄弟节点了，说明需要回退到父亲节点，父亲节点处理完成之后，准备处理父亲节点的下一个兄弟节点\n        if (stack.length) {\n          treeNode = stack.pop();\n          // 继续切换到父节点的兄弟节点\n          treeNode = nextSiblingMap.get(treeNode);\n        } else {\n          // 已经将所有的节点处理完成，可以功成身退\n          treeNode = null;\n        }\n      }\n    }\n  }\n}\n',normalizedContent:'# 栈的应用之 dfs\n\n在 dfs 中，如果我们不用递归，需要自己用一个栈来模拟系统的堆栈。\n\n\n# 先序遍历二叉树\n\n/**\n * 先序非递归遍历二叉树\n * @param {treenode<number>} tree\n */\nfunction treepreorder(tree) {\n  if (!tree) {\n    console.log("empty tree!");\n    return;\n  }\n  // 定义一个栈用于模拟系统提供的堆栈\n  let stack = [];\n  // 让node指向树的跟节点，准备开始遍历\n  let node = tree;\n  // 如果树不空，或者栈中还有内容，则应该继续进行遍历\n  while (stack.length > 0 || node) {\n    // 如果node节点不为空的话，不断的向左压栈，直到为空\n    while (node) {\n      stack.push(node);\n      console.log(node.data);\n      node = node.left;\n    }\n    // 向左走到头了，若当前栈中还有内容，则从栈中取出一个内容，从当前内容的右子树继续遍历\n    if (stack.length > 0) {\n      node = stack.pop();\n      node = node.right;\n    }\n  }\n}\n\n\n\n# dfs 遍历 n-叉树\n\n/**\n * n叉树非递归深度优先遍历\n * @param { ntreenode<number>[] } treenodes\n */\nfunction dfsvisit(treenodes) {\n  if (!array.isarray(treenodes) || treenodes.length === 0) {\n    console.warn("treenodes empty");\n    return;\n  }\n  let stack = [];\n  // 用来记住每个节点的下一个兄弟节点\n  let nextsiblingmap = new map();\n  // 建立下一个兄弟节点的关系\n  for (let i = 0; i < treenodes.length; i++) {\n    const curnode = treenodes[i];\n    const nextnode = treenodes[i + 1] || null;\n    nextsiblingmap.set(curnode, nextnode);\n  }\n  let treenode = treenodes[0];\n  while (stack.length || treenode) {\n    // 当节点为空时，说明已经迭代到最叶节点了，退出循环\n    while (treenode) {\n      console.log(treenode.data);\n      stack.push(treenode);\n      let subnodes = array.isarray(treenode.children) ? treenode.children : [];\n      // 每一层都建立下一个兄弟节点的关系\n      for (let k = 0; k < subnodes.length; k++) {\n        const curnode = subnodes[k];\n        const nextnode = subnodes[k + 1] || null;\n        nextsiblingmap.set(curnode, nextnode);\n      }\n      // 下滤节点\n      treenode = subnodes[0] || null;\n    }\n    if (stack.length) {\n      treenode = stack.pop();\n      // 根据当前节点到map里面找当前节点的下一个兄弟节点\n      let nextsiblingnode = nextsiblingmap.get(treenode);\n      if (nextsiblingnode) {\n        treenode = nextsiblingnode;\n      } else {\n        // 如果没有下一个兄弟节点了，说明需要回退到父亲节点，父亲节点处理完成之后，准备处理父亲节点的下一个兄弟节点\n        if (stack.length) {\n          treenode = stack.pop();\n          // 继续切换到父节点的兄弟节点\n          treenode = nextsiblingmap.get(treenode);\n        } else {\n          // 已经将所有的节点处理完成，可以功成身退\n          treenode = null;\n        }\n      }\n    }\n  }\n}\n',charsets:{cjk:!0}},{title:"二分查找",frontmatter:{},regularPath:"/data-structure/search/binarySearch.html",relativePath:"data-structure/search/binarySearch.md",key:"v-bbc4fa82",path:"/data-structure/search/binarySearch.html",headers:[{level:2,title:"二分查找",slug:"二分查找",normalizedTitle:"二分查找",charIndex:2},{level:3,title:"概念",slug:"概念",normalizedTitle:"概念",charIndex:11},{level:3,title:"代码实现",slug:"代码实现",normalizedTitle:"代码实现",charIndex:155},{level:3,title:"复杂度分析",slug:"复杂度分析",normalizedTitle:"复杂度分析",charIndex:1127}],headersStr:"二分查找 概念 代码实现 复杂度分析",content:"# 二分查找\n\n\n# 概念\n\n二分查找：对于有序的线性表，首先找到位于这个线性表中央的元素(即mid)，将查找区域分为左半区([0,mid-1])和右半区[mid+1, length-1]，如果mid元素比待查找元素大，则在左半区查找，否则在右边区查找，重复这个过程，直到待查找区域为空时，结束查找。\n\n\n# 代码实现\n\n/**\n * 二分查找法\n * @param {Array<Number>} arr 需要查找的序列\n * @param {Number} target 需要查找的数据\n * @returns {Number} 查找成功返回数据所在的下标索引，查找失败，返回-1\n */\nfunction binarySearch(arr, target) {\n    if (!Array.isArray(arr) || arr.length == 0) {\n        console.log('empty array')\n        return -1;\n    }\n    // 初始化开始指针\n    let low = 0;\n    // 初始化结束指针\n    let high = arr.length - 1\n    // 初始化中间位置标记\n    let mid = Math.floor((low + high) / 2)\n    // 定义初始的位置\n    let pos = -1;\n    while (low <= high) {\n        // 如果找到了，则不再进行查找，跳出循环\n        if (arr[mid] === target) {\n            pos = mid;\n            break\n        }\n        // 如果当前值在中间值的左侧，说明从中间值往左的元素，都是不大于target的 缩小查找范围，因此从mid的前一位查找\n        if (arr[mid] > target) {\n            high = mid - 1\n        }\n        // 如果当前值在中间值的右侧，说明中间值往右的元素，都是不小于target的 缩小查找范围，因此从mid的后一位查找\n        else if (arr[mid] < target) {\n            low = mid + 1\n        }\n        // 重新划分中间值\n        mid = Math.floor((low + high) / 2)\n    }\n    return pos\n}\n\n\n\n# 复杂度分析\n\n二分查找是高效的查找算法，其时间复杂度为O(logN)。",normalizedContent:"# 二分查找\n\n\n# 概念\n\n二分查找：对于有序的线性表，首先找到位于这个线性表中央的元素(即mid)，将查找区域分为左半区([0,mid-1])和右半区[mid+1, length-1]，如果mid元素比待查找元素大，则在左半区查找，否则在右边区查找，重复这个过程，直到待查找区域为空时，结束查找。\n\n\n# 代码实现\n\n/**\n * 二分查找法\n * @param {array<number>} arr 需要查找的序列\n * @param {number} target 需要查找的数据\n * @returns {number} 查找成功返回数据所在的下标索引，查找失败，返回-1\n */\nfunction binarysearch(arr, target) {\n    if (!array.isarray(arr) || arr.length == 0) {\n        console.log('empty array')\n        return -1;\n    }\n    // 初始化开始指针\n    let low = 0;\n    // 初始化结束指针\n    let high = arr.length - 1\n    // 初始化中间位置标记\n    let mid = math.floor((low + high) / 2)\n    // 定义初始的位置\n    let pos = -1;\n    while (low <= high) {\n        // 如果找到了，则不再进行查找，跳出循环\n        if (arr[mid] === target) {\n            pos = mid;\n            break\n        }\n        // 如果当前值在中间值的左侧，说明从中间值往左的元素，都是不大于target的 缩小查找范围，因此从mid的前一位查找\n        if (arr[mid] > target) {\n            high = mid - 1\n        }\n        // 如果当前值在中间值的右侧，说明中间值往右的元素，都是不小于target的 缩小查找范围，因此从mid的后一位查找\n        else if (arr[mid] < target) {\n            low = mid + 1\n        }\n        // 重新划分中间值\n        mid = math.floor((low + high) / 2)\n    }\n    return pos\n}\n\n\n\n# 复杂度分析\n\n二分查找是高效的查找算法，其时间复杂度为o(logn)。",charsets:{cjk:!0}},{title:"栈的应用之逆序",frontmatter:{},regularPath:"/data-structure/stack/reverse.html",relativePath:"data-structure/stack/reverse.md",key:"v-495d0d29",path:"/data-structure/stack/reverse.html",headers:[{level:2,title:"栈的应用之逆序",slug:"栈的应用之逆序",normalizedTitle:"栈的应用之逆序",charIndex:2},{level:3,title:"两数相加",slug:"两数相加",normalizedTitle:"两数相加",charIndex:57},{level:3,title:"无权图的单源最短路径",slug:"无权图的单源最短路径",normalizedTitle:"无权图的单源最短路径",charIndex:2273}],headersStr:"栈的应用之逆序 两数相加 无权图的单源最短路径",content:'# 栈的应用之逆序\n\n在实际开发中，我们一旦遇到逆序的问题，可以想当然的先思考一下是否可以用栈进行处理。\n\n\n# 两数相加\n\n# 描述\n\n给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。\n\n你可以假设除了数字 0 之外，这两个数字都不会以零开头。\n\n# 思路分析\n\n因为是逆序，所以我们会想到用栈，分别遍历两个链表，用两个栈存储对应的节点，则问题转化为类似合并 2 个有序数组的问题。\n\n# 算法实现\n\n链表节点定义如下：\n\ninterface ListNode<T> {\n  next: ListNode<T> | null;\n  val: T;\n}\n\n\n/**\n * @param {ListNode} l1\n * @param {ListNode} l2\n * @return {ListNode}\n */\nvar addTwoNumbers = function (l1, l2) {\n  const stack1 = [];\n  const stack2 = [];\n  let node1 = l1;\n  let node2 = l2;\n  while (node1 && node2) {\n    stack1.push(node1);\n    stack2.push(node2);\n    node1 = node1.next;\n    node2 = node2.next;\n  }\n\n  while (node1) {\n    stack1.push(node1);\n    node1 = node1.next;\n  }\n\n  while (node2) {\n    stack2.push(node2);\n    node2 = node2.next;\n  }\n\n  let needIncrease = false;\n  let newHead = null;\n  while (stack1.length && stack2.length) {\n    const num1Node = stack1.pop();\n    const num2Node = stack2.pop();\n    let val = num1Node.val + num2Node.val + (needIncrease ? 1 : 0);\n    needIncrease = false;\n    if (val >= 10) {\n      val = val - 10;\n      needIncrease = true;\n    }\n    const tempNode = {\n      val,\n      next: null,\n    };\n    if (!newHead) {\n      newHead = tempNode;\n    } else {\n      tempNode.next = newHead;\n      newHead = tempNode;\n    }\n  }\n  while (stack1.length) {\n    const num1Node = stack1.pop();\n    let val = num1Node.val + (needIncrease ? 1 : 0);\n    needIncrease = false;\n    if (val >= 10) {\n      val = val - 10;\n      needIncrease = true;\n    }\n    const tempNode = {\n      val,\n      next: null,\n    };\n    if (!newHead) {\n      newHead = tempNode;\n    } else {\n      tempNode.next = newHead;\n      newHead = tempNode;\n    }\n  }\n  while (stack2.length) {\n    const num2Node = stack2.pop();\n    let val = num2Node.val + (needIncrease ? 1 : 0);\n    needIncrease = false;\n    if (val >= 10) {\n      val = val - 10;\n      needIncrease = true;\n    }\n    const tempNode = {\n      val,\n      next: null,\n    };\n    if (!newHead) {\n      newHead = tempNode;\n    } else {\n      tempNode.next = newHead;\n      newHead = tempNode;\n    }\n  }\n  if (needIncrease) {\n    const tempNode = {\n      val: 1,\n      next: null,\n    };\n    tempNode.next = newHead;\n    newHead = tempNode;\n  }\n  return newHead;\n};\n\n\n\n# 无权图的单源最短路径\n\n对于有这样的图：\n\n\n\n假设我们用如下方式表示图：\n\nclass Edge {\n  constructor(name) {\n    this.name = name;\n  }\n  /**\n   * 边的编号\n   */\n  name;\n  /**\n   * 起始点\n   * @type {Vertex}\n   */\n  from;\n  /**\n   * 终止点\n   * @type {Vertex}\n   */\n  to;\n}\n\nclass Vertex {\n  /**\n   * 城市名称\n   */\n  cityName;\n  /**\n   * 邻接点\n   */\n  siblings = [];\n  constructor(cityName) {\n    this.cityName = cityName;\n  }\n}\n\nclass Graph {\n  vertexList = [];\n  edgeList = [];\n  addVertex(v) {\n    this.vertexList.push(v);\n  }\n\n  /**\n   * 增加边\n   * @param {Vertex} from\n   * @param {Vertex} to\n   */\n  addEdge(from, to) {\n    const name = `${from.cityName}至${to.cityName}`;\n    const edge = new Edge(name);\n    this.edgeList.push(edge);\n    from.siblings.push(to);\n    to.siblings.push(from);\n  }\n}\n\nconst g = new Graph();\nconst beijing = new Vertex("北京");\nconst nanjing = new Vertex("南京");\nconst guangzhou = new Vertex("广州");\nconst shenzhen = new Vertex("深圳");\nconst hongkong = new Vertex("香港");\nconst chengdu = new Vertex("成都");\nconst xian = new Vertex("西安");\nconst urumchi = new Vertex("乌鲁木齐");\n\n/**\n * 将城市加入到图中\n */\ng.addVertex(beijing);\ng.addVertex(nanjing);\ng.addVertex(guangzhou);\ng.addVertex(shenzhen);\ng.addVertex(hongkong);\ng.addVertex(chengdu);\ng.addVertex(xian);\ng.addVertex(urumchi);\n/**\n * 建立连接关系\n */\ng.addEdge(beijing, nanjing);\ng.addEdge(beijing, xian);\ng.addEdge(nanjing, guangzhou);\ng.addEdge(guangzhou, shenzhen);\ng.addEdge(guangzhou, hongkong);\ng.addEdge(hongkong, shenzhen);\ng.addEdge(chengdu, guangzhou);\ng.addEdge(chengdu, xian);\ng.addEdge(urumchi, xian);\ng.addEdge(urumchi, beijing);\n/**\n * 单源无权图的最短路算法\n * @param {Vertex} start\n * @param {Vertex} end\n */\nfunction unweightedShortestPath(start, end) {\n  const queue = [];\n  const dist = new Map();\n  const path = new Map();\n  dist.set(start, 0);\n  queue.push(start);\n  while (queue.length > 0) {\n    let vertex = queue.shift();\n    for (let i = 0; i < vertex.siblings.length; i++) {\n      let adjoinVertex = vertex.siblings[i];\n      /* 若adjoinVertex未被访问过 */\n      if (typeof dist.get(adjoinVertex) === "undefined") {\n        /* 将这个点到start的距离更新 */\n        dist.set(adjoinVertex, dist.get(vertex) + 1);\n        /* 将这个点记录在S到adjoinVertex的路径上 */\n        path.set(adjoinVertex, vertex);\n        queue.push(adjoinVertex);\n      }\n    }\n  }\n  // 获取终点的最短路径长度\n  const distance = dist.get(end);\n  // 使用栈记住终点\n  const stack = [end];\n  let preVertex = path.get(end);\n  // 沿途处理从终点到起点所经过的路径\n  while (preVertex) {\n    stack.push(preVertex);\n    preVertex = path.get(preVertex);\n  }\n  // 经过逆序，得到了正确的路径\n  let via = "";\n  while (stack.length) {\n    const city = stack.pop();\n    via += "->" + city.cityName;\n  }\n  return { distance, path: via.replace(/(^->)|(->$)/g, "") };\n}\n',normalizedContent:'# 栈的应用之逆序\n\n在实际开发中，我们一旦遇到逆序的问题，可以想当然的先思考一下是否可以用栈进行处理。\n\n\n# 两数相加\n\n# 描述\n\n给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。\n\n你可以假设除了数字 0 之外，这两个数字都不会以零开头。\n\n# 思路分析\n\n因为是逆序，所以我们会想到用栈，分别遍历两个链表，用两个栈存储对应的节点，则问题转化为类似合并 2 个有序数组的问题。\n\n# 算法实现\n\n链表节点定义如下：\n\ninterface listnode<t> {\n  next: listnode<t> | null;\n  val: t;\n}\n\n\n/**\n * @param {listnode} l1\n * @param {listnode} l2\n * @return {listnode}\n */\nvar addtwonumbers = function (l1, l2) {\n  const stack1 = [];\n  const stack2 = [];\n  let node1 = l1;\n  let node2 = l2;\n  while (node1 && node2) {\n    stack1.push(node1);\n    stack2.push(node2);\n    node1 = node1.next;\n    node2 = node2.next;\n  }\n\n  while (node1) {\n    stack1.push(node1);\n    node1 = node1.next;\n  }\n\n  while (node2) {\n    stack2.push(node2);\n    node2 = node2.next;\n  }\n\n  let needincrease = false;\n  let newhead = null;\n  while (stack1.length && stack2.length) {\n    const num1node = stack1.pop();\n    const num2node = stack2.pop();\n    let val = num1node.val + num2node.val + (needincrease ? 1 : 0);\n    needincrease = false;\n    if (val >= 10) {\n      val = val - 10;\n      needincrease = true;\n    }\n    const tempnode = {\n      val,\n      next: null,\n    };\n    if (!newhead) {\n      newhead = tempnode;\n    } else {\n      tempnode.next = newhead;\n      newhead = tempnode;\n    }\n  }\n  while (stack1.length) {\n    const num1node = stack1.pop();\n    let val = num1node.val + (needincrease ? 1 : 0);\n    needincrease = false;\n    if (val >= 10) {\n      val = val - 10;\n      needincrease = true;\n    }\n    const tempnode = {\n      val,\n      next: null,\n    };\n    if (!newhead) {\n      newhead = tempnode;\n    } else {\n      tempnode.next = newhead;\n      newhead = tempnode;\n    }\n  }\n  while (stack2.length) {\n    const num2node = stack2.pop();\n    let val = num2node.val + (needincrease ? 1 : 0);\n    needincrease = false;\n    if (val >= 10) {\n      val = val - 10;\n      needincrease = true;\n    }\n    const tempnode = {\n      val,\n      next: null,\n    };\n    if (!newhead) {\n      newhead = tempnode;\n    } else {\n      tempnode.next = newhead;\n      newhead = tempnode;\n    }\n  }\n  if (needincrease) {\n    const tempnode = {\n      val: 1,\n      next: null,\n    };\n    tempnode.next = newhead;\n    newhead = tempnode;\n  }\n  return newhead;\n};\n\n\n\n# 无权图的单源最短路径\n\n对于有这样的图：\n\n\n\n假设我们用如下方式表示图：\n\nclass edge {\n  constructor(name) {\n    this.name = name;\n  }\n  /**\n   * 边的编号\n   */\n  name;\n  /**\n   * 起始点\n   * @type {vertex}\n   */\n  from;\n  /**\n   * 终止点\n   * @type {vertex}\n   */\n  to;\n}\n\nclass vertex {\n  /**\n   * 城市名称\n   */\n  cityname;\n  /**\n   * 邻接点\n   */\n  siblings = [];\n  constructor(cityname) {\n    this.cityname = cityname;\n  }\n}\n\nclass graph {\n  vertexlist = [];\n  edgelist = [];\n  addvertex(v) {\n    this.vertexlist.push(v);\n  }\n\n  /**\n   * 增加边\n   * @param {vertex} from\n   * @param {vertex} to\n   */\n  addedge(from, to) {\n    const name = `${from.cityname}至${to.cityname}`;\n    const edge = new edge(name);\n    this.edgelist.push(edge);\n    from.siblings.push(to);\n    to.siblings.push(from);\n  }\n}\n\nconst g = new graph();\nconst beijing = new vertex("北京");\nconst nanjing = new vertex("南京");\nconst guangzhou = new vertex("广州");\nconst shenzhen = new vertex("深圳");\nconst hongkong = new vertex("香港");\nconst chengdu = new vertex("成都");\nconst xian = new vertex("西安");\nconst urumchi = new vertex("乌鲁木齐");\n\n/**\n * 将城市加入到图中\n */\ng.addvertex(beijing);\ng.addvertex(nanjing);\ng.addvertex(guangzhou);\ng.addvertex(shenzhen);\ng.addvertex(hongkong);\ng.addvertex(chengdu);\ng.addvertex(xian);\ng.addvertex(urumchi);\n/**\n * 建立连接关系\n */\ng.addedge(beijing, nanjing);\ng.addedge(beijing, xian);\ng.addedge(nanjing, guangzhou);\ng.addedge(guangzhou, shenzhen);\ng.addedge(guangzhou, hongkong);\ng.addedge(hongkong, shenzhen);\ng.addedge(chengdu, guangzhou);\ng.addedge(chengdu, xian);\ng.addedge(urumchi, xian);\ng.addedge(urumchi, beijing);\n/**\n * 单源无权图的最短路算法\n * @param {vertex} start\n * @param {vertex} end\n */\nfunction unweightedshortestpath(start, end) {\n  const queue = [];\n  const dist = new map();\n  const path = new map();\n  dist.set(start, 0);\n  queue.push(start);\n  while (queue.length > 0) {\n    let vertex = queue.shift();\n    for (let i = 0; i < vertex.siblings.length; i++) {\n      let adjoinvertex = vertex.siblings[i];\n      /* 若adjoinvertex未被访问过 */\n      if (typeof dist.get(adjoinvertex) === "undefined") {\n        /* 将这个点到start的距离更新 */\n        dist.set(adjoinvertex, dist.get(vertex) + 1);\n        /* 将这个点记录在s到adjoinvertex的路径上 */\n        path.set(adjoinvertex, vertex);\n        queue.push(adjoinvertex);\n      }\n    }\n  }\n  // 获取终点的最短路径长度\n  const distance = dist.get(end);\n  // 使用栈记住终点\n  const stack = [end];\n  let prevertex = path.get(end);\n  // 沿途处理从终点到起点所经过的路径\n  while (prevertex) {\n    stack.push(prevertex);\n    prevertex = path.get(prevertex);\n  }\n  // 经过逆序，得到了正确的路径\n  let via = "";\n  while (stack.length) {\n    const city = stack.pop();\n    via += "->" + city.cityname;\n  }\n  return { distance, path: via.replace(/(^->)|(->$)/g, "") };\n}\n',charsets:{cjk:!0}},{title:"单调栈",frontmatter:{},regularPath:"/data-structure/stack/monotonous-stack.html",relativePath:"data-structure/stack/monotonous-stack.md",key:"v-21516316",path:"/data-structure/stack/monotonous-stack.html",headers:[{level:2,title:"单调栈",slug:"单调栈",normalizedTitle:"单调栈",charIndex:2}],headersStr:"单调栈",content:"# 单调栈\n\n建设中，敬请期待...",normalizedContent:"# 单调栈\n\n建设中，敬请期待...",charsets:{cjk:!0}},{title:"栈的应用之词法分析",frontmatter:{},regularPath:"/data-structure/stack/syntaxAnalysis.html",relativePath:"data-structure/stack/syntaxAnalysis.md",key:"v-78408355",path:"/data-structure/stack/syntaxAnalysis.html",headers:[{level:2,title:"栈的应用之词法分析",slug:"栈的应用之词法分析",normalizedTitle:"栈的应用之词法分析",charIndex:2},{level:3,title:"1. 序列化与反序列化二叉树",slug:"_1-序列化与反序列化二叉树",normalizedTitle:"1. 序列化与反序列化二叉树",charIndex:16},{level:3,title:"2. 四则运算求值",slug:"_2-四则运算求值",normalizedTitle:"2. 四则运算求值",charIndex:3344}],headersStr:"栈的应用之词法分析 1. 序列化与反序列化二叉树 2. 四则运算求值",content:'# 栈的应用之词法分析\n\n\n# 1. 序列化与反序列化二叉树\n\n二叉树节点的定义如下：\n\ninterface TreeNode<T> {\n  left: TreeNode | null;\n  right: TreeNode | null;\n  val: T;\n}\n\n\n# 分析\n\n序列化二叉树的代码较为简单，只要对数据结构有一点儿入门的同学一定能够解答出来。但是反序列化就相当不简单了。因为序列化之后的结果是一层一层的{和}的嵌套。首先假设输入一定合法，怎么样确定解析规则呢？每当我们遇到一个}，向前推导，那么一定是可以遇到一个{的。如果一个二叉树有左右子树，那么一定就存在左右子节点。这段字符串里面也一定有相应的字段。（但是也有可能没有，或者是left:null这样的情况），我们把左右儿子节点解析出来以后，先按规则存下来，然后，再解析根节点存下来，重复这样一个过程，最终存结果的容器里面只会有一个节点，那就是根节点，即可得到最终的结果。\n\n# 代码实现：\n\n/**\n * 序列化二叉树\n * @param {TreeNode} root\n * @return {string}\n */\nvar serialize = function (root) {\n  if (typeof root === "undefined") {\n    return "";\n  } else if (root === null) {\n    return "null";\n  } else {\n    const leftStr = serialize(root.left);\n    const rightStr = serialize(root.right);\n    let str = `val:${root.val}`;\n    if (leftStr !== "") {\n      str += `,left:${leftStr}`;\n    }\n    if (rightStr !== "") {\n      str += `,right:${rightStr}`;\n    }\n    return `{${str}}`;\n  }\n};\n\n/**\n * 反序列化二叉树\n * @param {string} data\n * @return {TreeNode}\n */\nvar deserialize = function (data) {\n  try {\n    // 定义一个栈，用于词法分析\n    const stack = [];\n    // 定义一个节点栈，用于存储解析的结果，你也可以不用栈，根据自己的需要即可\n    const nodeStack = [];\n    let offset = 0;\n    while (offset < data.length) {\n      let char = data[offset];\n      // 如果遇到后大括号，需要退栈，退到遇到前花括号为止\n      if (char === "}") {\n        let leftChar = stack.pop();\n        let tempStr = "";\n        while (stack.length && leftChar != "{") {\n          tempStr = leftChar + tempStr;\n          leftChar = stack.pop();\n        }\n        /*\n          经过上述操作之后，我们可以得到一个不含嵌套的树节点字符串\n          主要有这几种case:\n          "val: 1"\n          "val: 1, left: null",\n          "val: 1, left: null, right: null",\n          "val: 1, left: , right: "\n        */\n        // 定义解析val域的正则\n        let valArr = tempStr.match(/val:\\s*(-?\\d+)/);\n        // 定义解析左子树的正则\n        let leftArr = tempStr.match(/left:\\s*(null)?/);\n        // 定义解析右子树的正则\n        let rightArr = tempStr.match(/right:\\s*(null)?/);\n        // 申明一个初始的空节点，一会根据提取的内容覆盖其属性\n        let node = { val: Infinity };\n        // 解析val\n        if (!Array.isArray(valArr)) {\n          throw `the data source is not valid`;\n        } else {\n          node.val = Number.parseInt(valArr[1]);\n        }\n        // 解析左子树，但左子树不一定存在\n        if (Array.isArray(rightArr)) {\n          if (rightArr[1] === "null") {\n            node.right = null;\n          } else {\n            const rightChild = nodeStack.pop();\n            if (typeof rightChild === "undefined") {\n              throw `the data source is not valid`;\n            }\n            node.right = rightChild;\n          }\n        }\n        // 解析右子树，但右子树不一定存在\n        if (Array.isArray(leftArr)) {\n          if (leftArr[1] === "null") {\n            node.left = null;\n          } else {\n            const leftChild = nodeStack.pop();\n            if (typeof leftChild === "undefined") {\n              throw `the data source is not valid`;\n            }\n            node.left = leftChild;\n          }\n        }\n        /* 把解析出来的节点加入节点栈 */\n        nodeStack.push(node);\n      } else {\n        // 否则内容直接入栈\n        stack.push(char);\n      }\n      offset++;\n    }\n    if (nodeStack.length != 1) {\n      throw `the data source is not valid`;\n    }\n    // 在输入合法的前提下，节点栈中的第一个节点就是树的根节点\n    return nodeStack[0];\n  } catch (exp) {\n    console.log(exp);\n    return null;\n  }\n};\n\n\n有了这个基础，相信有能力的同学一定能够手写JSON.parse()。\n\n\n# 2. 四则运算求值\n\n# 描述：\n\n输入一个表达式（用字符串表示），求这个表达式的值。 保证字符串中的有效字符包括[‘0’-‘9’],‘+’,‘-’, ‘*’,‘/’ ,‘(’， ‘)’,‘[’, ‘]’,‘{’ ,‘}’。且表达式一定合法。\n\n例如: 3+2*{1+2*[-4/(8-6)+7]}，最终结果为 25。\n\n# 分析：\n\n题设已经说了输入有效。那我们就不考虑异常 case 了，对于一个正常的不带{},[],()表达式，比较好求。如1+2/-10*4-3,只需要正常的求，首先还是要遍历，第一轮我们主要考虑*和/,一轮之后,得到的结果便是1+-0.8-3，然后第二轮我们可以直接按顺序算便可以得到结果（这儿还有个取巧的方法，用eval，哈哈哈）。如果带上{},[],()这类运算符号的话，我们是否可以像我们之前的思维方式一样还是分轮进行解析。首先把()之间的表达式的值求出来，再填到表达式里面去。接着处理[],再者处理{},最后，问题转化成了我们最开始讨论的不带括号的表达式了。\n\n# 算法实现：\n\n/**\n * 根据不带括号的表达式求值\n * @param {string} str\n */\nvar calc = function (str) {\n  // TODO: 暂时先用eval实现，后期优化为自行处理\n  return eval(str);\n};\n\n/**\n * 四则运算求值\n * @param {string} s\n */\nvar arithmetic = function (s) {\n  let offset = 0;\n  let stack = [];\n  while (offset < s.length) {\n    let char = s[offset];\n    if (char === ")") {\n      // 解析()之间的内容\n      let tmpStr = "";\n      let tmpChar = stack.pop();\n      while (tmpChar != "(") {\n        tmpStr = tmpChar + tmpStr;\n        tmpChar = stack.pop();\n      }\n      stack.push(eval(tmpStr));\n    } else if (char === "]") {\n      // 解析[]之间的内容\n      let tmpStr = "";\n      let tmpChar = stack.pop();\n      while (tmpChar != "[") {\n        tmpStr = tmpChar + tmpStr;\n        tmpChar = stack.pop();\n      }\n      stack.push(calc(tmpStr));\n    } else if (char === "}") {\n      // 解析{}\n      let tmpStr = "";\n      let tmpChar = stack.pop();\n      while (tmpChar != "{") {\n        tmpStr = tmpChar + tmpStr;\n        tmpChar = stack.pop();\n      }\n      stack.push(calc(tmpStr));\n    } else {\n      stack.push(char);\n    }\n    offset++;\n  }\n  // 解析不带括号的表达式的结果\n  let tmpStr = "";\n  while (stack.length) {\n    tmpStr = stack.pop() + tmpStr;\n  }\n  let val = calc(tmpStr);\n  return val;\n};\n',normalizedContent:'# 栈的应用之词法分析\n\n\n# 1. 序列化与反序列化二叉树\n\n二叉树节点的定义如下：\n\ninterface treenode<t> {\n  left: treenode | null;\n  right: treenode | null;\n  val: t;\n}\n\n\n# 分析\n\n序列化二叉树的代码较为简单，只要对数据结构有一点儿入门的同学一定能够解答出来。但是反序列化就相当不简单了。因为序列化之后的结果是一层一层的{和}的嵌套。首先假设输入一定合法，怎么样确定解析规则呢？每当我们遇到一个}，向前推导，那么一定是可以遇到一个{的。如果一个二叉树有左右子树，那么一定就存在左右子节点。这段字符串里面也一定有相应的字段。（但是也有可能没有，或者是left:null这样的情况），我们把左右儿子节点解析出来以后，先按规则存下来，然后，再解析根节点存下来，重复这样一个过程，最终存结果的容器里面只会有一个节点，那就是根节点，即可得到最终的结果。\n\n# 代码实现：\n\n/**\n * 序列化二叉树\n * @param {treenode} root\n * @return {string}\n */\nvar serialize = function (root) {\n  if (typeof root === "undefined") {\n    return "";\n  } else if (root === null) {\n    return "null";\n  } else {\n    const leftstr = serialize(root.left);\n    const rightstr = serialize(root.right);\n    let str = `val:${root.val}`;\n    if (leftstr !== "") {\n      str += `,left:${leftstr}`;\n    }\n    if (rightstr !== "") {\n      str += `,right:${rightstr}`;\n    }\n    return `{${str}}`;\n  }\n};\n\n/**\n * 反序列化二叉树\n * @param {string} data\n * @return {treenode}\n */\nvar deserialize = function (data) {\n  try {\n    // 定义一个栈，用于词法分析\n    const stack = [];\n    // 定义一个节点栈，用于存储解析的结果，你也可以不用栈，根据自己的需要即可\n    const nodestack = [];\n    let offset = 0;\n    while (offset < data.length) {\n      let char = data[offset];\n      // 如果遇到后大括号，需要退栈，退到遇到前花括号为止\n      if (char === "}") {\n        let leftchar = stack.pop();\n        let tempstr = "";\n        while (stack.length && leftchar != "{") {\n          tempstr = leftchar + tempstr;\n          leftchar = stack.pop();\n        }\n        /*\n          经过上述操作之后，我们可以得到一个不含嵌套的树节点字符串\n          主要有这几种case:\n          "val: 1"\n          "val: 1, left: null",\n          "val: 1, left: null, right: null",\n          "val: 1, left: , right: "\n        */\n        // 定义解析val域的正则\n        let valarr = tempstr.match(/val:\\s*(-?\\d+)/);\n        // 定义解析左子树的正则\n        let leftarr = tempstr.match(/left:\\s*(null)?/);\n        // 定义解析右子树的正则\n        let rightarr = tempstr.match(/right:\\s*(null)?/);\n        // 申明一个初始的空节点，一会根据提取的内容覆盖其属性\n        let node = { val: infinity };\n        // 解析val\n        if (!array.isarray(valarr)) {\n          throw `the data source is not valid`;\n        } else {\n          node.val = number.parseint(valarr[1]);\n        }\n        // 解析左子树，但左子树不一定存在\n        if (array.isarray(rightarr)) {\n          if (rightarr[1] === "null") {\n            node.right = null;\n          } else {\n            const rightchild = nodestack.pop();\n            if (typeof rightchild === "undefined") {\n              throw `the data source is not valid`;\n            }\n            node.right = rightchild;\n          }\n        }\n        // 解析右子树，但右子树不一定存在\n        if (array.isarray(leftarr)) {\n          if (leftarr[1] === "null") {\n            node.left = null;\n          } else {\n            const leftchild = nodestack.pop();\n            if (typeof leftchild === "undefined") {\n              throw `the data source is not valid`;\n            }\n            node.left = leftchild;\n          }\n        }\n        /* 把解析出来的节点加入节点栈 */\n        nodestack.push(node);\n      } else {\n        // 否则内容直接入栈\n        stack.push(char);\n      }\n      offset++;\n    }\n    if (nodestack.length != 1) {\n      throw `the data source is not valid`;\n    }\n    // 在输入合法的前提下，节点栈中的第一个节点就是树的根节点\n    return nodestack[0];\n  } catch (exp) {\n    console.log(exp);\n    return null;\n  }\n};\n\n\n有了这个基础，相信有能力的同学一定能够手写json.parse()。\n\n\n# 2. 四则运算求值\n\n# 描述：\n\n输入一个表达式（用字符串表示），求这个表达式的值。 保证字符串中的有效字符包括[‘0’-‘9’],‘+’,‘-’, ‘*’,‘/’ ,‘(’， ‘)’,‘[’, ‘]’,‘{’ ,‘}’。且表达式一定合法。\n\n例如: 3+2*{1+2*[-4/(8-6)+7]}，最终结果为 25。\n\n# 分析：\n\n题设已经说了输入有效。那我们就不考虑异常 case 了，对于一个正常的不带{},[],()表达式，比较好求。如1+2/-10*4-3,只需要正常的求，首先还是要遍历，第一轮我们主要考虑*和/,一轮之后,得到的结果便是1+-0.8-3，然后第二轮我们可以直接按顺序算便可以得到结果（这儿还有个取巧的方法，用eval，哈哈哈）。如果带上{},[],()这类运算符号的话，我们是否可以像我们之前的思维方式一样还是分轮进行解析。首先把()之间的表达式的值求出来，再填到表达式里面去。接着处理[],再者处理{},最后，问题转化成了我们最开始讨论的不带括号的表达式了。\n\n# 算法实现：\n\n/**\n * 根据不带括号的表达式求值\n * @param {string} str\n */\nvar calc = function (str) {\n  // todo: 暂时先用eval实现，后期优化为自行处理\n  return eval(str);\n};\n\n/**\n * 四则运算求值\n * @param {string} s\n */\nvar arithmetic = function (s) {\n  let offset = 0;\n  let stack = [];\n  while (offset < s.length) {\n    let char = s[offset];\n    if (char === ")") {\n      // 解析()之间的内容\n      let tmpstr = "";\n      let tmpchar = stack.pop();\n      while (tmpchar != "(") {\n        tmpstr = tmpchar + tmpstr;\n        tmpchar = stack.pop();\n      }\n      stack.push(eval(tmpstr));\n    } else if (char === "]") {\n      // 解析[]之间的内容\n      let tmpstr = "";\n      let tmpchar = stack.pop();\n      while (tmpchar != "[") {\n        tmpstr = tmpchar + tmpstr;\n        tmpchar = stack.pop();\n      }\n      stack.push(calc(tmpstr));\n    } else if (char === "}") {\n      // 解析{}\n      let tmpstr = "";\n      let tmpchar = stack.pop();\n      while (tmpchar != "{") {\n        tmpstr = tmpchar + tmpstr;\n        tmpchar = stack.pop();\n      }\n      stack.push(calc(tmpstr));\n    } else {\n      stack.push(char);\n    }\n    offset++;\n  }\n  // 解析不带括号的表达式的结果\n  let tmpstr = "";\n  while (stack.length) {\n    tmpstr = stack.pop() + tmpstr;\n  }\n  let val = calc(tmpstr);\n  return val;\n};\n',charsets:{cjk:!0}},{title:"KMP 算法",frontmatter:{},regularPath:"/data-structure/string/KMP.html",relativePath:"data-structure/string/KMP.md",key:"v-0f60c256",path:"/data-structure/string/KMP.html",headers:[{level:2,title:"KMP 算法",slug:"kmp-算法",normalizedTitle:"kmp 算法",charIndex:2},{level:3,title:"朴素法",slug:"朴素法",normalizedTitle:"朴素法",charIndex:339},{level:3,title:"KMP",slug:"kmp",normalizedTitle:"kmp",charIndex:2}],headersStr:"KMP 算法 朴素法 KMP",content:'# KMP 算法\n\nKMP 算法是什么？主要解决的问题是在给定一个字符串 template,快速的发现是否在 template 存在子串 pattern。\n\nKMP 算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris 和 V.R.Pratt 提出的，所以由 3 位杰出的前辈的名字各取了一个字母得名。在某些版本的《数据结构》这门课中，存在于“串”这一章节。\n\nKMP 算法是出了名的难，其思想可能大多数同学都能掌握，但关键是求next数组，很多同学都没有理解为什么简短的几行代码就可实现神奇的效果，网上的博客或视频大多对于next数组对求解过程也是一笔带过，而KMP算法如果你不搞懂对next数组求解过程，那么你就不算真正懂得的 KMP 算法。\n\n\n# 朴素法\n\n在介绍 KMP 算法之前不得不提蛮力匹配算法，因为了解了蛮力匹配算法才能通过比较知道 KMP 算法的优势。\n\n之所以说它是蛮力匹配算法，设定 2 个指针，指针表示在主串上移动的位置，j 指针表示在目标字符串上的位置，就是通过一位一位的去比较，如果匹配失败，则 j 指针归 0，i 指针向后挪动一位，这其实并没有把之前子串上已经匹配到的内容利用起来，所以这个算法是快不起来的。\n\nfunction subString(tpl, pattern) {\n  let m = tpl.length;\n  let n = pattern.length;\n  for (let i = 0; i < m - n; ++i) {\n    let j = 0;\n    while (j < n && tpl[i + j] == pattern[j]) {\n      ++j;\n    }\n    if (j == n) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n\n其大概得算法流程如下：\n\n\n"\n"\n当遇到不匹配的时候，i指针向后移动一位，j指针回溯\n\n蛮力匹配的问题就出在这个i,j指针的回溯上，因此`KMP`算法的核心就是解决回溯。\n\n# 朴素法的复杂度分析\n\n朴素法是简单的两个循环相叠加，因此其时间复杂度是O(m*n)，m 和 n 分别为两个字符串的长度\n\n\n# KMP\n\nKMP 算法的聪明之处就是可以把之前已经匹配过的信息利用起来，用最小的代价知道我们下一次应该从哪个位置开始匹配。\n\n\n\n假设现在在 x 和 c 的位置发生失配，那么，我们只需要把模式串pattern向前进 c 之前的最长前后公共子串的长度，即图上的 ab 子串。\n\n因为只有前后公共子串的话，你挪动过去才有可能相配啊。简单一点儿的例子就好比一把两头都可以拧螺丝的扳手，你把这头拿去拧螺丝，跟把另外一头拿去拧螺丝，必须得跟螺丝的规格相配，如果都配的话，那么就无所谓你用那一头拧了。\n\n在明白匹配失败之后的操作之后，我们就需要去计算这个最长前后公共子串，即上文所说的next数组。\n\n为什么我们要先求next数组呢，可以看到，我们的pattern字符串其实是给定的，在匹配的过程中是不会发生变化的，那么，在每次失配的时候，我们一定知道当前失配位置前面是什么样的字符串，利用哈希表的思想，我们可以事先把每个位置的最长公共前后缀先算出来。\n\n接下来就是给出 KMP 算法最关键的 next 数组 求解过程：\n\n假设我们有如下pattern: abcabca\n\n对于子串a（即在匹配的时候，在它的下一个位置 b这个位置发生失配，后面也是这个意思，不赘述），没有公共前后缀，所以计为 0。\n\n对于子串ab，前缀有a, 后缀b,没有相同的前后缀，计为 0；\n\n对于子串abc，前缀a,ab； 后缀c,bc,没有相同的前后缀，计为 0；\n\n对于子串abca，前缀有a，ab，abc；后缀有a，ca，bca，最大公共前后缀a，计为 1；\n\n对于子串abcab，前缀有a，ab，abc，abca；后缀有b，ab，cab，bcab，最大公共前后缀ab，计为 2；\n\n对于子串abcabc，前缀有a，ab，abc，abca，abcab；后缀有c，bc，abc，cabc，bcabc，最大公共前后缀abc，计为 3；\n\n其实最后一个我们是没有多大的算的必要的，因为要在最后一个 a 的后面一位发生失配，这个可能吗？都匹配成功了，还需要什么匹配呢，但是只不过我们算next数组的过程中，没有必要去对这个进行特值处理，为了方便编程，所以还是会将其计算在里面。\n\n所以对于子串abcabca，前缀有a，ab，abc，abca，abcab，abcabc；后缀有 a, ca，bca，abca，cabca，bcabca，最大公共前后缀a，计为 1；\n\n列一个表格，如下：\n\nA   B   C   A   B   C   A\n0   0   0   1   2   3   1\n\n刚才我们已经知道最长公共前后缀的求解方法了，接下来开始思考一下怎么用代码去实现。\n\n首先看一下，比较朴素的方法。\n\n首部取一个字符，尾部取一个字符比较，继续重复这个操作，2 个字符进行比较，不断继续重复这个操作，直到 j 个字符串的长度。\n\n\n\n上述算法的比较次数为：1+2+3+...+(j+1)/2+...+j = O(j²)\n\n这个方法效率不高，因此我们得采取另外的方案，接下来看看三位巨擘是怎么做的。\n\n更好的这个方案是动态规划，主要是利用了回溯的思想。\n\n在阅读下文之前，请先在心里面默念三遍next 数组保存的是子串的最长公共前后缀，加深一下大脑的认识。\n\n下面我们来理解它是怎么样的一个流程：\n\n数组next[X]指向的是前缀，i指向的是后缀，假设在某个时刻如下：\n\n\n\n假设前面最长相同前缀为next[j-1]，最长相同后缀是i-1这个位置，那么，如果next[j-1]+1这个位置和i这个位置上的字符相同的话，那我们至少可以粗略的得出一个结论：\n\nnext[j] >= next[j-1]+1。\n\n有没有可能next[j] > next[j-1]+1呢？\n\n我们先假设可能存在这样的情况\n\n注意：下图中红色色块和蓝色色块并不是它们相等的意思，是描述这两个色块加入能否让next[j]变得更长。\n\n\n\n那么，根据假设，则应该存在：\n\n两个蓝色的色块应该相等才对\n\n\n\n如这种场景：\n\n\n\n那么，对于长度为[0, i-1]的子串，最长公共前缀应该指向next[j-1] + 1才对，而不应该是指向next[j-1]。所以我们可以得出结论，每新增一个字符，最长公共前缀只有可能增加 1，即： next[j-1] + 1 = next[j]\n\n上面我们讨论了匹配成功的情况，那么，如果失配呢？比如下图：\n\n\n\n因为我们的 next[j-1]是一个递推计算的结果，我们此刻是能够知道next[next[j-1]]的。（想不明白的同学可以在此多思考一下，动态规划的问题本来就非常难以让人理解，想想刚才让你默念三遍的话）。 如下图所示：\n\n\n\n因此，我们可以回到如下状态重新开启匹配，如下图所示：\n\n\n\n因此，又重复回到了我们刚才的流程。\n\n这个解题思路非常复杂，它是回溯和动态规划思想的结合，一般回溯都会和递归挂钩，但是递归有时候会存在大量的重复计算，所以会考虑逆向思维将其转变为动规规划问题，这些都是算法里面较难且非常锻炼思维能力的章节（我个人感受是在面试中遇到动态规划算法题，就全靠你和公司的缘分了），这方面比较小白的朋友，可以尝试学习这门课程，相信你学过之后，再回头查看这篇博客，你会有新的理解。\n\n整个求解next数组的算法的实现过程如下：\n\n/**\n * 生成next数组\n * @param {String} pattern\n * @param {Number[]} next\n */\nfunction genNext(pattern) {\n  let m = pattern.length;\n  let next = [];\n  // 因为第一个字符串没有前后缀，所以可以直接赋值0，相当于动态规划可直接求得的初始条件\n  next[0] = 0;\n  //当取一个字符的时候，肯定是一个前后缀都没有的\n  for (let i = 1, j = 0; i < m; ++i) {\n    // 如果没有匹配到，递归的去求之前的最大前缀\n    // 退出循环条件是 k大于0 并且当前位置的字符串要是一样的\n    while (j > 0 && pattern[i] !== pattern[j]) {\n      // 回溯，找到上一次的最大前后缀的长度\n      j = next[j - 1];\n    }\n    // 如果匹配到了，最大的前后缀+1\n    if (pattern[i] == pattern[j]) {\n      j++;\n    }\n    // 求出当前字符串的最大公共前后缀，更新next数组\n    next[i] = j;\n  }\n  return next;\n}\n\n\n看到这儿，如果你全部都理解了的话，恭喜你，其实你已经掌握KMP算法了。\n\nKMP算法搜索流程非常简单，其的实现如下：\n\n/**\n * KMP-Search\n * @param {String} tpl\n * @param {String} pattern\n * @returns\n */\nfunction kmpSearch(tpl, pattern) {\n  let n = tpl.length,\n    m = pattern.length;\n  let pos = -1;\n  let next = genNext(pattern);\n  for (let i = 0, q = 0; i < n; i++) {\n    /* 不断回溯，直到存在最长公共前后缀或回退到0，此处思路和求next数组求解思路一致。 */\n    while (q > 0 && pattern[q] != tpl[i]) {\n      q = next[q - 1];\n    }\n    // 如果当前字符和模式字符串指针位上的字符相等, 模式指针后移一位\n    if (pattern[q] == tpl[i]) {\n      q++;\n    }\n    /*\n     *  上述2个if不能交换位置，必须先判断是否匹配失败，才能继续进行匹配，如果交换的话，q指针先向后移动了一位，当前循环并没有结束，i指针还在前一个位置，此刻出现了错位，那么函数将不会正常运行。\n     */\n    // 如果模式字符串指针的位置走到了最后一位，则说明匹配成功了\n    if (q == m) {\n      // 因为当前匹配的位置实际上是在pattern的length-1的位置上\n      pos = i - m + 1;\n      break;\n    }\n  }\n  return pos;\n}\n\n\n# KMP 的复杂度分析\n\n在生成next数组的时候，我们看到是一个for循环和while循环嵌套，可以看到的是，每次j最坏退到0，但是只有在pattern[i] === pattern[j]的时候，j 才会递增的。j回退的总次数，是不会超过j增加的总次数的，最坏情况下，j累加的总次数是不会超过m的，所以while循环的执行次数是不会超过O(m)。所以生成next数组的时间复杂度是O(m)。在搜索过程中，同理。因此算法总的时间复杂度为 O(m+n)，m 和 n 分别为两个字符串的长度；\n\n因为生成next数组占用了一定的空间，所以空间复杂度为O(m)，m 为子字符串的长度。',normalizedContent:'# kmp 算法\n\nkmp 算法是什么？主要解决的问题是在给定一个字符串 template,快速的发现是否在 template 存在子串 pattern。\n\nkmp 算法是一种改进的字符串匹配算法，由d.e.knuth，j.h.morris 和 v.r.pratt 提出的，所以由 3 位杰出的前辈的名字各取了一个字母得名。在某些版本的《数据结构》这门课中，存在于“串”这一章节。\n\nkmp 算法是出了名的难，其思想可能大多数同学都能掌握，但关键是求next数组，很多同学都没有理解为什么简短的几行代码就可实现神奇的效果，网上的博客或视频大多对于next数组对求解过程也是一笔带过，而kmp算法如果你不搞懂对next数组求解过程，那么你就不算真正懂得的 kmp 算法。\n\n\n# 朴素法\n\n在介绍 kmp 算法之前不得不提蛮力匹配算法，因为了解了蛮力匹配算法才能通过比较知道 kmp 算法的优势。\n\n之所以说它是蛮力匹配算法，设定 2 个指针，指针表示在主串上移动的位置，j 指针表示在目标字符串上的位置，就是通过一位一位的去比较，如果匹配失败，则 j 指针归 0，i 指针向后挪动一位，这其实并没有把之前子串上已经匹配到的内容利用起来，所以这个算法是快不起来的。\n\nfunction substring(tpl, pattern) {\n  let m = tpl.length;\n  let n = pattern.length;\n  for (let i = 0; i < m - n; ++i) {\n    let j = 0;\n    while (j < n && tpl[i + j] == pattern[j]) {\n      ++j;\n    }\n    if (j == n) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n\n其大概得算法流程如下：\n\n\n"\n"\n当遇到不匹配的时候，i指针向后移动一位，j指针回溯\n\n蛮力匹配的问题就出在这个i,j指针的回溯上，因此`kmp`算法的核心就是解决回溯。\n\n# 朴素法的复杂度分析\n\n朴素法是简单的两个循环相叠加，因此其时间复杂度是o(m*n)，m 和 n 分别为两个字符串的长度\n\n\n# kmp\n\nkmp 算法的聪明之处就是可以把之前已经匹配过的信息利用起来，用最小的代价知道我们下一次应该从哪个位置开始匹配。\n\n\n\n假设现在在 x 和 c 的位置发生失配，那么，我们只需要把模式串pattern向前进 c 之前的最长前后公共子串的长度，即图上的 ab 子串。\n\n因为只有前后公共子串的话，你挪动过去才有可能相配啊。简单一点儿的例子就好比一把两头都可以拧螺丝的扳手，你把这头拿去拧螺丝，跟把另外一头拿去拧螺丝，必须得跟螺丝的规格相配，如果都配的话，那么就无所谓你用那一头拧了。\n\n在明白匹配失败之后的操作之后，我们就需要去计算这个最长前后公共子串，即上文所说的next数组。\n\n为什么我们要先求next数组呢，可以看到，我们的pattern字符串其实是给定的，在匹配的过程中是不会发生变化的，那么，在每次失配的时候，我们一定知道当前失配位置前面是什么样的字符串，利用哈希表的思想，我们可以事先把每个位置的最长公共前后缀先算出来。\n\n接下来就是给出 kmp 算法最关键的 next 数组 求解过程：\n\n假设我们有如下pattern: abcabca\n\n对于子串a（即在匹配的时候，在它的下一个位置 b这个位置发生失配，后面也是这个意思，不赘述），没有公共前后缀，所以计为 0。\n\n对于子串ab，前缀有a, 后缀b,没有相同的前后缀，计为 0；\n\n对于子串abc，前缀a,ab； 后缀c,bc,没有相同的前后缀，计为 0；\n\n对于子串abca，前缀有a，ab，abc；后缀有a，ca，bca，最大公共前后缀a，计为 1；\n\n对于子串abcab，前缀有a，ab，abc，abca；后缀有b，ab，cab，bcab，最大公共前后缀ab，计为 2；\n\n对于子串abcabc，前缀有a，ab，abc，abca，abcab；后缀有c，bc，abc，cabc，bcabc，最大公共前后缀abc，计为 3；\n\n其实最后一个我们是没有多大的算的必要的，因为要在最后一个 a 的后面一位发生失配，这个可能吗？都匹配成功了，还需要什么匹配呢，但是只不过我们算next数组的过程中，没有必要去对这个进行特值处理，为了方便编程，所以还是会将其计算在里面。\n\n所以对于子串abcabca，前缀有a，ab，abc，abca，abcab，abcabc；后缀有 a, ca，bca，abca，cabca，bcabca，最大公共前后缀a，计为 1；\n\n列一个表格，如下：\n\na   b   c   a   b   c   a\n0   0   0   1   2   3   1\n\n刚才我们已经知道最长公共前后缀的求解方法了，接下来开始思考一下怎么用代码去实现。\n\n首先看一下，比较朴素的方法。\n\n首部取一个字符，尾部取一个字符比较，继续重复这个操作，2 个字符进行比较，不断继续重复这个操作，直到 j 个字符串的长度。\n\n\n\n上述算法的比较次数为：1+2+3+...+(j+1)/2+...+j = o(j²)\n\n这个方法效率不高，因此我们得采取另外的方案，接下来看看三位巨擘是怎么做的。\n\n更好的这个方案是动态规划，主要是利用了回溯的思想。\n\n在阅读下文之前，请先在心里面默念三遍next 数组保存的是子串的最长公共前后缀，加深一下大脑的认识。\n\n下面我们来理解它是怎么样的一个流程：\n\n数组next[x]指向的是前缀，i指向的是后缀，假设在某个时刻如下：\n\n\n\n假设前面最长相同前缀为next[j-1]，最长相同后缀是i-1这个位置，那么，如果next[j-1]+1这个位置和i这个位置上的字符相同的话，那我们至少可以粗略的得出一个结论：\n\nnext[j] >= next[j-1]+1。\n\n有没有可能next[j] > next[j-1]+1呢？\n\n我们先假设可能存在这样的情况\n\n注意：下图中红色色块和蓝色色块并不是它们相等的意思，是描述这两个色块加入能否让next[j]变得更长。\n\n\n\n那么，根据假设，则应该存在：\n\n两个蓝色的色块应该相等才对\n\n\n\n如这种场景：\n\n\n\n那么，对于长度为[0, i-1]的子串，最长公共前缀应该指向next[j-1] + 1才对，而不应该是指向next[j-1]。所以我们可以得出结论，每新增一个字符，最长公共前缀只有可能增加 1，即： next[j-1] + 1 = next[j]\n\n上面我们讨论了匹配成功的情况，那么，如果失配呢？比如下图：\n\n\n\n因为我们的 next[j-1]是一个递推计算的结果，我们此刻是能够知道next[next[j-1]]的。（想不明白的同学可以在此多思考一下，动态规划的问题本来就非常难以让人理解，想想刚才让你默念三遍的话）。 如下图所示：\n\n\n\n因此，我们可以回到如下状态重新开启匹配，如下图所示：\n\n\n\n因此，又重复回到了我们刚才的流程。\n\n这个解题思路非常复杂，它是回溯和动态规划思想的结合，一般回溯都会和递归挂钩，但是递归有时候会存在大量的重复计算，所以会考虑逆向思维将其转变为动规规划问题，这些都是算法里面较难且非常锻炼思维能力的章节（我个人感受是在面试中遇到动态规划算法题，就全靠你和公司的缘分了），这方面比较小白的朋友，可以尝试学习这门课程，相信你学过之后，再回头查看这篇博客，你会有新的理解。\n\n整个求解next数组的算法的实现过程如下：\n\n/**\n * 生成next数组\n * @param {string} pattern\n * @param {number[]} next\n */\nfunction gennext(pattern) {\n  let m = pattern.length;\n  let next = [];\n  // 因为第一个字符串没有前后缀，所以可以直接赋值0，相当于动态规划可直接求得的初始条件\n  next[0] = 0;\n  //当取一个字符的时候，肯定是一个前后缀都没有的\n  for (let i = 1, j = 0; i < m; ++i) {\n    // 如果没有匹配到，递归的去求之前的最大前缀\n    // 退出循环条件是 k大于0 并且当前位置的字符串要是一样的\n    while (j > 0 && pattern[i] !== pattern[j]) {\n      // 回溯，找到上一次的最大前后缀的长度\n      j = next[j - 1];\n    }\n    // 如果匹配到了，最大的前后缀+1\n    if (pattern[i] == pattern[j]) {\n      j++;\n    }\n    // 求出当前字符串的最大公共前后缀，更新next数组\n    next[i] = j;\n  }\n  return next;\n}\n\n\n看到这儿，如果你全部都理解了的话，恭喜你，其实你已经掌握kmp算法了。\n\nkmp算法搜索流程非常简单，其的实现如下：\n\n/**\n * kmp-search\n * @param {string} tpl\n * @param {string} pattern\n * @returns\n */\nfunction kmpsearch(tpl, pattern) {\n  let n = tpl.length,\n    m = pattern.length;\n  let pos = -1;\n  let next = gennext(pattern);\n  for (let i = 0, q = 0; i < n; i++) {\n    /* 不断回溯，直到存在最长公共前后缀或回退到0，此处思路和求next数组求解思路一致。 */\n    while (q > 0 && pattern[q] != tpl[i]) {\n      q = next[q - 1];\n    }\n    // 如果当前字符和模式字符串指针位上的字符相等, 模式指针后移一位\n    if (pattern[q] == tpl[i]) {\n      q++;\n    }\n    /*\n     *  上述2个if不能交换位置，必须先判断是否匹配失败，才能继续进行匹配，如果交换的话，q指针先向后移动了一位，当前循环并没有结束，i指针还在前一个位置，此刻出现了错位，那么函数将不会正常运行。\n     */\n    // 如果模式字符串指针的位置走到了最后一位，则说明匹配成功了\n    if (q == m) {\n      // 因为当前匹配的位置实际上是在pattern的length-1的位置上\n      pos = i - m + 1;\n      break;\n    }\n  }\n  return pos;\n}\n\n\n# kmp 的复杂度分析\n\n在生成next数组的时候，我们看到是一个for循环和while循环嵌套，可以看到的是，每次j最坏退到0，但是只有在pattern[i] === pattern[j]的时候，j 才会递增的。j回退的总次数，是不会超过j增加的总次数的，最坏情况下，j累加的总次数是不会超过m的，所以while循环的执行次数是不会超过o(m)。所以生成next数组的时间复杂度是o(m)。在搜索过程中，同理。因此算法总的时间复杂度为 o(m+n)，m 和 n 分别为两个字符串的长度；\n\n因为生成next数组占用了一定的空间，所以空间复杂度为o(m)，m 为子字符串的长度。',charsets:{cjk:!0}},{title:"字典树",frontmatter:{},regularPath:"/data-structure/tree/N-Tree/Trie.html",relativePath:"data-structure/tree/N-Tree/Trie.md",key:"v-02a48cf5",path:"/data-structure/tree/N-Tree/Trie.html",headers:[{level:2,title:"字典树",slug:"字典树",normalizedTitle:"字典树",charIndex:2},{level:3,title:"基本概念",slug:"基本概念",normalizedTitle:"基本概念",charIndex:202},{level:3,title:"字典树的插入和查询",slug:"字典树的插入和查询",normalizedTitle:"字典树的插入和查询",charIndex:566},{level:3,title:"应用场景——统计词频",slug:"应用场景-统计词频",normalizedTitle:"应用场景——统计词频",charIndex:2444}],headersStr:"字典树 基本概念 字典树的插入和查询 应用场景——统计词频",content:"# 字典树\n\n我们每天都可能会用到的有道词典，但是却没有思考过计算机是如何在几十万级别的数据中快速的查出单词的含义及例句的，本文即讲述一个词频统计的高效的数据结构字典树。\n\n字典树，也叫前缀树，是一颗N-叉树，典型应用是用于统计，排序和保存大量的字符串，所以经常被搜索引擎系统用于文本词频统计。\n\n它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率非常高。\n\n\n# 基本概念\n\n如果大家不了解字典树的话，有业务需要存储一堆单词，传统的手段一般都是会考虑使用数组进行存储，然后要查找一个单词是否存在的话，我们需要对这个数组进行遍历，这个时间复杂度至少是O(N*K)，N是单词的个数，K是单词的长度。\n\n这儿有个问题，就是可能有些单词是相同的，但是我们却不得不把它的共同的前缀存M遍，其实也是大大的浪费了空间的。\n\n字典树是一种聪明的办法，它将单词拆分成字母，然后对于个字符成为一个树节点，并且指向它的后面的字符节点。这样，其实对于一些单词拥有相同的前缀的话，只需要存储一份即可，并且这样设计查询效率非常快，O(K)，K为单词的长度。\n\n下图表示的就是一个字典树：\n\n\n\n这个字典树目前存储的单词有：wc， word，world，app, apple，非蓝色节点表示的就是当前单词的结尾。\n\n\n# 字典树的插入和查询\n\n将字典树的节点定义为如下，主要是为了方便找词和统计相同单词出现的业务（如果不需要，可以去掉times和word域）\n\ninterface TrieNode {\n  /**\n   * 字典树当前对应的字符\n   */\n  char: string;\n\n  /**\n   * 如果这个位置对应的是一个单词，则次数不为0，否则为0\n   */\n  times: number;\n\n  /**\n   * 当前字符是否存在以当前字符结尾的单词\n   */\n  word: string | null;\n\n  /**\n   * 子树\n   */\n  children: Map<string, TrieNode> | null;\n}\n\n\n根据上述的树节点定义，字典树的查询和插入实现如下：\n\n/**\n * 字典树\n */\nclass Trie {\n  /**\n   * 前缀树的根节点\n   */\n  private root = new Map<string, TrieNode>();\n\n  /**\n   * 向字典树中插入单词\n   * @param word\n   */\n  insert(word: string) {\n    let parentNode = this.root;\n    let lastIndex = word.length - 1;\n    for (let i = 0; i < word.length; i++) {\n      const char = word[i];\n      const isLast = i === lastIndex;\n      let trieNode = parentNode.get(char);\n      if (!trieNode) {\n        trieNode = {\n          char,\n          times: isLast ? 1 : 0,\n          word: isLast ? word : null,\n          children: isLast ? new Map() : null,\n        };\n        parentNode.set(char, trieNode);\n      } else if (trieNode && isLast) {\n        // 更新词频和单词\n        trieNode.times++;\n        trieNode.word = word;\n      }\n      // 如果当前节点是早些时候的叶节点，继续向后插入\n      if (!trieNode.children) {\n        trieNode.children = new Map();\n      }\n      // 将父节点指针向下沉\n      parentNode = trieNode.children;\n    }\n  }\n  /**\n   * 在字典树中查询单词\n   * @param word\n   * @returns\n   */\n  search(word: string) {\n    let parentNode = this.root;\n    let lastIndex = word.length - 1;\n    for (let i = 0; i < word.length; i++) {\n      const char = word[i];\n      const isLast = i === lastIndex;\n      let trieNode = parentNode.get(char);\n      // 如果当前字幕不匹配。或者如果找到了尽头还没有找到，说明单词不匹配\n      if (!trieNode || !trieNode.children) {\n        return false;\n      }\n      // 如果遇到了结尾标志，需要判断以当前字母结尾的单词是不是我们想找的单词\n      if (isLast) {\n        return trieNode.word === word;\n      }\n      // 将父节点指针向下沉\n      parentNode = trieNode.children;\n    }\n  }\n}\n\n\n\n# 应用场景——统计词频\n\n",normalizedContent:"# 字典树\n\n我们每天都可能会用到的有道词典，但是却没有思考过计算机是如何在几十万级别的数据中快速的查出单词的含义及例句的，本文即讲述一个词频统计的高效的数据结构字典树。\n\n字典树，也叫前缀树，是一颗n-叉树，典型应用是用于统计，排序和保存大量的字符串，所以经常被搜索引擎系统用于文本词频统计。\n\n它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率非常高。\n\n\n# 基本概念\n\n如果大家不了解字典树的话，有业务需要存储一堆单词，传统的手段一般都是会考虑使用数组进行存储，然后要查找一个单词是否存在的话，我们需要对这个数组进行遍历，这个时间复杂度至少是o(n*k)，n是单词的个数，k是单词的长度。\n\n这儿有个问题，就是可能有些单词是相同的，但是我们却不得不把它的共同的前缀存m遍，其实也是大大的浪费了空间的。\n\n字典树是一种聪明的办法，它将单词拆分成字母，然后对于个字符成为一个树节点，并且指向它的后面的字符节点。这样，其实对于一些单词拥有相同的前缀的话，只需要存储一份即可，并且这样设计查询效率非常快，o(k)，k为单词的长度。\n\n下图表示的就是一个字典树：\n\n\n\n这个字典树目前存储的单词有：wc， word，world，app, apple，非蓝色节点表示的就是当前单词的结尾。\n\n\n# 字典树的插入和查询\n\n将字典树的节点定义为如下，主要是为了方便找词和统计相同单词出现的业务（如果不需要，可以去掉times和word域）\n\ninterface trienode {\n  /**\n   * 字典树当前对应的字符\n   */\n  char: string;\n\n  /**\n   * 如果这个位置对应的是一个单词，则次数不为0，否则为0\n   */\n  times: number;\n\n  /**\n   * 当前字符是否存在以当前字符结尾的单词\n   */\n  word: string | null;\n\n  /**\n   * 子树\n   */\n  children: map<string, trienode> | null;\n}\n\n\n根据上述的树节点定义，字典树的查询和插入实现如下：\n\n/**\n * 字典树\n */\nclass trie {\n  /**\n   * 前缀树的根节点\n   */\n  private root = new map<string, trienode>();\n\n  /**\n   * 向字典树中插入单词\n   * @param word\n   */\n  insert(word: string) {\n    let parentnode = this.root;\n    let lastindex = word.length - 1;\n    for (let i = 0; i < word.length; i++) {\n      const char = word[i];\n      const islast = i === lastindex;\n      let trienode = parentnode.get(char);\n      if (!trienode) {\n        trienode = {\n          char,\n          times: islast ? 1 : 0,\n          word: islast ? word : null,\n          children: islast ? new map() : null,\n        };\n        parentnode.set(char, trienode);\n      } else if (trienode && islast) {\n        // 更新词频和单词\n        trienode.times++;\n        trienode.word = word;\n      }\n      // 如果当前节点是早些时候的叶节点，继续向后插入\n      if (!trienode.children) {\n        trienode.children = new map();\n      }\n      // 将父节点指针向下沉\n      parentnode = trienode.children;\n    }\n  }\n  /**\n   * 在字典树中查询单词\n   * @param word\n   * @returns\n   */\n  search(word: string) {\n    let parentnode = this.root;\n    let lastindex = word.length - 1;\n    for (let i = 0; i < word.length; i++) {\n      const char = word[i];\n      const islast = i === lastindex;\n      let trienode = parentnode.get(char);\n      // 如果当前字幕不匹配。或者如果找到了尽头还没有找到，说明单词不匹配\n      if (!trienode || !trienode.children) {\n        return false;\n      }\n      // 如果遇到了结尾标志，需要判断以当前字母结尾的单词是不是我们想找的单词\n      if (islast) {\n        return trienode.word === word;\n      }\n      // 将父节点指针向下沉\n      parentnode = trienode.children;\n    }\n  }\n}\n\n\n\n# 应用场景——统计词频\n\n",charsets:{cjk:!0}},{title:"描述",frontmatter:{},regularPath:"/data-structure/tree/N-Tree/dfsVisit.html",relativePath:"data-structure/tree/N-Tree/dfsVisit.md",key:"v-3a2914f5",path:"/data-structure/tree/N-Tree/dfsVisit.html",headers:[{level:2,title:"描述",slug:"描述",normalizedTitle:"描述",charIndex:2},{level:2,title:"N-叉树的 DFS 递归实现",slug:"n-叉树的-dfs-递归实现",normalizedTitle:"n-叉树的 dfs 递归实现",charIndex:267},{level:2,title:"N-叉树的 DFS 非递归实现",slug:"n-叉树的-dfs-非递归实现",normalizedTitle:"n-叉树的 dfs 非递归实现",charIndex:677},{level:2,title:"复杂度分析",slug:"复杂度分析",normalizedTitle:"复杂度分析",charIndex:2258},{level:2,title:"应用场景",slug:"应用场景",normalizedTitle:"应用场景",charIndex:2319}],headersStr:"描述 N-叉树的 DFS 递归实现 N-叉树的 DFS 非递归实现 复杂度分析 应用场景",content:'# 描述\n\n假设我们的树节点的定义如下：\n\ninterface NTreeNode<T> {\n  left: TreeNode | null;\n  right: TreeNode | null;\n  children: T[] | undefined;\n  data: T;\n}\n\n\n对于 N-叉树则不存在先序、中序、后序的提法，但是我们可以在每次遍历的时候，总是先遍历当前节点的最左边的至树的叶节点，然后再向上回溯，再遍历后续的节点，直到完成所有节点的遍历(即深度优先遍历（DFS: deep-first-search）)\n\n\n# N-叉树的 DFS 递归实现\n\n/**\n * N叉树深度优先递归遍历\n * @param {NTreeNode<number>[]} treeNodes\n */\nfunction dfsVisitRecursion(treeNodes) {\n  if (!Array.isArray(treeNodes) || treeNodes.length === 0) {\n    console.log("treeNodes empty");\n    return;\n  }\n\n  treeNodes.forEach((treeNode) => {\n    if (Array.isArray(treeNode.children)) {\n      dfsVisitRecursion(treeNode.children);\n    }\n    console.log(treeNode.data);\n  });\n}\n\n\n\n# N-叉树的 DFS 非递归实现\n\n/**\n * N叉树非递归深度优先遍历\n * @param { NTreeNode<number>[] } treeNodes\n */\nfunction dfsVisit(treeNodes) {\n  if (!Array.isArray(treeNodes) || treeNodes.length === 0) {\n    console.warn("treeNodes empty");\n    return;\n  }\n  let stack = [];\n  // 用来记住每个节点的下一个兄弟节点\n  let nextSiblingMap = new Map();\n  // 建立下一个兄弟节点的关系\n  for (let i = 0; i < treeNodes.length; i++) {\n    const curNode = treeNodes[i];\n    const nextNode = treeNodes[i + 1] || null;\n    nextSiblingMap.set(curNode, nextNode);\n  }\n  let treeNode = treeNodes[0];\n  while (stack.length || treeNode) {\n    // 当节点为空时，说明已经迭代到最叶节点了，退出循环\n    while (treeNode) {\n      console.log(treeNode.data);\n      stack.push(treeNode);\n      let subNodes = Array.isArray(treeNode.children) ? treeNode.children : [];\n      // 每一层都建立下一个兄弟节点的关系\n      for (let k = 0; k < subNodes.length; k++) {\n        const curNode = subNodes[k];\n        const nextNode = subNodes[k + 1] || null;\n        nextSiblingMap.set(curNode, nextNode);\n      }\n      // 下滤节点\n      treeNode = subNodes[0] || null;\n    }\n    if (stack.length) {\n      treeNode = stack.pop();\n      // 根据当前节点到map里面找当前节点的下一个兄弟节点\n      let nextSiblingNode = nextSiblingMap.get(treeNode);\n      if (nextSiblingNode) {\n        treeNode = nextSiblingNode;\n      } else {\n        // 如果没有下一个兄弟节点了，说明需要回退到父亲节点，父亲节点处理完成之后，准备处理父亲节点的下一个兄弟节点\n        if (stack.length) {\n          treeNode = stack.pop();\n          // 继续切换到父节点的兄弟节点\n          treeNode = nextSiblingMap.get(treeNode);\n        } else {\n          // 已经将所有的节点处理完成，可以功成身退\n          treeNode = null;\n        }\n      }\n    }\n  }\n}\n\n\n\n# 复杂度分析\n\n时间复杂度O(n)；平均空间复杂度O(m*h)，为 N-叉树的最大高度,m为N-叉树的子节点个数;\n\n\n# 应用场景\n\n电脑中的文件目录；\n\n权限管理中的权限列表；\n\n设备管理中的设备树等；\n\n前端的路由表等；',normalizedContent:'# 描述\n\n假设我们的树节点的定义如下：\n\ninterface ntreenode<t> {\n  left: treenode | null;\n  right: treenode | null;\n  children: t[] | undefined;\n  data: t;\n}\n\n\n对于 n-叉树则不存在先序、中序、后序的提法，但是我们可以在每次遍历的时候，总是先遍历当前节点的最左边的至树的叶节点，然后再向上回溯，再遍历后续的节点，直到完成所有节点的遍历(即深度优先遍历（dfs: deep-first-search）)\n\n\n# n-叉树的 dfs 递归实现\n\n/**\n * n叉树深度优先递归遍历\n * @param {ntreenode<number>[]} treenodes\n */\nfunction dfsvisitrecursion(treenodes) {\n  if (!array.isarray(treenodes) || treenodes.length === 0) {\n    console.log("treenodes empty");\n    return;\n  }\n\n  treenodes.foreach((treenode) => {\n    if (array.isarray(treenode.children)) {\n      dfsvisitrecursion(treenode.children);\n    }\n    console.log(treenode.data);\n  });\n}\n\n\n\n# n-叉树的 dfs 非递归实现\n\n/**\n * n叉树非递归深度优先遍历\n * @param { ntreenode<number>[] } treenodes\n */\nfunction dfsvisit(treenodes) {\n  if (!array.isarray(treenodes) || treenodes.length === 0) {\n    console.warn("treenodes empty");\n    return;\n  }\n  let stack = [];\n  // 用来记住每个节点的下一个兄弟节点\n  let nextsiblingmap = new map();\n  // 建立下一个兄弟节点的关系\n  for (let i = 0; i < treenodes.length; i++) {\n    const curnode = treenodes[i];\n    const nextnode = treenodes[i + 1] || null;\n    nextsiblingmap.set(curnode, nextnode);\n  }\n  let treenode = treenodes[0];\n  while (stack.length || treenode) {\n    // 当节点为空时，说明已经迭代到最叶节点了，退出循环\n    while (treenode) {\n      console.log(treenode.data);\n      stack.push(treenode);\n      let subnodes = array.isarray(treenode.children) ? treenode.children : [];\n      // 每一层都建立下一个兄弟节点的关系\n      for (let k = 0; k < subnodes.length; k++) {\n        const curnode = subnodes[k];\n        const nextnode = subnodes[k + 1] || null;\n        nextsiblingmap.set(curnode, nextnode);\n      }\n      // 下滤节点\n      treenode = subnodes[0] || null;\n    }\n    if (stack.length) {\n      treenode = stack.pop();\n      // 根据当前节点到map里面找当前节点的下一个兄弟节点\n      let nextsiblingnode = nextsiblingmap.get(treenode);\n      if (nextsiblingnode) {\n        treenode = nextsiblingnode;\n      } else {\n        // 如果没有下一个兄弟节点了，说明需要回退到父亲节点，父亲节点处理完成之后，准备处理父亲节点的下一个兄弟节点\n        if (stack.length) {\n          treenode = stack.pop();\n          // 继续切换到父节点的兄弟节点\n          treenode = nextsiblingmap.get(treenode);\n        } else {\n          // 已经将所有的节点处理完成，可以功成身退\n          treenode = null;\n        }\n      }\n    }\n  }\n}\n\n\n\n# 复杂度分析\n\n时间复杂度o(n)；平均空间复杂度o(m*h)，为 n-叉树的最大高度,m为n-叉树的子节点个数;\n\n\n# 应用场景\n\n电脑中的文件目录；\n\n权限管理中的权限列表；\n\n设备管理中的设备树等；\n\n前端的路由表等；',charsets:{cjk:!0}},{title:"树的构建",frontmatter:{},regularPath:"/data-structure/tree/binaryTree/construct.html",relativePath:"data-structure/tree/binaryTree/construct.md",key:"v-0352edef",path:"/data-structure/tree/binaryTree/construct.html",headers:[{level:2,title:"树的构建",slug:"树的构建",normalizedTitle:"树的构建",charIndex:2},{level:3,title:"1. 把后端返回的数据构建成树",slug:"_1-把后端返回的数据构建成树",normalizedTitle:"1. 把后端返回的数据构建成树",charIndex:11},{level:3,title:"2. 从二叉树的两个遍历序列构建二叉树",slug:"_2-从二叉树的两个遍历序列构建二叉树",normalizedTitle:"2. 从二叉树的两个遍历序列构建二叉树",charIndex:2115}],headersStr:"树的构建 1. 把后端返回的数据构建成树 2. 从二叉树的两个遍历序列构建二叉树",content:"# 树的构建\n\n\n# 1. 把后端返回的数据构建成树\n\n这是一个很常见的操作，有些时候，是因为后端直接返回树结构的话，序列化时i/o开销比较大，在高并发场景下，会使得服务器的效率降低，因此不得不让前端自行构建树型结构的数据。\n\n还有一种情况就比较搞笑了，这种情况一般出现在小公司，你的后端因为某些不可告人的秘密，告诉你只能给你返回数组。但是我们前端又必须需要一个树状结构。此时为了避免尴尬，前端可能会要求后端怎么样操作简单就怎么样约定数据格式了，然后前端按照相应的规格自己将其构建成树。\n\n一般，后端给到前端的数据是这样的，我就以文件列表的例子来举例。\n\n/**\n * 文件信息\n */\ninterface File {\n  /**\n   * 文件的ID，需要使用string类型，若使用number类型，当id特别大的时候，前端解析的结果将不正确\n   */\n  id: string;\n\n  /**\n   * 文件的父级ID, 可能不存在\n   */\n  pid: string | null;\n\n  /**\n   * 文件名\n   */\n  filename: string;\n\n  /**\n   * 文件类型，比如是文件还是文件夹\n   */\n  type: number;\n\n  /**\n   * 子文件列表\n   */\n  children?: File[];\n}\n\n\n# 方案 1 使用递归\n\n/**\n * 构建文件树\n * @param file 文件信息\n * @param file 文件列表信息\n */\nfunction buildTree(file: File, files: File[]) {\n  // 找到当前文件的子文件列表\n  let children = files.filter((fileEle: File) => {\n    return fileEle.pid === file.id;\n  });\n  // 递归的处理当前文件子文件列表的子文件\n  file.children =\n    children.length === 0\n      ? undefined\n      : children.map((subFile: File) => buildTree(subFile, files));\n  return file;\n}\n\n/**\n * 将文件列表转为文件树，并且返回根节点\n * @param files 文件列表\n */\nfunction build(files: File[]) {\n  // 构建结果\n  const roots = files\n    .filter((file) => {\n      // 这一步操作是为了找到所有的根节点\n      return file.pid === null;\n    })\n    .map((file) => {\n      // 对根节点的数据进行构建\n      return buildTree(file, files);\n    });\n  return roots;\n}\n\n\n# 方案 2 使用哈希表\n\n这个方案是有点儿取巧的一种做法了，因为其完美的利用了引用类型数据的特征，因为引用数据类型，大家都同时持有一块相同的内存区域，不同的人对它进行修改，都会在它的身上得到体现。\n\n/**\n * 将文件列表转换成为哈希表\n * @param {File[]} files\n */\nfunction makeHashMap(files) {\n  const map = new Map();\n  files.forEach((file) => {\n    // 以ID为主键建立哈希映射\n    map.set(file.id, file);\n  });\n  return map;\n}\n\nfunction buildTree(files) {\n  // 将文件构建成哈希表，主要是为了后续的查找方便\n  const fileMap = makeHashMap(files);\n  const roots = [];\n  // 逐个的对每个文件增加子元素\n  files.forEach((file) => {\n    // 找父级文件，如果找不到的话，说明是根节点\n    const parentFile = fileMap.get(file.pid);\n    if (parentFile) {\n      if (!Array.isArray(parentFile.children)) {\n        parentFile.children = [file];\n      } else {\n        parentFile.children.push(file);\n      }\n    } else {\n      roots.push(file);\n    }\n  });\n  // 最后只需要找出根节点的文件列表即可完成构建\n  return roots;\n}\n\n\n\n# 2. 从二叉树的两个遍历序列构建二叉树\n\n通过无重复值的二叉树遍历中序序列+先序（或后序）序列能唯一确定一颗二叉树。\n\n注意事项\n\n仅凭先序和后序序列无法唯一确定一颗二叉树。\n\n先序序列的第一个节点一定是根节点，然后我们就可以通过这个根节点，在中序序列中确定其根节点的位置。一旦确定了中序序列的根节点位置，那就可以得到左子树序列和右子树序列。而同一颗二叉树的左右子树序列长度是相同的，因此，我们可以根据从中序序列获取到的左右子树片段，找出先序序列的左右子树片段。重复这个过程，直到构建完成。\n\n后序序列+中序序列构建思路还先序序列+中序序列构建思路类似。\n\n# 通过先序序列+中序序列构建二叉树\n\n二叉树结构定义如下：\n\ninterface TreeNode<T> {\n  left: TreeNode<T> | null;\n  right: TreeNode<T> | null;\n  val: T;\n}\n\n\n算法实现如下：\n\n/**\n * 从二叉树的先序序列+中序序列构建二叉树\n * @param {number[]} preorder 先序序列\n * @param {number[]} inorder 中序序列\n * @return {TreeNode}\n */\nvar buildTree = function (preorder, inorder) {\n  if (\n    !Array.isArray(preorder) ||\n    preorder.length === 0 ||\n    !Array.isArray(inorder) ||\n    inorder.length === 0 ||\n    preorder.length != inorder.length\n  ) {\n    return null;\n  }\n  let rootVal = preorder[0];\n  // 在中序遍历的结果中找到根节点所在的位置，则【0，idx】的是左子树，【idx+1，length】的是右子树\n  let rootNodeIdx = inorder.findIndex((x) => x === rootVal);\n  let inLeftSubtreeNodes = inorder.slice(0, rootNodeIdx);\n  let inRightSubtreeNodes = inorder.slice(rootNodeIdx + 1);\n  // 在先序遍历的结果中提取对应长度的的子集 可以得到对应的左子树结果集合\n  let preLeftSubtreeNodes = preorder.slice(1, inLeftSubtreeNodes.length + 1);\n  // 继续在先序遍历的结果中提取对应长度的子集，可以得到对应右子树结果集合\n  let preRightSubtreeNodes = preorder.slice(1 + inLeftSubtreeNodes.length);\n  return {\n    val: rootVal,\n    left: buildTree(preLeftSubtreeNodes, inLeftSubtreeNodes),\n    right: buildTree(preRightSubtreeNodes, inRightSubtreeNodes),\n  };\n};\n\n\n# 通过后序序列+中序序列构建二叉树\n\n算法实现如下：\n\n/**\n * 通过后序序列+中序序列构建二叉树\n * @param {number[]} inorder\n * @param {number[]} postorder\n * @return {TreeNode}\n */\nvar buildTree = function (inorder, postorder) {\n  if (\n    !Array.isArray(inorder) ||\n    inorder.length === 0 ||\n    !Array.isArray(postorder) ||\n    postorder.length === 0 ||\n    inorder.length != postorder.length\n  ) {\n    return null;\n  }\n  let len = postorder.length;\n  let rootVal = postorder[len - 1];\n  // 在中序遍历的结果中找到根节点所在的位置，则【0，idx】的是左子树，【idx+1，length】的是右子树\n  let rootNodeIdx = inorder.findIndex((x) => x === rootVal);\n  let inLeftSubtreeNodes = inorder.slice(0, rootNodeIdx);\n  let inRightSubtreeNodes = inorder.slice(rootNodeIdx + 1);\n  // 在后序遍历的结果中提取对应长度的的子集 可以得到对应的左子树结果集合\n  let posLeftSubtreeNodes = postorder.slice(0, inLeftSubtreeNodes.length);\n  // 继续在后序遍历的结果中提取对应长度的子集，可以得到对应右子树结果集合\n  let postRightSubtreeNodes = postorder.slice(\n    posLeftSubtreeNodes.length,\n    postorder.length - 1\n  );\n  return {\n    val: rootVal,\n    left: buildTree(inLeftSubtreeNodes, posLeftSubtreeNodes),\n    right: buildTree(inRightSubtreeNodes, postRightSubtreeNodes),\n  };\n};\n\n\n为什么同一颗二叉树的先序序列+后序序列不能唯一确定一颗二叉树呢，我们通过举反例来证明这个结论。\n\n假设我们有一个二叉树的先序序列 ABC，一个后序序列 CBA\n\n那么，能够得到 ABC 先序序列的可能的二叉树如下：\n\n\n\n那么，能够得到 CBA 后续序列可能的二叉树如下：\n\n\n\n可以看到，同一颗二叉树的先序和后序序列，但是可以构造出不同的二叉树。",normalizedContent:"# 树的构建\n\n\n# 1. 把后端返回的数据构建成树\n\n这是一个很常见的操作，有些时候，是因为后端直接返回树结构的话，序列化时i/o开销比较大，在高并发场景下，会使得服务器的效率降低，因此不得不让前端自行构建树型结构的数据。\n\n还有一种情况就比较搞笑了，这种情况一般出现在小公司，你的后端因为某些不可告人的秘密，告诉你只能给你返回数组。但是我们前端又必须需要一个树状结构。此时为了避免尴尬，前端可能会要求后端怎么样操作简单就怎么样约定数据格式了，然后前端按照相应的规格自己将其构建成树。\n\n一般，后端给到前端的数据是这样的，我就以文件列表的例子来举例。\n\n/**\n * 文件信息\n */\ninterface file {\n  /**\n   * 文件的id，需要使用string类型，若使用number类型，当id特别大的时候，前端解析的结果将不正确\n   */\n  id: string;\n\n  /**\n   * 文件的父级id, 可能不存在\n   */\n  pid: string | null;\n\n  /**\n   * 文件名\n   */\n  filename: string;\n\n  /**\n   * 文件类型，比如是文件还是文件夹\n   */\n  type: number;\n\n  /**\n   * 子文件列表\n   */\n  children?: file[];\n}\n\n\n# 方案 1 使用递归\n\n/**\n * 构建文件树\n * @param file 文件信息\n * @param file 文件列表信息\n */\nfunction buildtree(file: file, files: file[]) {\n  // 找到当前文件的子文件列表\n  let children = files.filter((fileele: file) => {\n    return fileele.pid === file.id;\n  });\n  // 递归的处理当前文件子文件列表的子文件\n  file.children =\n    children.length === 0\n      ? undefined\n      : children.map((subfile: file) => buildtree(subfile, files));\n  return file;\n}\n\n/**\n * 将文件列表转为文件树，并且返回根节点\n * @param files 文件列表\n */\nfunction build(files: file[]) {\n  // 构建结果\n  const roots = files\n    .filter((file) => {\n      // 这一步操作是为了找到所有的根节点\n      return file.pid === null;\n    })\n    .map((file) => {\n      // 对根节点的数据进行构建\n      return buildtree(file, files);\n    });\n  return roots;\n}\n\n\n# 方案 2 使用哈希表\n\n这个方案是有点儿取巧的一种做法了，因为其完美的利用了引用类型数据的特征，因为引用数据类型，大家都同时持有一块相同的内存区域，不同的人对它进行修改，都会在它的身上得到体现。\n\n/**\n * 将文件列表转换成为哈希表\n * @param {file[]} files\n */\nfunction makehashmap(files) {\n  const map = new map();\n  files.foreach((file) => {\n    // 以id为主键建立哈希映射\n    map.set(file.id, file);\n  });\n  return map;\n}\n\nfunction buildtree(files) {\n  // 将文件构建成哈希表，主要是为了后续的查找方便\n  const filemap = makehashmap(files);\n  const roots = [];\n  // 逐个的对每个文件增加子元素\n  files.foreach((file) => {\n    // 找父级文件，如果找不到的话，说明是根节点\n    const parentfile = filemap.get(file.pid);\n    if (parentfile) {\n      if (!array.isarray(parentfile.children)) {\n        parentfile.children = [file];\n      } else {\n        parentfile.children.push(file);\n      }\n    } else {\n      roots.push(file);\n    }\n  });\n  // 最后只需要找出根节点的文件列表即可完成构建\n  return roots;\n}\n\n\n\n# 2. 从二叉树的两个遍历序列构建二叉树\n\n通过无重复值的二叉树遍历中序序列+先序（或后序）序列能唯一确定一颗二叉树。\n\n注意事项\n\n仅凭先序和后序序列无法唯一确定一颗二叉树。\n\n先序序列的第一个节点一定是根节点，然后我们就可以通过这个根节点，在中序序列中确定其根节点的位置。一旦确定了中序序列的根节点位置，那就可以得到左子树序列和右子树序列。而同一颗二叉树的左右子树序列长度是相同的，因此，我们可以根据从中序序列获取到的左右子树片段，找出先序序列的左右子树片段。重复这个过程，直到构建完成。\n\n后序序列+中序序列构建思路还先序序列+中序序列构建思路类似。\n\n# 通过先序序列+中序序列构建二叉树\n\n二叉树结构定义如下：\n\ninterface treenode<t> {\n  left: treenode<t> | null;\n  right: treenode<t> | null;\n  val: t;\n}\n\n\n算法实现如下：\n\n/**\n * 从二叉树的先序序列+中序序列构建二叉树\n * @param {number[]} preorder 先序序列\n * @param {number[]} inorder 中序序列\n * @return {treenode}\n */\nvar buildtree = function (preorder, inorder) {\n  if (\n    !array.isarray(preorder) ||\n    preorder.length === 0 ||\n    !array.isarray(inorder) ||\n    inorder.length === 0 ||\n    preorder.length != inorder.length\n  ) {\n    return null;\n  }\n  let rootval = preorder[0];\n  // 在中序遍历的结果中找到根节点所在的位置，则【0，idx】的是左子树，【idx+1，length】的是右子树\n  let rootnodeidx = inorder.findindex((x) => x === rootval);\n  let inleftsubtreenodes = inorder.slice(0, rootnodeidx);\n  let inrightsubtreenodes = inorder.slice(rootnodeidx + 1);\n  // 在先序遍历的结果中提取对应长度的的子集 可以得到对应的左子树结果集合\n  let preleftsubtreenodes = preorder.slice(1, inleftsubtreenodes.length + 1);\n  // 继续在先序遍历的结果中提取对应长度的子集，可以得到对应右子树结果集合\n  let prerightsubtreenodes = preorder.slice(1 + inleftsubtreenodes.length);\n  return {\n    val: rootval,\n    left: buildtree(preleftsubtreenodes, inleftsubtreenodes),\n    right: buildtree(prerightsubtreenodes, inrightsubtreenodes),\n  };\n};\n\n\n# 通过后序序列+中序序列构建二叉树\n\n算法实现如下：\n\n/**\n * 通过后序序列+中序序列构建二叉树\n * @param {number[]} inorder\n * @param {number[]} postorder\n * @return {treenode}\n */\nvar buildtree = function (inorder, postorder) {\n  if (\n    !array.isarray(inorder) ||\n    inorder.length === 0 ||\n    !array.isarray(postorder) ||\n    postorder.length === 0 ||\n    inorder.length != postorder.length\n  ) {\n    return null;\n  }\n  let len = postorder.length;\n  let rootval = postorder[len - 1];\n  // 在中序遍历的结果中找到根节点所在的位置，则【0，idx】的是左子树，【idx+1，length】的是右子树\n  let rootnodeidx = inorder.findindex((x) => x === rootval);\n  let inleftsubtreenodes = inorder.slice(0, rootnodeidx);\n  let inrightsubtreenodes = inorder.slice(rootnodeidx + 1);\n  // 在后序遍历的结果中提取对应长度的的子集 可以得到对应的左子树结果集合\n  let posleftsubtreenodes = postorder.slice(0, inleftsubtreenodes.length);\n  // 继续在后序遍历的结果中提取对应长度的子集，可以得到对应右子树结果集合\n  let postrightsubtreenodes = postorder.slice(\n    posleftsubtreenodes.length,\n    postorder.length - 1\n  );\n  return {\n    val: rootval,\n    left: buildtree(inleftsubtreenodes, posleftsubtreenodes),\n    right: buildtree(inrightsubtreenodes, postrightsubtreenodes),\n  };\n};\n\n\n为什么同一颗二叉树的先序序列+后序序列不能唯一确定一颗二叉树呢，我们通过举反例来证明这个结论。\n\n假设我们有一个二叉树的先序序列 abc，一个后序序列 cba\n\n那么，能够得到 abc 先序序列的可能的二叉树如下：\n\n\n\n那么，能够得到 cba 后续序列可能的二叉树如下：\n\n\n\n可以看到，同一颗二叉树的先序和后序序列，但是可以构造出不同的二叉树。",charsets:{cjk:!0}},{title:"二叉搜索树",frontmatter:{},regularPath:"/data-structure/tree/binarySearchTree/desc.html",relativePath:"data-structure/tree/binarySearchTree/desc.md",key:"v-f3313c56",path:"/data-structure/tree/binarySearchTree/desc.html",headers:[{level:2,title:"二叉搜索树",slug:"二叉搜索树",normalizedTitle:"二叉搜索树",charIndex:2},{level:2,title:"二叉搜索树的实现",slug:"二叉搜索树的实现",normalizedTitle:"二叉搜索树的实现",charIndex:133},{level:3,title:"递归实现",slug:"递归实现",normalizedTitle:"递归实现",charIndex:513},{level:3,title:"非递归实现",slug:"非递归实现",normalizedTitle:"非递归实现",charIndex:3479},{level:2,title:"复杂度分析",slug:"复杂度分析",normalizedTitle:"复杂度分析",charIndex:9101}],headersStr:"二叉搜索树 二叉搜索树的实现 递归实现 非递归实现 复杂度分析",content:'# 二叉搜索树\n\n二叉搜索树（或者叫二叉排序树），是一种特殊的二叉树，其中一个重要的性质是它的左子树的节点值均比根节点小，右子树的节点值均比根节点值大，并且其左右子树也是一颗二叉搜索树。\n\n正是因为这个性质，通常会采用二叉搜索树进行高效率的检索和删除操作。\n\n\n# 二叉搜索树的实现\n\n首先定义树节点的结构定义如下：\n\ninterface TreeNode<T> {\n  // 树节点的值域\n  val: T;\n  // 树节点的左子节点\n  left: TreeNode<T> | null;\n  // 树节点的右子节点\n  right: TreeNode<T> | null;\n}\n\n\n根据二叉搜索性质，我们可以得出一个结论:\n\n最大节点一定是在右子树上，并且一定没有右子节点。\n\n最小节点一定是在左子树上，并且这个节点一定没有左右儿子节点，即叶节点。\n\n二叉树的中序遍历序列一定是一个非降序的序列\n\n编程技巧\n\n二叉树的中序遍历序列一定是一个非降序的序列，因此可以用一颗树的中序序列来判断一颗树是否是二叉搜索树。\n\n二叉搜索树的主要操作有 find,findMin,findMax,insert,delete。\n\n\n# 递归实现\n\n# 查找\n\n根据二叉搜索树的定义，左儿子一定会比右儿子小。因此，如果我们当前起始节点不存在的话，说明对应的值在二叉树中不存在，如果当前节点存在，并且恰好和我们要找的节点值相等的话，那么就说明找到了，因此我们可以直接返回当前节点，如果待查找值比当前节点的值小，那么它只有可能在左子树上找的到，因次，我们沿着左子树递归，反之，我们则沿着右子树递归。\n\n# 插入\n\n对于插入，如果树是空，直接插入返回新树即可，如果树不为空，若待插入的值比根节点的值小，则沿着左子树进行插入，否则沿着右子树进行插入，重复这个过程直到找到合适的位置，完成插入。\n\n# 删除\n\n二叉搜索树的删除相比插入要复杂的多，我们需要考虑的情况比较多： 首先，递归的思路此处不再赘述了，如果传入的节点就不存在，说明要删除的值肯定在搜索树中根本不存在。\n\n我们主要考虑能找到待删除节点的情况，如下：\n\n * 1、没有左右儿子节点。\n * 2、仅有左儿子节点。\n * 3、仅有右儿子节点。\n * 4、同时具有左右儿子节点。\n\n对于 case1,因为不需要进行任何操作。 传入的是有值的节点，返回空，我们给上层节点的左（或者 右）儿子接上这个空，则完成了删除。\n\n对于 case2,也不难，不就是要删除当前节点嘛，好呀，我直接把当前节点变成当前节点的左儿子给你返回，你上层递归调用的函数不就老老实实的给我接上了吗，嘿嘿（或者，把当前节点的左儿子的值拷贝给自己，然后把当前节点的左儿子指针置为空，然后返回这个节点，不过好像没有必要这样做呢）。\n\n对于 case3,同 case2，只不过我们操作的是右儿子。\n\n对于 case4,也就是最关键的，这个问题需要利用转化的思想。首先，因为总是有右子树的任何节点比当前待删除节点大，左子树的任何节点比当前待删除节点的值小的性质。我们可以换个角度想，我从右子树里面先找一个最小值节点替换到当前的这个待删除节点上，如果不考虑之前找到的最小值节点，是否仍然满足二叉搜索树的性质呀，nice，那我再从这个位置开始把之前找到的最小值节点删了不就行了吗，哈哈哈。有的朋友会说了，待删除右子树的最小值节点可能同时有左右儿子节点嘛，不就又绕回来了吗。根据二叉搜索树的性质，当前子树的最小值肯定是不会再有左子节点的了。所以，我们再从待删除节点出发，递归的删除当前节点右子树的最小值即可（上述操作找左子树的最大值也可以）。\n\n/**\n * 二叉搜索树类\n */\nclass BST {\n  /**\n   * @type {TreeNode}\n   */\n  #tree = null;\n\n  /**\n   * 创建一个树节点\n   * @param {number} val\n   * @returns {TreeNode}\n   */\n  #createTreeNode(val) {\n    return {\n      val,\n      left: null,\n      right: null,\n    };\n  }\n\n  /**\n   * 查找指定值是否在二叉搜索树中存在\n   * @param {number} val\n   * @returns {TreeNode}\n   */\n  find(val) {\n    return this.#find(val, this.#tree);\n  }\n\n  #find(val, node) {\n    if (!node) {\n      return null;\n    }\n    if (node.val === val) {\n      return node;\n    } else if (node.val > val) {\n      return this.#find(val, node.left);\n    } else if (node.val < val) {\n      return this.#find(val, node.right);\n    }\n  }\n\n  insert(val) {\n    this.tree = this.#insert(val, this.tree);\n  }\n\n  /**\n   * 使用递归的方式向搜索树中插入一个节点\n   * @param {number} val\n   * @param {Node} node\n   * @returns\n   */\n  #insert(val, node) {\n    if (!node) {\n      node = this.#createTreeNode(val);\n    } else {\n      if (val < node.val) {\n        node.left = this.#insert(val, node.left);\n      } else if (val > node.val) {\n        node.right = this.#insert(val, node.right);\n      }\n    }\n    return node;\n  }\n\n  delete(val) {\n    this.tree = this.#delete(val, this.tree);\n  }\n\n  /**\n   * 使用递归的方式删除一个节点\n   * @param {number} val 待删除的值\n   * @param {TreeNode} node 从指定的节点开始删除\n   * @returns\n   */\n  #delete(val, node) {\n    if (!node) {\n      console.warn("无法找到需要删除的值");\n      return null;\n    } else if (val > node.val) {\n      node.right = this.#delete(val, node.right);\n    } else if (val < node.val) {\n      node.left = this.#delete(val, node.left);\n    } else {\n      if (node.left && node.right) {\n        let rightMin = this.#findMinPosition(node.right);\n        node.val = rightMin.val;\n        node.right = this.#delete(rightMin.val, node.right);\n      } else if (node.left) {\n        node = node.left;\n      } else if (node.right) {\n        node = node.right;\n      } else {\n        node = null;\n      }\n    }\n    return node;\n  }\n}\n\n\n\n# 非递归实现\n\n# 查找\n\n对于查找此处不再赘述，递归和非递归完全类似\n\n# 插入\n\n对于插入，如果当前树是空的话直接插入即可。\n\n如果有插入相同的值肯定不允许插入。\n\n如果当前的节点值比待插入值小的话，说明我们应该往当前节点的右子树找位置插入才对。如果当前节点的右子树不存在的话，OK，恭喜你，这个位置就是你要插入的位置啦。我们的循环就没有必要再继续做下去了。否则，我们就接着从右子树下面找插入位置往下找呗。\n\n如果当前的节点值比待插入值大的话，说明我们应该往当前节点的左子树找位置插入才对。如果当前节点的左子树不存在，OK，恭喜你，这个位置就是你要插入的位置啦，结束循环。否则，我们接着从左子树下面找合适的插入位置。\n\n# 删除\n\n使用非递归删除二叉搜素树的思路和递归一致，但是代码的实现复杂程度一下子提高了很多。\n\n在使用递归删除的过程中，因为我们借用了系统的调用栈，我们可以很好的处理删除之后的节点引用关系，而使用非递归操作，这个过程完全就交给我们自己了，正所谓划了多少水，迟早要还的。\n\n首先，我们需要定义一个 parent 指针，因为一会儿需要用这个指针来连接子树。迭代步骤跟插入查找一致，此处不再赘述。退出第一个循环有 2 种情况: 树为空 或者 找到了待删除的节点。 如果是第一种情况，那好说，直接就啥事儿不用干，多好啊，哈哈哈。\n\n主要就是看第二种情况,这种情况下仍然和之前递归删除的时候我们需要考虑的问题是一致的，仍然是 4 种 case。\n\n首先考虑最简单的 case，当前待删除节点无左右儿子，此时 parent 指针指向的是父节点，但是有个问题需要注意哦，当前这个待删除节点是左儿子还是右儿子得根据父节点的值来确定哦。\n\n接着考虑待删除节点仅有右子节点的 case，这个 case 和删除没有左右儿子节点的节点的 case 类似，只需要把当前待删除节点的右子树接上就可以了。同样，还是需要考虑是用父节点的左儿子指针接还是右儿子指针接。\n\n待删除节点仅有左子节点的 case 和待删除节点仅有右子节点的 case 类似，此处也不再赘述。\n\n最后考虑同时有左右儿子的 case，好想递归调用删除节点方法有没有？哈哈哈哈。既然我们使用非递归删除，那就完完全全的用非递归实现吧。我们先用一个变量先把当前这个节点的位置先记住，免得一会儿向下迭代的时候找不到了。还是和递归删除的思路一致，当前节点的左子树找一个最大值或者右子树里面找一个最小值。找到之后把这个值拷贝到之前我们事先记住的那个节点上去，然后删除这个节点，又变成了删除只有单子节点的 case 了。\n\n这儿有一个需要注意的店是假设我们删除的时候以当前节点的左子树最大值替换待删除节点的值。\n\nDANGER\n\n一定不要忘了，左子树的最大值是有可能有左子树的，一定不要忘了把这个子树给拼接上，否则就会丢失这一大块存储区域。\n\nleftMaxParentNode.right = leftMaxNode.left; // 拼接左子树，有可能没有左子树，但此步骤不能少。\n\n\n/**\n * 二叉搜索树的非递归实现\n */\nclass BST {\n  /**\n   * @type {TreeNode}\n   */\n  #tree = null;\n\n  /**\n   * 创建一个树节点\n   * @param {number} val\n   * @returns {TreeNode}\n   */\n  #createTreeNode(val) {\n    return {\n      val,\n      left: null,\n      right: null,\n    };\n  }\n\n  /**\n   * 查找二叉树中值为val的节点\n   * @param {number} val\n   * @returns\n   */\n  #findPosition(val) {\n    let node = this.#tree;\n    let targetNode = null;\n    while (node) {\n      if (node.val === val) {\n        targetNode = node;\n        break;\n      } else if (val > node.val) {\n        node = node.right;\n      } else if (val < node.val) {\n        node = node.left;\n      }\n    }\n    return targetNode;\n  }\n\n  /**\n   * 从二叉搜素树中删除一个值\n   * @param {number} val\n   */\n  delete(val) {\n    let node = this.#tree;\n    let parent = null;\n    while (node) {\n      // 如果找到了当前节点 则中断循环\n      if (node.val === val) {\n        break;\n      }\n      parent = node;\n      // 如果当前节点的值比val小，说明待删除的节点在右子树上\n      if (node.val < val) {\n        node = node.right;\n        // 如果当前节点的值比val大，说明待删除的节点在左子树上\n      } else if (node.val > val) {\n        node = node.left;\n      }\n    }\n    if (!node) {\n      console.warn("要删除的节点不存在");\n    } else if (node.left && node.right) {\n      let leftMaxParentNode = node;\n      let leftMaxNode = node.left;\n      // 退出循环的时候，leftMaxNode是肯定没有右子树节点的了\n      while (leftMaxNode.right) {\n        leftMaxParentNode = leftMaxNode;\n        leftMaxNode = leftMaxNode.right;\n      }\n      // 先把左子树的最大值拷贝到当前要删除的节点上去，然后从左子树删除左子树的最大值节点\n      node.val = leftMaxNode.val;\n      // 前驱节点的右指针指向当前节点的左指针 虽然leftMaxNode.left可能不存在，但是还是要将其链接在前驱节点的右子节点上\n      leftMaxParentNode.right = leftMaxNode.left;\n    } else if (node.left) {\n      if (parent === null) {\n        this.#tree = node.left;\n      } else {\n        // 判断当前节点是来源于左子节点还是右子节点\n        if (parent.val > node.val) {\n          parent.left = node.left;\n        } else {\n          parent.right = node.left;\n        }\n      }\n    } else if (node.right) {\n      if (parent === null) {\n        this.#tree = node.right;\n      } else {\n        // 判断当前节点是来源于左子节点还是右子节点\n        if (parent.val > node.val) {\n          parent.left = node.right;\n        } else {\n          parent.right = node.right;\n        }\n        node = null;\n      }\n    } else {\n      if (parent === null) {\n        this.#tree = null;\n      } else {\n        // 判断当前节点是来源于左子节点还是右子节点\n        if (parent.val > node.val) {\n          parent.left = null;\n        } else {\n          parent.right = null;\n        }\n      }\n      node = null;\n    }\n  }\n\n  /**\n   * 向二叉搜索树中插入一个值\n   * @param {number} val\n   */\n  insert(val) {\n    // 创建一个新的节点\n    let newNode = this.#createTreeNode(val);\n    // 如果当前树为空, 直接将节点插入根节点\n    if (!this.#tree) {\n      this.#tree = newNode;\n      return;\n    }\n    let node = this.#tree;\n    while (true) {\n      // 如果插入相同值，直接报错\n      if (val === node.val) {\n        console.warn("不允许插入相同值的节点");\n        break;\n      }\n      // 如果当前值比节点值大，node向右子树下滤\n      else if (val > node.val) {\n        // 如果当前节点的右儿子没了，说明这个就是一个合适的插入位置\n        if (!node.right) {\n          node.right = newNode;\n          break;\n        }\n        // 沿着右子树下滤\n        node = node.right;\n        // 如果当前值比节点值小，node向左子树下滤\n      } else if (val < node.val) {\n        // 如果当前节点的左儿子没了，说明这个就是一个合适的插入位置\n        if (!node.left) {\n          node.left = newNode;\n          break;\n        }\n        // 沿着左子树下滤\n        node = node.left;\n      }\n    }\n  }\n\n  /**\n   * 查找树中最大值\n   */\n  findMax() {\n    let node = this.#findMaxPosition();\n    return node ? node.val : null;\n  }\n\n  /**\n   * 查找树中最大值的位置\n   * @param {TreeNode} startNode 从指定节点开始查询\n   * @returns {TreeNode}\n   */\n  #findMaxPosition(startNode) {\n    startNode = startNode || this.#tree;\n    if (!startNode) {\n      console.warn("empty tree");\n      return null;\n    }\n    let node = startNode;\n    while (node.right) {\n      node = node.right;\n    }\n    return node;\n  }\n\n  /**\n   * 查找树中最小值\n   * @returns {number}\n   */\n  findMin() {\n    let node = this.#findMinPosition();\n    return node ? node.val : null;\n  }\n\n  /**\n   * 查找树中最小值的节点\n   * @param {TreeNode} startNode 从指定节点开始查询\n   * @returns {TreeNode}\n   */\n  #findMinPosition(startNode) {\n    startNode = startNode || this.#tree;\n    if (startNode) {\n      console.warn("empty tree");\n      return;\n    }\n    let node = startNode;\n    while (node.left) {\n      node = node.left;\n    }\n    return node;\n  }\n}\n\n\n\n# 复杂度分析\n\n二叉搜索树理想情况插入、查找、删除的效率是非常高的，是典型的二分查找思想，能达到 O(logN)，但是理想很丰满，现实很骨感。假设我们插入有序序列或者总是删除二叉搜索树的最大值或者最小值，最终我们的二叉搜索树竟然会成为一个链表，效率直接降到 O(N)，所以如何在插入或删除的时候总是使得我们的树左半部分和右半部分节点数差异不大，那么我们查找和删除的效率总能达到 O(logN)，这便是 AVL树或红黑树。AVL 树或红黑树在后面我们会详细讨论。',normalizedContent:'# 二叉搜索树\n\n二叉搜索树（或者叫二叉排序树），是一种特殊的二叉树，其中一个重要的性质是它的左子树的节点值均比根节点小，右子树的节点值均比根节点值大，并且其左右子树也是一颗二叉搜索树。\n\n正是因为这个性质，通常会采用二叉搜索树进行高效率的检索和删除操作。\n\n\n# 二叉搜索树的实现\n\n首先定义树节点的结构定义如下：\n\ninterface treenode<t> {\n  // 树节点的值域\n  val: t;\n  // 树节点的左子节点\n  left: treenode<t> | null;\n  // 树节点的右子节点\n  right: treenode<t> | null;\n}\n\n\n根据二叉搜索性质，我们可以得出一个结论:\n\n最大节点一定是在右子树上，并且一定没有右子节点。\n\n最小节点一定是在左子树上，并且这个节点一定没有左右儿子节点，即叶节点。\n\n二叉树的中序遍历序列一定是一个非降序的序列\n\n编程技巧\n\n二叉树的中序遍历序列一定是一个非降序的序列，因此可以用一颗树的中序序列来判断一颗树是否是二叉搜索树。\n\n二叉搜索树的主要操作有 find,findmin,findmax,insert,delete。\n\n\n# 递归实现\n\n# 查找\n\n根据二叉搜索树的定义，左儿子一定会比右儿子小。因此，如果我们当前起始节点不存在的话，说明对应的值在二叉树中不存在，如果当前节点存在，并且恰好和我们要找的节点值相等的话，那么就说明找到了，因此我们可以直接返回当前节点，如果待查找值比当前节点的值小，那么它只有可能在左子树上找的到，因次，我们沿着左子树递归，反之，我们则沿着右子树递归。\n\n# 插入\n\n对于插入，如果树是空，直接插入返回新树即可，如果树不为空，若待插入的值比根节点的值小，则沿着左子树进行插入，否则沿着右子树进行插入，重复这个过程直到找到合适的位置，完成插入。\n\n# 删除\n\n二叉搜索树的删除相比插入要复杂的多，我们需要考虑的情况比较多： 首先，递归的思路此处不再赘述了，如果传入的节点就不存在，说明要删除的值肯定在搜索树中根本不存在。\n\n我们主要考虑能找到待删除节点的情况，如下：\n\n * 1、没有左右儿子节点。\n * 2、仅有左儿子节点。\n * 3、仅有右儿子节点。\n * 4、同时具有左右儿子节点。\n\n对于 case1,因为不需要进行任何操作。 传入的是有值的节点，返回空，我们给上层节点的左（或者 右）儿子接上这个空，则完成了删除。\n\n对于 case2,也不难，不就是要删除当前节点嘛，好呀，我直接把当前节点变成当前节点的左儿子给你返回，你上层递归调用的函数不就老老实实的给我接上了吗，嘿嘿（或者，把当前节点的左儿子的值拷贝给自己，然后把当前节点的左儿子指针置为空，然后返回这个节点，不过好像没有必要这样做呢）。\n\n对于 case3,同 case2，只不过我们操作的是右儿子。\n\n对于 case4,也就是最关键的，这个问题需要利用转化的思想。首先，因为总是有右子树的任何节点比当前待删除节点大，左子树的任何节点比当前待删除节点的值小的性质。我们可以换个角度想，我从右子树里面先找一个最小值节点替换到当前的这个待删除节点上，如果不考虑之前找到的最小值节点，是否仍然满足二叉搜索树的性质呀，nice，那我再从这个位置开始把之前找到的最小值节点删了不就行了吗，哈哈哈。有的朋友会说了，待删除右子树的最小值节点可能同时有左右儿子节点嘛，不就又绕回来了吗。根据二叉搜索树的性质，当前子树的最小值肯定是不会再有左子节点的了。所以，我们再从待删除节点出发，递归的删除当前节点右子树的最小值即可（上述操作找左子树的最大值也可以）。\n\n/**\n * 二叉搜索树类\n */\nclass bst {\n  /**\n   * @type {treenode}\n   */\n  #tree = null;\n\n  /**\n   * 创建一个树节点\n   * @param {number} val\n   * @returns {treenode}\n   */\n  #createtreenode(val) {\n    return {\n      val,\n      left: null,\n      right: null,\n    };\n  }\n\n  /**\n   * 查找指定值是否在二叉搜索树中存在\n   * @param {number} val\n   * @returns {treenode}\n   */\n  find(val) {\n    return this.#find(val, this.#tree);\n  }\n\n  #find(val, node) {\n    if (!node) {\n      return null;\n    }\n    if (node.val === val) {\n      return node;\n    } else if (node.val > val) {\n      return this.#find(val, node.left);\n    } else if (node.val < val) {\n      return this.#find(val, node.right);\n    }\n  }\n\n  insert(val) {\n    this.tree = this.#insert(val, this.tree);\n  }\n\n  /**\n   * 使用递归的方式向搜索树中插入一个节点\n   * @param {number} val\n   * @param {node} node\n   * @returns\n   */\n  #insert(val, node) {\n    if (!node) {\n      node = this.#createtreenode(val);\n    } else {\n      if (val < node.val) {\n        node.left = this.#insert(val, node.left);\n      } else if (val > node.val) {\n        node.right = this.#insert(val, node.right);\n      }\n    }\n    return node;\n  }\n\n  delete(val) {\n    this.tree = this.#delete(val, this.tree);\n  }\n\n  /**\n   * 使用递归的方式删除一个节点\n   * @param {number} val 待删除的值\n   * @param {treenode} node 从指定的节点开始删除\n   * @returns\n   */\n  #delete(val, node) {\n    if (!node) {\n      console.warn("无法找到需要删除的值");\n      return null;\n    } else if (val > node.val) {\n      node.right = this.#delete(val, node.right);\n    } else if (val < node.val) {\n      node.left = this.#delete(val, node.left);\n    } else {\n      if (node.left && node.right) {\n        let rightmin = this.#findminposition(node.right);\n        node.val = rightmin.val;\n        node.right = this.#delete(rightmin.val, node.right);\n      } else if (node.left) {\n        node = node.left;\n      } else if (node.right) {\n        node = node.right;\n      } else {\n        node = null;\n      }\n    }\n    return node;\n  }\n}\n\n\n\n# 非递归实现\n\n# 查找\n\n对于查找此处不再赘述，递归和非递归完全类似\n\n# 插入\n\n对于插入，如果当前树是空的话直接插入即可。\n\n如果有插入相同的值肯定不允许插入。\n\n如果当前的节点值比待插入值小的话，说明我们应该往当前节点的右子树找位置插入才对。如果当前节点的右子树不存在的话，ok，恭喜你，这个位置就是你要插入的位置啦。我们的循环就没有必要再继续做下去了。否则，我们就接着从右子树下面找插入位置往下找呗。\n\n如果当前的节点值比待插入值大的话，说明我们应该往当前节点的左子树找位置插入才对。如果当前节点的左子树不存在，ok，恭喜你，这个位置就是你要插入的位置啦，结束循环。否则，我们接着从左子树下面找合适的插入位置。\n\n# 删除\n\n使用非递归删除二叉搜素树的思路和递归一致，但是代码的实现复杂程度一下子提高了很多。\n\n在使用递归删除的过程中，因为我们借用了系统的调用栈，我们可以很好的处理删除之后的节点引用关系，而使用非递归操作，这个过程完全就交给我们自己了，正所谓划了多少水，迟早要还的。\n\n首先，我们需要定义一个 parent 指针，因为一会儿需要用这个指针来连接子树。迭代步骤跟插入查找一致，此处不再赘述。退出第一个循环有 2 种情况: 树为空 或者 找到了待删除的节点。 如果是第一种情况，那好说，直接就啥事儿不用干，多好啊，哈哈哈。\n\n主要就是看第二种情况,这种情况下仍然和之前递归删除的时候我们需要考虑的问题是一致的，仍然是 4 种 case。\n\n首先考虑最简单的 case，当前待删除节点无左右儿子，此时 parent 指针指向的是父节点，但是有个问题需要注意哦，当前这个待删除节点是左儿子还是右儿子得根据父节点的值来确定哦。\n\n接着考虑待删除节点仅有右子节点的 case，这个 case 和删除没有左右儿子节点的节点的 case 类似，只需要把当前待删除节点的右子树接上就可以了。同样，还是需要考虑是用父节点的左儿子指针接还是右儿子指针接。\n\n待删除节点仅有左子节点的 case 和待删除节点仅有右子节点的 case 类似，此处也不再赘述。\n\n最后考虑同时有左右儿子的 case，好想递归调用删除节点方法有没有？哈哈哈哈。既然我们使用非递归删除，那就完完全全的用非递归实现吧。我们先用一个变量先把当前这个节点的位置先记住，免得一会儿向下迭代的时候找不到了。还是和递归删除的思路一致，当前节点的左子树找一个最大值或者右子树里面找一个最小值。找到之后把这个值拷贝到之前我们事先记住的那个节点上去，然后删除这个节点，又变成了删除只有单子节点的 case 了。\n\n这儿有一个需要注意的店是假设我们删除的时候以当前节点的左子树最大值替换待删除节点的值。\n\ndanger\n\n一定不要忘了，左子树的最大值是有可能有左子树的，一定不要忘了把这个子树给拼接上，否则就会丢失这一大块存储区域。\n\nleftmaxparentnode.right = leftmaxnode.left; // 拼接左子树，有可能没有左子树，但此步骤不能少。\n\n\n/**\n * 二叉搜索树的非递归实现\n */\nclass bst {\n  /**\n   * @type {treenode}\n   */\n  #tree = null;\n\n  /**\n   * 创建一个树节点\n   * @param {number} val\n   * @returns {treenode}\n   */\n  #createtreenode(val) {\n    return {\n      val,\n      left: null,\n      right: null,\n    };\n  }\n\n  /**\n   * 查找二叉树中值为val的节点\n   * @param {number} val\n   * @returns\n   */\n  #findposition(val) {\n    let node = this.#tree;\n    let targetnode = null;\n    while (node) {\n      if (node.val === val) {\n        targetnode = node;\n        break;\n      } else if (val > node.val) {\n        node = node.right;\n      } else if (val < node.val) {\n        node = node.left;\n      }\n    }\n    return targetnode;\n  }\n\n  /**\n   * 从二叉搜素树中删除一个值\n   * @param {number} val\n   */\n  delete(val) {\n    let node = this.#tree;\n    let parent = null;\n    while (node) {\n      // 如果找到了当前节点 则中断循环\n      if (node.val === val) {\n        break;\n      }\n      parent = node;\n      // 如果当前节点的值比val小，说明待删除的节点在右子树上\n      if (node.val < val) {\n        node = node.right;\n        // 如果当前节点的值比val大，说明待删除的节点在左子树上\n      } else if (node.val > val) {\n        node = node.left;\n      }\n    }\n    if (!node) {\n      console.warn("要删除的节点不存在");\n    } else if (node.left && node.right) {\n      let leftmaxparentnode = node;\n      let leftmaxnode = node.left;\n      // 退出循环的时候，leftmaxnode是肯定没有右子树节点的了\n      while (leftmaxnode.right) {\n        leftmaxparentnode = leftmaxnode;\n        leftmaxnode = leftmaxnode.right;\n      }\n      // 先把左子树的最大值拷贝到当前要删除的节点上去，然后从左子树删除左子树的最大值节点\n      node.val = leftmaxnode.val;\n      // 前驱节点的右指针指向当前节点的左指针 虽然leftmaxnode.left可能不存在，但是还是要将其链接在前驱节点的右子节点上\n      leftmaxparentnode.right = leftmaxnode.left;\n    } else if (node.left) {\n      if (parent === null) {\n        this.#tree = node.left;\n      } else {\n        // 判断当前节点是来源于左子节点还是右子节点\n        if (parent.val > node.val) {\n          parent.left = node.left;\n        } else {\n          parent.right = node.left;\n        }\n      }\n    } else if (node.right) {\n      if (parent === null) {\n        this.#tree = node.right;\n      } else {\n        // 判断当前节点是来源于左子节点还是右子节点\n        if (parent.val > node.val) {\n          parent.left = node.right;\n        } else {\n          parent.right = node.right;\n        }\n        node = null;\n      }\n    } else {\n      if (parent === null) {\n        this.#tree = null;\n      } else {\n        // 判断当前节点是来源于左子节点还是右子节点\n        if (parent.val > node.val) {\n          parent.left = null;\n        } else {\n          parent.right = null;\n        }\n      }\n      node = null;\n    }\n  }\n\n  /**\n   * 向二叉搜索树中插入一个值\n   * @param {number} val\n   */\n  insert(val) {\n    // 创建一个新的节点\n    let newnode = this.#createtreenode(val);\n    // 如果当前树为空, 直接将节点插入根节点\n    if (!this.#tree) {\n      this.#tree = newnode;\n      return;\n    }\n    let node = this.#tree;\n    while (true) {\n      // 如果插入相同值，直接报错\n      if (val === node.val) {\n        console.warn("不允许插入相同值的节点");\n        break;\n      }\n      // 如果当前值比节点值大，node向右子树下滤\n      else if (val > node.val) {\n        // 如果当前节点的右儿子没了，说明这个就是一个合适的插入位置\n        if (!node.right) {\n          node.right = newnode;\n          break;\n        }\n        // 沿着右子树下滤\n        node = node.right;\n        // 如果当前值比节点值小，node向左子树下滤\n      } else if (val < node.val) {\n        // 如果当前节点的左儿子没了，说明这个就是一个合适的插入位置\n        if (!node.left) {\n          node.left = newnode;\n          break;\n        }\n        // 沿着左子树下滤\n        node = node.left;\n      }\n    }\n  }\n\n  /**\n   * 查找树中最大值\n   */\n  findmax() {\n    let node = this.#findmaxposition();\n    return node ? node.val : null;\n  }\n\n  /**\n   * 查找树中最大值的位置\n   * @param {treenode} startnode 从指定节点开始查询\n   * @returns {treenode}\n   */\n  #findmaxposition(startnode) {\n    startnode = startnode || this.#tree;\n    if (!startnode) {\n      console.warn("empty tree");\n      return null;\n    }\n    let node = startnode;\n    while (node.right) {\n      node = node.right;\n    }\n    return node;\n  }\n\n  /**\n   * 查找树中最小值\n   * @returns {number}\n   */\n  findmin() {\n    let node = this.#findminposition();\n    return node ? node.val : null;\n  }\n\n  /**\n   * 查找树中最小值的节点\n   * @param {treenode} startnode 从指定节点开始查询\n   * @returns {treenode}\n   */\n  #findminposition(startnode) {\n    startnode = startnode || this.#tree;\n    if (startnode) {\n      console.warn("empty tree");\n      return;\n    }\n    let node = startnode;\n    while (node.left) {\n      node = node.left;\n    }\n    return node;\n  }\n}\n\n\n\n# 复杂度分析\n\n二叉搜索树理想情况插入、查找、删除的效率是非常高的，是典型的二分查找思想，能达到 o(logn)，但是理想很丰满，现实很骨感。假设我们插入有序序列或者总是删除二叉搜索树的最大值或者最小值，最终我们的二叉搜索树竟然会成为一个链表，效率直接降到 o(n)，所以如何在插入或删除的时候总是使得我们的树左半部分和右半部分节点数差异不大，那么我们查找和删除的效率总能达到 o(logn)，这便是 avl树或红黑树。avl 树或红黑树在后面我们会详细讨论。',charsets:{cjk:!0}},{title:"中序遍历",frontmatter:{},regularPath:"/data-structure/tree/binaryTree/inOrderVisit.html",relativePath:"data-structure/tree/binaryTree/inOrderVisit.md",key:"v-f5497496",path:"/data-structure/tree/binaryTree/inOrderVisit.html",headers:[{level:2,title:"中序遍历",slug:"中序遍历",normalizedTitle:"中序遍历",charIndex:2},{level:2,title:"递归遍历",slug:"递归遍历",normalizedTitle:"递归遍历",charIndex:146},{level:2,title:"非递归遍历",slug:"非递归遍历",normalizedTitle:"非递归遍历",charIndex:526},{level:2,title:"复杂度分析",slug:"复杂度分析",normalizedTitle:"复杂度分析",charIndex:1032}],headersStr:"中序遍历 递归遍历 非递归遍历 复杂度分析",content:'# 中序遍历\n\n假设我们的树节点的定义如下：\n\ninterface TreeNode<T> {\n  left: TreeNode | null;\n  right: TreeNode | null;\n  data: T;\n}\n\n\nTIP\n\n总是以左->根->右的顺序输出二叉树中的节点\n\n\n# 递归遍历\n\n/**\n * 中序递归遍历二叉树\n * @param {TreeNode<number>} tree 树的根节点\n */\nfunction treeInOrderTraverseRecursion(tree) {\n  if (!tree) {\n    console.log("empty tree");\n    return;\n  }\n  // 和先序递归遍历区别仅体现在输出的时机不同，因为代码的顺序会导致调用堆栈的循序的改变，因此可以完成中序遍历\n  tree.left && treeInOrderTraverseRecursion(tree.left);\n  console.log(tree.data);\n  tree.right && treeInOrderTraverseRecursion(tree.right);\n}\n\n\n\n# 非递归遍历\n\n/**\n * 二叉树非递归中序遍历\n * @param {TreeNode<number>} tree 树的根节点\n */\nfunction treeInOrderTraverse(tree) {\n  if (!tree) {\n    console.log("empty tree");\n    return;\n  }\n  let stack = [];\n  let node = tree;\n  while (stack.length > 0 || node) {\n    // 压栈的时候不能立即输出节点\n    while (node) {\n      stack.push(node);\n      node = node.left;\n    }\n    if (stack.length > 0) {\n      // 当从栈中取出节点时，方可以输出节点，接着再从当前节点的右子树进行遍历\n      node = stack.pop();\n      console.log(node.data);\n      node = node.right;\n    }\n  }\n}\n\n\n\n# 复杂度分析\n\n时间复杂度O(n)；空间复杂度O(h);',normalizedContent:'# 中序遍历\n\n假设我们的树节点的定义如下：\n\ninterface treenode<t> {\n  left: treenode | null;\n  right: treenode | null;\n  data: t;\n}\n\n\ntip\n\n总是以左->根->右的顺序输出二叉树中的节点\n\n\n# 递归遍历\n\n/**\n * 中序递归遍历二叉树\n * @param {treenode<number>} tree 树的根节点\n */\nfunction treeinordertraverserecursion(tree) {\n  if (!tree) {\n    console.log("empty tree");\n    return;\n  }\n  // 和先序递归遍历区别仅体现在输出的时机不同，因为代码的顺序会导致调用堆栈的循序的改变，因此可以完成中序遍历\n  tree.left && treeinordertraverserecursion(tree.left);\n  console.log(tree.data);\n  tree.right && treeinordertraverserecursion(tree.right);\n}\n\n\n\n# 非递归遍历\n\n/**\n * 二叉树非递归中序遍历\n * @param {treenode<number>} tree 树的根节点\n */\nfunction treeinordertraverse(tree) {\n  if (!tree) {\n    console.log("empty tree");\n    return;\n  }\n  let stack = [];\n  let node = tree;\n  while (stack.length > 0 || node) {\n    // 压栈的时候不能立即输出节点\n    while (node) {\n      stack.push(node);\n      node = node.left;\n    }\n    if (stack.length > 0) {\n      // 当从栈中取出节点时，方可以输出节点，接着再从当前节点的右子树进行遍历\n      node = stack.pop();\n      console.log(node.data);\n      node = node.right;\n    }\n  }\n}\n\n\n\n# 复杂度分析\n\n时间复杂度o(n)；空间复杂度o(h);',charsets:{cjk:!0}},{title:"二叉树的 Morris 遍历法",frontmatter:{},regularPath:"/data-structure/tree/binaryTree/morrisVisit%20copy.html",relativePath:"data-structure/tree/binaryTree/morrisVisit copy.md",key:"v-a66e355c",path:"/data-structure/tree/binaryTree/morrisVisit%20copy.html",headers:[{level:2,title:"二叉树的 Morris 遍历法",slug:"二叉树的-morris-遍历法",normalizedTitle:"二叉树的 morris 遍历法",charIndex:2},{level:2,title:"递归序",slug:"递归序",normalizedTitle:"递归序",charIndex:261},{level:2,title:"Morris 先序",slug:"morris-先序",normalizedTitle:"morris 先序",charIndex:401},{level:2,title:"Morris 中序",slug:"morris-中序",normalizedTitle:"morris 中序",charIndex:415},{level:2,title:"Morris 后序",slug:"morris-后序",normalizedTitle:"morris 后序",charIndex:429},{level:2,title:"复杂度分析",slug:"复杂度分析",normalizedTitle:"复杂度分析",charIndex:443}],headersStr:"二叉树的 Morris 遍历法 递归序 Morris 先序 Morris 中序 Morris 后序 复杂度分析",content:"# 二叉树的 Morris 遍历法\n\n二叉树的 Morris遍历法是在传统二叉树遍历法的又一次改进。\n\n正常我们遍历二叉树时，都会有一定的空间复杂度，不管是利用递归还是非递归遍历，栈里面都要把树节点存起来，因为在遍历完成底部的也节点之后，我们需要顺着栈里面记录线索去找上层后面的节点。对于层序遍历来说，仍然需要把当前处理的儿子节点（若有）加入到队列中，也需要占用额外的内存。而Morris遍历法利用了二叉树的空闲指针，巧妙的用它记录后续的需要处理的节点，在完成底部的叶节点之后清楚的知道后面需要处理的节点在哪儿。\n\n\n# 递归序\n\n首先，我们得明白什么是递归序。\n\n对于这颗二叉树：\n\n\n\n不管怎么样，3 节点永远会比 2 节点和 4 节点先访问到，只不过，我们在某些场合，不是遇到 3 节点就立刻将其输出。因为有栈的关系，当我们处理到最叶节点的时候，能够根据栈内容清楚的知道回溯的准确位置。\n\n\n# Morris 先序\n\n\n# Morris 中序\n\n\n# Morris 后序\n\n\n# 复杂度分析",normalizedContent:"# 二叉树的 morris 遍历法\n\n二叉树的 morris遍历法是在传统二叉树遍历法的又一次改进。\n\n正常我们遍历二叉树时，都会有一定的空间复杂度，不管是利用递归还是非递归遍历，栈里面都要把树节点存起来，因为在遍历完成底部的也节点之后，我们需要顺着栈里面记录线索去找上层后面的节点。对于层序遍历来说，仍然需要把当前处理的儿子节点（若有）加入到队列中，也需要占用额外的内存。而morris遍历法利用了二叉树的空闲指针，巧妙的用它记录后续的需要处理的节点，在完成底部的叶节点之后清楚的知道后面需要处理的节点在哪儿。\n\n\n# 递归序\n\n首先，我们得明白什么是递归序。\n\n对于这颗二叉树：\n\n\n\n不管怎么样，3 节点永远会比 2 节点和 4 节点先访问到，只不过，我们在某些场合，不是遇到 3 节点就立刻将其输出。因为有栈的关系，当我们处理到最叶节点的时候，能够根据栈内容清楚的知道回溯的准确位置。\n\n\n# morris 先序\n\n\n# morris 中序\n\n\n# morris 后序\n\n\n# 复杂度分析",charsets:{cjk:!0}},{title:"二叉树的 Morris 遍历法",frontmatter:{},regularPath:"/data-structure/tree/binaryTree/morrisVisit.html",relativePath:"data-structure/tree/binaryTree/morrisVisit.md",key:"v-aaa51dc2",path:"/data-structure/tree/binaryTree/morrisVisit.html",headers:[{level:2,title:"二叉树的 Morris 遍历法",slug:"二叉树的-morris-遍历法",normalizedTitle:"二叉树的 morris 遍历法",charIndex:2}],headersStr:"二叉树的 Morris 遍历法",content:"# 二叉树的 Morris 遍历法\n\n建设中，敬请期待...",normalizedContent:"# 二叉树的 morris 遍历法\n\n建设中，敬请期待...",charsets:{cjk:!0}},{title:"适配器模式",frontmatter:{},regularPath:"/design-pattern/adaptor.html",relativePath:"design-pattern/adaptor.md",key:"v-d039a31a",path:"/design-pattern/adaptor.html",headersStr:null,content:"",normalizedContent:"",charsets:{}},{title:"命令模式",frontmatter:{},regularPath:"/design-pattern/command.html",relativePath:"design-pattern/command.md",key:"v-20aeabe7",path:"/design-pattern/command.html",headersStr:null,content:"",normalizedContent:"",charsets:{}},{title:"后序遍历",frontmatter:{},regularPath:"/data-structure/tree/binaryTree/postOrderVisit.html",relativePath:"data-structure/tree/binaryTree/postOrderVisit.md",key:"v-785b8656",path:"/data-structure/tree/binaryTree/postOrderVisit.html",headers:[{level:2,title:"后序遍历",slug:"后序遍历",normalizedTitle:"后序遍历",charIndex:2},{level:2,title:"递归遍历",slug:"递归遍历",normalizedTitle:"递归遍历",charIndex:146},{level:2,title:"非递归遍历",slug:"非递归遍历",normalizedTitle:"非递归遍历",charIndex:509},{level:2,title:"复杂度分析",slug:"复杂度分析",normalizedTitle:"复杂度分析",charIndex:1245}],headersStr:"后序遍历 递归遍历 非递归遍历 复杂度分析",content:'# 后序遍历\n\n假设我们的树节点的定义如下：\n\ninterface TreeNode<T> {\n  left: TreeNode | null;\n  right: TreeNode | null;\n  data: T;\n}\n\n\nTIP\n\n总是以左->右->根的顺序输出二叉树中的节点\n\n\n# 递归遍历\n\n/**\n * 后序递归遍历二叉树\n * @param {TreeNode} tree 树的根节点\n */\nfunction treePostTraverseRecursion(tree) {\n  if (!tree) {\n    console.log("empty tree");\n    return;\n  }\n  // 和先序递归遍历区别仅体现在输出的时机不同，因为代码的顺序会导致调用堆栈的循序的改变，因此可以完成后序遍历\n  tree.left && treePostTraverseRecursion(tree.left);\n  tree.right && treePostTraverseRecursion(tree.right);\n  console.log(tree.data);\n}\n\n\n\n# 非递归遍历\n\n/**\n * 二叉树非递归后序遍历\n * @param {TreeNode} tree 树的根节点\n */\nfunction treePostTraverse(tree) {\n  if (!tree) {\n    console.log("empty tree");\n    return;\n  }\n  // 栈1用于遍历\n  let stack1 = [];\n  // 栈2用于保持输出顺序\n  let stack2 = [];\n  let node = tree;\n  stack1.push(node);\n  while (stack1.length > 0) {\n    node = stack1.pop();\n    // 将根节点加入栈2，先加入的后输出\n    stack2.push(node);\n    // 如果左子树存在，将左子树节点加入到栈1中\n    if (node.left != null) {\n      stack1.push(node.left);\n    }\n    // 如果右子树存在，将右子树节点加入到栈1中\n    if (node.right != null) {\n      stack1.push(node.right);\n    }\n    /**\n     * 因为先加入栈1的节点，会后输出，但是再加入栈2，又会先输出，所以这儿要先处理左子树，才能处理右子树\n     */\n  }\n  while (stack2.length > 0) {\n    let tempNode = stack2.pop();\n    console.log(tempNode.data);\n  }\n}\n\n\n\n# 复杂度分析\n\n时间复杂度O(n)；空间复杂度O(h);',normalizedContent:'# 后序遍历\n\n假设我们的树节点的定义如下：\n\ninterface treenode<t> {\n  left: treenode | null;\n  right: treenode | null;\n  data: t;\n}\n\n\ntip\n\n总是以左->右->根的顺序输出二叉树中的节点\n\n\n# 递归遍历\n\n/**\n * 后序递归遍历二叉树\n * @param {treenode} tree 树的根节点\n */\nfunction treeposttraverserecursion(tree) {\n  if (!tree) {\n    console.log("empty tree");\n    return;\n  }\n  // 和先序递归遍历区别仅体现在输出的时机不同，因为代码的顺序会导致调用堆栈的循序的改变，因此可以完成后序遍历\n  tree.left && treeposttraverserecursion(tree.left);\n  tree.right && treeposttraverserecursion(tree.right);\n  console.log(tree.data);\n}\n\n\n\n# 非递归遍历\n\n/**\n * 二叉树非递归后序遍历\n * @param {treenode} tree 树的根节点\n */\nfunction treeposttraverse(tree) {\n  if (!tree) {\n    console.log("empty tree");\n    return;\n  }\n  // 栈1用于遍历\n  let stack1 = [];\n  // 栈2用于保持输出顺序\n  let stack2 = [];\n  let node = tree;\n  stack1.push(node);\n  while (stack1.length > 0) {\n    node = stack1.pop();\n    // 将根节点加入栈2，先加入的后输出\n    stack2.push(node);\n    // 如果左子树存在，将左子树节点加入到栈1中\n    if (node.left != null) {\n      stack1.push(node.left);\n    }\n    // 如果右子树存在，将右子树节点加入到栈1中\n    if (node.right != null) {\n      stack1.push(node.right);\n    }\n    /**\n     * 因为先加入栈1的节点，会后输出，但是再加入栈2，又会先输出，所以这儿要先处理左子树，才能处理右子树\n     */\n  }\n  while (stack2.length > 0) {\n    let tempnode = stack2.pop();\n    console.log(tempnode.data);\n  }\n}\n\n\n\n# 复杂度分析\n\n时间复杂度o(n)；空间复杂度o(h);',charsets:{cjk:!0}},{title:"装饰模式",frontmatter:{},regularPath:"/design-pattern/decorator.html",relativePath:"design-pattern/decorator.md",key:"v-e73b2872",path:"/design-pattern/decorator.html",headersStr:null,content:"",normalizedContent:"",charsets:{}},{title:"工厂模式",frontmatter:{},regularPath:"/design-pattern/factory.html",relativePath:"design-pattern/factory.md",key:"v-0d51cfe9",path:"/design-pattern/factory.html",headersStr:null,content:"",normalizedContent:"",charsets:{}},{title:"桥接模式",frontmatter:{},regularPath:"/design-pattern/bridge.html",relativePath:"design-pattern/bridge.md",key:"v-4ff83756",path:"/design-pattern/bridge.html",headersStr:null,content:"",normalizedContent:"",charsets:{}},{title:"中介者模式",frontmatter:{},regularPath:"/design-pattern/mediator.html",relativePath:"design-pattern/mediator.md",key:"v-04c70155",path:"/design-pattern/mediator.html",headersStr:null,content:"",normalizedContent:"",charsets:{}},{title:"代理模式",frontmatter:{},regularPath:"/design-pattern/proxy.html",relativePath:"design-pattern/proxy.md",key:"v-1690bca1",path:"/design-pattern/proxy.html",headersStr:null,content:"",normalizedContent:"",charsets:{}},{title:"享元模式",frontmatter:{},regularPath:"/design-pattern/flyweight.html",relativePath:"design-pattern/flyweight.md",key:"v-73b8d232",path:"/design-pattern/flyweight.html",headersStr:null,content:"",normalizedContent:"",charsets:{}},{title:"先序遍历",frontmatter:{},regularPath:"/data-structure/tree/binaryTree/preOrderVisit.html",relativePath:"data-structure/tree/binaryTree/preOrderVisit.md",key:"v-56edd5c6",path:"/data-structure/tree/binaryTree/preOrderVisit.html",headers:[{level:2,title:"先序遍历",slug:"先序遍历",normalizedTitle:"先序遍历",charIndex:2},{level:2,title:"递归遍历",slug:"递归遍历",normalizedTitle:"递归遍历",charIndex:146},{level:2,title:"非递归遍历",slug:"非递归遍历",normalizedTitle:"非递归遍历",charIndex:514},{level:2,title:"复杂度分析",slug:"复杂度分析",normalizedTitle:"复杂度分析",charIndex:1103}],headersStr:"先序遍历 递归遍历 非递归遍历 复杂度分析",content:'# 先序遍历\n\n假设我们的树节点的定义如下：\n\ninterface TreeNode<T> {\n  left: TreeNode | null;\n  right: TreeNode | null;\n  data: T;\n}\n\n\nTIP\n\n总是以根->左->右的顺序输出二叉树中的节点\n\n\n# 递归遍历\n\n/**\n * 先序递归遍历二叉树\n * @param {TreeNode<number>} tree\n */\nfunction treePreOrderRecursion(tree) {\n  // 如果树空，则完成遍历\n  if (!tree) {\n    console.log("tree empty!");\n    return;\n  }\n  // 打印当前节点的值\n  console.log(tree.data);\n  // 如果左子树存在，递归遍历左子树\n  tree.left && treePreOrderRecursion(tree.left);\n  // 如果右子树存在，递归遍历右子树\n  tree.right && treePreOrderRecursion(tree.right);\n}\n\n\n\n# 非递归遍历\n\n/**\n * 先序非递归遍历二叉树\n * @param {TreeNode<number>} tree\n */\nfunction treePreOrder(tree) {\n  if (!tree) {\n    console.log("empty tree!");\n    return;\n  }\n  // 定义一个栈用于模拟系统提供的堆栈\n  let stack = [];\n  // 让node指向树的跟节点，准备开始遍历\n  let node = tree;\n  // 如果树不空，或者栈中还有内容，则应该继续进行遍历\n  while (stack.length > 0 || node) {\n    // 如果node节点不为空的话，不断的向左压栈，直到为空\n    while (node) {\n      stack.push(node);\n      console.log(node.data);\n      node = node.left;\n    }\n    // 向左走到头了，若当前栈中还有内容，则从栈中取出一个内容，从当前内容的右子树继续遍历\n    if (stack.length > 0) {\n      node = stack.pop();\n      node = node.right;\n    }\n  }\n}\n\n\n\n# 复杂度分析\n\n不管是非递归遍历还是递归遍历，二叉树遍历的时间复杂度是O(n)(不管怎么样，你总得把所有的树节点都看一遍),空间复杂度为O(h)，h 为树的高度，使用递归遍历是用的系统的堆栈，而非递归遍历需要我们自己用一个栈去模拟系统堆栈的行为。',normalizedContent:'# 先序遍历\n\n假设我们的树节点的定义如下：\n\ninterface treenode<t> {\n  left: treenode | null;\n  right: treenode | null;\n  data: t;\n}\n\n\ntip\n\n总是以根->左->右的顺序输出二叉树中的节点\n\n\n# 递归遍历\n\n/**\n * 先序递归遍历二叉树\n * @param {treenode<number>} tree\n */\nfunction treepreorderrecursion(tree) {\n  // 如果树空，则完成遍历\n  if (!tree) {\n    console.log("tree empty!");\n    return;\n  }\n  // 打印当前节点的值\n  console.log(tree.data);\n  // 如果左子树存在，递归遍历左子树\n  tree.left && treepreorderrecursion(tree.left);\n  // 如果右子树存在，递归遍历右子树\n  tree.right && treepreorderrecursion(tree.right);\n}\n\n\n\n# 非递归遍历\n\n/**\n * 先序非递归遍历二叉树\n * @param {treenode<number>} tree\n */\nfunction treepreorder(tree) {\n  if (!tree) {\n    console.log("empty tree!");\n    return;\n  }\n  // 定义一个栈用于模拟系统提供的堆栈\n  let stack = [];\n  // 让node指向树的跟节点，准备开始遍历\n  let node = tree;\n  // 如果树不空，或者栈中还有内容，则应该继续进行遍历\n  while (stack.length > 0 || node) {\n    // 如果node节点不为空的话，不断的向左压栈，直到为空\n    while (node) {\n      stack.push(node);\n      console.log(node.data);\n      node = node.left;\n    }\n    // 向左走到头了，若当前栈中还有内容，则从栈中取出一个内容，从当前内容的右子树继续遍历\n    if (stack.length > 0) {\n      node = stack.pop();\n      node = node.right;\n    }\n  }\n}\n\n\n\n# 复杂度分析\n\n不管是非递归遍历还是递归遍历，二叉树遍历的时间复杂度是o(n)(不管怎么样，你总得把所有的树节点都看一遍),空间复杂度为o(h)，h 为树的高度，使用递归遍历是用的系统的堆栈，而非递归遍历需要我们自己用一个栈去模拟系统堆栈的行为。',charsets:{cjk:!0}},{title:"策略模式",frontmatter:{},regularPath:"/design-pattern/strategy.html",relativePath:"design-pattern/strategy.md",key:"v-ebee5d56",path:"/design-pattern/strategy.html",headersStr:null,content:"",normalizedContent:"",charsets:{}},{title:"层序遍历",frontmatter:{},regularPath:"/data-structure/tree/binaryTree/levelOrderVisit.html",relativePath:"data-structure/tree/binaryTree/levelOrderVisit.md",key:"v-23d56c5b",path:"/data-structure/tree/binaryTree/levelOrderVisit.html",headers:[{level:2,title:"层序遍历",slug:"层序遍历",normalizedTitle:"层序遍历",charIndex:2},{level:2,title:"复杂度分析",slug:"复杂度分析",normalizedTitle:"复杂度分析",charIndex:736}],headersStr:"层序遍历 复杂度分析",content:'# 层序遍历\n\n假设我们的树节点的定义如下：\n\ninterface TreeNode<T> {\n  left: TreeNode | null;\n  right: TreeNode | null;\n  data: T;\n}\n\n\nTIP\n\n总是按每层从左到右的顺序输出二叉树中的节点\n\n算法实现：\n\n/**\n * 二叉树的层序遍历\n * @param {TreeNode} tree 树的根节点\n */\nfunction treeLevelTraverse(tree) {\n  if (!tree) {\n    console.log("empty tree");\n    return;\n  }\n  let node = tree;\n  let list = [];\n  // 将跟节点入队\n  list.push(node);\n  // 如果队列不为空，则进行遍历\n  while (list.length > 0) {\n    // 从队首取出一个元素用以处理\n    const curNode = list.shift();\n    console.log(curNode.data);\n    // 如果存在左子树，将左子树入队\n    if (curNode.left) {\n      list.push(curNode.left);\n    }\n    // 如果存在右子树，将右子树入队\n    if (curNode.right) {\n      list.push(curNode.right);\n    }\n  }\n  /**\n   * 因为队列先入先出的特性，所以最后的打印顺序总是按层从上至下，每层从左到右的顺序输出\n   */\n}\n\n\n\n# 复杂度分析\n\n时间复杂度O(n)；空间复杂度O(w)，为二叉树的最大宽度;',normalizedContent:'# 层序遍历\n\n假设我们的树节点的定义如下：\n\ninterface treenode<t> {\n  left: treenode | null;\n  right: treenode | null;\n  data: t;\n}\n\n\ntip\n\n总是按每层从左到右的顺序输出二叉树中的节点\n\n算法实现：\n\n/**\n * 二叉树的层序遍历\n * @param {treenode} tree 树的根节点\n */\nfunction treeleveltraverse(tree) {\n  if (!tree) {\n    console.log("empty tree");\n    return;\n  }\n  let node = tree;\n  let list = [];\n  // 将跟节点入队\n  list.push(node);\n  // 如果队列不为空，则进行遍历\n  while (list.length > 0) {\n    // 从队首取出一个元素用以处理\n    const curnode = list.shift();\n    console.log(curnode.data);\n    // 如果存在左子树，将左子树入队\n    if (curnode.left) {\n      list.push(curnode.left);\n    }\n    // 如果存在右子树，将右子树入队\n    if (curnode.right) {\n      list.push(curnode.right);\n    }\n  }\n  /**\n   * 因为队列先入先出的特性，所以最后的打印顺序总是按层从上至下，每层从左到右的顺序输出\n   */\n}\n\n\n\n# 复杂度分析\n\n时间复杂度o(n)；空间复杂度o(w)，为二叉树的最大宽度;',charsets:{cjk:!0}},{title:"观察者模式",frontmatter:{},regularPath:"/design-pattern/watcher.html",relativePath:"design-pattern/watcher.md",key:"v-2264f0f6",path:"/design-pattern/watcher.html",headersStr:null,content:"",normalizedContent:"",charsets:{}},{title:"单例模式",frontmatter:{},regularPath:"/design-pattern/singleton.html",relativePath:"design-pattern/singleton.md",key:"v-2b5eefb2",path:"/design-pattern/singleton.html",headersStr:null,content:"单例模式",normalizedContent:"单例模式",charsets:{cjk:!0}},{frontmatter:{},regularPath:"/frameworks/",relativePath:"frameworks/index.md",key:"v-19a2deaa",path:"/frameworks/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{title:"设计模式专题",frontmatter:{title:"设计模式专题"},regularPath:"/design-pattern/",relativePath:"design-pattern/index.md",key:"v-3a2a67dc",path:"/design-pattern/",headers:[{level:2,title:"1. 面向对象的三大特性",slug:"_1-面向对象的三大特性",normalizedTitle:"1. 面向对象的三大特性",charIndex:2},{level:3,title:"封装",slug:"封装",normalizedTitle:"封装",charIndex:19},{level:3,title:"继承",slug:"继承",normalizedTitle:"继承",charIndex:2738},{level:3,title:"多态",slug:"多态",normalizedTitle:"多态",charIndex:3591},{level:2,title:"2. 面向对象的 7 大设计原则",slug:"_2-面向对象的-7-大设计原则",normalizedTitle:"2. 面向对象的 7 大设计原则",charIndex:6046},{level:3,title:"开闭原则",slug:"开闭原则",normalizedTitle:"开闭原则",charIndex:6067},{level:3,title:"里氏代换原则",slug:"里氏代换原则",normalizedTitle:"里氏代换原则",charIndex:7834},{level:3,title:"接口隔离原则",slug:"接口隔离原则",normalizedTitle:"接口隔离原则",charIndex:7845},{level:3,title:"组合代替继承原则",slug:"组合代替继承原则",normalizedTitle:"组合代替继承原则",charIndex:7856},{level:3,title:"单一职责原则",slug:"单一职责原则",normalizedTitle:"单一职责原则",charIndex:7869},{level:3,title:"依赖倒置原则",slug:"依赖倒置原则",normalizedTitle:"依赖倒置原则",charIndex:8163},{level:3,title:"迪米特原则(即最小知识原则，当前类知道的事儿越少越好)",slug:"迪米特原则-即最小知识原则-当前类知道的事儿越少越好",normalizedTitle:"迪米特原则(即最小知识原则，当前类知道的事儿越少越好)",charIndex:8174},{level:2,title:"2.常见的设计模式列表",slug:"_2-常见的设计模式列表",normalizedTitle:"2.常见的设计模式列表",charIndex:8206}],headersStr:"1. 面向对象的三大特性 封装 继承 多态 2. 面向对象的 7 大设计原则 开闭原则 里氏代换原则 接口隔离原则 组合代替继承原则 单一职责原则 依赖倒置原则 迪米特原则(即最小知识原则，当前类知道的事儿越少越好) 2.常见的设计模式列表",content:'# 1. 面向对象的三大特性\n\n\n# 封装\n\n封装：将信息隐藏，也就是说，封装不仅仅是隐藏数据，还包括隐藏实现细节、设计细节以及隐藏对象的类型等，封装使得对象内部的变化对其他对象是不可见的。\n\n对象对它自己的行为负责，其他对象或者用户都不关心它的内部实现。封装使得对象之间的耦合变松散，对象之间只通过暴露的API（Application Program Interface）接口来通信。当我们修改一个对象时，可以随意地修改它的内部实现，只要对外的接口没有变化，就不会影响到程序的其他功能。\n\n下面是一个封装的例子：\n\n\n\n正常的思维，借助一个数组实现，然后会牵涉到对于数组的调整（有杠精会说 JS 不是有数组的shift和push吗？题目已经要求了不要使用内置的Queue，如果这样使用就违背了题目要求），因为有可能对数据进行拷贝，若每个数组项拷贝时间不可忽略的话，这个效率是比较低的。此外数组调整的逻辑也并不简单，还容易犯错。\n\n但题目只要求不使用内置Queue即可，只要满足上述的API定义的要求就可以了，至于队列内部怎么实现，与外界无关。 因此可以自由发挥了，完全没有必要采用数组实现，链表的插入和删除都是O(1)，只要限制队列的最大长度，外界完全感觉不到队列的内容调整。\n\n由此，采用双向链表实现这个循环队列，逻辑简单且高效，具体实现如下：\n\n/**\n * 队列节点定义\n */\ninterface CircularQueueNode<T> {\n  /**\n   * 前驱节点\n   */\n  prev: CircularQueueNode<T> | null;\n  /**\n   * 后继节点\n   */\n  next: CircularQueueNode<T> | null;\n  /**\n   * 数据域\n   */\n  data: T;\n}\n/**\n * 循环双端队列\n */\nclass MyCircularQueue<T> {\n  /**\n   * 队列的最大长度限制\n   */\n  private limit: number = Infinity;\n  /**\n   * 队列当前已存储的长度\n   */\n  private size: number = 0;\n  /**\n   * 链表表头\n   */\n  private head: null | CircularQueueNode<T> = null;\n  /**\n   * 链表表尾\n   */\n  private tail: null | CircularQueueNode<T> = null;\n  /**\n   * 暴露给外界的当前队列的长度，不允许修改\n   */\n  public get count(): number {\n    return this.size;\n  }\n  constructor(k: number) {\n    this.limit = k;\n  }\n  /**\n   * 入队\n   * @param value\n   * @returns\n   */\n  public enQueue(value: T): void {\n    if (this.isFull()) {\n      console.warn("can not enqueue an full queue");\n      return;\n    }\n    let newNode: CircularQueueNode<T> = {\n      prev: null,\n      next: null,\n      data: value,\n    };\n    /* 入队：使用头插法 */\n    if (this.head === null && this.tail === null) {\n      this.head = this.tail = newNode;\n    } else {\n      this.tail!.next = newNode;\n      newNode.prev = this.tail;\n      this.tail = newNode;\n    }\n    this.size++;\n  }\n  /**\n   * 出队\n   * @returns\n   */\n  public deQueue(): null | T {\n    if (this.isEmpty()) {\n      console.warn("can not dequeue from an empty queue");\n      return null;\n    }\n    let node = this.head!;\n    /* 出队：删除尾节点，将尾节点的前驱节点变成尾节点 */\n    if (this.head === this.tail) {\n      this.head = this.tail = null;\n    } else {\n      let nextNode = node.next;\n      nextNode!.prev = null;\n      this.head = nextNode;\n    }\n    this.size--;\n    return node.data;\n  }\n  /**\n   * 获取队首的元素\n   * @returns\n   */\n  public Front(): null | T {\n    return !this.isEmpty() ? this.head!.data : null;\n  }\n  /**\n   * 获取队尾元素\n   */\n  public Rear(): null | T {\n    return !this.isEmpty() ? this.tail!.data : null;\n  }\n  /**\n   * 队列是否为空\n   */\n  public isEmpty(): boolean {\n    return this.size === 0;\n  }\n  /**\n   * 队列是否满\n   */\n  public isFull(): boolean {\n    return this.size === this.limit;\n  }\n}\n\n\n外界看不到内部任何的技术实现细节，只需要按照Queue提供的接口进行调用即可，这样可以使得我们的Queue在不修改代码的前提下又能适应绝大部分的业务场景，由此例完全体现了封装的优势。\n\n\n# 继承\n\n继承：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。\n\n继承的过程，就是从一般到特殊的过程。\n\n在实际的开发中，我们通常会对我们的业务进行抽象，将一些比较宏观的行为编写成一个超类，不同的业务因为特殊的业务，可以对抽象的超类实现以获得更好的代码复用。\n\n下面是一个继承的例子(节选自vue-router@3.5.4)：\n\n/**\n * 操作浏览器History的类\n */\nclass History {\n  cb: (r: Route) => void;\n  ready: boolean;\n  readyCbs: Array<Function>;\n  readyErrorCbs: Array<Function>;\n  errorCbs: Array<Function>;\n  listeners: Array<Function>;\n\n  listen(cb: Function) {\n    this.cb = cb;\n  }\n\n  onReady(cb: Function, errorCb: ?Function) {\n    if (this.ready) {\n      cb();\n    } else {\n      this.readyCbs.push(cb);\n      if (errorCb) {\n        this.readyErrorCbs.push(errorCb);\n      }\n    }\n  }\n\n  onError(errorCb: Function) {\n    this.errorCbs.push(errorCb);\n  }\n}\n\n/**\n * 低版本操作浏览器History的类\n */\nclass HashHistory extends History {}\n\n/**\n * 高版本操作浏览器History的类\n */\nclass HTML5History extends History {}\n\n\n\n# 多态\n\n多态的实际含义是:同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果。\n\n举个例子，假设现在需要给不同的对象发送同一个消息，这些对象会根据这个消息分别给出不同的反馈。\n\n多态的实现有二种方式，重写（也可以叫做覆盖），重载。\n\n重写：对于父类和子类的同一个方法，子类完全（或完全不）舍弃父类的逻辑，并且由自己的业务决定实现一套新的逻辑。\n\n重载：对于一个类中同一个方法名，参数类型不同，参数数量不同，方法执行的结果返回类型不同，均可构成重载。\n\nDANGER\n\n最常见的一个面试题：请问重写和重载什么关系？答案是没有关系\n\n由于JS是弱语言，实际开发中不存在重载，实现多态主要是采用重写。\n\n下面是一个多态的例子(节选自vue-router@3.5.4)：\n\nclass History {\n  go(n: number): never {\n    throw new Error("not implement exception");\n  }\n\n  push(loc: RawLocation, onComplete?: Function, onAbort?: Function): never {\n    throw new Error("not implement exception");\n  }\n\n  replace(loc: RawLocation, onComplete?: Function, onAbort?: Function): never {\n    throw new Error("not implement exception");\n  }\n}\n\n/**\n * 低版本操作浏览器History的类\n */\nclass HashHistory extends History {\n  push(location: RawLocation, onComplete?: Function, onAbort?: Function) {\n    const { current: fromRoute } = this;\n    this.transitionTo(\n      location,\n      (route) => {\n        pushHash(route.fullPath);\n        handleScroll(this.router, route, fromRoute, false);\n        onComplete && onComplete(route);\n      },\n      onAbort\n    );\n  }\n\n  replace(location: RawLocation, onComplete?: Function, onAbort?: Function) {\n    const { current: fromRoute } = this;\n    this.transitionTo(\n      location,\n      (route) => {\n        replaceHash(route.fullPath);\n        handleScroll(this.router, route, fromRoute, false);\n        onComplete && onComplete(route);\n      },\n      onAbort\n    );\n  }\n\n  go(n: number) {\n    window.history.go(n);\n  }\n}\n\n/**\n * 高版本操作浏览器History的类\n */\nclass HTML5History extends History {\n  go(n: number): void {\n    window.history.go(n);\n  }\n\n  push(location: RawLocation, onComplete?: Function, onAbort?: Function) {\n    const { current: fromRoute } = this;\n    this.transitionTo(\n      location,\n      (route) => {\n        pushState(cleanPath(this.base + route.fullPath));\n        handleScroll(this.router, route, fromRoute, false);\n        onComplete && onComplete(route);\n      },\n      onAbort\n    );\n  }\n\n  replace(location: RawLocation, onComplete?: Function, onAbort?: Function) {\n    const { current: fromRoute } = this;\n    this.transitionTo(\n      location,\n      (route) => {\n        replaceState(cleanPath(this.base + route.fullPath));\n        handleScroll(this.router, route, fromRoute, false);\n        onComplete && onComplete(route);\n      },\n      onAbort\n    );\n  }\n}\n\n\n上面的代码，大家如果看不懂没有关系，不用过分关心其中的详细实现，把主要关注点放在类的方法名定义上即可。\n\n在实际开发中，继承和多态几乎都是一起出现的。\n\n\n# 2. 面向对象的 7 大设计原则\n\n\n# 开闭原则\n\n开闭原则（Open-Closed Principle，OCP）是指一个软件实体（如类、模块和函数）应该对扩展开放，对修改关闭。\n\n所谓的开闭，也正是对扩展和修改两个行为的一个原则。它强调的是用抽象构建框架，用实现扩展细节，可以提高软件系统的可复用性及可维护性。\n\n开闭原则的核心思想就是面向抽象编程。\n\n对于前端，我们经常接触到的一个业务，导入导出，就拿导出举例，前端的导出五花八门，可以是xlsx，可以是xml，也可以是json，还可以是普通的text等。\n\n对于导出的业务来说，它不应该预设一些if-else语句去判断系统需要支持导出什么样的文件类型，因为这个关系的维持是脆弱的，设想现在要导出一个yml格式的文件，恭喜你，你的if-else语句就必须要增加分支了，显然已经违背开闭原则。\n\n我们可以设想，这些行为其实都是具有共性的，它们都是向服务器拉取数据，然后向浏览器写文件，回到上文提到的面向抽象编程。\n\n所以导出接口的定义就比较明确了，如下：\n\n/**\n * 定义一个导出接口\n */\ninterface IExporter {\n  /**\n   * 获取导出数据\n   */\n  fetchData(): any[];\n  /**\n   * 导出文件\n   */\n  generateFile(filename: string): void;\n}\n\n/**\n * 定义一个导出Excel文件的实现类\n */\nclass XlsxExporter implements IExporter {\n  fetchData(): any[] {\n    return [];\n  }\n\n  generateFile(filename: string): void {\n    console.log("Generating file..., please wait a moment");\n  }\n}\n\n\n对于我们的业务，比如点击一个按钮实现导出：\n\nimport React, { Component } from "react";\nimport { Factory } from "./utils";\nexport class MyComponent extends Component {\n  onExport = (filename: string) => {\n    const exportInstance: IExport = Factory.getInstance();\n    exportInstance.onExport("爱我中华");\n  };\n\n  render() {\n    return <Button onClick={this.onExport}>导出文件</Button>;\n  }\n}\n\n\n如果产品经理现在来找你说，小杨啊，我导出Excel的时候，发现有很多残缺数据，用户导出这些数据其实没有多大的意义的，能不能前端做一些判断呀？\n\n辛辛苦苦写好的导出，一句话又给加了一个需求，做肯定是要做的，关键是怎么做呢？\n\n上文已经提到了面向对象编程的多态，此刻我们也不需要改动多少代码，大致修改如下：\n\nclass AdvanceXlsxExporter extends XlsxExporter {\n  fetchData(): any[] {\n    const data = super.fetchData();\n    // TODO: 对数据进行一些处理\n    return data;\n  }\n}\n\n\n有的朋友可能不太明白为什么要这样做，觉得这样设计有点儿无病呻吟之嫌，现实场景中产品经理的这个需求其实也是很脆弱的，如果此时产品总监说，不行，我们的系统就需要向用户呈现真实的数据性便于用户进行统计分析，那刚才的需求其实就废了，这样又需要改动XlsxExporter这个类的实现，这类业务场景本来工厂函数就是极易改动的地方，因此把修改动作这种脏活累活交给工厂方法做的话，要好过直接修改XlsxExporter类，所以通过继承+重写较为妥当。\n\nTIP\n\n如果系统现在需要新增导出的文件类型，直接编写一个新的导出类实现相应的业务逻辑即可，无需对业务代码进行修改。\n\n\n# 里氏代换原则\n\n\n# 接口隔离原则\n\n\n# 组合代替继承原则\n\n\n# 单一职责原则\n\n单一职责原则(Single Responsibility Principle，SRP)的职责被定义为“引起变化的原因”。如果我们有两个动机去改写一个方法，那么这个方法就具有两个职责。每个职责都是变化的一个轴线，如果一个方法承担了过多的职责，那么在需求的变迁过程中，需要改写这个方法的可能性就越大。\n\n此时，这个方法通常是一个不稳定的方法，修改代码总是一件危险的事情，特别是当两个职责耦合在一起的时候，一个职责发生变化可能会影响到其他职责的实现，造成意想不到的破坏，这种耦合性得到的是低内聚和脆弱的设计。\n\n因此，SRP原则体现为: 一个对象(方法)只做一件事情。\n\n\n# 依赖倒置原则\n\n\n# 迪米特原则(即最小知识原则，当前类知道的事儿越少越好)\n\n\n# 2.常见的设计模式列表\n\n * 单例模式\n * 工厂模式\n * 命令模式\n * 代理模式\n * 观察者模式\n * 桥接模式\n * 适配器模式\n * 装饰模式\n * 模板方法模式\n * 策略模式\n * 享元模式\n * 中介者模式',normalizedContent:'# 1. 面向对象的三大特性\n\n\n# 封装\n\n封装：将信息隐藏，也就是说，封装不仅仅是隐藏数据，还包括隐藏实现细节、设计细节以及隐藏对象的类型等，封装使得对象内部的变化对其他对象是不可见的。\n\n对象对它自己的行为负责，其他对象或者用户都不关心它的内部实现。封装使得对象之间的耦合变松散，对象之间只通过暴露的api（application program interface）接口来通信。当我们修改一个对象时，可以随意地修改它的内部实现，只要对外的接口没有变化，就不会影响到程序的其他功能。\n\n下面是一个封装的例子：\n\n\n\n正常的思维，借助一个数组实现，然后会牵涉到对于数组的调整（有杠精会说 js 不是有数组的shift和push吗？题目已经要求了不要使用内置的queue，如果这样使用就违背了题目要求），因为有可能对数据进行拷贝，若每个数组项拷贝时间不可忽略的话，这个效率是比较低的。此外数组调整的逻辑也并不简单，还容易犯错。\n\n但题目只要求不使用内置queue即可，只要满足上述的api定义的要求就可以了，至于队列内部怎么实现，与外界无关。 因此可以自由发挥了，完全没有必要采用数组实现，链表的插入和删除都是o(1)，只要限制队列的最大长度，外界完全感觉不到队列的内容调整。\n\n由此，采用双向链表实现这个循环队列，逻辑简单且高效，具体实现如下：\n\n/**\n * 队列节点定义\n */\ninterface circularqueuenode<t> {\n  /**\n   * 前驱节点\n   */\n  prev: circularqueuenode<t> | null;\n  /**\n   * 后继节点\n   */\n  next: circularqueuenode<t> | null;\n  /**\n   * 数据域\n   */\n  data: t;\n}\n/**\n * 循环双端队列\n */\nclass mycircularqueue<t> {\n  /**\n   * 队列的最大长度限制\n   */\n  private limit: number = infinity;\n  /**\n   * 队列当前已存储的长度\n   */\n  private size: number = 0;\n  /**\n   * 链表表头\n   */\n  private head: null | circularqueuenode<t> = null;\n  /**\n   * 链表表尾\n   */\n  private tail: null | circularqueuenode<t> = null;\n  /**\n   * 暴露给外界的当前队列的长度，不允许修改\n   */\n  public get count(): number {\n    return this.size;\n  }\n  constructor(k: number) {\n    this.limit = k;\n  }\n  /**\n   * 入队\n   * @param value\n   * @returns\n   */\n  public enqueue(value: t): void {\n    if (this.isfull()) {\n      console.warn("can not enqueue an full queue");\n      return;\n    }\n    let newnode: circularqueuenode<t> = {\n      prev: null,\n      next: null,\n      data: value,\n    };\n    /* 入队：使用头插法 */\n    if (this.head === null && this.tail === null) {\n      this.head = this.tail = newnode;\n    } else {\n      this.tail!.next = newnode;\n      newnode.prev = this.tail;\n      this.tail = newnode;\n    }\n    this.size++;\n  }\n  /**\n   * 出队\n   * @returns\n   */\n  public dequeue(): null | t {\n    if (this.isempty()) {\n      console.warn("can not dequeue from an empty queue");\n      return null;\n    }\n    let node = this.head!;\n    /* 出队：删除尾节点，将尾节点的前驱节点变成尾节点 */\n    if (this.head === this.tail) {\n      this.head = this.tail = null;\n    } else {\n      let nextnode = node.next;\n      nextnode!.prev = null;\n      this.head = nextnode;\n    }\n    this.size--;\n    return node.data;\n  }\n  /**\n   * 获取队首的元素\n   * @returns\n   */\n  public front(): null | t {\n    return !this.isempty() ? this.head!.data : null;\n  }\n  /**\n   * 获取队尾元素\n   */\n  public rear(): null | t {\n    return !this.isempty() ? this.tail!.data : null;\n  }\n  /**\n   * 队列是否为空\n   */\n  public isempty(): boolean {\n    return this.size === 0;\n  }\n  /**\n   * 队列是否满\n   */\n  public isfull(): boolean {\n    return this.size === this.limit;\n  }\n}\n\n\n外界看不到内部任何的技术实现细节，只需要按照queue提供的接口进行调用即可，这样可以使得我们的queue在不修改代码的前提下又能适应绝大部分的业务场景，由此例完全体现了封装的优势。\n\n\n# 继承\n\n继承：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。\n\n继承的过程，就是从一般到特殊的过程。\n\n在实际的开发中，我们通常会对我们的业务进行抽象，将一些比较宏观的行为编写成一个超类，不同的业务因为特殊的业务，可以对抽象的超类实现以获得更好的代码复用。\n\n下面是一个继承的例子(节选自vue-router@3.5.4)：\n\n/**\n * 操作浏览器history的类\n */\nclass history {\n  cb: (r: route) => void;\n  ready: boolean;\n  readycbs: array<function>;\n  readyerrorcbs: array<function>;\n  errorcbs: array<function>;\n  listeners: array<function>;\n\n  listen(cb: function) {\n    this.cb = cb;\n  }\n\n  onready(cb: function, errorcb: ?function) {\n    if (this.ready) {\n      cb();\n    } else {\n      this.readycbs.push(cb);\n      if (errorcb) {\n        this.readyerrorcbs.push(errorcb);\n      }\n    }\n  }\n\n  onerror(errorcb: function) {\n    this.errorcbs.push(errorcb);\n  }\n}\n\n/**\n * 低版本操作浏览器history的类\n */\nclass hashhistory extends history {}\n\n/**\n * 高版本操作浏览器history的类\n */\nclass html5history extends history {}\n\n\n\n# 多态\n\n多态的实际含义是:同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果。\n\n举个例子，假设现在需要给不同的对象发送同一个消息，这些对象会根据这个消息分别给出不同的反馈。\n\n多态的实现有二种方式，重写（也可以叫做覆盖），重载。\n\n重写：对于父类和子类的同一个方法，子类完全（或完全不）舍弃父类的逻辑，并且由自己的业务决定实现一套新的逻辑。\n\n重载：对于一个类中同一个方法名，参数类型不同，参数数量不同，方法执行的结果返回类型不同，均可构成重载。\n\ndanger\n\n最常见的一个面试题：请问重写和重载什么关系？答案是没有关系\n\n由于js是弱语言，实际开发中不存在重载，实现多态主要是采用重写。\n\n下面是一个多态的例子(节选自vue-router@3.5.4)：\n\nclass history {\n  go(n: number): never {\n    throw new error("not implement exception");\n  }\n\n  push(loc: rawlocation, oncomplete?: function, onabort?: function): never {\n    throw new error("not implement exception");\n  }\n\n  replace(loc: rawlocation, oncomplete?: function, onabort?: function): never {\n    throw new error("not implement exception");\n  }\n}\n\n/**\n * 低版本操作浏览器history的类\n */\nclass hashhistory extends history {\n  push(location: rawlocation, oncomplete?: function, onabort?: function) {\n    const { current: fromroute } = this;\n    this.transitionto(\n      location,\n      (route) => {\n        pushhash(route.fullpath);\n        handlescroll(this.router, route, fromroute, false);\n        oncomplete && oncomplete(route);\n      },\n      onabort\n    );\n  }\n\n  replace(location: rawlocation, oncomplete?: function, onabort?: function) {\n    const { current: fromroute } = this;\n    this.transitionto(\n      location,\n      (route) => {\n        replacehash(route.fullpath);\n        handlescroll(this.router, route, fromroute, false);\n        oncomplete && oncomplete(route);\n      },\n      onabort\n    );\n  }\n\n  go(n: number) {\n    window.history.go(n);\n  }\n}\n\n/**\n * 高版本操作浏览器history的类\n */\nclass html5history extends history {\n  go(n: number): void {\n    window.history.go(n);\n  }\n\n  push(location: rawlocation, oncomplete?: function, onabort?: function) {\n    const { current: fromroute } = this;\n    this.transitionto(\n      location,\n      (route) => {\n        pushstate(cleanpath(this.base + route.fullpath));\n        handlescroll(this.router, route, fromroute, false);\n        oncomplete && oncomplete(route);\n      },\n      onabort\n    );\n  }\n\n  replace(location: rawlocation, oncomplete?: function, onabort?: function) {\n    const { current: fromroute } = this;\n    this.transitionto(\n      location,\n      (route) => {\n        replacestate(cleanpath(this.base + route.fullpath));\n        handlescroll(this.router, route, fromroute, false);\n        oncomplete && oncomplete(route);\n      },\n      onabort\n    );\n  }\n}\n\n\n上面的代码，大家如果看不懂没有关系，不用过分关心其中的详细实现，把主要关注点放在类的方法名定义上即可。\n\n在实际开发中，继承和多态几乎都是一起出现的。\n\n\n# 2. 面向对象的 7 大设计原则\n\n\n# 开闭原则\n\n开闭原则（open-closed principle，ocp）是指一个软件实体（如类、模块和函数）应该对扩展开放，对修改关闭。\n\n所谓的开闭，也正是对扩展和修改两个行为的一个原则。它强调的是用抽象构建框架，用实现扩展细节，可以提高软件系统的可复用性及可维护性。\n\n开闭原则的核心思想就是面向抽象编程。\n\n对于前端，我们经常接触到的一个业务，导入导出，就拿导出举例，前端的导出五花八门，可以是xlsx，可以是xml，也可以是json，还可以是普通的text等。\n\n对于导出的业务来说，它不应该预设一些if-else语句去判断系统需要支持导出什么样的文件类型，因为这个关系的维持是脆弱的，设想现在要导出一个yml格式的文件，恭喜你，你的if-else语句就必须要增加分支了，显然已经违背开闭原则。\n\n我们可以设想，这些行为其实都是具有共性的，它们都是向服务器拉取数据，然后向浏览器写文件，回到上文提到的面向抽象编程。\n\n所以导出接口的定义就比较明确了，如下：\n\n/**\n * 定义一个导出接口\n */\ninterface iexporter {\n  /**\n   * 获取导出数据\n   */\n  fetchdata(): any[];\n  /**\n   * 导出文件\n   */\n  generatefile(filename: string): void;\n}\n\n/**\n * 定义一个导出excel文件的实现类\n */\nclass xlsxexporter implements iexporter {\n  fetchdata(): any[] {\n    return [];\n  }\n\n  generatefile(filename: string): void {\n    console.log("generating file..., please wait a moment");\n  }\n}\n\n\n对于我们的业务，比如点击一个按钮实现导出：\n\nimport react, { component } from "react";\nimport { factory } from "./utils";\nexport class mycomponent extends component {\n  onexport = (filename: string) => {\n    const exportinstance: iexport = factory.getinstance();\n    exportinstance.onexport("爱我中华");\n  };\n\n  render() {\n    return <button onclick={this.onexport}>导出文件</button>;\n  }\n}\n\n\n如果产品经理现在来找你说，小杨啊，我导出excel的时候，发现有很多残缺数据，用户导出这些数据其实没有多大的意义的，能不能前端做一些判断呀？\n\n辛辛苦苦写好的导出，一句话又给加了一个需求，做肯定是要做的，关键是怎么做呢？\n\n上文已经提到了面向对象编程的多态，此刻我们也不需要改动多少代码，大致修改如下：\n\nclass advancexlsxexporter extends xlsxexporter {\n  fetchdata(): any[] {\n    const data = super.fetchdata();\n    // todo: 对数据进行一些处理\n    return data;\n  }\n}\n\n\n有的朋友可能不太明白为什么要这样做，觉得这样设计有点儿无病呻吟之嫌，现实场景中产品经理的这个需求其实也是很脆弱的，如果此时产品总监说，不行，我们的系统就需要向用户呈现真实的数据性便于用户进行统计分析，那刚才的需求其实就废了，这样又需要改动xlsxexporter这个类的实现，这类业务场景本来工厂函数就是极易改动的地方，因此把修改动作这种脏活累活交给工厂方法做的话，要好过直接修改xlsxexporter类，所以通过继承+重写较为妥当。\n\ntip\n\n如果系统现在需要新增导出的文件类型，直接编写一个新的导出类实现相应的业务逻辑即可，无需对业务代码进行修改。\n\n\n# 里氏代换原则\n\n\n# 接口隔离原则\n\n\n# 组合代替继承原则\n\n\n# 单一职责原则\n\n单一职责原则(single responsibility principle，srp)的职责被定义为“引起变化的原因”。如果我们有两个动机去改写一个方法，那么这个方法就具有两个职责。每个职责都是变化的一个轴线，如果一个方法承担了过多的职责，那么在需求的变迁过程中，需要改写这个方法的可能性就越大。\n\n此时，这个方法通常是一个不稳定的方法，修改代码总是一件危险的事情，特别是当两个职责耦合在一起的时候，一个职责发生变化可能会影响到其他职责的实现，造成意想不到的破坏，这种耦合性得到的是低内聚和脆弱的设计。\n\n因此，srp原则体现为: 一个对象(方法)只做一件事情。\n\n\n# 依赖倒置原则\n\n\n# 迪米特原则(即最小知识原则，当前类知道的事儿越少越好)\n\n\n# 2.常见的设计模式列表\n\n * 单例模式\n * 工厂模式\n * 命令模式\n * 代理模式\n * 观察者模式\n * 桥接模式\n * 适配器模式\n * 装饰模式\n * 模板方法模式\n * 策略模式\n * 享元模式\n * 中介者模式',charsets:{cjk:!0}},{title:"Ajax",frontmatter:{},regularPath:"/javascript/ajax.html",relativePath:"javascript/ajax.md",key:"v-fa7f0416",path:"/javascript/ajax.html",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{},regularPath:"/guide/",relativePath:"guide/index.md",key:"v-e18b4c64",path:"/guide/",headersStr:null,content:"数据结构和算法专题\n\n> 常见数据结构和算法（树、图、数组、堆、栈、队列）的基本使用以及典型题目分析。\n\n----------------------------------------\n\n设计模式\n\n> 常见设计模式在 JavaScript 中的实现。\n\n----------------------------------------\n\nJavaScript 专题\n\n> JavaScript常见的一些核心概念以及部分API的手写实现，如节流防抖等。",normalizedContent:"数据结构和算法专题\n\n> 常见数据结构和算法（树、图、数组、堆、栈、队列）的基本使用以及典型题目分析。\n\n----------------------------------------\n\n设计模式\n\n> 常见设计模式在 javascript 中的实现。\n\n----------------------------------------\n\njavascript 专题\n\n> javascript常见的一些核心概念以及部分api的手写实现，如节流防抖等。",charsets:{cjk:!0}},{title:"RegExp对象",frontmatter:{},regularPath:"/javascript/RegExp.html",relativePath:"javascript/RegExp.md",key:"v-c0792b56",path:"/javascript/RegExp.html",headers:[{level:2,title:"RegExp对象",slug:"regexp对象",normalizedTitle:"regexp对象",charIndex:2},{level:3,title:"组",slug:"组",normalizedTitle:"组",charIndex:1346},{level:3,title:"序列化",slug:"序列化",normalizedTitle:"序列化",charIndex:1818},{level:3,title:"全局匹配与lastIndex",slug:"全局匹配与lastindex",normalizedTitle:"全局匹配与lastindex",charIndex:1851}],headersStr:"RegExp对象 组 序列化 全局匹配与lastIndex",content:'# RegExp对象\n\n本文不着重阐述正则表达式本身，主要是阐述RegExp一些应用以及实际开发中的坑。\n\n对于想详细理解RegExp对象的朋友，可以查看MDN原文\n\n在JS中，一般我们喜欢写RegExp对象的字面量形式，如：\n\nconst regExp = /^(\\+86)?1[3456789]\\d{9}$/;\nregExp.test("14730909030");\n\n\n而如果写构造函数的形式，还需要对特殊字符进行转义，相对来说就比较复杂了，比如，实现同等功能，代码要这样写：\n\nconst regExp = new RegExp("^(\\\\+86)?1[3456789]\\\\d{9}$")\n\n\n有些时候，难免会把一些转义字符写错，所以为了避免问题，还是尽量避免写构造函数的形式。\n\n不过凡事不是绝对的，有的情况是不得不写构造函数形式的，比如：\n\nconst obj = { name: "yangxu", age: 28, vocation: "web-frontend developer" };\n\nconst html = `<div class="person">\n                <span class=\'name\'>{{name}}</span>\n                <span class=\'age\'>{{age}}</span>\n                <span class=\'vocation\'>{{vocation}}</span>\n              </div>\n            `;\n/*\n  希望得到如下结果\n  <div class="person">\n    <span class=\'name\'>yangxu</span>\n    <span class=\'age\'>28</span>\n    <span class=\'vocation\'>web-frontend developer</span>\n  </div>\n*/\n\n\nconst compile = (str, targetObj) => {\n  let distStr = str;\n  Object.entries(targetObj).forEach(([prop, val]) => {\n    distStr = distStr.replace(new RegExp("{{(" + prop + ")}}"), val);\n  });\n  return distStr;\n};\n/* 这个例子举的不是特别恰当，但是主要想说明RegExp构造器初始化正则表达式一般都是在动态生成正则表达式的场景下 */\n/**\n  const compile = (str, targetObj) => {\n    let distStr = str.replace(/{{([a-zA-Z0-9]+)}}/g, function (...args) {\n      return args.length > 1 && targetObj[args[1]];\n    });\n    return distStr;\n  };\n*/\n\n\n\n# 组\n\n关于正则的组的概念，请先查阅相关资料，本文主要阐述实际的应用。\n\nRegExp对象上存在$1-$9对象用来表示组，比如：\n\nconst regExp = /^(\\d)[\\u4e00-\\u9fa5]+/\nregExp.test(\'1生一世写前端\');\nRegExp.$1 // 匹配成功之后，RegExp.$1 的值就是 \'1\'，不标准，不建议使用\n\n\n如果使用exec：\n\nconst regExp = /^(\\d)[\\u4e00-\\u9fa5]+/;\nregExp.exec("1生一世写前端"); // 匹配成功得到的是一个数组，如[\'1生一世写前端\', \'1\', index: 0, input: \'1生一世写前端\', groups: undefined]，否则null\n\n\n在字符串的替换中，可以用到这些匹配的结果，如：\n\nconst regExp = /^(\\d)[\\u4e00-\\u9fa5]+/;\nlet str = "1生一世写前端";\nstr = str.replace(regExp, "$1起写代码");\n\n\n\n# 序列化\n\nRegExp的实例只能被序列化成为一个普通对象\n\n\n# 全局匹配与lastIndex\n\n这个问题可能是绝大部分前端都没有搞清楚的问题，并且我也被这个问题坑过。\n\n下面就来看一个例子：\n\nconst regExp = /^(\\+86)?1[3456789]\\d{9}$/g;\n\nregExp.test("14730909030"); // true\nregExp.test("14730909030"); // false\nregExp.test("14730909030"); // true\n\n/^(\\+86)?1[3456789]\\d{9}$/g.test("14730909030") // true\n/^(\\+86)?1[3456789]\\d{9}$/g.test("14730909030") // true\n/^(\\+86)?1[3456789]\\d{9}$/g.test("14730909030") // true\n\n\n为什么中间的这个语句得到的结果是false，超出自己的认知了？？？\n\nno no no！！！，这是你还没有理解到 RegExp.lastIndex 是什么意思。\n\nlastIndex只有正则表达式使用了表示全局检索的 "g" 或者粘性检索的 "y" 标志时，该属性才会起作用。\n\n * 如果 regexp.test 和 regexp.exec 匹配成功，lastIndex 会被设置为紧随最近一次成功匹配的下一个位置。\n * 如果 regexp.test 和 regexp.exec 匹配失败，lastIndex 会被设置为 0\n\n上述第一个情况，三个test，有一个是false的原因是，第一次成功匹配，lastIndex 走到最后一个位置，下次匹配的时候，相当于是从\'\'匹配 \'14730909030\'，那当然是匹配不到了，匹配不到，lastIndex就要归零，所以下次再匹配的时候，就能匹配了。而第二个情况每次都申明一个新的正则对象来进行匹配，其实也就丢失了全局匹配的意义，所以，每次都能匹配上。\n\n明确了这个问题，其实你也明确了什么时候该用全局匹配和什么时候不该用全局匹配了，简言之就是：如果你想在上次的搜索结果上继续向后匹配，那么你就需要使用全局匹配。',normalizedContent:'# regexp对象\n\n本文不着重阐述正则表达式本身，主要是阐述regexp一些应用以及实际开发中的坑。\n\n对于想详细理解regexp对象的朋友，可以查看mdn原文\n\n在js中，一般我们喜欢写regexp对象的字面量形式，如：\n\nconst regexp = /^(\\+86)?1[3456789]\\d{9}$/;\nregexp.test("14730909030");\n\n\n而如果写构造函数的形式，还需要对特殊字符进行转义，相对来说就比较复杂了，比如，实现同等功能，代码要这样写：\n\nconst regexp = new regexp("^(\\\\+86)?1[3456789]\\\\d{9}$")\n\n\n有些时候，难免会把一些转义字符写错，所以为了避免问题，还是尽量避免写构造函数的形式。\n\n不过凡事不是绝对的，有的情况是不得不写构造函数形式的，比如：\n\nconst obj = { name: "yangxu", age: 28, vocation: "web-frontend developer" };\n\nconst html = `<div class="person">\n                <span class=\'name\'>{{name}}</span>\n                <span class=\'age\'>{{age}}</span>\n                <span class=\'vocation\'>{{vocation}}</span>\n              </div>\n            `;\n/*\n  希望得到如下结果\n  <div class="person">\n    <span class=\'name\'>yangxu</span>\n    <span class=\'age\'>28</span>\n    <span class=\'vocation\'>web-frontend developer</span>\n  </div>\n*/\n\n\nconst compile = (str, targetobj) => {\n  let diststr = str;\n  object.entries(targetobj).foreach(([prop, val]) => {\n    diststr = diststr.replace(new regexp("{{(" + prop + ")}}"), val);\n  });\n  return diststr;\n};\n/* 这个例子举的不是特别恰当，但是主要想说明regexp构造器初始化正则表达式一般都是在动态生成正则表达式的场景下 */\n/**\n  const compile = (str, targetobj) => {\n    let diststr = str.replace(/{{([a-za-z0-9]+)}}/g, function (...args) {\n      return args.length > 1 && targetobj[args[1]];\n    });\n    return diststr;\n  };\n*/\n\n\n\n# 组\n\n关于正则的组的概念，请先查阅相关资料，本文主要阐述实际的应用。\n\nregexp对象上存在$1-$9对象用来表示组，比如：\n\nconst regexp = /^(\\d)[\\u4e00-\\u9fa5]+/\nregexp.test(\'1生一世写前端\');\nregexp.$1 // 匹配成功之后，regexp.$1 的值就是 \'1\'，不标准，不建议使用\n\n\n如果使用exec：\n\nconst regexp = /^(\\d)[\\u4e00-\\u9fa5]+/;\nregexp.exec("1生一世写前端"); // 匹配成功得到的是一个数组，如[\'1生一世写前端\', \'1\', index: 0, input: \'1生一世写前端\', groups: undefined]，否则null\n\n\n在字符串的替换中，可以用到这些匹配的结果，如：\n\nconst regexp = /^(\\d)[\\u4e00-\\u9fa5]+/;\nlet str = "1生一世写前端";\nstr = str.replace(regexp, "$1起写代码");\n\n\n\n# 序列化\n\nregexp的实例只能被序列化成为一个普通对象\n\n\n# 全局匹配与lastindex\n\n这个问题可能是绝大部分前端都没有搞清楚的问题，并且我也被这个问题坑过。\n\n下面就来看一个例子：\n\nconst regexp = /^(\\+86)?1[3456789]\\d{9}$/g;\n\nregexp.test("14730909030"); // true\nregexp.test("14730909030"); // false\nregexp.test("14730909030"); // true\n\n/^(\\+86)?1[3456789]\\d{9}$/g.test("14730909030") // true\n/^(\\+86)?1[3456789]\\d{9}$/g.test("14730909030") // true\n/^(\\+86)?1[3456789]\\d{9}$/g.test("14730909030") // true\n\n\n为什么中间的这个语句得到的结果是false，超出自己的认知了？？？\n\nno no no！！！，这是你还没有理解到 regexp.lastindex 是什么意思。\n\nlastindex只有正则表达式使用了表示全局检索的 "g" 或者粘性检索的 "y" 标志时，该属性才会起作用。\n\n * 如果 regexp.test 和 regexp.exec 匹配成功，lastindex 会被设置为紧随最近一次成功匹配的下一个位置。\n * 如果 regexp.test 和 regexp.exec 匹配失败，lastindex 会被设置为 0\n\n上述第一个情况，三个test，有一个是false的原因是，第一次成功匹配，lastindex 走到最后一个位置，下次匹配的时候，相当于是从\'\'匹配 \'14730909030\'，那当然是匹配不到了，匹配不到，lastindex就要归零，所以下次再匹配的时候，就能匹配了。而第二个情况每次都申明一个新的正则对象来进行匹配，其实也就丢失了全局匹配的意义，所以，每次都能匹配上。\n\n明确了这个问题，其实你也明确了什么时候该用全局匹配和什么时候不该用全局匹配了，简言之就是：如果你想在上次的搜索结果上继续向后匹配，那么你就需要使用全局匹配。',charsets:{cjk:!0}},{title:"描述",frontmatter:{},regularPath:"/data-structure/tree/N-Tree/bfsVisit.html",relativePath:"data-structure/tree/N-Tree/bfsVisit.md",key:"v-0171d335",path:"/data-structure/tree/N-Tree/bfsVisit.html",headers:[{level:2,title:"描述",slug:"描述",normalizedTitle:"描述",charIndex:2},{level:2,title:"N-叉树的 BFS",slug:"n-叉树的-bfs",normalizedTitle:"n-叉树的 bfs",charIndex:280},{level:2,title:"复杂度分析",slug:"复杂度分析",normalizedTitle:"复杂度分析",charIndex:775},{level:2,title:"应用场景",slug:"应用场景",normalizedTitle:"应用场景",charIndex:836}],headersStr:"描述 N-叉树的 BFS 复杂度分析 应用场景",content:'# 描述\n\n假设我们的树节点的定义如下：\n\ninterface NTreeNode<T> {\n  left: TreeNode | null;\n  right: TreeNode | null;\n  children: T[] | undefined;\n  data: T;\n}\n\n\n在二叉树的层序遍历时，我们即已掌握广度优先遍历，但是只是没有这样提而已。对于图这类复杂的数据结构，我们总是从当前节点出发，每次遍历当前节点的所有邻接节点（遍历一层），直至遍历完整个结构的遍历方法(即广度优先遍历（BFS: breadth-first-search）)\n\n\n# N-叉树的 BFS\n\n/**\n * N叉树广度优先遍历\n * @param {NTreeNode<number>[]} treeNodes\n */\nfunction bfs(treeNodes) {\n  if (!Array.isArray(treeNodes) || treeNodes.length === 0) {\n    console.log("treeNodes empty");\n    return;\n  }\n  const queue = [];\n  treeNodes.forEach((treeNode) => {\n    queue.push(treeNode);\n  });\n  while (queue.length) {\n    const treeNode = queue.shift();\n    console.log(treeNode.data);\n    if (Array.isArray(treeNode.children)) {\n      queue.push(...treeNode.children);\n    }\n  }\n}\n\n\n\n# 复杂度分析\n\n时间复杂度O(n)；平均空间复杂度O(m*w)，为 N-叉树的最大宽度,m为N-叉树的子节点个数;\n\n\n# 应用场景\n\n电脑中的文件目录；\n\n权限管理中的权限列表；\n\n设备管理中的设备树；\n\n前端的路由表等；',normalizedContent:'# 描述\n\n假设我们的树节点的定义如下：\n\ninterface ntreenode<t> {\n  left: treenode | null;\n  right: treenode | null;\n  children: t[] | undefined;\n  data: t;\n}\n\n\n在二叉树的层序遍历时，我们即已掌握广度优先遍历，但是只是没有这样提而已。对于图这类复杂的数据结构，我们总是从当前节点出发，每次遍历当前节点的所有邻接节点（遍历一层），直至遍历完整个结构的遍历方法(即广度优先遍历（bfs: breadth-first-search）)\n\n\n# n-叉树的 bfs\n\n/**\n * n叉树广度优先遍历\n * @param {ntreenode<number>[]} treenodes\n */\nfunction bfs(treenodes) {\n  if (!array.isarray(treenodes) || treenodes.length === 0) {\n    console.log("treenodes empty");\n    return;\n  }\n  const queue = [];\n  treenodes.foreach((treenode) => {\n    queue.push(treenode);\n  });\n  while (queue.length) {\n    const treenode = queue.shift();\n    console.log(treenode.data);\n    if (array.isarray(treenode.children)) {\n      queue.push(...treenode.children);\n    }\n  }\n}\n\n\n\n# 复杂度分析\n\n时间复杂度o(n)；平均空间复杂度o(m*w)，为 n-叉树的最大宽度,m为n-叉树的子节点个数;\n\n\n# 应用场景\n\n电脑中的文件目录；\n\n权限管理中的权限列表；\n\n设备管理中的设备树；\n\n前端的路由表等；',charsets:{cjk:!0}},{frontmatter:{},regularPath:"/javascript/es6/spread-symbol.html",relativePath:"javascript/es6/spread-symbol.md",key:"v-900bc0e2",path:"/javascript/es6/spread-symbol.html",headersStr:null,content:"",normalizedContent:"",charsets:{}},{title:"JavaScript专题",frontmatter:{title:"JavaScript专题"},regularPath:"/javascript/",relativePath:"javascript/index.md",key:"v-4b62e23a",path:"/javascript/",headersStr:null,content:" * JavaScript 专题\n * 函数上下文 this\n * 原型链\n * 继承\n * 闭包\n * Ajax",normalizedContent:" * javascript 专题\n * 函数上下文 this\n * 原型链\n * 继承\n * 闭包\n * ajax",charsets:{cjk:!0}},{title:"原型及原型链",frontmatter:{},regularPath:"/javascript/prototype.html",relativePath:"javascript/prototype.md",key:"v-5da62161",path:"/javascript/prototype.html",headers:[{level:2,title:"原型及原型链",slug:"原型及原型链",normalizedTitle:"原型及原型链",charIndex:2},{level:3,title:"__proto__ 和 prototype",slug:"proto-和-prototype",normalizedTitle:"<strong>proto</strong> 和 prototype",charIndex:null},{level:3,title:"获取或修改原型的指向关系",slug:"获取或修改原型的指向关系",normalizedTitle:"获取或修改原型的指向关系",charIndex:1591},{level:3,title:"函数与构造器",slug:"函数与构造器",normalizedTitle:"函数与构造器",charIndex:1653},{level:3,title:"ES6类继承中的原型链指向关系",slug:"es6类继承中的原型链指向关系",normalizedTitle:"es6类继承中的原型链指向关系",charIndex:3094},{level:3,title:"实际应用",slug:"实际应用",normalizedTitle:"实际应用",charIndex:6089}],headersStr:"原型及原型链 __proto__ 和 prototype 获取或修改原型的指向关系 函数与构造器 ES6类继承中的原型链指向关系 实际应用",content:'# 原型及原型链\n\nJS是一门基于原型继承的语言，并不是传统的Java，C#基于类继承的语言，这是JS较为重要的一个特征之一。\n\n虽然ES6增加了class的语法，然而class的本质还是基于原型及原型链的关系，是个语法糖而已，因此对于任何一个前端来说这个知识点是必须要掌握的。\n\n\n# __proto__ 和 prototype\n\n之前我在论坛上听大家有叫__proto__什么隐式原型对象的，我个人感觉叫什么不重要，只要你理解它能干啥就行了（就好比你说话，如果别人都能听懂了，你还去纠结什么是主语什么是谓语什么是宾语就有点儿孔乙己了），所以我一直从初学到现在任意大中小厂面试只要提到原型链我都是直接念的__proto__。\n\n# __proto__\n\n为什么说JS万物皆对象呢，我想大概就是因为它吧。\n\n已知的除了null，undefined，ø(即Object.create(null))没有这个属性以外，所有的变量都会有__proto__。为什么一个空对象（{}）能够拥有toString方法呢，因为({}).__proto__指向的是Object.prototype。\n\nJS属性的一个读取特征就是，首先它会在当前的对象上找，如果找的到的话，直接就使用，找不到就通过__proto__到它的原型对象上去找，如果还找不到，就到原型对象的原型对象上去找，如果原型对象的原型对象不存在呢？不存在的话就报错了，如：a.demo is not a function。\n\n所以，任意的数据类型的实例都指向它的原型对象，因此有：\n\n(1).__proto__ === Number.prototype;\n// 注意：NaN也是number类型\ntrue.__proto__ === Boolean.prototype;\n({}.__proto__ === Object.prototype);\nSymbol(1).__proto__ === Symbol.prototype;\n"hello world".__proto__ === String.prototype;\n(() => {}).__proto__ === Function.prototype;\n\n\n# prototype\n\n这个属性是找原型对象的钥匙，也就是说，我们要获取到一个原型对象，必须得通过prototype，我的理解就是原型对象它是放在仓库的一个工具箱，要想使用这个工具箱，首先得找仓库（即找对应的构造器），找到仓库之后，拿钥匙开门（即prototype），然后我们就可以打开这个工具箱，发现这里面有好多工具可以用。\n\n\n\n但是问题就是，不是随便一个阿猫阿狗都能拥有prototype这个属性的，想要拥有这个属性，这个对象必须是一个构造器(constructor)\n\n现在我们用一个生活中的例子来捋一捋刚才所讲的知识点之间的关系：\n\n印度尼西亚想向中国订购一列高铁（对象的实例，即instance），那么，中国中车是造高铁的工厂（构造器），高铁不是生产出来就完了，还需要有一系列维护运营的技术（即原型对象上的方法），生产的高铁上贴着标签: 中国中车制造(__proto__)，那么以后这列高铁的维护运营都可以使用中国中车提供的技术了。\n\n\n\n有一个问题就是，虽然这些高铁技术是中国中车的，但是这些技术放在那儿，但我们总感觉会被西方反华势力剽窃走，所以，我们最好希望让这些技术的专业技术人员们知道自己是归属于谁的，因此原型对象上有一个constructor属性是指向构造器的，如：\n\nObject.prototype.constructor === Object; // true\n\n\n有了这个例子之后，我们可以很容易的分清楚构造器和原型对象的关系了，如Object和Object.prototype。\n\n\n# 获取或修改原型的指向关系\n\nObject.setPrototypeOf和Object.getPrototypeOf\n\n\n# 函数与构造器\n\n# 函数\n\n上一节中，我们强调了在JS中万物皆对象，函数也是一类特殊的对象。\n\n我们定义一个函数，就生成了一个函数的实例，如：\n\nfunction Person() {}\n\n\n根据上文阐述的内容得知，函数的实例指向的是函数的原型对象，即：\n\nPerson.__proto__ === Function.prototype; // true\nPerson.prototype.constructor === Person; // true\n\n\nJS的函数除了普通的调用方式以外，还可以通过new调用以生成对象，但是通过new调用是有条件的，这个函数必须拥有prototype属性（从逻辑上讲，这样用当前函数创建对象之后才能知道是哪个工厂生产的呀），有prototype才会有constructor，而这个构造器又指向的是它自己，所以有无prototype就成为了这个函数是否能通过new调用的先决条件了。\n\n# 构造器\n\n刚才我们阐述原型对象的过程中有一个非常关键的概念还没有详细阐述，那就是constructor(基于上文所述，此处阐述的构造器譬如Object.prototype.constructor，简化描述为Object)，通过第一节的分析，它跟原型对象，存在一定的关系，但是肯定不是一个东西，（最开始我们只阐述了3个没有原型对象的类型），那它指向的是谁呢？答案是函数原型对象(Function.prototype)。\n\n任意一个构造器都是函数原型对象的实例，即：\n\nObject.__proto__ === Function.prototype; // true\nNumber.__proto__ === Function.prototype; // true\nBoolean.__proto__ === Function.prototype; // true\nString.__proto__ === Function.prototype; // true\nSymbol.__proto__ === Function.prototype; // true\nArray.__proto__ === Function.prototype; // true\n\n\n上面还有一个关键的指向关系没有阐述,容我卖个关子。\n\n我们已经得出结论，任意一个构造器都是函数原型对象的实例，请问Function是构造器吗？ 毫无疑问必须得是啊，既然是，那就应该符合我们这个结论，即：\n\nFunction.__proto__ === Function.prototype; // true\n\n\n曾经很长一段时间，我都是把这个指向关系当结论给记住的，其实经过上述的一通分析，完全没有必要死记硬背啦。\n\n所以，我们就可以画出一个比较全面的指向关系：\n\n\n\n再来个更复杂一点儿的，加一个自定义的函数试试：\n\nfunction Person() {}\n\nPerson.prototype.getName = function () {\n  return "JohnYang";\n};\n\nlet p = new Person();\n\n\n把Person和p加到我们刚才的图中去，得到的关系如下：\n\n\n\nDANGER\n\n箭头函数是一类特殊的函数，其没有prototype，导致其不存在constructor，因此不能通过new调用。\n\n打个比方，箭头函数就好像是一只做了绝育手术的猫。\n\n\n# ES6类继承中的原型链指向关系\n\n本文不阐述class的语法，如果还不了解的朋友可以先行查阅相关资料。\n\n假设现在有如下两个类，并且有继承关系：\n\nclass Parent {\n  static aaa;\n\n  bbb() {\n    console.log("hello world");\n  }\n}\n\nclass Child extends Parent {\n  bbb() {\n    super.bbb();\n    console.log("hello world 222");\n  }\n}\n\n\n接下来看一下经过babel编译之后的结果，为了节约篇幅，只贴比较关键的部分。\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== "function" && superClass !== null) {\n    throw new TypeError("Super expression must either be null or a function");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });\n  Object.defineProperty(subClass, "prototype", { writable: false });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, "prototype", { writable: false });\n  return Constructor;\n}\n\nvar Parent = /*#__PURE__*/ (function () {\n  function Parent() {\n    _classCallCheck(this, Parent);\n  }\n\n  _createClass(Parent, [\n    {\n      key: "bbb",\n      value: function bbb() {\n        console.log("hello world");\n      },\n    },\n  ]);\n\n  return Parent;\n})();\n\n\n_defineProperty(Parent, "aaa", void 0);\n\nvar Child = /*#__PURE__*/ (function (_Parent) {\n  _inherits(Child, _Parent);\n\n  var _super = _createSuper(Child);\n\n  function Child() {\n    _classCallCheck(this, Child);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Child, [\n    {\n      key: "bbb",\n      value: function bbb() {\n        _get(_getPrototypeOf(Child.prototype), "bbb", this).call(this);\n\n        console.log("hello world 222");\n      },\n    },\n  ]);\n\n  return Child;\n})(Parent);\n\n\n从编译的结果看，凡是带static的关键字的都给添加到了构造器上，没有static关键字的都添加到了原型对象上。\n\n最关键的一个方法是_inherits，其中：\n\nsubClass.prototype = Object.create(superClass && superClass.prototype, {\n  constructor: { value: subClass, writable: true, configurable: true },\n});\n/**\n Object.create: 创建一个以什么对象为原型的对象，即可以理解为：\n subClass.prototype.__proto__ === superClass.prototype // true\n */\n_setPrototypeOf(subClass, superClass);\n\n/**\n  subClass.__proto__ === superClass // true\n */\n\n\nTIP\n\n在ES6中，**子类.__proto__ === 父类， 子类的原型对象.__proto__ === 父类的原型对象 **\n\n其实这个结论从我们的实际开发中也体验的出来，static属性可以被继承，那么必然存在子类.__proto__ === 父类，非 static 属性也可以被继承（均非私有）当我们初始化一个子类的实例的时候，必然存在 ins.__proto__ 指向 Child.prototype，Child.prototype.__proto__指向Parent.prototype\n\n\n# 实际应用\n\n对于应付面试八股文非我们学习的本意，学习的目的还是为了提高生产力\n\n# 1、 实现instanceof\n\ninstanceof的原理就是判断输入参数的__proto__在不断向其原型链上迭代的过程中，最终是否指向构造器关联的原型对象。\n\nfunction MyInstanceOf(child, parent) {\n  if (!parent || !parent.prototype) {\n    throw `the instanceof must apply to compare two object`;\n  }\n  let flag = false;\n  while (child) {\n    if (child.__proto__ === parent.prototype) {\n      flag = true;\n      break;\n    }\n    child = child.__proto__;\n  }\n  return flag;\n}\n\n\n# 2、面向切面编程\n\n这是一个在实际开发中非常有价值的应用。\n\n现在某个团队提供给你了一个包和这个包的API，这个包是被压缩过的，你没有修改包源码的权利，但是某个方法A我们发现它不完全满足我们的业务场景，怎么办呢？其实挺好办的，修改原型链，给它追加一层我们自己的业务逻辑控制，并且不改变它本身的实现，这就是常提到的面向切面编程（或者说是装饰模式也行）。\n\nimport lib from "@xxx/xxx-sdk";\nconst enhancedLib = {\n  /* 注意：不能写成 init: function() {} */\n  init() {\n    // 不侵入库本来的代码\n    typeof super.init === "function" && super.init.apply(this, arguments);\n    // 扩展当前特殊的业务\n    console.log("Initialized");\n  },\n};\n// 让增强的对象的__prototo__指向库\nObject.setPrototypeOf(enhancedLib, Lib);\nexport default enhancedLib;\n\n\nDANGER\n\nsuper关键字必须要在类中或者要将对象的方法写成ES6方法的简写形式才可使用。',normalizedContent:'# 原型及原型链\n\njs是一门基于原型继承的语言，并不是传统的java，c#基于类继承的语言，这是js较为重要的一个特征之一。\n\n虽然es6增加了class的语法，然而class的本质还是基于原型及原型链的关系，是个语法糖而已，因此对于任何一个前端来说这个知识点是必须要掌握的。\n\n\n# __proto__ 和 prototype\n\n之前我在论坛上听大家有叫__proto__什么隐式原型对象的，我个人感觉叫什么不重要，只要你理解它能干啥就行了（就好比你说话，如果别人都能听懂了，你还去纠结什么是主语什么是谓语什么是宾语就有点儿孔乙己了），所以我一直从初学到现在任意大中小厂面试只要提到原型链我都是直接念的__proto__。\n\n# __proto__\n\n为什么说js万物皆对象呢，我想大概就是因为它吧。\n\n已知的除了null，undefined，ø(即object.create(null))没有这个属性以外，所有的变量都会有__proto__。为什么一个空对象（{}）能够拥有tostring方法呢，因为({}).__proto__指向的是object.prototype。\n\njs属性的一个读取特征就是，首先它会在当前的对象上找，如果找的到的话，直接就使用，找不到就通过__proto__到它的原型对象上去找，如果还找不到，就到原型对象的原型对象上去找，如果原型对象的原型对象不存在呢？不存在的话就报错了，如：a.demo is not a function。\n\n所以，任意的数据类型的实例都指向它的原型对象，因此有：\n\n(1).__proto__ === number.prototype;\n// 注意：nan也是number类型\ntrue.__proto__ === boolean.prototype;\n({}.__proto__ === object.prototype);\nsymbol(1).__proto__ === symbol.prototype;\n"hello world".__proto__ === string.prototype;\n(() => {}).__proto__ === function.prototype;\n\n\n# prototype\n\n这个属性是找原型对象的钥匙，也就是说，我们要获取到一个原型对象，必须得通过prototype，我的理解就是原型对象它是放在仓库的一个工具箱，要想使用这个工具箱，首先得找仓库（即找对应的构造器），找到仓库之后，拿钥匙开门（即prototype），然后我们就可以打开这个工具箱，发现这里面有好多工具可以用。\n\n\n\n但是问题就是，不是随便一个阿猫阿狗都能拥有prototype这个属性的，想要拥有这个属性，这个对象必须是一个构造器(constructor)\n\n现在我们用一个生活中的例子来捋一捋刚才所讲的知识点之间的关系：\n\n印度尼西亚想向中国订购一列高铁（对象的实例，即instance），那么，中国中车是造高铁的工厂（构造器），高铁不是生产出来就完了，还需要有一系列维护运营的技术（即原型对象上的方法），生产的高铁上贴着标签: 中国中车制造(__proto__)，那么以后这列高铁的维护运营都可以使用中国中车提供的技术了。\n\n\n\n有一个问题就是，虽然这些高铁技术是中国中车的，但是这些技术放在那儿，但我们总感觉会被西方反华势力剽窃走，所以，我们最好希望让这些技术的专业技术人员们知道自己是归属于谁的，因此原型对象上有一个constructor属性是指向构造器的，如：\n\nobject.prototype.constructor === object; // true\n\n\n有了这个例子之后，我们可以很容易的分清楚构造器和原型对象的关系了，如object和object.prototype。\n\n\n# 获取或修改原型的指向关系\n\nobject.setprototypeof和object.getprototypeof\n\n\n# 函数与构造器\n\n# 函数\n\n上一节中，我们强调了在js中万物皆对象，函数也是一类特殊的对象。\n\n我们定义一个函数，就生成了一个函数的实例，如：\n\nfunction person() {}\n\n\n根据上文阐述的内容得知，函数的实例指向的是函数的原型对象，即：\n\nperson.__proto__ === function.prototype; // true\nperson.prototype.constructor === person; // true\n\n\njs的函数除了普通的调用方式以外，还可以通过new调用以生成对象，但是通过new调用是有条件的，这个函数必须拥有prototype属性（从逻辑上讲，这样用当前函数创建对象之后才能知道是哪个工厂生产的呀），有prototype才会有constructor，而这个构造器又指向的是它自己，所以有无prototype就成为了这个函数是否能通过new调用的先决条件了。\n\n# 构造器\n\n刚才我们阐述原型对象的过程中有一个非常关键的概念还没有详细阐述，那就是constructor(基于上文所述，此处阐述的构造器譬如object.prototype.constructor，简化描述为object)，通过第一节的分析，它跟原型对象，存在一定的关系，但是肯定不是一个东西，（最开始我们只阐述了3个没有原型对象的类型），那它指向的是谁呢？答案是函数原型对象(function.prototype)。\n\n任意一个构造器都是函数原型对象的实例，即：\n\nobject.__proto__ === function.prototype; // true\nnumber.__proto__ === function.prototype; // true\nboolean.__proto__ === function.prototype; // true\nstring.__proto__ === function.prototype; // true\nsymbol.__proto__ === function.prototype; // true\narray.__proto__ === function.prototype; // true\n\n\n上面还有一个关键的指向关系没有阐述,容我卖个关子。\n\n我们已经得出结论，任意一个构造器都是函数原型对象的实例，请问function是构造器吗？ 毫无疑问必须得是啊，既然是，那就应该符合我们这个结论，即：\n\nfunction.__proto__ === function.prototype; // true\n\n\n曾经很长一段时间，我都是把这个指向关系当结论给记住的，其实经过上述的一通分析，完全没有必要死记硬背啦。\n\n所以，我们就可以画出一个比较全面的指向关系：\n\n\n\n再来个更复杂一点儿的，加一个自定义的函数试试：\n\nfunction person() {}\n\nperson.prototype.getname = function () {\n  return "johnyang";\n};\n\nlet p = new person();\n\n\n把person和p加到我们刚才的图中去，得到的关系如下：\n\n\n\ndanger\n\n箭头函数是一类特殊的函数，其没有prototype，导致其不存在constructor，因此不能通过new调用。\n\n打个比方，箭头函数就好像是一只做了绝育手术的猫。\n\n\n# es6类继承中的原型链指向关系\n\n本文不阐述class的语法，如果还不了解的朋友可以先行查阅相关资料。\n\n假设现在有如下两个类，并且有继承关系：\n\nclass parent {\n  static aaa;\n\n  bbb() {\n    console.log("hello world");\n  }\n}\n\nclass child extends parent {\n  bbb() {\n    super.bbb();\n    console.log("hello world 222");\n  }\n}\n\n\n接下来看一下经过babel编译之后的结果，为了节约篇幅，只贴比较关键的部分。\n\nfunction _inherits(subclass, superclass) {\n  if (typeof superclass !== "function" && superclass !== null) {\n    throw new typeerror("super expression must either be null or a function");\n  }\n  subclass.prototype = object.create(superclass && superclass.prototype, { constructor: { value: subclass, writable: true, configurable: true } });\n  object.defineproperty(subclass, "prototype", { writable: false });\n  if (superclass) _setprototypeof(subclass, superclass);\n}\n\nfunction _createsuper(derived) {\n  var hasnativereflectconstruct = _isnativereflectconstruct();\n  return function _createsuperinternal() {\n    var super = _getprototypeof(derived),\n      result;\n    if (hasnativereflectconstruct) {\n      var newtarget = _getprototypeof(this).constructor;\n      result = reflect.construct(super, arguments, newtarget);\n    } else {\n      result = super.apply(this, arguments);\n    }\n    return _possibleconstructorreturn(this, result);\n  };\n}\n\nfunction _createclass(constructor, protoprops, staticprops) {\n  if (protoprops) _defineproperties(constructor.prototype, protoprops);\n  if (staticprops) _defineproperties(constructor, staticprops);\n  object.defineproperty(constructor, "prototype", { writable: false });\n  return constructor;\n}\n\nvar parent = /*#__pure__*/ (function () {\n  function parent() {\n    _classcallcheck(this, parent);\n  }\n\n  _createclass(parent, [\n    {\n      key: "bbb",\n      value: function bbb() {\n        console.log("hello world");\n      },\n    },\n  ]);\n\n  return parent;\n})();\n\n\n_defineproperty(parent, "aaa", void 0);\n\nvar child = /*#__pure__*/ (function (_parent) {\n  _inherits(child, _parent);\n\n  var _super = _createsuper(child);\n\n  function child() {\n    _classcallcheck(this, child);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createclass(child, [\n    {\n      key: "bbb",\n      value: function bbb() {\n        _get(_getprototypeof(child.prototype), "bbb", this).call(this);\n\n        console.log("hello world 222");\n      },\n    },\n  ]);\n\n  return child;\n})(parent);\n\n\n从编译的结果看，凡是带static的关键字的都给添加到了构造器上，没有static关键字的都添加到了原型对象上。\n\n最关键的一个方法是_inherits，其中：\n\nsubclass.prototype = object.create(superclass && superclass.prototype, {\n  constructor: { value: subclass, writable: true, configurable: true },\n});\n/**\n object.create: 创建一个以什么对象为原型的对象，即可以理解为：\n subclass.prototype.__proto__ === superclass.prototype // true\n */\n_setprototypeof(subclass, superclass);\n\n/**\n  subclass.__proto__ === superclass // true\n */\n\n\ntip\n\n在es6中，**子类.__proto__ === 父类， 子类的原型对象.__proto__ === 父类的原型对象 **\n\n其实这个结论从我们的实际开发中也体验的出来，static属性可以被继承，那么必然存在子类.__proto__ === 父类，非 static 属性也可以被继承（均非私有）当我们初始化一个子类的实例的时候，必然存在 ins.__proto__ 指向 child.prototype，child.prototype.__proto__指向parent.prototype\n\n\n# 实际应用\n\n对于应付面试八股文非我们学习的本意，学习的目的还是为了提高生产力\n\n# 1、 实现instanceof\n\ninstanceof的原理就是判断输入参数的__proto__在不断向其原型链上迭代的过程中，最终是否指向构造器关联的原型对象。\n\nfunction myinstanceof(child, parent) {\n  if (!parent || !parent.prototype) {\n    throw `the instanceof must apply to compare two object`;\n  }\n  let flag = false;\n  while (child) {\n    if (child.__proto__ === parent.prototype) {\n      flag = true;\n      break;\n    }\n    child = child.__proto__;\n  }\n  return flag;\n}\n\n\n# 2、面向切面编程\n\n这是一个在实际开发中非常有价值的应用。\n\n现在某个团队提供给你了一个包和这个包的api，这个包是被压缩过的，你没有修改包源码的权利，但是某个方法a我们发现它不完全满足我们的业务场景，怎么办呢？其实挺好办的，修改原型链，给它追加一层我们自己的业务逻辑控制，并且不改变它本身的实现，这就是常提到的面向切面编程（或者说是装饰模式也行）。\n\nimport lib from "@xxx/xxx-sdk";\nconst enhancedlib = {\n  /* 注意：不能写成 init: function() {} */\n  init() {\n    // 不侵入库本来的代码\n    typeof super.init === "function" && super.init.apply(this, arguments);\n    // 扩展当前特殊的业务\n    console.log("initialized");\n  },\n};\n// 让增强的对象的__prototo__指向库\nobject.setprototypeof(enhancedlib, lib);\nexport default enhancedlib;\n\n\ndanger\n\nsuper关键字必须要在类中或者要将对象的方法写成es6方法的简写形式才可使用。',charsets:{cjk:!0}},{frontmatter:{},regularPath:"/javascript/write/EventEmitter.html",relativePath:"javascript/write/EventEmitter.md",key:"v-4f9c3516",path:"/javascript/write/EventEmitter.html",headersStr:null,content:"",normalizedContent:"",charsets:{}},{title:"Class 的前世今生",frontmatter:{},regularPath:"/javascript/es6/class.html",relativePath:"javascript/es6/class.md",key:"v-b548d0fa",path:"/javascript/es6/class.html",headers:[{level:2,title:"Class 的前世今生",slug:"class-的前世今生",normalizedTitle:"class 的前世今生",charIndex:2},{level:2,title:"Class 的基础语法",slug:"class-的基础语法",normalizedTitle:"class 的基础语法",charIndex:273},{level:2,title:"Class 的 constructor 方法",slug:"class-的-constructor-方法",normalizedTitle:"class 的 constructor 方法",charIndex:1217},{level:2,title:"Class 的静态属性和方法",slug:"class-的静态属性和方法",normalizedTitle:"class 的静态属性和方法",charIndex:1475},{level:2,title:"Class 的私有属性和私有方法",slug:"class-的私有属性和私有方法",normalizedTitle:"class 的私有属性和私有方法",charIndex:1827},{level:2,title:"Class 的 getter 和 setter",slug:"class-的-getter-和-setter",normalizedTitle:"class 的 getter 和 setter",charIndex:2543},{level:2,title:"Class 的静态块",slug:"class-的静态块",normalizedTitle:"class 的静态块",charIndex:4105},{level:2,title:"Class 的继承",slug:"class-的继承",normalizedTitle:"class 的继承",charIndex:4834},{level:3,title:"super 关键字",slug:"super-关键字",normalizedTitle:"super 关键字",charIndex:7311},{level:2,title:"Class 的一些注意点",slug:"class-的一些注意点",normalizedTitle:"class 的一些注意点",charIndex:8322}],headersStr:"Class 的前世今生 Class 的基础语法 Class 的 constructor 方法 Class 的静态属性和方法 Class 的私有属性和私有方法 Class 的 getter 和 setter Class 的静态块 Class 的继承 super 关键字 Class 的一些注意点",content:'# Class 的前世今生\n\nJS是一门基于原型继承的语言，对于熟悉C#，Java等语言的人来说，理解起来相当费解(我在学习JS的初期几乎是以完全忘记C#语法的姿态去学习的)，随着现代 Web 技术的发展（尤其是nodejs的出现），我们的项目也变得越来越庞大，维护成本也变得越来越高，因此 TC39 委员会也致力于将JS向一门完备的工业化语言迈进，因此就引入了ES的下一代版本，即ES6。\n\n其中相当令人兴奋的一个特性便是引入了Class这一语法糖，使得我们可以不用再费力的去基于原型，控制JS代码的一些行为，对于初学者也更加的友好。\n\n\n# Class 的基础语法\n\nclass Person {\n  name = "awesome boy";\n\n  age = 18;\n\n  constructor(hobby) {\n    this.hobby = hobby;\n  }\n\n  run() {\n    console.log("I can run");\n  }\n\n  say() {\n    if (this.hobby) {\n      console.log("I can say, I like " + this.hobby);\n      return;\n    }\n    console.log("I can say");\n  }\n\n  inspect() {\n    console.log(this);\n  }\n}\n\nconst xiaoming = new Person("Java");\nxiaoming.say();\nxiaoming.run();\n\n\n上述代码我们便定义了一个Person，其中name和age叫做类的属性，run和say叫做类的方法，使用起来和ES5完全一致，如果改写成ES5的代码，大致如下。如果不修改类的方法的this指向的话，方法中this默认指向类的实例对象。\n\nfunction Person(hobby) {\n  this.name = "awesome boy";\n  this.age = 18;\n  this.hobby = hobby;\n}\n\nPerson.prototype.say = function () {\n  if (this.hobby) {\n    console.log("I can say, I like " + this.hobby);\n    return;\n  }\n  console.log("I can say");\n};\n\nPerson.prototype.run = function () {\n  console.log("I can run");\n};\n\n\nWARNING\n\n需要注意的一点儿就是，类中的方法是归属于类的实例对象的原型对象上的，并不在实例本身上，因此增加say和run方法不能直接写在构造函数内部。\n\n\n# Class 的 constructor 方法\n\n用法和 Java 和 C#一样，当我们需要在类初始化的时候传递一些参数就需要用到构造函数，默认构造函数是可以不写的。\n\n如果在使用类实现继承的时候，一旦写了构造函数就必须要在构造函数中首先调用父类的构造函数（仍然默认可以不写）\n\nclass Person {}\n\nclass Male extends Person {\n  constructor() {\n    super();\n    console.log("hello world");\n  }\n}\n\n\n\n# Class 的静态属性和方法\n\n对于静态属性和方法，其实也没有什么好神秘的，其实就是加了一个static关键字，使得这个属性或者方法归属于这个类本身，而不再归属于类的实例对象。\n\nclass Person {\n  static version = "0.0.1";\n\n  static bootstrap() {\n    console.log("I am alive");\n  }\n}\n\n\n上述改写成ES5的代码的话，即:\n\nfunction Person() {}\n\nPerson.version = "0.0.1";\n\nPerson.bootstrap = function () {\n  console.log("I am alive");\n};\n\n\n静态方法中this默认指向类本身。\n\n\n# Class 的私有属性和私有方法\n\n像Java，C# 甚至TS都有私有属性或者私有方法，并且是使用private，不过这个设想最终还是没有落到JS的语法上，JS类的私有属性和方法比较杀马特，需要在前面加入一个#，以表示这是一个私有的字段，如：\n\nclass Person {\n  #salary = 1800;\n\n  #settleSalary() {\n    console.log("月入1800，每天笑哈哈，月入3800，拿命往里搭");\n  }\n}\n\n\n私有字段只有在类的内部才能访问的到，一旦出了类，就无法访问了，你可以简单的理解为在类的这两个{}之前可以访问到，除此之外再也无法访问到了。\n\n至于这个是怎么实现的，就需要更高级的语法了，ES6中引入了一个叫做WeakMap的接口，而class的私有字段便是基于这个实现的。\n\n"use strict";\n\nvar _background = new WeakMap();\n\nvar Point = /*#__PURE__*/ (function () {\n  function Point(x, y) {\n    _background.set(this, {\n      writable: true,\n      value: "red",\n    });\n  }\n\n  return Point;\n})();\n\n\n对于每一个私有字段，都声明一个WeakMap来控制，每个WeakMap挂载的key为当前类，因此，一旦出了类，再也访问不到它，因为WeakMap不会增加对象的引用计数，一旦这个类销毁了，那么这个WeakMap也随之销毁了，不会造成内存泄露。\n\n\n# Class 的 getter 和 setter\n\n因为有私有属性，有些时候，我们仅仅想让外界读取而不能改写(只读)或者只写的时候就需要用到getter或者setter。\n\nclass Person {\n  #_salary = 0;\n\n  get salary() {\n    return this.#_salary;\n  }\n\n  set salary(value) {\n    if (value <= 0) {\n      console.warn("薪资不能是负值");\n      return;\n    }\n    this.#_salary = value;\n  }\n}\n\n\ngetter和setter其实对应的就是ES5提供的Object.defineProperty方法中的get和set\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if ("value" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, "prototype", { writable: false });\n  return Constructor;\n}\n\nvar Person = /*#__PURE__*/ (function () {\n  function Person() {\n    _classCallCheck(this, Person);\n\n    _classPrivateFieldInitSpec(this, _salary, {\n      writable: true,\n      value: 0,\n    });\n  }\n\n  _createClass(Person, [\n    {\n      key: "salary",\n      get: function get() {\n        return _classPrivateFieldGet(this, _salary);\n      },\n      set: function set(value) {\n        if (value <= 0) {\n          console.warn("薪资不能是负值");\n          return;\n        }\n\n        _classPrivateFieldSet(this, _salary, value);\n      },\n    },\n  ]);\n\n  return Person;\n})();\n\n\n\n# Class 的静态块\n\n这是在ES2021中增加的内容，主要目的是对静态属性进行初始化，因为在这之前，静态属性的一个问题是，如果它有初始化逻辑，这个逻辑要么写在类的外部，要么写在constructor()方法里面。后者带来的问题是每次这个类初始化实例的时候都会执行一遍。前者的问题是使得代码的内聚性降低，不利于维护。\n\nclass Position {\n  static x;\n  static y;\n  static z;\n\n  static {\n    // 模拟一些初始化的操作\n    this.x = 1;\n    this.y = 2;\n    this.z = 3;\n  }\n}\n\n\n在类生成时运行且只运行一次，以后，新建类的实例时，这个块就不运行了。\n\n转化为ES5的语法大致如下：\n\nvar Position = /*#__PURE__*/ _createClass(function Position() {\n  _classCallCheck(this, Position);\n});\n\n_defineProperty(Position, "x", void 0);\n\n_defineProperty(Position, "y", void 0);\n\n_defineProperty(Position, "z", void 0);\n\n(function () {\n  // 模拟一些初始化的操作\n  Position.x = 1;\n  Position.y = 2;\n  Position.z = 3;\n})();\n\n\n用一个立即执行函数初始化这些操作，解决了写在构造器执行多次的问题，本质上是初始化逻辑写在类的外部的语法糖。\n\n\n# Class 的继承\n\n使用 Class 继承完美的解决了早期 ES 种继承的问题，而且语法相当简单，就一个extends就搞定了。\n\n我们先以数学定理的形式先记住继承中父类子类之间的属性和方法的关系\n\n * 1、子类可以继承父类中所有的非私有属性和方法\n * 2、子类可以继承父类中所有的非私有静态属性和静态方法\n\n假设有如下继承关系\n\nclass Base {\n  name = "111";\n\n  age = 222;\n\n  say() {\n    console.log("base say");\n  }\n\n  run() {\n    console.log("base run");\n  }\n}\n\nclass Sub extends Base {\n  run() {\n    console.log("sub run");\n  }\n}\n\nconst parent = new Base();\nconst child = new Sub();\nchild.run();\nconsole.log(child.name);\n\n\n我们根据第一条定理来推导第一条原型指向关系：\n\nSub.prototype.__proto__ === Base.prototype;\n\n\n为什么是这样，根据上文阐述，我们知道，所有的类的方法都挂载类的原型对象上的，既然当前类能够访问到父类的所有方法，当前类方法定义的位置在Sub.prototype，既然 JS 引擎取值不会报错，那么自然这个原型对象的原型是父类的原型对象。\n\n那么，属性是怎么继承来的呢？\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, "prototype", { writable: false });\n  return Constructor;\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nvar Base = /*#__PURE__*/ (function () {\n  function Base() {\n    _classCallCheck(this, Base);\n\n    _defineProperty(this, "name", "111");\n\n    _defineProperty(this, "age", 222);\n  }\n\n  _createClass(Base, [\n    {\n      key: "say",\n      value: function say() {\n        console.log("base say");\n      },\n    },\n    {\n      key: "run",\n      value: function run() {\n        console.log("base run");\n      },\n    },\n  ]);\n\n  return Base;\n})();\n\nvar Sub = /*#__PURE__*/ (function (_Base) {\n  _inherits(Sub, _Base);\n\n  var _super = _createSuper(Sub);\n\n  function Sub() {\n    _classCallCheck(this, Sub);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Sub, [\n    {\n      key: "run",\n      value: function run() {\n        console.log("sub run");\n      },\n    },\n  ]);\n\n  return Sub;\n})(Base);\n\n\n关键就是看_createSuper这个辅助函数，其返回一个函数，其直接调用了一次Super，相当于我们得到的是一个把当前类上所有属性完成拷贝的对象，这就避免了多个子类继承同一个父类的时候，共用一个父类的属性的问题\n\n接着，我们根据第二条定理来推导的第二条原型指向关系：\n\nSub.__proto__ = Base;\n\n\n为什么是这样，根据上文阐述，我们知道，所有类的静态属性或者方法都挂载在类本身的，既然 JS 引擎取值不会报错，那么自然这个类的原型是父类。\n\n\n# super 关键字\n\n上述代码中我们可以看到，当子类中方法和父类重名的时候，会出现一种比较奇妙的现象，我们回想一下 JS 对象的属性访问规则，当前对象上有名为 xxx 的方法，便不会向上查找了，子类已经完全修改了父类的行为，专业术语叫做重写或者覆盖，这个语法特性在面向对象程序设计中有相当大的应用，比如常见的设计模式：模板方法模式、策略模式、命令模式等都可以看到这个特性的应用。\n\nclass Strategy {\n  run() {\n    console.log("base run");\n  }\n}\n\nclass SimpleStrategy extends Strategy {\n  run() {\n    console.log("sub run");\n  }\n}\n\nclass ComplexStrategy extends Strategy() {\n  run() {\n    console.log("sub run");\n  }\n}\n\nfunction selectStrategy(mode) {\n  let stg = null;\n  switch (mode) {\n    case "simple":\n      stg = new SimleStrategy();\n      break;\n    case "multi":\n      stg = new ComplexStrategy();\n      break;\n  }\n  return stg;\n}\n\nclass Bootstrap {\n  runner() {\n    const stg = selectStrategy(import.meta.env.STRATEGY);\n    stg.run();\n  }\n}\n\n\n若我们又不想完全覆盖父类的行为呢，比如某些时候，我们得到的一个 SDK 已经提供了某些功能，但是这个功能又不完全满足我们的业务，我们需要针对我们的业务定制化，此刻就可以使得super关键字派上用场了。\n\nclass Base {\n  run() {\n    console.log("base run");\n  }\n}\n\nclass Sub extends Base {\n  run() {\n    super.run();\n    console.log("sub run");\n  }\n}\n\n\n\n# Class 的一些注意点\n\n * 类和模块的内部，默认就是严格模式\n * 类的方法内部如果含有this，它默认指向类的实例，但是并不意味着就是绝对安全的，比如有些老六\n\nclass Person {\n  name = "yx";\n\n  say() {\n    console.log(this.name);\n  }\n}\nconst p = new Person();\nconst say = p.say;\n// Uncaught TypeError: Cannot read properties of undefined\nsay();\n\n\n * 类不存在提升\n * 类中有一个名为new.target的属性，这个属性在初始化的时候指向的是类本身，因此可以用这个属性判断类是否使用new调用，即便子类继承了父类，在父类中，new.target仍然指向子类。',normalizedContent:'# class 的前世今生\n\njs是一门基于原型继承的语言，对于熟悉c#，java等语言的人来说，理解起来相当费解(我在学习js的初期几乎是以完全忘记c#语法的姿态去学习的)，随着现代 web 技术的发展（尤其是nodejs的出现），我们的项目也变得越来越庞大，维护成本也变得越来越高，因此 tc39 委员会也致力于将js向一门完备的工业化语言迈进，因此就引入了es的下一代版本，即es6。\n\n其中相当令人兴奋的一个特性便是引入了class这一语法糖，使得我们可以不用再费力的去基于原型，控制js代码的一些行为，对于初学者也更加的友好。\n\n\n# class 的基础语法\n\nclass person {\n  name = "awesome boy";\n\n  age = 18;\n\n  constructor(hobby) {\n    this.hobby = hobby;\n  }\n\n  run() {\n    console.log("i can run");\n  }\n\n  say() {\n    if (this.hobby) {\n      console.log("i can say, i like " + this.hobby);\n      return;\n    }\n    console.log("i can say");\n  }\n\n  inspect() {\n    console.log(this);\n  }\n}\n\nconst xiaoming = new person("java");\nxiaoming.say();\nxiaoming.run();\n\n\n上述代码我们便定义了一个person，其中name和age叫做类的属性，run和say叫做类的方法，使用起来和es5完全一致，如果改写成es5的代码，大致如下。如果不修改类的方法的this指向的话，方法中this默认指向类的实例对象。\n\nfunction person(hobby) {\n  this.name = "awesome boy";\n  this.age = 18;\n  this.hobby = hobby;\n}\n\nperson.prototype.say = function () {\n  if (this.hobby) {\n    console.log("i can say, i like " + this.hobby);\n    return;\n  }\n  console.log("i can say");\n};\n\nperson.prototype.run = function () {\n  console.log("i can run");\n};\n\n\nwarning\n\n需要注意的一点儿就是，类中的方法是归属于类的实例对象的原型对象上的，并不在实例本身上，因此增加say和run方法不能直接写在构造函数内部。\n\n\n# class 的 constructor 方法\n\n用法和 java 和 c#一样，当我们需要在类初始化的时候传递一些参数就需要用到构造函数，默认构造函数是可以不写的。\n\n如果在使用类实现继承的时候，一旦写了构造函数就必须要在构造函数中首先调用父类的构造函数（仍然默认可以不写）\n\nclass person {}\n\nclass male extends person {\n  constructor() {\n    super();\n    console.log("hello world");\n  }\n}\n\n\n\n# class 的静态属性和方法\n\n对于静态属性和方法，其实也没有什么好神秘的，其实就是加了一个static关键字，使得这个属性或者方法归属于这个类本身，而不再归属于类的实例对象。\n\nclass person {\n  static version = "0.0.1";\n\n  static bootstrap() {\n    console.log("i am alive");\n  }\n}\n\n\n上述改写成es5的代码的话，即:\n\nfunction person() {}\n\nperson.version = "0.0.1";\n\nperson.bootstrap = function () {\n  console.log("i am alive");\n};\n\n\n静态方法中this默认指向类本身。\n\n\n# class 的私有属性和私有方法\n\n像java，c# 甚至ts都有私有属性或者私有方法，并且是使用private，不过这个设想最终还是没有落到js的语法上，js类的私有属性和方法比较杀马特，需要在前面加入一个#，以表示这是一个私有的字段，如：\n\nclass person {\n  #salary = 1800;\n\n  #settlesalary() {\n    console.log("月入1800，每天笑哈哈，月入3800，拿命往里搭");\n  }\n}\n\n\n私有字段只有在类的内部才能访问的到，一旦出了类，就无法访问了，你可以简单的理解为在类的这两个{}之前可以访问到，除此之外再也无法访问到了。\n\n至于这个是怎么实现的，就需要更高级的语法了，es6中引入了一个叫做weakmap的接口，而class的私有字段便是基于这个实现的。\n\n"use strict";\n\nvar _background = new weakmap();\n\nvar point = /*#__pure__*/ (function () {\n  function point(x, y) {\n    _background.set(this, {\n      writable: true,\n      value: "red",\n    });\n  }\n\n  return point;\n})();\n\n\n对于每一个私有字段，都声明一个weakmap来控制，每个weakmap挂载的key为当前类，因此，一旦出了类，再也访问不到它，因为weakmap不会增加对象的引用计数，一旦这个类销毁了，那么这个weakmap也随之销毁了，不会造成内存泄露。\n\n\n# class 的 getter 和 setter\n\n因为有私有属性，有些时候，我们仅仅想让外界读取而不能改写(只读)或者只写的时候就需要用到getter或者setter。\n\nclass person {\n  #_salary = 0;\n\n  get salary() {\n    return this.#_salary;\n  }\n\n  set salary(value) {\n    if (value <= 0) {\n      console.warn("薪资不能是负值");\n      return;\n    }\n    this.#_salary = value;\n  }\n}\n\n\ngetter和setter其实对应的就是es5提供的object.defineproperty方法中的get和set\n\nfunction _defineproperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if ("value" in descriptor) descriptor.writable = true;\n    object.defineproperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createclass(constructor, protoprops, staticprops) {\n  if (protoprops) _defineproperties(constructor.prototype, protoprops);\n  if (staticprops) _defineproperties(constructor, staticprops);\n  object.defineproperty(constructor, "prototype", { writable: false });\n  return constructor;\n}\n\nvar person = /*#__pure__*/ (function () {\n  function person() {\n    _classcallcheck(this, person);\n\n    _classprivatefieldinitspec(this, _salary, {\n      writable: true,\n      value: 0,\n    });\n  }\n\n  _createclass(person, [\n    {\n      key: "salary",\n      get: function get() {\n        return _classprivatefieldget(this, _salary);\n      },\n      set: function set(value) {\n        if (value <= 0) {\n          console.warn("薪资不能是负值");\n          return;\n        }\n\n        _classprivatefieldset(this, _salary, value);\n      },\n    },\n  ]);\n\n  return person;\n})();\n\n\n\n# class 的静态块\n\n这是在es2021中增加的内容，主要目的是对静态属性进行初始化，因为在这之前，静态属性的一个问题是，如果它有初始化逻辑，这个逻辑要么写在类的外部，要么写在constructor()方法里面。后者带来的问题是每次这个类初始化实例的时候都会执行一遍。前者的问题是使得代码的内聚性降低，不利于维护。\n\nclass position {\n  static x;\n  static y;\n  static z;\n\n  static {\n    // 模拟一些初始化的操作\n    this.x = 1;\n    this.y = 2;\n    this.z = 3;\n  }\n}\n\n\n在类生成时运行且只运行一次，以后，新建类的实例时，这个块就不运行了。\n\n转化为es5的语法大致如下：\n\nvar position = /*#__pure__*/ _createclass(function position() {\n  _classcallcheck(this, position);\n});\n\n_defineproperty(position, "x", void 0);\n\n_defineproperty(position, "y", void 0);\n\n_defineproperty(position, "z", void 0);\n\n(function () {\n  // 模拟一些初始化的操作\n  position.x = 1;\n  position.y = 2;\n  position.z = 3;\n})();\n\n\n用一个立即执行函数初始化这些操作，解决了写在构造器执行多次的问题，本质上是初始化逻辑写在类的外部的语法糖。\n\n\n# class 的继承\n\n使用 class 继承完美的解决了早期 es 种继承的问题，而且语法相当简单，就一个extends就搞定了。\n\n我们先以数学定理的形式先记住继承中父类子类之间的属性和方法的关系\n\n * 1、子类可以继承父类中所有的非私有属性和方法\n * 2、子类可以继承父类中所有的非私有静态属性和静态方法\n\n假设有如下继承关系\n\nclass base {\n  name = "111";\n\n  age = 222;\n\n  say() {\n    console.log("base say");\n  }\n\n  run() {\n    console.log("base run");\n  }\n}\n\nclass sub extends base {\n  run() {\n    console.log("sub run");\n  }\n}\n\nconst parent = new base();\nconst child = new sub();\nchild.run();\nconsole.log(child.name);\n\n\n我们根据第一条定理来推导第一条原型指向关系：\n\nsub.prototype.__proto__ === base.prototype;\n\n\n为什么是这样，根据上文阐述，我们知道，所有的类的方法都挂载类的原型对象上的，既然当前类能够访问到父类的所有方法，当前类方法定义的位置在sub.prototype，既然 js 引擎取值不会报错，那么自然这个原型对象的原型是父类的原型对象。\n\n那么，属性是怎么继承来的呢？\n\nfunction _createclass(constructor, protoprops, staticprops) {\n  if (protoprops) _defineproperties(constructor.prototype, protoprops);\n  if (staticprops) _defineproperties(constructor, staticprops);\n  object.defineproperty(constructor, "prototype", { writable: false });\n  return constructor;\n}\n\nfunction _createsuper(derived) {\n  var hasnativereflectconstruct = _isnativereflectconstruct();\n  return function _createsuperinternal() {\n    var super = _getprototypeof(derived),\n      result;\n    if (hasnativereflectconstruct) {\n      var newtarget = _getprototypeof(this).constructor;\n      result = reflect.construct(super, arguments, newtarget);\n    } else {\n      result = super.apply(this, arguments);\n    }\n    return _possibleconstructorreturn(this, result);\n  };\n}\n\nvar base = /*#__pure__*/ (function () {\n  function base() {\n    _classcallcheck(this, base);\n\n    _defineproperty(this, "name", "111");\n\n    _defineproperty(this, "age", 222);\n  }\n\n  _createclass(base, [\n    {\n      key: "say",\n      value: function say() {\n        console.log("base say");\n      },\n    },\n    {\n      key: "run",\n      value: function run() {\n        console.log("base run");\n      },\n    },\n  ]);\n\n  return base;\n})();\n\nvar sub = /*#__pure__*/ (function (_base) {\n  _inherits(sub, _base);\n\n  var _super = _createsuper(sub);\n\n  function sub() {\n    _classcallcheck(this, sub);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createclass(sub, [\n    {\n      key: "run",\n      value: function run() {\n        console.log("sub run");\n      },\n    },\n  ]);\n\n  return sub;\n})(base);\n\n\n关键就是看_createsuper这个辅助函数，其返回一个函数，其直接调用了一次super，相当于我们得到的是一个把当前类上所有属性完成拷贝的对象，这就避免了多个子类继承同一个父类的时候，共用一个父类的属性的问题\n\n接着，我们根据第二条定理来推导的第二条原型指向关系：\n\nsub.__proto__ = base;\n\n\n为什么是这样，根据上文阐述，我们知道，所有类的静态属性或者方法都挂载在类本身的，既然 js 引擎取值不会报错，那么自然这个类的原型是父类。\n\n\n# super 关键字\n\n上述代码中我们可以看到，当子类中方法和父类重名的时候，会出现一种比较奇妙的现象，我们回想一下 js 对象的属性访问规则，当前对象上有名为 xxx 的方法，便不会向上查找了，子类已经完全修改了父类的行为，专业术语叫做重写或者覆盖，这个语法特性在面向对象程序设计中有相当大的应用，比如常见的设计模式：模板方法模式、策略模式、命令模式等都可以看到这个特性的应用。\n\nclass strategy {\n  run() {\n    console.log("base run");\n  }\n}\n\nclass simplestrategy extends strategy {\n  run() {\n    console.log("sub run");\n  }\n}\n\nclass complexstrategy extends strategy() {\n  run() {\n    console.log("sub run");\n  }\n}\n\nfunction selectstrategy(mode) {\n  let stg = null;\n  switch (mode) {\n    case "simple":\n      stg = new simlestrategy();\n      break;\n    case "multi":\n      stg = new complexstrategy();\n      break;\n  }\n  return stg;\n}\n\nclass bootstrap {\n  runner() {\n    const stg = selectstrategy(import.meta.env.strategy);\n    stg.run();\n  }\n}\n\n\n若我们又不想完全覆盖父类的行为呢，比如某些时候，我们得到的一个 sdk 已经提供了某些功能，但是这个功能又不完全满足我们的业务，我们需要针对我们的业务定制化，此刻就可以使得super关键字派上用场了。\n\nclass base {\n  run() {\n    console.log("base run");\n  }\n}\n\nclass sub extends base {\n  run() {\n    super.run();\n    console.log("sub run");\n  }\n}\n\n\n\n# class 的一些注意点\n\n * 类和模块的内部，默认就是严格模式\n * 类的方法内部如果含有this，它默认指向类的实例，但是并不意味着就是绝对安全的，比如有些老六\n\nclass person {\n  name = "yx";\n\n  say() {\n    console.log(this.name);\n  }\n}\nconst p = new person();\nconst say = p.say;\n// uncaught typeerror: cannot read properties of undefined\nsay();\n\n\n * 类不存在提升\n * 类中有一个名为new.target的属性，这个属性在初始化的时候指向的是类本身，因此可以用这个属性判断类是否使用new调用，即便子类继承了父类，在父类中，new.target仍然指向子类。',charsets:{cjk:!0}},{title:"函数上下文——this",frontmatter:{},regularPath:"/javascript/this.html",relativePath:"javascript/this.md",key:"v-397682b5",path:"/javascript/this.html",headers:[{level:2,title:"函数上下文——this",slug:"函数上下文-this",normalizedTitle:"函数上下文——this",charIndex:2},{level:2,title:"this的默认绑定",slug:"this的默认绑定",normalizedTitle:"this的默认绑定",charIndex:252},{level:3,title:"方法中的this",slug:"方法中的this",normalizedTitle:"方法中的this",charIndex:322},{level:3,title:"单独的this",slug:"单独的this",normalizedTitle:"单独的this",charIndex:826},{level:3,title:"函数的this",slug:"函数的this",normalizedTitle:"函数的this",charIndex:1054},{level:3,title:"事件处理中的this",slug:"事件处理中的this",normalizedTitle:"事件处理中的this",charIndex:1209},{level:2,title:"改变this的默认绑定方式",slug:"改变this的默认绑定方式",normalizedTitle:"改变this的默认绑定方式",charIndex:1328},{level:3,title:"new",slug:"new",normalizedTitle:"new",charIndex:1394},{level:3,title:"call，apply，bind",slug:"call-apply-bind",normalizedTitle:"call，apply，bind",charIndex:2213},{level:3,title:"箭头函数",slug:"箭头函数",normalizedTitle:"箭头函数",charIndex:3404},{level:2,title:"this绑定的优先级",slug:"this绑定的优先级",normalizedTitle:"this绑定的优先级",charIndex:4166}],headersStr:"函数上下文——this this的默认绑定 方法中的this 单独的this 函数的this 事件处理中的this 改变this的默认绑定方式 new call，apply，bind 箭头函数 this绑定的优先级",content:'# 函数上下文——this\n\n如果你是一个JS的初学者，this这一定是一个能够让你欲哭无泪的语法。像C#，Java这类语言，如果类的方法是非静态的，那么this指向的就是类的实例，如果是静态方法，那么就指向类本身，而JS的this是可变的，在没有搞懂this之前，不妨忘记之前学过的知识，以利于学习。\n\n它有一个更加贴切的名字，函数上下文，这个名字恰到好处的表达了this的含义。\n\n当函数在不同的环境下执行，this的指向是不同的，简言之就是哪个对象调用的这个函数，this就指向那个对象。\n\n\n# this的默认绑定\n\n默认情况的this调用都是隐式绑定，即谁调用，指向谁。因此，这节所有内容都不考虑方法被强制指定this的情况\n\n\n# 方法中的this\n\nlet person = {\n  firstName: "Bill",\n  lastName: "Gates",\n  id: 123,\n  fullName: function(){\n    return this.firstName + " " + this.lastName;\n  }\n};\n\nperson.fullName() // Bill Gates\n\nlet fullName = person.fullName;\n\nfullName(); // "undefined undefined"\n\n\n如果在 ES6 的class中的话，this的指向分两种情况：\n\nclass App {\n  static run() {\n    console.log(this);\n  }\n\n  log() {\n    console.log(this);\n  }\n}\n\n\n对于静态方法中的this，默认指向的是当前class（如run方法的this指向App），对于非静态方法的this，默认指向的是当前class的原型对象(如log方法的this指向App.prototype)\n\n\n# 单独的this\n\nconsole.log(this); // globalThis\n\n\n在单独使用时，拥有者是全局对象，this指的是全局对象，即globalThis，对于nodejs，globalThis指向的是global对象，而对于浏览器， globalThis指向的是window对象，这就是上小节内容为什么fullName()输出的内容是"undefined undefined"，而对于WebWorker中，this指向self对象。\n\n\n# 函数的this\n\nfunction Person(){\n  return this;\n}\n\n\n非严格模式中，函数的拥有者默认绑定this，因此，在函数中，this指的是全局对象globalThis。\n\n严格模式不允许默认绑定，因此，在函数中使用时，在严格模式下，this是未定义的undefined。\n\n\n# 事件处理中的this\n\n<button onclick="this.style.display=\'none\'">点击来删除我！</button>\n\n\nthis指向的是当前触发事件的元素，如上面例子中，this指向的是button\n\n\n# 改变this的默认绑定方式\n\n由于this的可变性，导致我们的程序可能会变的脆弱，因此，需要在某些时候明确this的指向。\n\n\n# new\n\nfunction Person(){\n  console.log(this instanceof Person)\n  console.log(new.target);\n}\n\nconst people = new Person(); // Person Person\n\n\n这是一个隐式改变this的调用，同时又是this绑定中优先级最高的调用。\n\n有了这个手段，我们可以用来判断函数是否是被用于new的形式调用，下面的代码就是babel转码class的结果的节选。\n\n在ES6中为new引入了一个新的数据target，也可以用来判断是否是通过new调用的。\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError("Cannot call a class as a function");\n  }\n}\n\n\n接下来就是一个比较迷惑也不迷惑的面试题了，如下：\n\nconst obj = {\n  name: \'JohnYang\',\n  age: 28,\n}\nfunction Person(){\n  console.log(this instanceof Person)\n  console.log(new.target);\n  console.log(this.name, this.age);\n}\n// 想强制指定this为obj\nconst MyPerson = Person.bind(obj);\n\nconst p = new MyPerson();\n\n\n因为使用new调用时的this绑定优先级是最高的，所以其实MyPerson就是Person，this上不存在name和age，因此最终输出的是undefined undefined\n\n\n# call，apply，bind\n\n这几个问题是面试题中考场最多的问题之一了，面试官：“请问call，apply，bind三者有什么区别，并说出如何实现”?\n\n本文不讨论它们的实现，只讨论用法。\n\ninterface Function {\n  apply(this: Function, thisArg: any, argArray?: any): any;\n  call(this: Function, thisArg: any, ...argArray: any[]): any;\n  bind(this: Function, thisArg: any, ...argArray: any[]): any;\n}\n\n\n首先，call和apply几乎是差不多的，它们的第一个参数都是this上下文，而call是接受N个参数，一字排开，而apply是接受一个由函数的N个参数组成的数组（类数组对象也可以的），然后这个函数就被立即执行了。\n\n如：\n\nlet firstName = "John";\nlet lastName = "Yang";\nlet person = {\n  firstName: "Bill",\n  lastName: "Gates",\n  id: 123,\n  fullName: function (arg1, arg2) {\n    console.log(arg1, arg2);\n    return this.firstName + " " + this.lastName;\n  },\n};\nperson.fullName.apply(person, ["hello", "world"]); // "hello" "world" 返回 "Bill Gates"\nconst fullName2 = person.fullName.bind(window, "hello", "world"); // "hello" "world" 返回 "John Yang"\n\n\n而bind和它们两者有个最大的不同，bind是返回一个被改变了this指向的函数。\n\nbind在使用的过程中还可以预制一些参数，那么得到的函数在执行的时候就可以省略掉预制的参数，如：\n\nfunction Person(name, age) {\n  this.name = name;\n  this.age = age;\n}\n\nconst MyPerson = Person.bind(window, "Tom");\n\nconst p = new MyPerson("28"); // { name:\'Tom\', age: \'28\' }\nconst yang = new MyPerson("Yang", "28"); // { name:\'Yang\', age: \'28\' }\n\n\n\n# 箭头函数\n\n箭头函数的this其实本质并不是改变了this的默认绑定，但是为了说明改变this指向的手段，就将其暂且的列在这一小节了。\n\nclass MyButton extends React.Component {\n  onClick = () => {\n    console.log(this.name);\n  };\n\n  render() {\n    return <button onClick={this.onClick}>Hello World</button>;\n  }\n}\n\n\nES6中引入的新语法，箭头函数的this永远指向当前的父作用域的this，如在React的组件中可以经常看到上述代码。\n\n接下来看一段转码前与转码后的代码。\n\n转码前：\n\nclass A {\n  name = "A";\n\n  say = () => {\n    console.log(this.name);\n  };\n}\n\nconst D = () => {\n  console.log(this);\n};\n\n\n转码后：\n\nvar _this2 = void 0;\n\nvar A = /*#__PURE__*/ _createClass(function A() {\n  var _this = this;\n\n  _classCallCheck(this, A);\n\n  _defineProperty(this, "name", "A");\n\n  _defineProperty(this, "say", function () {\n    console.log(_this.name);\n  });\n});\n\nvar D = function D() {\n  console.log(_this2);\n};\n\n\n\n# this绑定的优先级\n\n说完了this在实际开发中的场景之后，最后来聊一下this绑定的优先级的问题。\n\n对于隐式绑定（或默认绑定）来说优先级是最低的（谁调用，指向谁），其次是使用call，apply，bind进行的显示绑定，优先级次之，最后是通过new调用的new绑定，优先级最高。\n\n这儿并没有讨论箭头函数的this的优先级，因为箭头函数的this绑定在父级作用域下，是babel通过定义特定作用域下的变量，转化使得函数的最终的this能够符合预期，是语法糖，属于作用域链的范畴，跟this绑定无关。',normalizedContent:'# 函数上下文——this\n\n如果你是一个js的初学者，this这一定是一个能够让你欲哭无泪的语法。像c#，java这类语言，如果类的方法是非静态的，那么this指向的就是类的实例，如果是静态方法，那么就指向类本身，而js的this是可变的，在没有搞懂this之前，不妨忘记之前学过的知识，以利于学习。\n\n它有一个更加贴切的名字，函数上下文，这个名字恰到好处的表达了this的含义。\n\n当函数在不同的环境下执行，this的指向是不同的，简言之就是哪个对象调用的这个函数，this就指向那个对象。\n\n\n# this的默认绑定\n\n默认情况的this调用都是隐式绑定，即谁调用，指向谁。因此，这节所有内容都不考虑方法被强制指定this的情况\n\n\n# 方法中的this\n\nlet person = {\n  firstname: "bill",\n  lastname: "gates",\n  id: 123,\n  fullname: function(){\n    return this.firstname + " " + this.lastname;\n  }\n};\n\nperson.fullname() // bill gates\n\nlet fullname = person.fullname;\n\nfullname(); // "undefined undefined"\n\n\n如果在 es6 的class中的话，this的指向分两种情况：\n\nclass app {\n  static run() {\n    console.log(this);\n  }\n\n  log() {\n    console.log(this);\n  }\n}\n\n\n对于静态方法中的this，默认指向的是当前class（如run方法的this指向app），对于非静态方法的this，默认指向的是当前class的原型对象(如log方法的this指向app.prototype)\n\n\n# 单独的this\n\nconsole.log(this); // globalthis\n\n\n在单独使用时，拥有者是全局对象，this指的是全局对象，即globalthis，对于nodejs，globalthis指向的是global对象，而对于浏览器， globalthis指向的是window对象，这就是上小节内容为什么fullname()输出的内容是"undefined undefined"，而对于webworker中，this指向self对象。\n\n\n# 函数的this\n\nfunction person(){\n  return this;\n}\n\n\n非严格模式中，函数的拥有者默认绑定this，因此，在函数中，this指的是全局对象globalthis。\n\n严格模式不允许默认绑定，因此，在函数中使用时，在严格模式下，this是未定义的undefined。\n\n\n# 事件处理中的this\n\n<button onclick="this.style.display=\'none\'">点击来删除我！</button>\n\n\nthis指向的是当前触发事件的元素，如上面例子中，this指向的是button\n\n\n# 改变this的默认绑定方式\n\n由于this的可变性，导致我们的程序可能会变的脆弱，因此，需要在某些时候明确this的指向。\n\n\n# new\n\nfunction person(){\n  console.log(this instanceof person)\n  console.log(new.target);\n}\n\nconst people = new person(); // person person\n\n\n这是一个隐式改变this的调用，同时又是this绑定中优先级最高的调用。\n\n有了这个手段，我们可以用来判断函数是否是被用于new的形式调用，下面的代码就是babel转码class的结果的节选。\n\n在es6中为new引入了一个新的数据target，也可以用来判断是否是通过new调用的。\n\nfunction _classcallcheck(instance, constructor) {\n  if (!(instance instanceof constructor)) {\n    throw new typeerror("cannot call a class as a function");\n  }\n}\n\n\n接下来就是一个比较迷惑也不迷惑的面试题了，如下：\n\nconst obj = {\n  name: \'johnyang\',\n  age: 28,\n}\nfunction person(){\n  console.log(this instanceof person)\n  console.log(new.target);\n  console.log(this.name, this.age);\n}\n// 想强制指定this为obj\nconst myperson = person.bind(obj);\n\nconst p = new myperson();\n\n\n因为使用new调用时的this绑定优先级是最高的，所以其实myperson就是person，this上不存在name和age，因此最终输出的是undefined undefined\n\n\n# call，apply，bind\n\n这几个问题是面试题中考场最多的问题之一了，面试官：“请问call，apply，bind三者有什么区别，并说出如何实现”?\n\n本文不讨论它们的实现，只讨论用法。\n\ninterface function {\n  apply(this: function, thisarg: any, argarray?: any): any;\n  call(this: function, thisarg: any, ...argarray: any[]): any;\n  bind(this: function, thisarg: any, ...argarray: any[]): any;\n}\n\n\n首先，call和apply几乎是差不多的，它们的第一个参数都是this上下文，而call是接受n个参数，一字排开，而apply是接受一个由函数的n个参数组成的数组（类数组对象也可以的），然后这个函数就被立即执行了。\n\n如：\n\nlet firstname = "john";\nlet lastname = "yang";\nlet person = {\n  firstname: "bill",\n  lastname: "gates",\n  id: 123,\n  fullname: function (arg1, arg2) {\n    console.log(arg1, arg2);\n    return this.firstname + " " + this.lastname;\n  },\n};\nperson.fullname.apply(person, ["hello", "world"]); // "hello" "world" 返回 "bill gates"\nconst fullname2 = person.fullname.bind(window, "hello", "world"); // "hello" "world" 返回 "john yang"\n\n\n而bind和它们两者有个最大的不同，bind是返回一个被改变了this指向的函数。\n\nbind在使用的过程中还可以预制一些参数，那么得到的函数在执行的时候就可以省略掉预制的参数，如：\n\nfunction person(name, age) {\n  this.name = name;\n  this.age = age;\n}\n\nconst myperson = person.bind(window, "tom");\n\nconst p = new myperson("28"); // { name:\'tom\', age: \'28\' }\nconst yang = new myperson("yang", "28"); // { name:\'yang\', age: \'28\' }\n\n\n\n# 箭头函数\n\n箭头函数的this其实本质并不是改变了this的默认绑定，但是为了说明改变this指向的手段，就将其暂且的列在这一小节了。\n\nclass mybutton extends react.component {\n  onclick = () => {\n    console.log(this.name);\n  };\n\n  render() {\n    return <button onclick={this.onclick}>hello world</button>;\n  }\n}\n\n\nes6中引入的新语法，箭头函数的this永远指向当前的父作用域的this，如在react的组件中可以经常看到上述代码。\n\n接下来看一段转码前与转码后的代码。\n\n转码前：\n\nclass a {\n  name = "a";\n\n  say = () => {\n    console.log(this.name);\n  };\n}\n\nconst d = () => {\n  console.log(this);\n};\n\n\n转码后：\n\nvar _this2 = void 0;\n\nvar a = /*#__pure__*/ _createclass(function a() {\n  var _this = this;\n\n  _classcallcheck(this, a);\n\n  _defineproperty(this, "name", "a");\n\n  _defineproperty(this, "say", function () {\n    console.log(_this.name);\n  });\n});\n\nvar d = function d() {\n  console.log(_this2);\n};\n\n\n\n# this绑定的优先级\n\n说完了this在实际开发中的场景之后，最后来聊一下this绑定的优先级的问题。\n\n对于隐式绑定（或默认绑定）来说优先级是最低的（谁调用，指向谁），其次是使用call，apply，bind进行的显示绑定，优先级次之，最后是通过new调用的new绑定，优先级最高。\n\n这儿并没有讨论箭头函数的this的优先级，因为箭头函数的this绑定在父级作用域下，是babel通过定义特定作用域下的变量，转化使得函数的最终的this能够符合预期，是语法糖，属于作用域链的范畴，跟this绑定无关。',charsets:{cjk:!0}},{frontmatter:{},regularPath:"/javascript/write/debounce.html",relativePath:"javascript/write/debounce.md",key:"v-7e8a4b55",path:"/javascript/write/debounce.html",headersStr:null,content:"",normalizedContent:"",charsets:{}},{title:"闭包",frontmatter:{},regularPath:"/javascript/closure.html",relativePath:"javascript/closure.md",key:"v-5ed5b2a2",path:"/javascript/closure.html",headersStr:null,content:"",normalizedContent:"",charsets:{}},{title:"克隆",frontmatter:{},regularPath:"/javascript/write/clone.html",relativePath:"javascript/write/clone.md",key:"v-49363b4b",path:"/javascript/write/clone.html",headers:[{level:2,title:"克隆",slug:"克隆",normalizedTitle:"克隆",charIndex:2},{level:3,title:"浅克隆",slug:"浅克隆",normalizedTitle:"浅克隆",charIndex:20},{level:3,title:"深克隆",slug:"深克隆",normalizedTitle:"深克隆",charIndex:24},{level:3,title:"深克隆的实现",slug:"深克隆的实现",normalizedTitle:"深克隆的实现",charIndex:1343}],headersStr:"克隆 浅克隆 深克隆 深克隆的实现",content:'# 克隆\n\n首先，先为大家介绍一下什么是浅克隆和深克隆。\n\n对于浅克隆和深克隆，我们都是针对引用类型来讨论的，比如说：\n\nconst a = "AAA";\nconst b = a;\n\n\n因为a和b，都是基础类型，这个操作，其实就相当于把a拷贝了一份给b，所以这个话题针对非引用类型讨论没有意义。\n\n\n# 浅克隆\n\nconst a = {};\nconst b = a;\n\n\n此刻，a和b都指向同一块内存区域，因此，大家都可以对这块区域进行修改。在实际开发中，经常会存在一些潜在的 bug，因为操作了同一块内存区域导致数据的一致性错误，因此，在处理数据的过程中，针对引用数据类型，一定要足够小心，注意其引用的内容。\n\nDANGER\n\n对于引用类型，不同的变量都引用同一个对象，都可以对这个对象进行修改\n\n\n# 深克隆\n\n下面 2 种情况，是我总结的不太容易察觉的可能是深克隆的情况。\n\n# 场景 1\n\nconst a = { name: "yangxu", age: "28" };\n/* const b = a; */\nconst b = { ...a };\n\n\n根据扩展运算符的运用场景，首先初始化了一个新对象b，然后就把对象a中的所有属性都复制给了b，其实这是完成了一次深克隆。\n\n但是，这只是针对这个场景下的深克隆，假设现在：\n\nconst a = {\n  name: "yangxu",\n  age: "28",\n  location: {\n    province: "sichuan",\n    city: "chengdu",\n    country: "shuangliu",\n  },\n};\nconst b = { ...a };\n\nb.location.province = "beijing";\n/* 输出beijing */\nconsole.log(a.location.province);\n\n\n为什么是beijing，这个操作，就相当于a和b都持有location，因此大家都可以对它进行修改了。\n\nTIP\n\n使用Object.assign和扩展运算符类似\n\n# 场景 2\n\nconst a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nconst b = a.map((v) => v);\n\n\n咋一看，好像是一个没有意义的操作，干嘛要空map一次呢？其实不然，我们知道map返回一个新的数组，那么，因为数组的元素是基本类型，不存在拷贝的问题，因此，我们就好比新建一个数组，把所有的元素都拷贝过去。\n\n下面这个场景和上面类似：\n\nconst a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nconst b = [...a];\n\n\n但是，对于这个场景，就需要注意了。\n\nconst a = [{}, {}, {}, {}, {}, {}, {}, {}, {}];\nconst b = a.map((v) => v);\n\n\n这样并没有完成一次深克隆，因为其实数组的键是特殊的键，即 a[0]和 b[0]都持有同一个对象，大家都能修改这个对象，数据一致性就可能存在问题，因此，这种情况就不能再使用map。\n\n\n# 深克隆的实现\n\n# 使用 JSON.parse + JSON.stringify\n\nconst o = {};\nconst b = JSON.parse(JSON.stringify(o));\n\n\n首先，我觉得绝大部分人说不清楚JSON.stringify的序列化规则，这个是我曾经面试遇到过的一个问题，我特意去看过MDN的描述。具体的序列化规则我就不在此叙述，本文主要阐述一下用它可能存在的问题。\n\n * JSON.stringify 无法解决循环引用的问题；\n * JSON.stringify 无法序列化Symbol，BigInt，Function这类不能被序列化的类型；\n * JSON.stringify 只能序列化对象的可枚举字段；\n * JSON.stringify 序列化的数据可能不准确，如Date，NaN；\n\n# 使用 DFS 实现深克隆\n\n同理，使用BFS或者DFS进行深克隆，仍然解决不全上述描述的问题（但解决度就可以取决于你自己对JS的积累了），但是，这个是基于算法的，它能够向面试官证明你的学习能力、编程能力与记忆力，至少能说明你是一个愿意学习的程序员。\n\n使用DFS或BFS是可以解决对象循环引用的问题。\n\n/**\n * 使用深度优先深拷贝对象\n * @param {Array<any> | object} obj\n * @param { Map<Array<any> | object, Array<any> | object> } map\n * @returns\n */\nfunction deepClone(obj, map = new Map()) {\n  // 如果已经拷贝过，则可以直接返回拷贝过的值，主要是为了防止循环引用\n  let cloneObj = map.get(obj);\n  if (typeof cloneObj !== "undefined") {\n    return cloneObj;\n  }\n  // 初始化拷贝的对象\n  cloneObj = Array.isArray(obj) ? [] : {};\n  // 建立已经拷贝的引用，不能再开始拷贝属性了再建立拷贝引用，否则将会导致递归最大调用栈的问题发生\n  map.set(obj, cloneObj);\n  // 对拷贝对象挨个赋值\n  for (let prop in obj) {\n    // 遇到对象，则递归拷贝\n    if (obj[prop] instanceof Object) {\n      cloneObj[prop] = deepClone(obj[prop], map);\n      // 拷贝完成后，还要将其加入引用Map中去\n      map.set(obj[prop], cloneObj[obj]);\n    } else {\n      cloneObj[prop] = obj[prop];\n    }\n  }\n  return cloneObj;\n}\n\n\n# 使用BFS实现深克隆\n\n与DFS类似，不赘述。\n\n/**\n * 使用广度优先深拷贝一个对象\n * @param {Array<any> | object} obj\n * @returns\n */\nfunction deepClone(obj) {\n  // 根据目标对象确定拷贝是数组还是对象\n  let cloneObj = Array.isArray(obj) ? [] : {};\n  // 用一个map用以记住被拷贝过的内容\n  const map = new Map();\n  // 记住当前对象已经被拷贝过了\n  map.set(obj, cloneObj);\n  // 把原始内容和拷贝的内容追加到队列中去，准备开始以广度优先的方式进行深拷贝\n  const queue = [\n    {\n      source: obj,\n      clone: cloneObj,\n    },\n  ];\n  while (queue.length > 0) {\n    const { source, clone } = queue.shift();\n    for (let prop in source) {\n      if (source[prop] instanceof Object) {\n        // 如果已经拷贝过，则直接将内容复制到目标对象上去\n        if (map.get(source[prop])) {\n          clone[prop] = map.get(source[prop]);\n        } else {\n          // 把当前对象和拷贝的空对象加入到队列中去，准备后序的深拷贝\n          const nextClone = Array.isArray(source[prop]) ? [] : {};\n          queue.push({\n            source: source[prop],\n            clone: nextClone,\n          });\n          // 建立拷贝关系，本轮还是空内容（可以理解为拷贝一个容器），待下一轮循环才拷贝值\n          clone[prop] = nextClone;\n          // 将已经拷贝的内容加入到map中去，防止循环拷贝\n          map.set(source[prop], nextClone);\n        }\n      } else {\n        // 基本类型，可直接拷贝\n        clone[prop] = source[prop];\n      }\n    }\n  }\n  return cloneObj;\n}\n',normalizedContent:'# 克隆\n\n首先，先为大家介绍一下什么是浅克隆和深克隆。\n\n对于浅克隆和深克隆，我们都是针对引用类型来讨论的，比如说：\n\nconst a = "aaa";\nconst b = a;\n\n\n因为a和b，都是基础类型，这个操作，其实就相当于把a拷贝了一份给b，所以这个话题针对非引用类型讨论没有意义。\n\n\n# 浅克隆\n\nconst a = {};\nconst b = a;\n\n\n此刻，a和b都指向同一块内存区域，因此，大家都可以对这块区域进行修改。在实际开发中，经常会存在一些潜在的 bug，因为操作了同一块内存区域导致数据的一致性错误，因此，在处理数据的过程中，针对引用数据类型，一定要足够小心，注意其引用的内容。\n\ndanger\n\n对于引用类型，不同的变量都引用同一个对象，都可以对这个对象进行修改\n\n\n# 深克隆\n\n下面 2 种情况，是我总结的不太容易察觉的可能是深克隆的情况。\n\n# 场景 1\n\nconst a = { name: "yangxu", age: "28" };\n/* const b = a; */\nconst b = { ...a };\n\n\n根据扩展运算符的运用场景，首先初始化了一个新对象b，然后就把对象a中的所有属性都复制给了b，其实这是完成了一次深克隆。\n\n但是，这只是针对这个场景下的深克隆，假设现在：\n\nconst a = {\n  name: "yangxu",\n  age: "28",\n  location: {\n    province: "sichuan",\n    city: "chengdu",\n    country: "shuangliu",\n  },\n};\nconst b = { ...a };\n\nb.location.province = "beijing";\n/* 输出beijing */\nconsole.log(a.location.province);\n\n\n为什么是beijing，这个操作，就相当于a和b都持有location，因此大家都可以对它进行修改了。\n\ntip\n\n使用object.assign和扩展运算符类似\n\n# 场景 2\n\nconst a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nconst b = a.map((v) => v);\n\n\n咋一看，好像是一个没有意义的操作，干嘛要空map一次呢？其实不然，我们知道map返回一个新的数组，那么，因为数组的元素是基本类型，不存在拷贝的问题，因此，我们就好比新建一个数组，把所有的元素都拷贝过去。\n\n下面这个场景和上面类似：\n\nconst a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nconst b = [...a];\n\n\n但是，对于这个场景，就需要注意了。\n\nconst a = [{}, {}, {}, {}, {}, {}, {}, {}, {}];\nconst b = a.map((v) => v);\n\n\n这样并没有完成一次深克隆，因为其实数组的键是特殊的键，即 a[0]和 b[0]都持有同一个对象，大家都能修改这个对象，数据一致性就可能存在问题，因此，这种情况就不能再使用map。\n\n\n# 深克隆的实现\n\n# 使用 json.parse + json.stringify\n\nconst o = {};\nconst b = json.parse(json.stringify(o));\n\n\n首先，我觉得绝大部分人说不清楚json.stringify的序列化规则，这个是我曾经面试遇到过的一个问题，我特意去看过mdn的描述。具体的序列化规则我就不在此叙述，本文主要阐述一下用它可能存在的问题。\n\n * json.stringify 无法解决循环引用的问题；\n * json.stringify 无法序列化symbol，bigint，function这类不能被序列化的类型；\n * json.stringify 只能序列化对象的可枚举字段；\n * json.stringify 序列化的数据可能不准确，如date，nan；\n\n# 使用 dfs 实现深克隆\n\n同理，使用bfs或者dfs进行深克隆，仍然解决不全上述描述的问题（但解决度就可以取决于你自己对js的积累了），但是，这个是基于算法的，它能够向面试官证明你的学习能力、编程能力与记忆力，至少能说明你是一个愿意学习的程序员。\n\n使用dfs或bfs是可以解决对象循环引用的问题。\n\n/**\n * 使用深度优先深拷贝对象\n * @param {array<any> | object} obj\n * @param { map<array<any> | object, array<any> | object> } map\n * @returns\n */\nfunction deepclone(obj, map = new map()) {\n  // 如果已经拷贝过，则可以直接返回拷贝过的值，主要是为了防止循环引用\n  let cloneobj = map.get(obj);\n  if (typeof cloneobj !== "undefined") {\n    return cloneobj;\n  }\n  // 初始化拷贝的对象\n  cloneobj = array.isarray(obj) ? [] : {};\n  // 建立已经拷贝的引用，不能再开始拷贝属性了再建立拷贝引用，否则将会导致递归最大调用栈的问题发生\n  map.set(obj, cloneobj);\n  // 对拷贝对象挨个赋值\n  for (let prop in obj) {\n    // 遇到对象，则递归拷贝\n    if (obj[prop] instanceof object) {\n      cloneobj[prop] = deepclone(obj[prop], map);\n      // 拷贝完成后，还要将其加入引用map中去\n      map.set(obj[prop], cloneobj[obj]);\n    } else {\n      cloneobj[prop] = obj[prop];\n    }\n  }\n  return cloneobj;\n}\n\n\n# 使用bfs实现深克隆\n\n与dfs类似，不赘述。\n\n/**\n * 使用广度优先深拷贝一个对象\n * @param {array<any> | object} obj\n * @returns\n */\nfunction deepclone(obj) {\n  // 根据目标对象确定拷贝是数组还是对象\n  let cloneobj = array.isarray(obj) ? [] : {};\n  // 用一个map用以记住被拷贝过的内容\n  const map = new map();\n  // 记住当前对象已经被拷贝过了\n  map.set(obj, cloneobj);\n  // 把原始内容和拷贝的内容追加到队列中去，准备开始以广度优先的方式进行深拷贝\n  const queue = [\n    {\n      source: obj,\n      clone: cloneobj,\n    },\n  ];\n  while (queue.length > 0) {\n    const { source, clone } = queue.shift();\n    for (let prop in source) {\n      if (source[prop] instanceof object) {\n        // 如果已经拷贝过，则直接将内容复制到目标对象上去\n        if (map.get(source[prop])) {\n          clone[prop] = map.get(source[prop]);\n        } else {\n          // 把当前对象和拷贝的空对象加入到队列中去，准备后序的深拷贝\n          const nextclone = array.isarray(source[prop]) ? [] : {};\n          queue.push({\n            source: source[prop],\n            clone: nextclone,\n          });\n          // 建立拷贝关系，本轮还是空内容（可以理解为拷贝一个容器），待下一轮循环才拷贝值\n          clone[prop] = nextclone;\n          // 将已经拷贝的内容加入到map中去，防止循环拷贝\n          map.set(source[prop], nextclone);\n        }\n      } else {\n        // 基本类型，可直接拷贝\n        clone[prop] = source[prop];\n      }\n    }\n  }\n  return cloneobj;\n}\n',charsets:{cjk:!0}},{frontmatter:{},regularPath:"/javascript/write/throttle.html",relativePath:"javascript/write/throttle.md",key:"v-3c1db7b5",path:"/javascript/write/throttle.html",headersStr:null,content:"",normalizedContent:"",charsets:{}},{title:"继承",frontmatter:{},regularPath:"/javascript/extend.html",relativePath:"javascript/extend.md",key:"v-2006ac96",path:"/javascript/extend.html",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{},regularPath:"/javascript/write/Promise.html",relativePath:"javascript/write/Promise.md",key:"v-7b268c62",path:"/javascript/write/Promise.html",headersStr:null,content:"",normalizedContent:"",charsets:{}},{title:"实现JSON.stringify",frontmatter:{},regularPath:"/javascript/write/JSON.html",relativePath:"javascript/write/JSON.md",key:"v-4cfc62f5",path:"/javascript/write/JSON.html",headers:[{level:2,title:"实现JSON.stringify",slug:"实现json-stringify",normalizedTitle:"实现json.stringify",charIndex:2},{level:2,title:"实现JSON.parse",slug:"实现json-parse",normalizedTitle:"实现json.parse",charIndex:69}],headersStr:"实现JSON.stringify 实现JSON.parse",content:"# 实现JSON.stringify\n\n我觉得能挑战这 2 个问题的程序员绝对是壮士。\n\n首先，对于JSON.stringify\n\n\n# 实现JSON.parse",normalizedContent:"# 实现json.stringify\n\n我觉得能挑战这 2 个问题的程序员绝对是壮士。\n\n首先，对于json.stringify\n\n\n# 实现json.parse",charsets:{cjk:!0}},{title:"flatten",frontmatter:{},regularPath:"/javascript/write/flatten.html",relativePath:"javascript/write/flatten.md",key:"v-778a4b06",path:"/javascript/write/flatten.html",headers:[{level:2,title:"flatten",slug:"flatten",normalizedTitle:"flatten",charIndex:2},{level:3,title:"正则替换",slug:"正则替换",normalizedTitle:"正则替换",charIndex:14},{level:3,title:"",slug:"",normalizedTitle:"",charIndex:0}],headersStr:"flatten 正则替换 ",content:"# flatten\n\n\n# 正则替换\n\n\n#",normalizedContent:"# flatten\n\n\n# 正则替换\n\n\n#",charsets:{cjk:!0}},{title:"MySQL 学习笔记",frontmatter:{},regularPath:"/mysql.html",relativePath:"mysql.md",key:"v-571ef5f5",path:"/mysql.html",headers:[{level:2,title:"登录",slug:"登录",normalizedTitle:"登录",charIndex:17},{level:2,title:"常见命令",slug:"常见命令",normalizedTitle:"常见命令",charIndex:64},{level:2,title:"注释",slug:"注释",normalizedTitle:"注释",charIndex:291},{level:2,title:"DQL 语言",slug:"dql-语言",normalizedTitle:"dql 语言",charIndex:358},{level:3,title:"查询",slug:"查询",normalizedTitle:"查询",charIndex:369},{level:2,title:"DML 语言",slug:"dml-语言",normalizedTitle:"dml 语言",charIndex:9612},{level:2,title:"DDL 语言",slug:"ddl-语言",normalizedTitle:"ddl 语言",charIndex:9623}],headersStr:"登录 常见命令 注释 DQL 语言 查询 DML 语言 DDL 语言",content:"# MySQL 学习笔记\n\n\n# 登录\n\nmysql -u root -p -h localhost -P 3306\n\n\n\n# 常见命令\n\n# 显示所有的数据库\nshow databases;\n# 选择数据库 xxx\nuse xxx;\n# 展示数据的表\nshow tables;\nshow tables from xxx;\n# 显示当前所在的数据库\nselect database();\n# 查看指定表的表结构\ndesc xxx;\n# 查看数据库的版本\nselect version();\n\n\n## 利用bash命令\nmysql --version;\nmysql -V;\n\n\n\n# 注释\n\n单行注释： -- 注释内容;（注意--后面有一个空格） 单行注释：#注释内容 多行注释：/* 我是一个注释内容 */\n\n\n# DQL 语言\n\n\n# 查询\n\n# select\n\n# 从表中查询字段\nselect * from employees;\nselect username,age,gender from employees;\nselect username as myName from employees;\n# 关键字区分\n# select NAME from employees NAME会被当做关键字，因此可以用``包起来，如。\nselect `name` from employees;\n\n# 查询常量值\nselect 100\n# 查询函数\nselect NOW();\nselect version();\n# 查询表达式\nselect 2*100;\n\n# 别名 as可以省略\nselect 2+100 as `add`;\nselect 2/100 'test';\n\n# 去重 distinct;\nselect distinct * from employees;\n\n# + 只存在数值相加的功能，但是如果是字符串和数字相加，则判断能否转化成数字型，能转就转，不能转就相当于是0\n# `NULL`和任何内容连接都是`NULL`\n\n\n\n# where 条件查询\n\n1、按条件表达式\n\n> < = != <> >= <=等。\n\nselect * from employees where salary > 1200;\nselect * from employees where department_id != 90;\n\n\n推荐用<>代替!=;\n\n2、按逻辑表达式\n\n&& || ! and or not等。\n\nselect * from employees where salary > 1200 && department_id > 90;\nselect * from employees where salary >= 10000 && salary <= 15000;\n\n\n推荐用 and， or， not。\n\n3、模糊查询\n\nlike; between and; in; is null; is not null等。\n\nselect * from employees where salary between 12000 and 15000;\nselect * from employees where commission_pct is not null and first_name like '%Jo%';\n# 匹配员工名中第三个字符为A，第五个字符为e的员工名\nselect last_name as lastName from employees where first_name like '__A_e%';\n\n\nlike和通配符搭配使用，%代表匹配任意个字符（0-n），_代表任意单个字符\n\n转义字符：\n\n# 直接转义\nselect last_name from employees where last_name like '_\\_%';\n# 使用escape关键字转义\nselect last_name from employees where last_name like '_$_%' escape '$';\n\n\n(not) between and，包含左右的临界值，但是必须是左大右小。\n\nselect * from employees where job_id in ('IT_PORT', 'AD_VP', 'AD_PRES');\n\n\nin 列表的内容的值类型必须一致或兼容。\n\nselect * from employees where commission_pct is null;\n\n\nis null 或者 is not null 可以判断NULL，但是，=，!=，<>不能判断NULL;\n\nselect * from employees where commission_pct <=> 12000;\n\n\n安全等于: <=>，既可以判断NULL，又可以判断普通数值。\n\n# 排序 order by\n\nasc 升序，desc降序，不写默认asc;\n\nselect * from employees where salary>12000 order by salary desc;\nselect * from employees where salary<12000 order by salary asc;\n# 按年薪的高低显示员工的信息和年薪\nselect *, salary * 12 * (1+IFNULL(commission_pct, 0)) as year_salary from employees order by year_salary desc;\n# 按函数排序\nselect *, salary * 12 * (1+IFNULL(commission_pct, 0)) as year_salary from employees order by LENGTH(last_name) desc;\n# 多关键字排序，多个关键字之间用逗号隔开，先按工资排序，再按编号排序\nselect * from employees order by salary desc, employee_id asc;\n\n\n# 常见函数\n\n字符串函数：\n\nLENGTH：求字符串的长度。 CONCAT：将字符串进行连接。 UPPER：将字符串转大写。 LOWER：将字符串转小写。 SUBSTR：取指定位置的子字符串， INSTR（和JS的indexOf类似）。 TRIM：消除字符串左右的空格。 LPAD：在字符串的左边填充指定的字符。 RPAD：在字符串的右边填充指定的字符。 REPLACE：将指定的字符替换。\n\n注意：索引从1开始。\n\nshow variables like '%char%';\n\n\n数学函数：\n\nROUND：四舍五入； CEIL：向上取整； FLOOR：向下取整； truncate：小数点保留 N 位有效数字； MOD：取余；\n\n日期函数：\n\nNOW：返回系统当前的时间； CURDATE：返回系统当前的日期，不包含时分秒。 CURTIME：返回系统当前的时间，不包含年月日。 YEAR：返回系统当前的年份。 MONTH：返回系统当前的月份。 MONTHNAME：返回系统当前月份的名称，如November。 ... DATE_FORMATE：将日期转换成字符。 STR_TO_DATE：将字符串转换成日期。\n\n其它函数：\n\nVERSION：返回数据库的版本。 DATABASE：返回当前使用的数据库。 USER：返回当前登录的用户。\n\nselect STR_TO_DATE('9-12-1994','%m-%d-%y');\nselect DATE_FORMAT('2022-10-10', '%y年%m月%d日');\n\n\n格式符   功能\n%Y    四位的年份\n%y    2 位的年份\n%m    月份, 01,02,03,04,05,06,07,08,09,10,11,12\n%c    月份, 1,2,3,4,5,6,7,8,9,10,11,12\n%d    月份, 1,2,3,4,5,6,7,8,9,10,11,12\n%H    小时，24 小时制\n%h    小时，12 小时制\n%i    分钟，01-59\n%s    秒，01-59\n\n流程控制函数：\n\nIFNULL： IF：IF(exp1, exp2, exp3)，如果exp1成立返回exp2，否则返回exp3。 CASE：\n\ncase 表达式 when 常量 1 then 值或语句 1 when 常量 2 then 值或语句 2 when 常量 3 then 值或语句 3 (else 值或语句) end\n\ncase when 条件 1 then 值或语句 1 when 条件 2 then 值或语句 2 when 条件 3 then 值或语句 3 (else 值或语句) end\n\nselect salary, department_id, case department_id when 30 then salary * 1.1 when 50 then salary * 1.2 else salary end as new_salary from employees;\n\n\n聚合函数：\n\nMAX：求最大值 MIN：求最小值 SUM：求和 AVG：求平均值 COUNT：统计\n\nsum和avg一般用于数值处理；max，min，count可以处理任何类型；\n\nsum、avg、count、min、max都将会忽略NULL。\n\n可以和distinct搭配，如：\n\nselect SUM(distinct salary), SUM(salary) from employees;\nselect COUNT(distinct salary) from employees;\n\n\nCOUNT函数的详细介绍，用于统计行数，如：\n\n# 用于统计行数\nselect count(*) from employees;\n# 或者\nselect count(1) from employees;\n\n\n在MYISAM引擎下，count(*)的效率高，在INNODB引擎下，COUNT(1)和COUNT(*)差不多，但是要比COUNT(字段名)要高。\n\n# group by\n\n和分组函数一同查询的字段要求是group by后的字段 伪代码如：\n\nselect column, group_function(column) from xxx_table [where condition] [group by group_by_expression] [order by column];\n\n\n例如：\n\nselect max(salary), job_id from employees group by job_id;\nselect count(*), location_id from departments group by location_id;\n\n\nwhere一定在group by之前，order by一定在最后。\n\n使用having关键字用于添加分组后的筛选：如查询部门员工数大于 2 的部门 id\n\nselect count(*), department_id from employees group by department_id having count(*) > 2;\n\n\n分组查询筛选，分为两类，一是分组前筛选，使用where（原始表数据），一类是分组后筛选，使用having（分组之后的结果集），如果是使用分组函数做条件的话，那么肯定是放在having子句中，能用分组前作筛选的，就优先考虑使用分组前筛选，group by字句支持单个或多个字段进行分组，若采用多个字段分组，则字段之间需要使用,分隔，无顺序要求。\n\n# 连接查询\n\n笛卡尔积的错误情况：\n\n# 假设输出12行\nselect count(*) from boys;\n# 假设输出4行\nselect count(*) from beauty;\n# 最终结果 4*12行\nselect `name`, `boyName` from beauty, boys;\n\n\n笛卡尔积的现象：表 1 有 m 行，表 2 有 n 行，结果 m*n 行，是因为没有有效的连接；\n\n\n分类:\n  内连接\n    等值连接\n    非等值连接\n    自连接\n  外连接\n    左外连接\n    右外连接\n    完全链接\n  交叉连接\n\n\n等值连接：\n\n# 两个表的顺序可以交换\nselect `name`, `boyName` from beauty, boys where beauty.boyfriend_id = boys.id;\n\n\n等值连接加上筛选，使用and连接。\n\nselect last_name, department_name from employees e, departments d where e.department_id = d.department_id and e.commission_pct is not null;\n# 查询所有女朋友的个数大于2的男生\nselect boy.boyName, count(*) as stat from boys as boy, beauty as girl where girl.boyfriend_id = boy.id group by boy.boyName having stat > 2 order by stat desc;\n\n\n多表等值连接连接的结果为多表的交集部分，多表连接的顺序没有要求，一般需要为表起别名。\n\n非等值连接： 即不用等号的连接查询。\n\nselect e.salary, j.grade_level from employees as e, job_grades as j where e.salary between j.lowest_sal and j.highest_sal;\n\n\n自连接：\n\n# 查询员工和领导的名称\nselect e.employee_id,e.last_name,m.employee_id as parent_id,m.last_name as parent_last_name from employees as e, employees as m where e.manager_id = m.employee_id;\n\n\n(inner) join： （查找两个表的并集）\n\nselect 查询列表 from 表1 inner join 表2 on 连接条件 [where 字句] [group by字句] [having字句] [order by 字句] [limit 字句]\n# 查询部门人数大于10的部门名称并且按人数降序排列\nSELECT d.department_name, COUNT(*) as 部门人数 from employees as e INNER JOIN departments as d on e.department_id = d.department_id GROUP BY d.department_name HAVING\t部门人数 >10 ORDER BY 部门人数 DESC;\n# 非等值连接\nselect salary,grade_level from employees as e inner join job_grades as g on e.salary between g.lowest_sal and g.highest_sal;\n# 自连接\nselect e.last_name, m.last_name from employees as e inner join employees as m on e.employee_id = m.manager_id;\n\n\nouter join:\n\n应用场景一般用于查找一个表中有，另外一个表中没有的情况，外连接的查询结果为主表中的所有记录，如果从表中有和它匹配的记录，则填充，否则填充NULL。 外连接查询结果=内连接结果+主表中有但从表中没有的记录。 全外连接=内连接的结果+表 1 中有但表 2 中没有的结果+表 2 中有的结果但表 1 中没有的结果（即求两表的并集）\n\nleft outer join: 左边的是主表，右边的是从表 right outer join: 左边的是从表，右边的主表\n\n左外连接和右外连接交换两个表的顺序，可以实现同样的效果。\n\n# 查找没有男朋友的女生列表\n# 最好选从表中的主键列作为筛选，因为主键列一般都是非空字段\nselect girl.name, girl.borndate from beauty as girl left outer join boys as boy on girl.boyfriend_id = boy.id where boy.id is null;\n\n\n交叉链接： 即笛卡尔乘积\n\nselect b.*, g.* from beauty as g cross join boys as b;\n# 等价于\nselect g.*, b.* from beauty as g, boys as b;\n\n\n# 子查询\n\n出现在其它语句中的 select 语句。 子查询先于主查询。\n\n# 查询工资比`Abel`高的人\nselect * from employees where salary > (\n  select salary from employees where last_name = 'Abel'\n);\n# 子查询中使用分组函数\nselect last_name, job_id, salary from employees where salary = (select min(salary) from employees);\n# 和`having`字句一起使用 查询最低工资大于50号部门最低工资的部门id和其最低工资\nselect department_id, min(salary) from employees group by department_id having min(salary) > (select min(salary) from employees where department_id = 50);\n# 使用IN\nselect last_name from employees where department_id in (\n   select distinct department_id from departments where location_id in (1400, 1700)\n);\n# 使用any或者some\n# 查询其它部门中比job_id为`IT_PROG`部门任一低工资的员工的员工号、姓名、job_id以及salary\nselect  last_name, employee_id, job_id, salary from employees where salary < any(\n  select distinct salary from employees where job_id='IT_PROG'\n) and job_id <> 'IT_PROG';\n# 使用all\n# 查询其它部门中比job_id为`IT_PROG`部门任一低工资的员工的员工号、姓名、job_id以及salary\nselect  last_name, employee_id, job_id, salary from employees where salary < all(\n  select distinct salary from employees where job_id='IT_PROG'\n) and job_id <> 'IT_PROG';\n# 不常用的行子查询\n# 查询员工编号最小并且工资最高的员工信息\nselect * from employees where job_id = (\n  select min(job_id) from employees\n)\nand salary = (\n  select max(salary) from employees\n);\n# 或者\nselect * from employees where (job_id,salary) = (\n  select min(job_id), max(salary) from employees\n);\n# 查询每个部门的员工个数\nselect (\n  select count(*) from employees as e where e.department_id = d.department_id\n) as 员工个数 from departments as d having 员工个数 > 0 order by 员工个数 desc;\n\n\nfrom后面字句，把一个查询结果当做表来使用\n\n# 查询各个部门的平均工资对应的工资等级\nselect ag_dep.*, g.grade_level from (\n  select AVG(salary) as ag, department_id from employees group by department_id\n) as ag_dep inner join job_grades as g on ag_dep.ag between lowest_sal and highest_sal;\n\n\n相关子查询(exists)\n\n语法： exists(完整的查询语句)，返回1或者0\n\n# 查询有员工的部门名\nselect department_name from departments as d where exists (\n  select * from employees as e where d.department_id = e.department_id\n);\n# 等价转换\nselect department_name from departments as d inner join employees as e on d.department_id = e.department_id group by d.department_id having count(*) > 0;\n# 查询没有女朋友的男生信息\n# 使用in\nselect boy.* from boys as boy where boy.id not in (\n  select boyfriend_id from beauty\n);\n# 使用exists\nselect boy.* from boys as boy where not exists(\n  select boyfriend_id from beauty as girl where boy.id = girl.boyfriend_id\n);\n\n\n\n# DML 语言\n\n\n# DDL 语言",normalizedContent:"# mysql 学习笔记\n\n\n# 登录\n\nmysql -u root -p -h localhost -p 3306\n\n\n\n# 常见命令\n\n# 显示所有的数据库\nshow databases;\n# 选择数据库 xxx\nuse xxx;\n# 展示数据的表\nshow tables;\nshow tables from xxx;\n# 显示当前所在的数据库\nselect database();\n# 查看指定表的表结构\ndesc xxx;\n# 查看数据库的版本\nselect version();\n\n\n## 利用bash命令\nmysql --version;\nmysql -v;\n\n\n\n# 注释\n\n单行注释： -- 注释内容;（注意--后面有一个空格） 单行注释：#注释内容 多行注释：/* 我是一个注释内容 */\n\n\n# dql 语言\n\n\n# 查询\n\n# select\n\n# 从表中查询字段\nselect * from employees;\nselect username,age,gender from employees;\nselect username as myname from employees;\n# 关键字区分\n# select name from employees name会被当做关键字，因此可以用``包起来，如。\nselect `name` from employees;\n\n# 查询常量值\nselect 100\n# 查询函数\nselect now();\nselect version();\n# 查询表达式\nselect 2*100;\n\n# 别名 as可以省略\nselect 2+100 as `add`;\nselect 2/100 'test';\n\n# 去重 distinct;\nselect distinct * from employees;\n\n# + 只存在数值相加的功能，但是如果是字符串和数字相加，则判断能否转化成数字型，能转就转，不能转就相当于是0\n# `null`和任何内容连接都是`null`\n\n\n\n# where 条件查询\n\n1、按条件表达式\n\n> < = != <> >= <=等。\n\nselect * from employees where salary > 1200;\nselect * from employees where department_id != 90;\n\n\n推荐用<>代替!=;\n\n2、按逻辑表达式\n\n&& || ! and or not等。\n\nselect * from employees where salary > 1200 && department_id > 90;\nselect * from employees where salary >= 10000 && salary <= 15000;\n\n\n推荐用 and， or， not。\n\n3、模糊查询\n\nlike; between and; in; is null; is not null等。\n\nselect * from employees where salary between 12000 and 15000;\nselect * from employees where commission_pct is not null and first_name like '%jo%';\n# 匹配员工名中第三个字符为a，第五个字符为e的员工名\nselect last_name as lastname from employees where first_name like '__a_e%';\n\n\nlike和通配符搭配使用，%代表匹配任意个字符（0-n），_代表任意单个字符\n\n转义字符：\n\n# 直接转义\nselect last_name from employees where last_name like '_\\_%';\n# 使用escape关键字转义\nselect last_name from employees where last_name like '_$_%' escape '$';\n\n\n(not) between and，包含左右的临界值，但是必须是左大右小。\n\nselect * from employees where job_id in ('it_port', 'ad_vp', 'ad_pres');\n\n\nin 列表的内容的值类型必须一致或兼容。\n\nselect * from employees where commission_pct is null;\n\n\nis null 或者 is not null 可以判断null，但是，=，!=，<>不能判断null;\n\nselect * from employees where commission_pct <=> 12000;\n\n\n安全等于: <=>，既可以判断null，又可以判断普通数值。\n\n# 排序 order by\n\nasc 升序，desc降序，不写默认asc;\n\nselect * from employees where salary>12000 order by salary desc;\nselect * from employees where salary<12000 order by salary asc;\n# 按年薪的高低显示员工的信息和年薪\nselect *, salary * 12 * (1+ifnull(commission_pct, 0)) as year_salary from employees order by year_salary desc;\n# 按函数排序\nselect *, salary * 12 * (1+ifnull(commission_pct, 0)) as year_salary from employees order by length(last_name) desc;\n# 多关键字排序，多个关键字之间用逗号隔开，先按工资排序，再按编号排序\nselect * from employees order by salary desc, employee_id asc;\n\n\n# 常见函数\n\n字符串函数：\n\nlength：求字符串的长度。 concat：将字符串进行连接。 upper：将字符串转大写。 lower：将字符串转小写。 substr：取指定位置的子字符串， instr（和js的indexof类似）。 trim：消除字符串左右的空格。 lpad：在字符串的左边填充指定的字符。 rpad：在字符串的右边填充指定的字符。 replace：将指定的字符替换。\n\n注意：索引从1开始。\n\nshow variables like '%char%';\n\n\n数学函数：\n\nround：四舍五入； ceil：向上取整； floor：向下取整； truncate：小数点保留 n 位有效数字； mod：取余；\n\n日期函数：\n\nnow：返回系统当前的时间； curdate：返回系统当前的日期，不包含时分秒。 curtime：返回系统当前的时间，不包含年月日。 year：返回系统当前的年份。 month：返回系统当前的月份。 monthname：返回系统当前月份的名称，如november。 ... date_formate：将日期转换成字符。 str_to_date：将字符串转换成日期。\n\n其它函数：\n\nversion：返回数据库的版本。 database：返回当前使用的数据库。 user：返回当前登录的用户。\n\nselect str_to_date('9-12-1994','%m-%d-%y');\nselect date_format('2022-10-10', '%y年%m月%d日');\n\n\n格式符   功能\n%y    四位的年份\n%y    2 位的年份\n%m    月份, 01,02,03,04,05,06,07,08,09,10,11,12\n%c    月份, 1,2,3,4,5,6,7,8,9,10,11,12\n%d    月份, 1,2,3,4,5,6,7,8,9,10,11,12\n%h    小时，24 小时制\n%h    小时，12 小时制\n%i    分钟，01-59\n%s    秒，01-59\n\n流程控制函数：\n\nifnull： if：if(exp1, exp2, exp3)，如果exp1成立返回exp2，否则返回exp3。 case：\n\ncase 表达式 when 常量 1 then 值或语句 1 when 常量 2 then 值或语句 2 when 常量 3 then 值或语句 3 (else 值或语句) end\n\ncase when 条件 1 then 值或语句 1 when 条件 2 then 值或语句 2 when 条件 3 then 值或语句 3 (else 值或语句) end\n\nselect salary, department_id, case department_id when 30 then salary * 1.1 when 50 then salary * 1.2 else salary end as new_salary from employees;\n\n\n聚合函数：\n\nmax：求最大值 min：求最小值 sum：求和 avg：求平均值 count：统计\n\nsum和avg一般用于数值处理；max，min，count可以处理任何类型；\n\nsum、avg、count、min、max都将会忽略null。\n\n可以和distinct搭配，如：\n\nselect sum(distinct salary), sum(salary) from employees;\nselect count(distinct salary) from employees;\n\n\ncount函数的详细介绍，用于统计行数，如：\n\n# 用于统计行数\nselect count(*) from employees;\n# 或者\nselect count(1) from employees;\n\n\n在myisam引擎下，count(*)的效率高，在innodb引擎下，count(1)和count(*)差不多，但是要比count(字段名)要高。\n\n# group by\n\n和分组函数一同查询的字段要求是group by后的字段 伪代码如：\n\nselect column, group_function(column) from xxx_table [where condition] [group by group_by_expression] [order by column];\n\n\n例如：\n\nselect max(salary), job_id from employees group by job_id;\nselect count(*), location_id from departments group by location_id;\n\n\nwhere一定在group by之前，order by一定在最后。\n\n使用having关键字用于添加分组后的筛选：如查询部门员工数大于 2 的部门 id\n\nselect count(*), department_id from employees group by department_id having count(*) > 2;\n\n\n分组查询筛选，分为两类，一是分组前筛选，使用where（原始表数据），一类是分组后筛选，使用having（分组之后的结果集），如果是使用分组函数做条件的话，那么肯定是放在having子句中，能用分组前作筛选的，就优先考虑使用分组前筛选，group by字句支持单个或多个字段进行分组，若采用多个字段分组，则字段之间需要使用,分隔，无顺序要求。\n\n# 连接查询\n\n笛卡尔积的错误情况：\n\n# 假设输出12行\nselect count(*) from boys;\n# 假设输出4行\nselect count(*) from beauty;\n# 最终结果 4*12行\nselect `name`, `boyname` from beauty, boys;\n\n\n笛卡尔积的现象：表 1 有 m 行，表 2 有 n 行，结果 m*n 行，是因为没有有效的连接；\n\n\n分类:\n  内连接\n    等值连接\n    非等值连接\n    自连接\n  外连接\n    左外连接\n    右外连接\n    完全链接\n  交叉连接\n\n\n等值连接：\n\n# 两个表的顺序可以交换\nselect `name`, `boyname` from beauty, boys where beauty.boyfriend_id = boys.id;\n\n\n等值连接加上筛选，使用and连接。\n\nselect last_name, department_name from employees e, departments d where e.department_id = d.department_id and e.commission_pct is not null;\n# 查询所有女朋友的个数大于2的男生\nselect boy.boyname, count(*) as stat from boys as boy, beauty as girl where girl.boyfriend_id = boy.id group by boy.boyname having stat > 2 order by stat desc;\n\n\n多表等值连接连接的结果为多表的交集部分，多表连接的顺序没有要求，一般需要为表起别名。\n\n非等值连接： 即不用等号的连接查询。\n\nselect e.salary, j.grade_level from employees as e, job_grades as j where e.salary between j.lowest_sal and j.highest_sal;\n\n\n自连接：\n\n# 查询员工和领导的名称\nselect e.employee_id,e.last_name,m.employee_id as parent_id,m.last_name as parent_last_name from employees as e, employees as m where e.manager_id = m.employee_id;\n\n\n(inner) join： （查找两个表的并集）\n\nselect 查询列表 from 表1 inner join 表2 on 连接条件 [where 字句] [group by字句] [having字句] [order by 字句] [limit 字句]\n# 查询部门人数大于10的部门名称并且按人数降序排列\nselect d.department_name, count(*) as 部门人数 from employees as e inner join departments as d on e.department_id = d.department_id group by d.department_name having\t部门人数 >10 order by 部门人数 desc;\n# 非等值连接\nselect salary,grade_level from employees as e inner join job_grades as g on e.salary between g.lowest_sal and g.highest_sal;\n# 自连接\nselect e.last_name, m.last_name from employees as e inner join employees as m on e.employee_id = m.manager_id;\n\n\nouter join:\n\n应用场景一般用于查找一个表中有，另外一个表中没有的情况，外连接的查询结果为主表中的所有记录，如果从表中有和它匹配的记录，则填充，否则填充null。 外连接查询结果=内连接结果+主表中有但从表中没有的记录。 全外连接=内连接的结果+表 1 中有但表 2 中没有的结果+表 2 中有的结果但表 1 中没有的结果（即求两表的并集）\n\nleft outer join: 左边的是主表，右边的是从表 right outer join: 左边的是从表，右边的主表\n\n左外连接和右外连接交换两个表的顺序，可以实现同样的效果。\n\n# 查找没有男朋友的女生列表\n# 最好选从表中的主键列作为筛选，因为主键列一般都是非空字段\nselect girl.name, girl.borndate from beauty as girl left outer join boys as boy on girl.boyfriend_id = boy.id where boy.id is null;\n\n\n交叉链接： 即笛卡尔乘积\n\nselect b.*, g.* from beauty as g cross join boys as b;\n# 等价于\nselect g.*, b.* from beauty as g, boys as b;\n\n\n# 子查询\n\n出现在其它语句中的 select 语句。 子查询先于主查询。\n\n# 查询工资比`abel`高的人\nselect * from employees where salary > (\n  select salary from employees where last_name = 'abel'\n);\n# 子查询中使用分组函数\nselect last_name, job_id, salary from employees where salary = (select min(salary) from employees);\n# 和`having`字句一起使用 查询最低工资大于50号部门最低工资的部门id和其最低工资\nselect department_id, min(salary) from employees group by department_id having min(salary) > (select min(salary) from employees where department_id = 50);\n# 使用in\nselect last_name from employees where department_id in (\n   select distinct department_id from departments where location_id in (1400, 1700)\n);\n# 使用any或者some\n# 查询其它部门中比job_id为`it_prog`部门任一低工资的员工的员工号、姓名、job_id以及salary\nselect  last_name, employee_id, job_id, salary from employees where salary < any(\n  select distinct salary from employees where job_id='it_prog'\n) and job_id <> 'it_prog';\n# 使用all\n# 查询其它部门中比job_id为`it_prog`部门任一低工资的员工的员工号、姓名、job_id以及salary\nselect  last_name, employee_id, job_id, salary from employees where salary < all(\n  select distinct salary from employees where job_id='it_prog'\n) and job_id <> 'it_prog';\n# 不常用的行子查询\n# 查询员工编号最小并且工资最高的员工信息\nselect * from employees where job_id = (\n  select min(job_id) from employees\n)\nand salary = (\n  select max(salary) from employees\n);\n# 或者\nselect * from employees where (job_id,salary) = (\n  select min(job_id), max(salary) from employees\n);\n# 查询每个部门的员工个数\nselect (\n  select count(*) from employees as e where e.department_id = d.department_id\n) as 员工个数 from departments as d having 员工个数 > 0 order by 员工个数 desc;\n\n\nfrom后面字句，把一个查询结果当做表来使用\n\n# 查询各个部门的平均工资对应的工资等级\nselect ag_dep.*, g.grade_level from (\n  select avg(salary) as ag, department_id from employees group by department_id\n) as ag_dep inner join job_grades as g on ag_dep.ag between lowest_sal and highest_sal;\n\n\n相关子查询(exists)\n\n语法： exists(完整的查询语句)，返回1或者0\n\n# 查询有员工的部门名\nselect department_name from departments as d where exists (\n  select * from employees as e where d.department_id = e.department_id\n);\n# 等价转换\nselect department_name from departments as d inner join employees as e on d.department_id = e.department_id group by d.department_id having count(*) > 0;\n# 查询没有女朋友的男生信息\n# 使用in\nselect boy.* from boys as boy where boy.id not in (\n  select boyfriend_id from beauty\n);\n# 使用exists\nselect boy.* from boys as boy where not exists(\n  select boyfriend_id from beauty as girl where boy.id = girl.boyfriend_id\n);\n\n\n\n# dml 语言\n\n\n# ddl 语言",charsets:{cjk:!0}}],themeConfig:{enableDarkMode:!0,repo:"https://github.com/sicau-hsuyang/sicau-hsuyang.github.io.git",nav:[{text:"数据结构&算法",link:"/data-structure/"},{text:"设计模式",link:"/design-pattern/"},{text:"JavaScript",link:"/javascript/"},{text:"前端框架",link:"/frameworks/"}],sidebar:{"/javascript/":[{title:"JavaScript专题",path:"/javascript/"},{title:"函数上下文this",path:"/javascript/this"},{title:"原型及原型链",path:"/javascript/prototype"},{title:"继承",path:"/javascript/extend"},{title:"闭包",path:"/javascript/closure"},{title:"Ajax",path:"/javascript/ajax"},{title:"手写",children:[{title:"深浅克隆",path:"/javascript/write/clone"}]},{title:"es6",children:[{title:"Class",path:"/javascript/es6/class"}]}],"/data-structure/":[{title:"常见的数据结构和算法",path:"/data-structure/"},{title:"数组",children:[{title:"数组的介绍",path:"/data-structure/list/array"},{title:"合并2（K）个有序数组",path:"/data-structure/list/mergeArray"}]},{title:"链表",children:[{title:"链表的介绍",path:"/data-structure/list/linkedList"},{title:"双向链表的介绍",path:"/data-structure/list/doubleLinkedList"},{title:"LRUCache",path:"/data-structure/list/lru-cache"},{title:"LFUCache",path:"/data-structure/list/lfu-cache"}]},{title:"字符串",children:[{title:"KMP算法",path:"/data-structure/string/KMP"}]},{title:"队列",children:[{title:"队列的介绍",path:"/data-structure/queue/desc"},{title:"队列的应用——广度优先遍历",path:"/data-structure/tree/N-Tree/bfsVisit"}]},{title:"栈",children:[{title:"栈的介绍",path:"/data-structure/stack/desc"},{title:"栈的应用之逆序",path:"/data-structure/stack/reverse"},{title:"栈的应用之DFS",path:"/data-structure/stack/dfs"},{title:"栈的应用之词法分析",path:"/data-structure/stack/syntaxAnalysis"},{title:"单调栈与应用",path:"/data-structure/stack/monotonous-stack"}]},{title:"堆（优先队列）",children:[{title:"堆的介绍",path:"/data-structure/heap/desc"},{title:"堆的应用——排序",path:"/data-structure/sort/heapSort"},{title:"堆的应用——前K个高频元素",path:"/data-structure/heap/topKFrequent"}]},{title:"树",sidebarDepth:4,children:[{title:"二叉树",children:[{title:"先序遍历",path:"/data-structure/tree/binaryTree/preOrderVisit"},{title:"中序遍历",path:"/data-structure/tree/binaryTree/inOrderVisit"},{title:"后序遍历",path:"/data-structure/tree/binaryTree/postOrderVisit"},{title:"层序遍历",path:"/data-structure/tree/binaryTree/levelOrderVisit"},{title:"Morris遍历法",path:"/data-structure/tree/binaryTree/morrisVisit"},{title:"二叉树的构建",path:"/data-structure/tree/binaryTree/construct"}]},{title:"N叉树",children:[{title:"深度优先遍历",path:"/data-structure/tree/N-Tree/dfsVisit"},{title:"广度优先遍历",path:"/data-structure/tree/N-Tree/bfsVisit"},{title:"字典树",path:"/data-structure/tree/N-Tree/Trie"}]},{title:"二叉搜索树",children:[{title:"二叉搜索树的介绍",path:"/data-structure/tree/binarySearchTree/desc"}]}]},{title:"图",children:[{title:"图的介绍",path:"/data-structure/graph/desc"},{title:"深度优先搜索",path:"/data-structure/graph/dfs"},{title:"广度优先搜索",path:"/data-structure/graph/bfs"},{title:"最短路径",path:"/data-structure/graph/shortest-path"},{title:"拓扑排序",path:"/data-structure/graph/topology-sort"},{title:"最小生成树",path:"/data-structure/graph/minimum-spanning-tree"}]},{title:"哈希表",children:[{title:"哈希表的介绍",path:"/data-structure/hash/desc"},{title:"哈希表的应用——两数之和",path:"/data-structure/hash/sum"},{title:"哈希表的应用——构建树",path:"/data-structure/hash/buildTree"},{title:"哈希表的应用——LRUCache",path:"/data-structure/list/lru-cache"},{title:"哈希表的应用——深克隆",path:"/data-structure/hash/deepClone"},{title:"哈希表的应用——从链表中删去总和值为零的连续节点",path:"/data-structure/hash/removeZero"}]},{title:"排序",children:[{title:"排序算法的比较",path:"/data-structure/sort/compare"},{title:"冒泡排序",path:"/data-structure/sort/bubbleSort"},{title:"选择排序",path:"/data-structure/sort/selectionSort"},{title:"插入排序",path:"/data-structure/sort/insertionSort"},{title:"希尔排序",path:"/data-structure/sort/shellSort"},{title:"快速排序",path:"/data-structure/sort/quickSort"},{title:"归并排序",path:"/data-structure/sort/mergeSort"},{title:"堆排序",path:"/data-structure/sort/heapSort"},{title:"桶排序",path:"/data-structure/sort/bucketSort"},{title:"基数排序",path:"/data-structure/sort/radixSort"}]},{title:"查找",children:[{title:"二分查找",path:"/data-structure/search/binarySearch"},{title:"平衡二叉树（AVL）",path:"/data-structure/search/avlTree"},{title:"跳跃链表",path:"/data-structure/search/skipList"}]}],"/design-pattern/":[{title:"面向对象设计原则&设计模式",path:"/design-pattern/"},{title:"单例模式",path:"/design-pattern/singleton"},{title:"工厂模式",path:"/design-pattern/factory"},{title:"命令模式",path:"/design-pattern/command"},{title:"代理模式",path:"/design-pattern/proxy"},{title:"观察者模式",path:"/design-pattern/watcher"},{title:"桥接模式",path:"/design-pattern/bridge"},{title:"适配器模式",path:"/design-pattern/adaptor"},{title:"装饰模式",path:"/design-pattern/decorator"},{title:"策略模式",path:"/design-pattern/strategy"},{title:"享元模式",path:"/design-pattern/flyweight"},{title:"中介者模式",path:"/design-pattern/mediator"}]},codeSwitcher:{groups:{default:{ts:"TypeScript",js:"JavaScript"},"plugin-usage":{tuple:"Tuple",object:"Object"}}}}};t(228);r.a.component("Badge",()=>Promise.all([t.e(0),t.e(3)]).then(t.bind(null,407))),r.a.component("CodeBlock",()=>Promise.all([t.e(0),t.e(4)]).then(t.bind(null,317))),r.a.component("CodeGroup",()=>Promise.all([t.e(0),t.e(5)]).then(t.bind(null,318))),r.a.component("Details",()=>Promise.all([t.e(0),t.e(6)]).then(t.bind(null,408))),r.a.component("Summary",()=>Promise.all([t.e(0),t.e(9)]).then(t.bind(null,409))),r.a.component("VPIconExternalLink",()=>Promise.all([t.e(0),t.e(10)]).then(t.bind(null,410))),r.a.component("VPLink",()=>t.e(12).then(t.bind(null,319))),r.a.component("Step",()=>Promise.all([t.e(0),t.e(8)]).then(t.bind(null,320))),r.a.component("NextSteps",()=>Promise.all([t.e(0),t.e(7)]).then(t.bind(null,411)));r.a.component("CodeSwitcher",()=>Promise.all([t.e(0),t.e(11)]).then(t.bind(null,315)));t(229);var Le=[{},({Vue:n})=>{n.mixin({computed:{$dataBlock(){return this.$options.__data__block__}}})},{},{},{}],Me=[];class Ve extends class{constructor(){this.store=new r.a({data:{state:{}}})}$get(n){return this.store.state[n]}$set(n,e){r.a.set(this.store.state,n,e)}$emit(...n){this.store.$emit(...n)}$on(...n){this.store.$on(...n)}}{}Object.assign(Ve.prototype,{getPageAsyncComponent:de,getLayoutAsyncComponent:ce,getAsyncComponent:ue,getVueComponent:he});var Re={install(n){const e=new Ve;n.$vuepress=e,n.prototype.$vuepress=e}};function $e(n,e){const t=e.toLowerCase();return n.options.routes.some(n=>n.path.toLowerCase()===t)}var De={props:{pageKey:String,slotKey:{type:String,default:"default"}},render(n){const e=this.pageKey||this.$parent.$page.key;return fe("pageKey",e),r.a.component(e)||r.a.component(e,de(e)),r.a.component(e)?n(e):n("")}},qe={functional:!0,props:{slotKey:String,required:!0},render:(n,{props:e,slots:t})=>n("div",{class:["content__"+e.slotKey]},t()[e.slotKey])},Fe={computed:{openInNewWindowTitle(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},Be=(t(230),t(231),Object(Oe.a)(Fe,(function(){var n=this._self._c;return n("span",[n("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[n("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),n("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),n("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports),He={functional:!0,render(n,{parent:e,children:t}){if(e._isMounted)return t;e.$once("hook:mounted",()=>{e.$forceUpdate()})}};r.a.config.productionTip=!1,r.a.use(Yn),r.a.use(Re),r.a.mixin(function(n,e,t=r.a){!function(n){n.locales&&Object.keys(n.locales).forEach(e=>{n.locales[e].path=e});Object.freeze(n)}(e),t.$vuepress.$set("siteData",e);const a=new(n(t.$vuepress.$get("siteData"))),i=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(a)),o={};return Object.keys(i).reduce((n,e)=>(e.startsWith("$")&&(n[e]=i[e].get),n),o),{computed:o}}(n=>class{setPage(n){this.__page=n}get $site(){return n}get $themeConfig(){return this.$site.themeConfig}get $frontmatter(){return this.$page.frontmatter}get $localeConfig(){const{locales:n={}}=this.$site;let e,t;for(const r in n)"/"===r?t=n[r]:0===this.$page.path.indexOf(r)&&(e=n[r]);return e||t||{}}get $siteTitle(){return this.$localeConfig.title||this.$site.title||""}get $canonicalUrl(){const{canonicalUrl:n}=this.$page.frontmatter;return"string"==typeof n&&n}get $title(){const n=this.$page,{metaTitle:e}=this.$page.frontmatter;if("string"==typeof e)return e;const t=this.$siteTitle,r=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?r?r+" | "+t:t:r||"VuePress"}get $description(){const n=function(n){if(n){const e=n.filter(n=>"description"===n.name)[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}get $lang(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}get $localePath(){return this.$localeConfig.path||"/"}get $themeLocaleConfig(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}get $page(){return this.__page?this.__page:function(n,e){for(let t=0;t<n.length;t++){const r=n[t];if(r.path.toLowerCase()===e.toLowerCase())return r}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}},Ee)),r.a.component("Content",De),r.a.component("ContentSlotsDistributor",qe),r.a.component("OutboundLink",Be),r.a.component("ClientOnly",He),r.a.component("Layout",ce("Layout")),r.a.component("NotFound",ce("NotFound")),r.a.prototype.$withBase=function(n){const e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.9.7",hash:"d5dd63f"},async function(n){const e="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:Ee.routerBase||Ee.base,t=new Yn({base:e,mode:"history",fallback:!1,routes:Ie,scrollBehavior:(n,e,t)=>t||(n.hash?!r.a.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})});!function(n){n.beforeEach((e,t,r)=>{if($e(n,e.path))r();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){const t=e.path.replace(/\/$/,"")+".html";$e(n,t)?r(t):r()}else r();else{const t=e.path+"/",a=e.path+".html";$e(n,a)?r(a):$e(n,t)?r(t):r()}})}(t);const a={};try{await Promise.all(Le.filter(n=>"function"==typeof n).map(e=>e({Vue:r.a,options:a,router:t,siteData:Ee,isServer:n})))}catch(n){console.error(n)}return{app:new r.a(Object.assign(a,{router:t,render:n=>n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},Me.map(e=>n(e)))])})),router:t}}(!1).then(({app:n,router:e})=>{e.onReady(()=>{n.$mount("#app")})})}]);