(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var r,i,s=e[0],l=e[1],c=e[2],d=0,p=[];d<s.length;d++)i=s[d],Object.prototype.hasOwnProperty.call(a,i)&&a[i]&&p.push(a[i][0]),a[i]=0;for(r in l)Object.prototype.hasOwnProperty.call(l,r)&&(n[r]=l[r]);for(u&&u(e);p.length;)p.shift()();return o.push.apply(o,c||[]),t()}function t(){for(var n,e=0;e<o.length;e++){for(var t=o[e],r=!0,s=1;s<t.length;s++){var l=t[s];0!==a[l]&&(r=!1)}r&&(o.splice(e--,1),n=i(i.s=t[0]))}return n}var r={},a={1:0},o=[];function i(e){if(r[e])return r[e].exports;var t=r[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,i),t.l=!0,t.exports}i.e=function(n){var e=[],t=a[n];if(0!==t)if(t)e.push(t[2]);else{var r=new Promise((function(e,r){t=a[n]=[e,r]}));e.push(t[2]=r);var o,s=document.createElement("script");s.charset="utf-8",s.timeout=120,i.nc&&s.setAttribute("nonce",i.nc),s.src=function(n){return i.p+"assets/js/"+({}[n]||n)+"."+{2:"12e8afdc",3:"8bb08900",4:"0c913116",5:"07013acf",6:"7ff5aaa5",7:"60fd6604",8:"f4f3a660",9:"ab5632a2",10:"baccc56b",11:"8638c842",12:"25c2f63c",13:"7f7122e6",14:"7c1c5f48",15:"9977009e",16:"64f28479",17:"7072c7fc",18:"8472dfff",19:"f7f73153",20:"f15d8f4f",21:"57c81c06",22:"a75f0d64",23:"df8fda1a",24:"f153675e",25:"4f188e2f",26:"507720bc",27:"f9c3a296",28:"b7f78186",29:"0d67fce7",30:"7eadc9eb",31:"e9fb364a",32:"bbae5727",33:"fe559f4a",34:"1ad7565c",35:"78e25877",36:"883d8e45",37:"bde30677",38:"477f4a2a",39:"45641837",40:"79e646ce",41:"09c6e79e",42:"9c3624ab",43:"b829e2be",44:"3fd8317b",45:"69c45e76",46:"5910105b",47:"17f7644c",48:"c80b5e67",49:"7a5ec15d",50:"7dfdc4a3",51:"76daa77e",52:"3172eac9",53:"abaf0864",54:"8e7c7a23",55:"77b8b772",56:"e13e3fd2",57:"675e0f05",58:"ee4db9ec",59:"54d287d2",60:"ccb9da38",61:"e054d881",62:"0de5a860",63:"bbe8e051",64:"e50ba1ce",65:"fc8216e4",66:"53402a10",67:"49e787ac",68:"63d35edb",69:"470de340",70:"0e962845",71:"6f4b3243",72:"f8b30cb9",73:"2f8f2a1f",74:"c14b7b23",75:"fad8a8bf",76:"994a0d86",77:"086c6ae5",78:"b07d4960",79:"019beafc",80:"eaad8363",81:"06d43c8c",82:"b98e5f30",83:"30561e92",84:"a7617970",85:"3fe2997a",86:"25831c0a",87:"22bad325",88:"423574ca",89:"1b31df01",90:"97ba019b",91:"7920a771",92:"c37fa853",93:"edd32c06",94:"25850ad0",95:"4b83de2f",96:"b84b1068",97:"d6e83989",98:"36b621cf",99:"817bd576",100:"4eb916c7",101:"b4322581",102:"a7b405e2",103:"013b875b",104:"d16b1ee3",105:"eb63c358",106:"a0b5f34b",107:"830e194d",108:"522535ad",109:"8b28ba5f",110:"b4bcd648",111:"9c8c329a",112:"aff7b283",113:"6d987a48",114:"dbaa41fd",115:"71eb4dae",116:"bb3c5fd3",117:"e4d6485d",118:"deb50861",119:"ada64290",120:"840eb8f5",121:"d253b524",122:"ae6595a6",123:"0c19ef68",124:"d3e61d1e",125:"fb2c053a",126:"b04b7c54",127:"4fd76df1",128:"95ecce5e",129:"488a96f1",130:"3ff45b69",131:"3522fd4b",132:"33c48bf9",133:"a65f2089",134:"079b260e",135:"6922369d",136:"a4e28b47",137:"9cc53095",138:"1fcb2a62",139:"7ab052c0",140:"061c672f",141:"7d3c0725",142:"5f2817f4"}[n]+".js"}(n);var l=new Error;o=function(e){s.onerror=s.onload=null,clearTimeout(c);var t=a[n];if(0!==t){if(t){var r=e&&("load"===e.type?"missing":e.type),o=e&&e.target&&e.target.src;l.message="Loading chunk "+n+" failed.\n("+r+": "+o+")",l.name="ChunkLoadError",l.type=r,l.request=o,t[1](l)}a[n]=void 0}};var c=setTimeout((function(){o({type:"timeout",target:s})}),12e4);s.onerror=s.onload=o,document.head.appendChild(s)}return Promise.all(e)},i.m=n,i.c=r,i.d=function(n,e,t){i.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},i.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},i.t=function(n,e){if(1&e&&(n=i(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(i.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var r in n)i.d(t,r,function(e){return n[e]}.bind(null,r));return t},i.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return i.d(e,"a",e),e},i.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},i.p="/",i.oe=function(n){throw console.error(n),n};var s=window.webpackJsonp=window.webpackJsonp||[],l=s.push.bind(s);s.push=e,s=s.slice();for(var c=0;c<s.length;c++)e(s[c]);var u=l;o.push([97,0]),t()}([function(n,e,t){"use strict";t.d(e,"a",(function(){return Ut}));
/*!
 * Vue.js v2.7.8
 * (c) 2014-2022 Evan You
 * Released under the MIT License.
 */
var r=Object.freeze({}),a=Array.isArray;function o(n){return null==n}function i(n){return null!=n}function s(n){return!0===n}function l(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function c(n){return"function"==typeof n}function u(n){return null!==n&&"object"==typeof n}var d=Object.prototype.toString;function p(n){return"[object Object]"===d.call(n)}function h(n){return"[object RegExp]"===d.call(n)}function f(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function m(n){return i(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function g(n){return null==n?"":Array.isArray(n)||p(n)&&n.toString===d?JSON.stringify(n,null,2):String(n)}function v(n){var e=parseFloat(n);return isNaN(e)?n:e}function y(n,e){for(var t=Object.create(null),r=n.split(","),a=0;a<r.length;a++)t[r[a]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}y("slot,component",!0);var b=y("key,ref,slot,slot-scope,is");function x(n,e){if(n.length){var t=n.indexOf(e);if(t>-1)return n.splice(t,1)}}var w=Object.prototype.hasOwnProperty;function k(n,e){return w.call(n,e)}function _(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var j=/-(\w)/g,S=_((function(n){return n.replace(j,(function(n,e){return e?e.toUpperCase():""}))})),N=_((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),P=/\B([A-Z])/g,T=_((function(n){return n.replace(P,"-$1").toLowerCase()}));var C=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var r=arguments.length;return r?r>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function I(n,e){e=e||0;for(var t=n.length-e,r=new Array(t);t--;)r[t]=n[t+e];return r}function A(n,e){for(var t in e)n[t]=e[t];return n}function E(n){for(var e={},t=0;t<n.length;t++)n[t]&&A(e,n[t]);return e}function z(n,e,t){}var O=function(n,e,t){return!1},L=function(n){return n};function M(n,e){if(n===e)return!0;var t=u(n),r=u(e);if(!t||!r)return!t&&!r&&String(n)===String(e);try{var a=Array.isArray(n),o=Array.isArray(e);if(a&&o)return n.length===e.length&&n.every((function(n,t){return M(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(a||o)return!1;var i=Object.keys(n),s=Object.keys(e);return i.length===s.length&&i.every((function(t){return M(n[t],e[t])}))}catch(n){return!1}}function D(n,e){for(var t=0;t<n.length;t++)if(M(n[t],e))return t;return-1}function R(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}function q(n,e){return n===e?0===n&&1/n!=1/e:n==n||e==e}var F=["component","directive","filter"],$=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch","renderTracked","renderTriggered"],V={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:O,isReservedAttr:O,isUnknownElement:O,getTagNamespace:z,parsePlatformTagName:L,mustUseProp:O,async:!0,_lifecycleHooks:$},B=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function H(n){var e=(n+"").charCodeAt(0);return 36===e||95===e}function U(n,e,t,r){Object.defineProperty(n,e,{value:t,enumerable:!!r,writable:!0,configurable:!0})}var G=new RegExp("[^".concat(B.source,".$_\\d]"));var K="__proto__"in{},J="undefined"!=typeof window,W=J&&window.navigator.userAgent.toLowerCase(),Q=W&&/msie|trident/.test(W),Y=W&&W.indexOf("msie 9.0")>0,X=W&&W.indexOf("edge/")>0;W&&W.indexOf("android");var Z=W&&/iphone|ipad|ipod|ios/.test(W);W&&/chrome\/\d+/.test(W),W&&/phantomjs/.test(W);var nn,en=W&&W.match(/firefox\/(\d+)/),tn={}.watch,rn=!1;if(J)try{var an={};Object.defineProperty(an,"passive",{get:function(){rn=!0}}),window.addEventListener("test-passive",null,an)}catch(n){}var on=function(){return void 0===nn&&(nn=!J&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),nn},sn=J&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function ln(n){return"function"==typeof n&&/native code/.test(n.toString())}var cn,un="undefined"!=typeof Symbol&&ln(Symbol)&&"undefined"!=typeof Reflect&&ln(Reflect.ownKeys);cn="undefined"!=typeof Set&&ln(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var dn=null;function pn(n){void 0===n&&(n=null),n||dn&&dn._scope.off(),dn=n,n&&n._scope.on()}var hn=function(){function n(n,e,t,r,a,o,i,s){this.tag=n,this.data=e,this.children=t,this.text=r,this.elm=a,this.ns=void 0,this.context=o,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=i,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=s,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}return Object.defineProperty(n.prototype,"child",{get:function(){return this.componentInstance},enumerable:!1,configurable:!0}),n}(),fn=function(n){void 0===n&&(n="");var e=new hn;return e.text=n,e.isComment=!0,e};function mn(n){return new hn(void 0,void 0,void 0,String(n))}function gn(n){var e=new hn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}var vn=0,yn=function(){function n(){this.id=vn++,this.subs=[]}return n.prototype.addSub=function(n){this.subs.push(n)},n.prototype.removeSub=function(n){x(this.subs,n)},n.prototype.depend=function(e){n.target&&n.target.addDep(this)},n.prototype.notify=function(n){var e=this.subs.slice();for(var t=0,r=e.length;t<r;t++){e[t].update()}},n}();yn.target=null;var bn=[];function xn(n){bn.push(n),yn.target=n}function wn(){bn.pop(),yn.target=bn[bn.length-1]}var kn=Array.prototype,_n=Object.create(kn);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=kn[n];U(_n,n,(function(){for(var t=[],r=0;r<arguments.length;r++)t[r]=arguments[r];var a,o=e.apply(this,t),i=this.__ob__;switch(n){case"push":case"unshift":a=t;break;case"splice":a=t.slice(2)}return a&&i.observeArray(a),i.dep.notify(),o}))}));var jn=Object.getOwnPropertyNames(_n),Sn={},Nn=!0;function Pn(n){Nn=n}var Tn={notify:z,depend:z,addSub:z,removeSub:z},Cn=function(){function n(n,e,t){if(void 0===e&&(e=!1),void 0===t&&(t=!1),this.value=n,this.shallow=e,this.mock=t,this.dep=t?Tn:new yn,this.vmCount=0,U(n,"__ob__",this),a(n)){if(!t)if(K)n.__proto__=_n;else for(var r=0,o=jn.length;r<o;r++){U(n,s=jn[r],_n[s])}e||this.observeArray(n)}else{var i=Object.keys(n);for(r=0;r<i.length;r++){var s;An(n,s=i[r],Sn,void 0,e,t)}}}return n.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)In(n[e],!1,this.mock)},n}();function In(n,e,t){var r;if(!(!u(n)||Rn(n)||n instanceof hn))return k(n,"__ob__")&&n.__ob__ instanceof Cn?r=n.__ob__:!Nn||!t&&on()||!a(n)&&!p(n)||!Object.isExtensible(n)||n.__v_skip||(r=new Cn(n,e,t)),r}function An(n,e,t,r,o,i){var s=new yn,l=Object.getOwnPropertyDescriptor(n,e);if(!l||!1!==l.configurable){var c=l&&l.get,u=l&&l.set;c&&!u||t!==Sn&&2!==arguments.length||(t=n[e]);var d=!o&&In(t,!1,i);return Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=c?c.call(n):t;return yn.target&&(s.depend(),d&&(d.dep.depend(),a(e)&&On(e))),Rn(e)&&!o?e.value:e},set:function(e){var r=c?c.call(n):t;if(q(r,e)){if(u)u.call(n,e);else{if(c)return;if(!o&&Rn(r)&&!Rn(e))return void(r.value=e);t=e}d=!o&&In(e,!1,i),s.notify()}}}),s}}function En(n,e,t){if(!Dn(n)){var r=n.__ob__;return a(n)&&f(e)?(n.length=Math.max(n.length,e),n.splice(e,1,t),r&&!r.shallow&&r.mock&&In(t,!1,!0),t):e in n&&!(e in Object.prototype)?(n[e]=t,t):n._isVue||r&&r.vmCount?t:r?(An(r.value,e,t,void 0,r.shallow,r.mock),r.dep.notify(),t):(n[e]=t,t)}}function zn(n,e){if(a(n)&&f(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||Dn(n)||k(n,e)&&(delete n[e],t&&t.dep.notify())}}function On(n){for(var e=void 0,t=0,r=n.length;t<r;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),a(e)&&On(e)}function Ln(n){return Mn(n,!0),U(n,"__v_isShallow",!0),n}function Mn(n,e){if(!Dn(n)){In(n,e,on());0}}function Dn(n){return!(!n||!n.__v_isReadonly)}function Rn(n){return!(!n||!0!==n.__v_isRef)}function qn(n,e,t){Object.defineProperty(n,t,{enumerable:!0,configurable:!0,get:function(){var n=e[t];if(Rn(n))return n.value;var r=n&&n.__ob__;return r&&r.dep.depend(),n},set:function(n){var r=e[t];Rn(r)&&!Rn(n)?r.value=n:e[t]=n}})}"".concat("watcher"," callback"),"".concat("watcher"," getter"),"".concat("watcher"," cleanup");var Fn;var $n=function(){function n(n){void 0===n&&(n=!1),this.active=!0,this.effects=[],this.cleanups=[],!n&&Fn&&(this.parent=Fn,this.index=(Fn.scopes||(Fn.scopes=[])).push(this)-1)}return n.prototype.run=function(n){if(this.active){var e=Fn;try{return Fn=this,n()}finally{Fn=e}}else 0},n.prototype.on=function(){Fn=this},n.prototype.off=function(){Fn=this.parent},n.prototype.stop=function(n){if(this.active){var e=void 0,t=void 0;for(e=0,t=this.effects.length;e<t;e++)this.effects[e].teardown();for(e=0,t=this.cleanups.length;e<t;e++)this.cleanups[e]();if(this.scopes)for(e=0,t=this.scopes.length;e<t;e++)this.scopes[e].stop(!0);if(this.parent&&!n){var r=this.parent.scopes.pop();r&&r!==this&&(this.parent.scopes[this.index]=r,r.index=this.index)}this.active=!1}},n}();function Vn(n){var e=n._provided,t=n.$parent&&n.$parent._provided;return t===e?n._provided=Object.create(t):e}var Bn=_((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),r="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=r?n.slice(1):n,once:t,capture:r,passive:e}}));function Hn(n,e){function t(){var n=t.fns;if(!a(n))return Ne(n,null,arguments,e,"v-on handler");for(var r=n.slice(),o=0;o<r.length;o++)Ne(r[o],null,arguments,e,"v-on handler")}return t.fns=n,t}function Un(n,e,t,r,a,i){var l,c,u,d;for(l in n)c=n[l],u=e[l],d=Bn(l),o(c)||(o(u)?(o(c.fns)&&(c=n[l]=Hn(c,i)),s(d.once)&&(c=n[l]=a(d.name,c,d.capture)),t(d.name,c,d.capture,d.passive,d.params)):c!==u&&(u.fns=c,n[l]=u));for(l in e)o(n[l])&&r((d=Bn(l)).name,e[l],d.capture)}function Gn(n,e,t){var r;n instanceof hn&&(n=n.data.hook||(n.data.hook={}));var a=n[e];function l(){t.apply(this,arguments),x(r.fns,l)}o(a)?r=Hn([l]):i(a.fns)&&s(a.merged)?(r=a).fns.push(l):r=Hn([a,l]),r.merged=!0,n[e]=r}function Kn(n,e,t,r,a){if(i(e)){if(k(e,t))return n[t]=e[t],a||delete e[t],!0;if(k(e,r))return n[t]=e[r],a||delete e[r],!0}return!1}function Jn(n){return l(n)?[mn(n)]:a(n)?function n(e,t){var r,c,u,d,p=[];for(r=0;r<e.length;r++)o(c=e[r])||"boolean"==typeof c||(u=p.length-1,d=p[u],a(c)?c.length>0&&(Wn((c=n(c,"".concat(t||"","_").concat(r)))[0])&&Wn(d)&&(p[u]=mn(d.text+c[0].text),c.shift()),p.push.apply(p,c)):l(c)?Wn(d)?p[u]=mn(d.text+c):""!==c&&p.push(mn(c)):Wn(c)&&Wn(d)?p[u]=mn(d.text+c.text):(s(e._isVList)&&i(c.tag)&&o(c.key)&&i(t)&&(c.key="__vlist".concat(t,"_").concat(r,"__")),p.push(c)));return p}(n):void 0}function Wn(n){return i(n)&&i(n.text)&&!1===n.isComment}function Qn(n,e){var t,r,o,s,l=null;if(a(n)||"string"==typeof n)for(l=new Array(n.length),t=0,r=n.length;t<r;t++)l[t]=e(n[t],t);else if("number"==typeof n)for(l=new Array(n),t=0;t<n;t++)l[t]=e(t+1,t);else if(u(n))if(un&&n[Symbol.iterator]){l=[];for(var c=n[Symbol.iterator](),d=c.next();!d.done;)l.push(e(d.value,l.length)),d=c.next()}else for(o=Object.keys(n),l=new Array(o.length),t=0,r=o.length;t<r;t++)s=o[t],l[t]=e(n[s],s,t);return i(l)||(l=[]),l._isVList=!0,l}function Yn(n,e,t,r){var a,o=this.$scopedSlots[n];o?(t=t||{},r&&(t=A(A({},r),t)),a=o(t)||(c(e)?e():e)):a=this.$slots[n]||(c(e)?e():e);var i=t&&t.slot;return i?this.$createElement("template",{slot:i},a):a}function Xn(n){return Ct(this.$options,"filters",n,!0)||L}function Zn(n,e){return a(n)?-1===n.indexOf(e):n!==e}function ne(n,e,t,r,a){var o=V.keyCodes[e]||t;return a&&r&&!V.keyCodes[e]?Zn(a,r):o?Zn(o,n):r?T(r)!==e:void 0===n}function ee(n,e,t,r,o){if(t)if(u(t)){a(t)&&(t=E(t));var i=void 0,s=function(a){if("class"===a||"style"===a||b(a))i=n;else{var s=n.attrs&&n.attrs.type;i=r||V.mustUseProp(e,s,a)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var l=S(a),c=T(a);l in i||c in i||(i[a]=t[a],o&&((n.on||(n.on={}))["update:".concat(a)]=function(n){t[a]=n}))};for(var l in t)s(l)}else;return n}function te(n,e){var t=this._staticTrees||(this._staticTrees=[]),r=t[n];return r&&!e||ae(r=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,this._c,this),"__static__".concat(n),!1),r}function re(n,e,t){return ae(n,"__once__".concat(e).concat(t?"_".concat(t):""),!0),n}function ae(n,e,t){if(a(n))for(var r=0;r<n.length;r++)n[r]&&"string"!=typeof n[r]&&oe(n[r],"".concat(e,"_").concat(r),t);else oe(n,e,t)}function oe(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function ie(n,e){if(e)if(p(e)){var t=n.on=n.on?A({},n.on):{};for(var r in e){var a=t[r],o=e[r];t[r]=a?[].concat(a,o):o}}else;return n}function se(n,e,t,r){e=e||{$stable:!t};for(var o=0;o<n.length;o++){var i=n[o];a(i)?se(i,e,t):i&&(i.proxy&&(i.fn.proxy=!0),e[i.key]=i.fn)}return r&&(e.$key=r),e}function le(n,e){for(var t=0;t<e.length;t+=2){var r=e[t];"string"==typeof r&&r&&(n[e[t]]=e[t+1])}return n}function ce(n,e){return"string"==typeof n?e+n:n}function ue(n){n._o=re,n._n=v,n._s=g,n._l=Qn,n._t=Yn,n._q=M,n._i=D,n._m=te,n._f=Xn,n._k=ne,n._b=ee,n._v=mn,n._e=fn,n._u=se,n._g=ie,n._d=le,n._p=ce}function de(n,e){if(!n||!n.length)return{};for(var t={},r=0,a=n.length;r<a;r++){var o=n[r],i=o.data;if(i&&i.attrs&&i.attrs.slot&&delete i.attrs.slot,o.context!==e&&o.fnContext!==e||!i||null==i.slot)(t.default||(t.default=[])).push(o);else{var s=i.slot,l=t[s]||(t[s]=[]);"template"===o.tag?l.push.apply(l,o.children||[]):l.push(o)}}for(var c in t)t[c].every(pe)&&delete t[c];return t}function pe(n){return n.isComment&&!n.asyncFactory||" "===n.text}function he(n){return n.isComment&&n.asyncFactory}function fe(n,e,t,a){var o,i=Object.keys(t).length>0,s=e?!!e.$stable:!i,l=e&&e.$key;if(e){if(e._normalized)return e._normalized;if(s&&a&&a!==r&&l===a.$key&&!i&&!a.$hasNormal)return a;for(var c in o={},e)e[c]&&"$"!==c[0]&&(o[c]=me(n,t,c,e[c]))}else o={};for(var u in t)u in o||(o[u]=ge(t,u));return e&&Object.isExtensible(e)&&(e._normalized=o),U(o,"$stable",s),U(o,"$key",l),U(o,"$hasNormal",i),o}function me(n,e,t,r){var o=function(){var e=dn;pn(n);var t=arguments.length?r.apply(null,arguments):r({}),o=(t=t&&"object"==typeof t&&!a(t)?[t]:Jn(t))&&t[0];return pn(e),t&&(!o||1===t.length&&o.isComment&&!he(o))?void 0:t};return r.proxy&&Object.defineProperty(e,t,{get:o,enumerable:!0,configurable:!0}),o}function ge(n,e){return function(){return n[e]}}function ve(n){return{get attrs(){if(!n._attrsProxy){var e=n._attrsProxy={};U(e,"_v_attr_proxy",!0),ye(e,n.$attrs,r,n,"$attrs")}return n._attrsProxy},get listeners(){n._listenersProxy||ye(n._listenersProxy={},n.$listeners,r,n,"$listeners");return n._listenersProxy},get slots(){return function(n){n._slotsProxy||xe(n._slotsProxy={},n.$scopedSlots);return n._slotsProxy}(n)},emit:C(n.$emit,n),expose:function(e){e&&Object.keys(e).forEach((function(t){return qn(n,e,t)}))}}}function ye(n,e,t,r,a){var o=!1;for(var i in e)i in n?e[i]!==t[i]&&(o=!0):(o=!0,be(n,i,r,a));for(var i in n)i in e||(o=!0,delete n[i]);return o}function be(n,e,t,r){Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){return t[r][e]}})}function xe(n,e){for(var t in e)n[t]=e[t];for(var t in n)t in e||delete n[t]}var we=null;function ke(n,e){return(n.__esModule||un&&"Module"===n[Symbol.toStringTag])&&(n=n.default),u(n)?e.extend(n):n}function _e(n){if(a(n))for(var e=0;e<n.length;e++){var t=n[e];if(i(t)&&(i(t.componentOptions)||he(t)))return t}}function je(n,e,t,r,d,p){return(a(t)||l(t))&&(d=r,r=t,t=void 0),s(p)&&(d=2),function(n,e,t,r,l){if(i(t)&&i(t.__ob__))return fn();i(t)&&i(t.is)&&(e=t.is);if(!e)return fn();0;a(r)&&c(r[0])&&((t=t||{}).scopedSlots={default:r[0]},r.length=0);2===l?r=Jn(r):1===l&&(r=function(n){for(var e=0;e<n.length;e++)if(a(n[e]))return Array.prototype.concat.apply([],n);return n}(r));var d,p;if("string"==typeof e){var h=void 0;p=n.$vnode&&n.$vnode.ns||V.getTagNamespace(e),d=V.isReservedTag(e)?new hn(V.parsePlatformTagName(e),t,r,void 0,void 0,n):t&&t.pre||!i(h=Ct(n.$options,"components",e))?new hn(e,t,r,void 0,void 0,n):bt(h,t,n,r,e)}else d=bt(e,t,n,r);return a(d)?d:i(d)?(i(p)&&function n(e,t,r){e.ns=t,"foreignObject"===e.tag&&(t=void 0,r=!0);if(i(e.children))for(var a=0,l=e.children.length;a<l;a++){var c=e.children[a];i(c.tag)&&(o(c.ns)||s(r)&&"svg"!==c.tag)&&n(c,t,r)}}(d,p),i(t)&&function(n){u(n.style)&&$e(n.style);u(n.class)&&$e(n.class)}(t),d):fn()}(n,e,t,r,d)}function Se(n,e,t){xn();try{if(e)for(var r=e;r=r.$parent;){var a=r.$options.errorCaptured;if(a)for(var o=0;o<a.length;o++)try{if(!1===a[o].call(r,n,e,t))return}catch(n){Pe(n,r,"errorCaptured hook")}}Pe(n,e,t)}finally{wn()}}function Ne(n,e,t,r,a){var o;try{(o=t?n.apply(e,t):n.call(e))&&!o._isVue&&m(o)&&!o._handled&&(o.catch((function(n){return Se(n,r,a+" (Promise/async)")})),o._handled=!0)}catch(n){Se(n,r,a)}return o}function Pe(n,e,t){if(V.errorHandler)try{return V.errorHandler.call(null,n,e,t)}catch(e){e!==n&&Te(e,null,"config.errorHandler")}Te(n,e,t)}function Te(n,e,t){if(!J||"undefined"==typeof console)throw n;console.error(n)}var Ce,Ie=!1,Ae=[],Ee=!1;function ze(){Ee=!1;var n=Ae.slice(0);Ae.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&ln(Promise)){var Oe=Promise.resolve();Ce=function(){Oe.then(ze),Z&&setTimeout(z)},Ie=!0}else if(Q||"undefined"==typeof MutationObserver||!ln(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Ce="undefined"!=typeof setImmediate&&ln(setImmediate)?function(){setImmediate(ze)}:function(){setTimeout(ze,0)};else{var Le=1,Me=new MutationObserver(ze),De=document.createTextNode(String(Le));Me.observe(De,{characterData:!0}),Ce=function(){Le=(Le+1)%2,De.data=String(Le)},Ie=!0}function Re(n,e){var t;if(Ae.push((function(){if(n)try{n.call(e)}catch(n){Se(n,e,"nextTick")}else t&&t(e)})),Ee||(Ee=!0,Ce()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}function qe(n){return function(e,t){if(void 0===t&&(t=dn),t)return function(n,e,t){var r=n.$options;r[e]=St(r[e],t)}(t,n,e)}}qe("beforeMount"),qe("mounted"),qe("beforeUpdate"),qe("updated"),qe("beforeDestroy"),qe("destroyed"),qe("errorCaptured"),qe("activated"),qe("deactivated"),qe("serverPrefetch"),qe("renderTracked"),qe("renderTriggered");var Fe=new cn;function $e(n){return function n(e,t){var r,o,i=a(e);if(!i&&!u(e)||Object.isFrozen(e)||e instanceof hn)return;if(e.__ob__){var s=e.__ob__.dep.id;if(t.has(s))return;t.add(s)}if(i)for(r=e.length;r--;)n(e[r],t);else if(Rn(e))n(e.value,t);else for(o=Object.keys(e),r=o.length;r--;)n(e[o[r]],t)}(n,Fe),Fe.clear(),n}var Ve,Be=0,He=function(){function n(n,e,t,r,a){var o,i;o=this,void 0===(i=Fn||(n?n._scope:void 0))&&(i=Fn),i&&i.active&&i.effects.push(o),(this.vm=n)&&a&&(n._watcher=this),r?(this.deep=!!r.deep,this.user=!!r.user,this.lazy=!!r.lazy,this.sync=!!r.sync,this.before=r.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++Be,this.active=!0,this.post=!1,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new cn,this.newDepIds=new cn,this.expression="",c(e)?this.getter=e:(this.getter=function(n){if(!G.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=z)),this.value=this.lazy?void 0:this.get()}return n.prototype.get=function(){var n;xn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;Se(n,e,'getter for watcher "'.concat(this.expression,'"'))}finally{this.deep&&$e(n),wn(),this.cleanupDeps()}return n},n.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},n.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},n.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():dt(this)},n.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||u(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'.concat(this.expression,'"');Ne(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},n.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},n.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},n.prototype.teardown=function(){if(this.vm&&!this.vm._isBeingDestroyed&&x(this.vm._scope.effects,this),this.active){for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1,this.onStop&&this.onStop()}},n}();function Ue(n,e){Ve.$on(n,e)}function Ge(n,e){Ve.$off(n,e)}function Ke(n,e){var t=Ve;return function r(){var a=e.apply(null,arguments);null!==a&&t.$off(n,r)}}function Je(n,e,t){Ve=n,Un(e,t||{},Ue,Ge,Ke,n),Ve=void 0}var We=null;function Qe(n){var e=We;return We=n,function(){We=e}}function Ye(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function Xe(n,e){if(e){if(n._directInactive=!1,Ye(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)Xe(n.$children[t]);Ze(n,"activated")}}function Ze(n,e,t,r){void 0===r&&(r=!0),xn();var a=dn;r&&pn(n);var o=n.$options[e],i="".concat(e," hook");if(o)for(var s=0,l=o.length;s<l;s++)Ne(o[s],n,t||null,n,i);n._hasHookEvent&&n.$emit("hook:"+e),r&&pn(a),wn()}var nt=[],et=[],tt={},rt=!1,at=!1,ot=0;var it=0,st=Date.now;if(J&&!Q){var lt=window.performance;lt&&"function"==typeof lt.now&&st()>document.createEvent("Event").timeStamp&&(st=function(){return lt.now()})}var ct=function(n,e){if(n.post){if(!e.post)return 1}else if(e.post)return-1;return n.id-e.id};function ut(){var n,e;for(it=st(),at=!0,nt.sort(ct),ot=0;ot<nt.length;ot++)(n=nt[ot]).before&&n.before(),e=n.id,tt[e]=null,n.run();var t=et.slice(),r=nt.slice();ot=nt.length=et.length=0,tt={},rt=at=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,Xe(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],r=t.vm;r&&r._watcher===t&&r._isMounted&&!r._isDestroyed&&Ze(r,"updated")}}(r),sn&&V.devtools&&sn.emit("flush")}function dt(n){var e=n.id;if(null==tt[e]&&(n!==yn.target||!n.noRecurse)){if(tt[e]=!0,at){for(var t=nt.length-1;t>ot&&nt[t].id>n.id;)t--;nt.splice(t+1,0,n)}else nt.push(n);rt||(rt=!0,Re(ut))}}function pt(n,e){if(n){for(var t=Object.create(null),r=un?Reflect.ownKeys(n):Object.keys(n),a=0;a<r.length;a++){var o=r[a];if("__ob__"!==o){var i=n[o].from;if(i in e._provided)t[o]=e._provided[i];else if("default"in n[o]){var s=n[o].default;t[o]=c(s)?s.call(e):s}else 0}}return t}}function ht(n,e,t,o,i){var l,c=this,u=i.options;k(o,"_uid")?(l=Object.create(o))._original=o:(l=o,o=o._original);var d=s(u._compiled),p=!d;this.data=n,this.props=e,this.children=t,this.parent=o,this.listeners=n.on||r,this.injections=pt(u.inject,o),this.slots=function(){return c.$slots||fe(o,n.scopedSlots,c.$slots=de(t,o)),c.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return fe(o,n.scopedSlots,this.slots())}}),d&&(this.$options=u,this.$slots=this.slots(),this.$scopedSlots=fe(o,n.scopedSlots,this.$slots)),u._scopeId?this._c=function(n,e,t,r){var i=je(l,n,e,t,r,p);return i&&!a(i)&&(i.fnScopeId=u._scopeId,i.fnContext=o),i}:this._c=function(n,e,t,r){return je(l,n,e,t,r,p)}}function ft(n,e,t,r,a){var o=gn(n);return o.fnContext=t,o.fnOptions=r,e.slot&&((o.data||(o.data={})).slot=e.slot),o}function mt(n,e){for(var t in e)n[S(t)]=e[t]}function gt(n){return n.name||n.__name||n._componentTag}ue(ht.prototype);var vt={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;vt.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},r=n.data.inlineTemplate;i(r)&&(t.render=r.render,t.staticRenderFns=r.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,We)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,a,o){var i=a.data.scopedSlots,s=n.$scopedSlots,l=!!(i&&!i.$stable||s!==r&&!s.$stable||i&&n.$scopedSlots.$key!==i.$key||!i&&n.$scopedSlots.$key),c=!!(o||n.$options._renderChildren||l),u=n.$vnode;n.$options._parentVnode=a,n.$vnode=a,n._vnode&&(n._vnode.parent=a),n.$options._renderChildren=o;var d=a.data.attrs||r;n._attrsProxy&&ye(n._attrsProxy,d,u.data&&u.data.attrs||r,n,"$attrs")&&(c=!0),n.$attrs=d,t=t||r;var p=n.$options._parentListeners;if(n._listenersProxy&&ye(n._listenersProxy,t,p||r,n,"$listeners"),n.$listeners=n.$options._parentListeners=t,Je(n,t,p),e&&n.$options.props){Pn(!1);for(var h=n._props,f=n.$options._propKeys||[],m=0;m<f.length;m++){var g=f[m],v=n.$options.props;h[g]=It(g,v,e,n)}Pn(!0),n.$options.propsData=e}c&&(n.$slots=de(o,a.context),n.$forceUpdate())}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,r=n.componentInstance;r._isMounted||(r._isMounted=!0,Ze(r,"mounted")),n.data.keepAlive&&(t._isMounted?((e=r)._inactive=!1,et.push(e)):Xe(r,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(!(t&&(e._directInactive=!0,Ye(e))||e._inactive)){e._inactive=!0;for(var r=0;r<e.$children.length;r++)n(e.$children[r]);Ze(e,"deactivated")}}(e,!0):e.$destroy())}},yt=Object.keys(vt);function bt(n,e,t,l,c){if(!o(n)){var d=t.$options._base;if(u(n)&&(n=d.extend(n)),"function"==typeof n){var p;if(o(n.cid)&&void 0===(n=function(n,e){if(s(n.error)&&i(n.errorComp))return n.errorComp;if(i(n.resolved))return n.resolved;var t=we;if(t&&i(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t),s(n.loading)&&i(n.loadingComp))return n.loadingComp;if(t&&!i(n.owners)){var r=n.owners=[t],a=!0,l=null,c=null;t.$on("hook:destroyed",(function(){return x(r,t)}));var d=function(n){for(var e=0,t=r.length;e<t;e++)r[e].$forceUpdate();n&&(r.length=0,null!==l&&(clearTimeout(l),l=null),null!==c&&(clearTimeout(c),c=null))},p=R((function(t){n.resolved=ke(t,e),a?r.length=0:d(!0)})),h=R((function(e){i(n.errorComp)&&(n.error=!0,d(!0))})),f=n(p,h);return u(f)&&(m(f)?o(n.resolved)&&f.then(p,h):m(f.component)&&(f.component.then(p,h),i(f.error)&&(n.errorComp=ke(f.error,e)),i(f.loading)&&(n.loadingComp=ke(f.loading,e),0===f.delay?n.loading=!0:l=setTimeout((function(){l=null,o(n.resolved)&&o(n.error)&&(n.loading=!0,d(!1))}),f.delay||200)),i(f.timeout)&&(c=setTimeout((function(){c=null,o(n.resolved)&&h(null)}),f.timeout)))),a=!1,n.loading?n.loadingComp:n.resolved}}(p=n,d)))return function(n,e,t,r,a){var o=fn();return o.asyncFactory=n,o.asyncMeta={data:e,context:t,children:r,tag:a},o}(p,e,t,l,c);e=e||{},Ht(n),i(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",r=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var o=e.on||(e.on={}),s=o[r],l=e.model.callback;i(s)?(a(s)?-1===s.indexOf(l):s!==l)&&(o[r]=[l].concat(s)):o[r]=l}(n.options,e);var h=function(n,e,t){var r=e.options.props;if(!o(r)){var a={},s=n.attrs,l=n.props;if(i(s)||i(l))for(var c in r){var u=T(c);Kn(a,l,c,u,!0)||Kn(a,s,c,u,!1)}return a}}(e,n);if(s(n.options.functional))return function(n,e,t,o,s){var l=n.options,c={},u=l.props;if(i(u))for(var d in u)c[d]=It(d,u,e||r);else i(t.attrs)&&mt(c,t.attrs),i(t.props)&&mt(c,t.props);var p=new ht(t,c,s,o,n),h=l.render.call(null,p._c,p);if(h instanceof hn)return ft(h,t,p.parent,l,p);if(a(h)){for(var f=Jn(h)||[],m=new Array(f.length),g=0;g<f.length;g++)m[g]=ft(f[g],t,p.parent,l,p);return m}}(n,h,e,t,l);var f=e.on;if(e.on=e.nativeOn,s(n.options.abstract)){var g=e.slot;e={},g&&(e.slot=g)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<yt.length;t++){var r=yt[t],a=e[r],o=vt[r];a===o||a&&a._merged||(e[r]=a?xt(o,a):o)}}(e);var v=gt(n.options)||c;return new hn("vue-component-".concat(n.cid).concat(v?"-".concat(v):""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:h,listeners:f,tag:c,children:l},p)}}}function xt(n,e){var t=function(t,r){n(t,r),e(t,r)};return t._merged=!0,t}var wt=z,kt=V.optionMergeStrategies;function _t(n,e){if(!e)return n;for(var t,r,a,o=un?Reflect.ownKeys(e):Object.keys(e),i=0;i<o.length;i++)"__ob__"!==(t=o[i])&&(r=n[t],a=e[t],k(n,t)?r!==a&&p(r)&&p(a)&&_t(r,a):En(n,t,a));return n}function jt(n,e,t){return t?function(){var r=c(e)?e.call(t,t):e,a=c(n)?n.call(t,t):n;return r?_t(r,a):a}:e?n?function(){return _t(c(e)?e.call(this,this):e,c(n)?n.call(this,this):n)}:e:n}function St(n,e){var t=e?n?n.concat(e):a(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function Nt(n,e,t,r){var a=Object.create(n||null);return e?A(a,e):a}kt.data=function(n,e,t){return t?jt(n,e,t):e&&"function"!=typeof e?n:jt(n,e)},$.forEach((function(n){kt[n]=St})),F.forEach((function(n){kt[n+"s"]=Nt})),kt.watch=function(n,e,t,r){if(n===tn&&(n=void 0),e===tn&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var o={};for(var i in A(o,n),e){var s=o[i],l=e[i];s&&!a(s)&&(s=[s]),o[i]=s?s.concat(l):a(l)?l:[l]}return o},kt.props=kt.methods=kt.inject=kt.computed=function(n,e,t,r){if(!n)return e;var a=Object.create(null);return A(a,n),e&&A(a,e),a},kt.provide=jt;var Pt=function(n,e){return void 0===e?n:e};function Tt(n,e,t){if(c(e)&&(e=e.options),function(n,e){var t=n.props;if(t){var r,o,i={};if(a(t))for(r=t.length;r--;)"string"==typeof(o=t[r])&&(i[S(o)]={type:null});else if(p(t))for(var s in t)o=t[s],i[S(s)]=p(o)?o:{type:o};else 0;n.props=i}}(e),function(n,e){var t=n.inject;if(t){var r=n.inject={};if(a(t))for(var o=0;o<t.length;o++)r[t[o]]={from:t[o]};else if(p(t))for(var i in t){var s=t[i];r[i]=p(s)?A({from:i},s):{from:s}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var r=e[t];c(r)&&(e[t]={bind:r,update:r})}}(e),!e._base&&(e.extends&&(n=Tt(n,e.extends,t)),e.mixins))for(var r=0,o=e.mixins.length;r<o;r++)n=Tt(n,e.mixins[r],t);var i,s={};for(i in n)l(i);for(i in e)k(n,i)||l(i);function l(r){var a=kt[r]||Pt;s[r]=a(n[r],e[r],t,r)}return s}function Ct(n,e,t,r){if("string"==typeof t){var a=n[e];if(k(a,t))return a[t];var o=S(t);if(k(a,o))return a[o];var i=N(o);return k(a,i)?a[i]:a[t]||a[o]||a[i]}}function It(n,e,t,r){var a=e[n],o=!k(t,n),i=t[n],s=Ot(Boolean,a.type);if(s>-1)if(o&&!k(a,"default"))i=!1;else if(""===i||i===T(n)){var l=Ot(String,a.type);(l<0||s<l)&&(i=!0)}if(void 0===i){i=function(n,e,t){if(!k(e,"default"))return;var r=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return c(r)&&"Function"!==Et(e.type)?r.call(n):r}(r,a,n);var u=Nn;Pn(!0),In(i),Pn(u)}return i}var At=/^\s*function (\w+)/;function Et(n){var e=n&&n.toString().match(At);return e?e[1]:""}function zt(n,e){return Et(n)===Et(e)}function Ot(n,e){if(!a(e))return zt(e,n)?0:-1;for(var t=0,r=e.length;t<r;t++)if(zt(e[t],n))return t;return-1}var Lt={enumerable:!0,configurable:!0,get:z,set:z};function Mt(n,e,t){Lt.get=function(){return this[e][t]},Lt.set=function(n){this[e][t]=n},Object.defineProperty(n,t,Lt)}function Dt(n){var e=n.$options;if(e.props&&function(n,e){var t=n.$options.propsData||{},r=n._props=Ln({}),a=n.$options._propKeys=[];n.$parent&&Pn(!1);var o=function(o){a.push(o);var i=It(o,e,t,n);An(r,o,i),o in n||Mt(n,"_props",o)};for(var i in e)o(i);Pn(!0)}(n,e.props),function(n){var e=n.$options,t=e.setup;if(t){var r=n._setupContext=ve(n);pn(n),xn();var a=Ne(t,null,[n._props||Ln({}),r],n,"setup");if(wn(),pn(),c(a))e.render=a;else if(u(a))if(n._setupState=a,a.__sfc){var o=n._setupProxy={};for(var i in a)"__sfc"!==i&&qn(o,a,i)}else for(var i in a)H(i)||qn(n,a,i);else 0}}(n),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?z:C(e[t],n)}(n,e.methods),e.data)!function(n){var e=n.$options.data;p(e=n._data=c(e)?function(n,e){xn();try{return n.call(e,e)}catch(n){return Se(n,e,"data()"),{}}finally{wn()}}(e,n):e||{})||(e={});var t=Object.keys(e),r=n.$options.props,a=(n.$options.methods,t.length);for(;a--;){var o=t[a];0,r&&k(r,o)||H(o)||Mt(n,"_data",o)}var i=In(e);i&&i.vmCount++}(n);else{var t=In(n._data={});t&&t.vmCount++}e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),r=on();for(var a in e){var o=e[a],i=c(o)?o:o.get;0,r||(t[a]=new He(n,i||z,z,Rt)),a in n||qt(n,a,o)}}(n,e.computed),e.watch&&e.watch!==tn&&function(n,e){for(var t in e){var r=e[t];if(a(r))for(var o=0;o<r.length;o++)Vt(n,t,r[o]);else Vt(n,t,r)}}(n,e.watch)}var Rt={lazy:!0};function qt(n,e,t){var r=!on();c(t)?(Lt.get=r?Ft(e):$t(t),Lt.set=z):(Lt.get=t.get?r&&!1!==t.cache?Ft(e):$t(t.get):z,Lt.set=t.set||z),Object.defineProperty(n,e,Lt)}function Ft(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),yn.target&&e.depend(),e.value}}function $t(n){return function(){return n.call(this,this)}}function Vt(n,e,t,r){return p(t)&&(r=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,r)}var Bt=0;function Ht(n){var e=n.options;if(n.super){var t=Ht(n.super);if(t!==n.superOptions){n.superOptions=t;var r=function(n){var e,t=n.options,r=n.sealedOptions;for(var a in t)t[a]!==r[a]&&(e||(e={}),e[a]=t[a]);return e}(n);r&&A(n.extendOptions,r),(e=n.options=Tt(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function Ut(n){this._init(n)}function Gt(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,r=t.cid,a=n._Ctor||(n._Ctor={});if(a[r])return a[r];var o=gt(n)||gt(t.options);var i=function(n){this._init(n)};return(i.prototype=Object.create(t.prototype)).constructor=i,i.cid=e++,i.options=Tt(t.options,n),i.super=t,i.options.props&&function(n){var e=n.options.props;for(var t in e)Mt(n.prototype,"_props",t)}(i),i.options.computed&&function(n){var e=n.options.computed;for(var t in e)qt(n.prototype,t,e[t])}(i),i.extend=t.extend,i.mixin=t.mixin,i.use=t.use,F.forEach((function(n){i[n]=t[n]})),o&&(i.options.components[o]=i),i.superOptions=t.options,i.extendOptions=n,i.sealedOptions=A({},i.options),a[r]=i,i}}function Kt(n){return n&&(gt(n.Ctor.options)||n.tag)}function Jt(n,e){return a(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!h(n)&&n.test(e)}function Wt(n,e){var t=n.cache,r=n.keys,a=n._vnode;for(var o in t){var i=t[o];if(i){var s=i.name;s&&!e(s)&&Qt(t,o,r,a)}}}function Qt(n,e,t,r){var a=n[e];!a||r&&a.tag===r.tag||a.componentInstance.$destroy(),n[e]=null,x(t,e)}!function(n){n.prototype._init=function(n){var e=this;e._uid=Bt++,e._isVue=!0,e.__v_skip=!0,e._scope=new $n(!0),n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),r=e._parentVnode;t.parent=e.parent,t._parentVnode=r;var a=r.componentOptions;t.propsData=a.propsData,t._parentListeners=a.listeners,t._renderChildren=a.children,t._componentTag=a.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=Tt(Ht(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._provided=t?t._provided:Object.create(null),n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Je(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,a=t&&t.context;n.$slots=de(e._renderChildren,a),n.$scopedSlots=t?fe(n.$parent,t.data.scopedSlots,n.$slots):r,n._c=function(e,t,r,a){return je(n,e,t,r,a,!1)},n.$createElement=function(e,t,r,a){return je(n,e,t,r,a,!0)};var o=t&&t.data;An(n,"$attrs",o&&o.attrs||r,null,!0),An(n,"$listeners",e._parentListeners||r,null,!0)}(e),Ze(e,"beforeCreate",void 0,!1),function(n){var e=pt(n.$options.inject,n);e&&(Pn(!1),Object.keys(e).forEach((function(t){An(n,t,e[t])})),Pn(!0))}(e),Dt(e),function(n){var e=n.$options.provide;if(e){var t=c(e)?e.call(n):e;if(!u(t))return;for(var r=Vn(n),a=un?Reflect.ownKeys(t):Object.keys(t),o=0;o<a.length;o++){var i=a[o];Object.defineProperty(r,i,Object.getOwnPropertyDescriptor(t,i))}}}(e),Ze(e,"created"),e.$options.el&&e.$mount(e.$options.el)}}(Ut),function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=En,n.prototype.$delete=zn,n.prototype.$watch=function(n,e,t){if(p(e))return Vt(this,n,e,t);(t=t||{}).user=!0;var r=new He(this,n,e,t);if(t.immediate){var a='callback for immediate watcher "'.concat(r.expression,'"');xn(),Ne(e,this,[r.value],this,a),wn()}return function(){r.teardown()}}}(Ut),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var r=this;if(a(n))for(var o=0,i=n.length;o<i;o++)r.$on(n[o],t);else(r._events[n]||(r._events[n]=[])).push(t),e.test(n)&&(r._hasHookEvent=!0);return r},n.prototype.$once=function(n,e){var t=this;function r(){t.$off(n,r),e.apply(t,arguments)}return r.fn=e,t.$on(n,r),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(a(n)){for(var r=0,o=n.length;r<o;r++)t.$off(n[r],e);return t}var i,s=t._events[n];if(!s)return t;if(!e)return t._events[n]=null,t;for(var l=s.length;l--;)if((i=s[l])===e||i.fn===e){s.splice(l,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?I(t):t;for(var r=I(arguments,1),a='event handler for "'.concat(n,'"'),o=0,i=t.length;o<i;o++)Ne(t[o],e,r,e,a)}return e}}(Ut),function(n){n.prototype._update=function(n,e){var t=this,r=t.$el,a=t._vnode,o=Qe(t);t._vnode=n,t.$el=a?t.__patch__(a,n):t.__patch__(t.$el,n,e,!1),o(),r&&(r.__vue__=null),t.$el&&(t.$el.__vue__=t),t.$vnode&&t.$parent&&t.$vnode===t.$parent._vnode&&(t.$parent.$el=t.$el)},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){Ze(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||x(e.$children,n),n._scope.stop(),n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),Ze(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(Ut),function(n){ue(n.prototype),n.prototype.$nextTick=function(n){return Re(n,this)},n.prototype._render=function(){var n,e=this,t=e.$options,r=t.render,o=t._parentVnode;o&&e._isMounted&&(e.$scopedSlots=fe(e.$parent,o.data.scopedSlots,e.$slots,e.$scopedSlots),e._slotsProxy&&xe(e._slotsProxy,e.$scopedSlots)),e.$vnode=o;try{pn(e),we=e,n=r.call(e._renderProxy,e.$createElement)}catch(t){Se(t,e,"render"),n=e._vnode}finally{we=null,pn()}return a(n)&&1===n.length&&(n=n[0]),n instanceof hn||(n=fn()),n.parent=o,n}}(Ut);var Yt=[String,RegExp,Array],Xt={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Yt,exclude:Yt,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,r=this.keyToCache;if(t){var a=t.tag,o=t.componentInstance,i=t.componentOptions;n[r]={name:Kt(i),tag:a,componentInstance:o},e.push(r),this.max&&e.length>parseInt(this.max)&&Qt(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)Qt(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){Wt(n,(function(n){return Jt(e,n)}))})),this.$watch("exclude",(function(e){Wt(n,(function(n){return!Jt(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=_e(n),t=e&&e.componentOptions;if(t){var r=Kt(t),a=this.include,o=this.exclude;if(a&&(!r||!Jt(a,r))||o&&r&&Jt(o,r))return e;var i=this.cache,s=this.keys,l=null==e.key?t.Ctor.cid+(t.tag?"::".concat(t.tag):""):e.key;i[l]?(e.componentInstance=i[l].componentInstance,x(s,l),s.push(l)):(this.vnodeToCache=e,this.keyToCache=l),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return V}};Object.defineProperty(n,"config",e),n.util={warn:wt,extend:A,mergeOptions:Tt,defineReactive:An},n.set=En,n.delete=zn,n.nextTick=Re,n.observable=function(n){return In(n),n},n.options=Object.create(null),F.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,A(n.options.components,Xt),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=I(arguments,1);return t.unshift(this),c(n.install)?n.install.apply(n,t):c(n)&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=Tt(this.options,n),this}}(n),Gt(n),function(n){F.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&p(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&c(t)&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(Ut),Object.defineProperty(Ut.prototype,"$isServer",{get:on}),Object.defineProperty(Ut.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Ut,"FunctionalRenderContext",{value:ht}),Ut.version="2.7.8";var Zt=y("style,class"),nr=y("input,textarea,option,select,progress"),er=y("contenteditable,draggable,spellcheck"),tr=y("events,caret,typing,plaintext-only"),rr=y("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),ar="http://www.w3.org/1999/xlink",or=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},ir=function(n){return or(n)?n.slice(6,n.length):""},sr=function(n){return null==n||!1===n};function lr(n){for(var e=n.data,t=n,r=n;i(r.componentInstance);)(r=r.componentInstance._vnode)&&r.data&&(e=cr(r.data,e));for(;i(t=t.parent);)t&&t.data&&(e=cr(e,t.data));return function(n,e){if(i(n)||i(e))return ur(n,dr(e));return""}(e.staticClass,e.class)}function cr(n,e){return{staticClass:ur(n.staticClass,e.staticClass),class:i(n.class)?[n.class,e.class]:e.class}}function ur(n,e){return n?e?n+" "+e:n:e||""}function dr(n){return Array.isArray(n)?function(n){for(var e,t="",r=0,a=n.length;r<a;r++)i(e=dr(n[r]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):u(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var pr={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},hr=y("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),fr=y("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),mr=function(n){return hr(n)||fr(n)};var gr=Object.create(null);var vr=y("text,number,password,search,email,tel,url");var yr=Object.freeze({__proto__:null,createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(pr[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),br={create:function(n,e){xr(e)},update:function(n,e){n.data.ref!==e.data.ref&&(xr(n,!0),xr(e))},destroy:function(n){xr(n,!0)}};function xr(n,e){var t=n.data.ref;if(i(t)){var r=n.context,o=n.componentInstance||n.elm,s=e?null:o,l=e?void 0:o;if(c(t))Ne(t,r,[s],r,"template ref function");else{var u=n.data.refInFor,d="string"==typeof t||"number"==typeof t,p=Rn(t),h=r.$refs;if(d||p)if(u){var f=d?h[t]:t.value;e?a(f)&&x(f,o):a(f)?f.includes(o)||f.push(o):d?(h[t]=[o],wr(r,t,h[t])):t.value=[o]}else if(d){if(e&&h[t]!==o)return;h[t]=l,wr(r,t,s)}else if(p){if(e&&t.value!==o)return;t.value=s}else 0}}}function wr(n,e,t){var r=n._setupState;r&&k(r,e)&&(Rn(r[e])?r[e].value=t:r[e]=t)}var kr=new hn("",{},[]),_r=["create","activate","update","remove","destroy"];function jr(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&i(n.data)===i(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,r=i(t=n.data)&&i(t=t.attrs)&&t.type,a=i(t=e.data)&&i(t=t.attrs)&&t.type;return r===a||vr(r)&&vr(a)}(n,e)||s(n.isAsyncPlaceholder)&&o(e.asyncFactory.error))}function Sr(n,e,t){var r,a,o={};for(r=e;r<=t;++r)i(a=n[r].key)&&(o[a]=r);return o}var Nr={create:Pr,update:Pr,destroy:function(n){Pr(n,kr)}};function Pr(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,r,a,o=n===kr,i=e===kr,s=Cr(n.data.directives,n.context),l=Cr(e.data.directives,e.context),c=[],u=[];for(t in l)r=s[t],a=l[t],r?(a.oldValue=r.value,a.oldArg=r.arg,Ar(a,"update",e,n),a.def&&a.def.componentUpdated&&u.push(a)):(Ar(a,"bind",e,n),a.def&&a.def.inserted&&c.push(a));if(c.length){var d=function(){for(var t=0;t<c.length;t++)Ar(c[t],"inserted",e,n)};o?Gn(e,"insert",d):d()}u.length&&Gn(e,"postpatch",(function(){for(var t=0;t<u.length;t++)Ar(u[t],"componentUpdated",e,n)}));if(!o)for(t in s)l[t]||Ar(s[t],"unbind",n,n,i)}(n,e)}var Tr=Object.create(null);function Cr(n,e){var t,r,a=Object.create(null);if(!n)return a;for(t=0;t<n.length;t++)(r=n[t]).modifiers||(r.modifiers=Tr),a[Ir(r)]=r,e._setupState&&e._setupState.__sfc&&(r.def=r.def||Ct(e,"_setupState","v-"+r.name)),r.def=r.def||Ct(e.$options,"directives",r.name);return a}function Ir(n){return n.rawName||"".concat(n.name,".").concat(Object.keys(n.modifiers||{}).join("."))}function Ar(n,e,t,r,a){var o=n.def&&n.def[e];if(o)try{o(t.elm,n,t,r,a)}catch(r){Se(r,t.context,"directive ".concat(n.name," ").concat(e," hook"))}}var Er=[br,Nr];function zr(n,e){var t=e.componentOptions;if(!(i(t)&&!1===t.Ctor.options.inheritAttrs||o(n.data.attrs)&&o(e.data.attrs))){var r,a,l=e.elm,c=n.data.attrs||{},u=e.data.attrs||{};for(r in(i(u.__ob__)||s(u._v_attr_proxy))&&(u=e.data.attrs=A({},u)),u)a=u[r],c[r]!==a&&Or(l,r,a,e.data.pre);for(r in(Q||X)&&u.value!==c.value&&Or(l,"value",u.value),c)o(u[r])&&(or(r)?l.removeAttributeNS(ar,ir(r)):er(r)||l.removeAttribute(r))}}function Or(n,e,t,r){r||n.tagName.indexOf("-")>-1?Lr(n,e,t):rr(e)?sr(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):er(e)?n.setAttribute(e,function(n,e){return sr(e)||"false"===e?"false":"contenteditable"===n&&tr(e)?e:"true"}(e,t)):or(e)?sr(t)?n.removeAttributeNS(ar,ir(e)):n.setAttributeNS(ar,e,t):Lr(n,e,t)}function Lr(n,e,t){if(sr(t))n.removeAttribute(e);else{if(Q&&!Y&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var r=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",r)};n.addEventListener("input",r),n.__ieph=!0}n.setAttribute(e,t)}}var Mr={create:zr,update:zr};function Dr(n,e){var t=e.elm,r=e.data,a=n.data;if(!(o(r.staticClass)&&o(r.class)&&(o(a)||o(a.staticClass)&&o(a.class)))){var s=lr(e),l=t._transitionClasses;i(l)&&(s=ur(s,dr(l))),s!==t._prevClass&&(t.setAttribute("class",s),t._prevClass=s)}}var Rr,qr={create:Dr,update:Dr};function Fr(n,e,t){var r=Rr;return function a(){var o=e.apply(null,arguments);null!==o&&Br(n,a,t,r)}}var $r=Ie&&!(en&&Number(en[1])<=53);function Vr(n,e,t,r){if($r){var a=it,o=e;e=o._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=a||n.timeStamp<=0||n.target.ownerDocument!==document)return o.apply(this,arguments)}}Rr.addEventListener(n,e,rn?{capture:t,passive:r}:t)}function Br(n,e,t,r){(r||Rr).removeEventListener(n,e._wrapper||e,t)}function Hr(n,e){if(!o(n.data.on)||!o(e.data.on)){var t=e.data.on||{},r=n.data.on||{};Rr=e.elm||n.elm,function(n){if(i(n.__r)){var e=Q?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}i(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),Un(t,r,Vr,Br,Fr,e.context),Rr=void 0}}var Ur,Gr={create:Hr,update:Hr,destroy:function(n){return Hr(n,kr)}};function Kr(n,e){if(!o(n.data.domProps)||!o(e.data.domProps)){var t,r,a=e.elm,l=n.data.domProps||{},c=e.data.domProps||{};for(t in(i(c.__ob__)||s(c._v_attr_proxy))&&(c=e.data.domProps=A({},c)),l)t in c||(a[t]="");for(t in c){if(r=c[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),r===l[t])continue;1===a.childNodes.length&&a.removeChild(a.childNodes[0])}if("value"===t&&"PROGRESS"!==a.tagName){a._value=r;var u=o(r)?"":String(r);Jr(a,u)&&(a.value=u)}else if("innerHTML"===t&&fr(a.tagName)&&o(a.innerHTML)){(Ur=Ur||document.createElement("div")).innerHTML="<svg>".concat(r,"</svg>");for(var d=Ur.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;d.firstChild;)a.appendChild(d.firstChild)}else if(r!==l[t])try{a[t]=r}catch(n){}}}}function Jr(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,r=n._vModifiers;if(i(r)){if(r.number)return v(t)!==v(e);if(r.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var Wr={create:Kr,update:Kr},Qr=_((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var r=n.split(t);r.length>1&&(e[r[0].trim()]=r[1].trim())}})),e}));function Yr(n){var e=Xr(n.style);return n.staticStyle?A(n.staticStyle,e):e}function Xr(n){return Array.isArray(n)?E(n):"string"==typeof n?Qr(n):n}var Zr,na=/^--/,ea=/\s*!important$/,ta=function(n,e,t){if(na.test(e))n.style.setProperty(e,t);else if(ea.test(t))n.style.setProperty(T(e),t.replace(ea,""),"important");else{var r=aa(e);if(Array.isArray(t))for(var a=0,o=t.length;a<o;a++)n.style[r]=t[a];else n.style[r]=t}},ra=["Webkit","Moz","ms"],aa=_((function(n){if(Zr=Zr||document.createElement("div").style,"filter"!==(n=S(n))&&n in Zr)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<ra.length;t++){var r=ra[t]+e;if(r in Zr)return r}}));function oa(n,e){var t=e.data,r=n.data;if(!(o(t.staticStyle)&&o(t.style)&&o(r.staticStyle)&&o(r.style))){var a,s,l=e.elm,c=r.staticStyle,u=r.normalizedStyle||r.style||{},d=c||u,p=Xr(e.data.style)||{};e.data.normalizedStyle=i(p.__ob__)?A({},p):p;var h=function(n,e){var t,r={};if(e)for(var a=n;a.componentInstance;)(a=a.componentInstance._vnode)&&a.data&&(t=Yr(a.data))&&A(r,t);(t=Yr(n.data))&&A(r,t);for(var o=n;o=o.parent;)o.data&&(t=Yr(o.data))&&A(r,t);return r}(e,!0);for(s in d)o(h[s])&&ta(l,s,"");for(s in h)(a=h[s])!==d[s]&&ta(l,s,null==a?"":a)}}var ia={create:oa,update:oa},sa=/\s+/;function la(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(sa).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" ".concat(n.getAttribute("class")||""," ");t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function ca(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(sa).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" ".concat(n.getAttribute("class")||""," "),r=" "+e+" ";t.indexOf(r)>=0;)t=t.replace(r," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function ua(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&A(e,da(n.name||"v")),A(e,n),e}return"string"==typeof n?da(n):void 0}}var da=_((function(n){return{enterClass:"".concat(n,"-enter"),enterToClass:"".concat(n,"-enter-to"),enterActiveClass:"".concat(n,"-enter-active"),leaveClass:"".concat(n,"-leave"),leaveToClass:"".concat(n,"-leave-to"),leaveActiveClass:"".concat(n,"-leave-active")}})),pa=J&&!Y,ha="transition",fa="transitionend",ma="animation",ga="animationend";pa&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(ha="WebkitTransition",fa="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(ma="WebkitAnimation",ga="webkitAnimationEnd"));var va=J?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function ya(n){va((function(){va(n)}))}function ba(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),la(n,e))}function xa(n,e){n._transitionClasses&&x(n._transitionClasses,e),ca(n,e)}function wa(n,e,t){var r=_a(n,e),a=r.type,o=r.timeout,i=r.propCount;if(!a)return t();var s="transition"===a?fa:ga,l=0,c=function(){n.removeEventListener(s,u),t()},u=function(e){e.target===n&&++l>=i&&c()};setTimeout((function(){l<i&&c()}),o+1),n.addEventListener(s,u)}var ka=/\b(transform|all)(,|$)/;function _a(n,e){var t,r=window.getComputedStyle(n),a=(r[ha+"Delay"]||"").split(", "),o=(r[ha+"Duration"]||"").split(", "),i=ja(a,o),s=(r[ma+"Delay"]||"").split(", "),l=(r[ma+"Duration"]||"").split(", "),c=ja(s,l),u=0,d=0;return"transition"===e?i>0&&(t="transition",u=i,d=o.length):"animation"===e?c>0&&(t="animation",u=c,d=l.length):d=(t=(u=Math.max(i,c))>0?i>c?"transition":"animation":null)?"transition"===t?o.length:l.length:0,{type:t,timeout:u,propCount:d,hasTransform:"transition"===t&&ka.test(r[ha+"Property"])}}function ja(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return Sa(e)+Sa(n[t])})))}function Sa(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function Na(n,e){var t=n.elm;i(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var r=ua(n.data.transition);if(!o(r)&&!i(t._enterCb)&&1===t.nodeType){for(var a=r.css,s=r.type,l=r.enterClass,d=r.enterToClass,p=r.enterActiveClass,h=r.appearClass,f=r.appearToClass,m=r.appearActiveClass,g=r.beforeEnter,y=r.enter,b=r.afterEnter,x=r.enterCancelled,w=r.beforeAppear,k=r.appear,_=r.afterAppear,j=r.appearCancelled,S=r.duration,N=We,P=We.$vnode;P&&P.parent;)N=P.context,P=P.parent;var T=!N._isMounted||!n.isRootInsert;if(!T||k||""===k){var C=T&&h?h:l,I=T&&m?m:p,A=T&&f?f:d,E=T&&w||g,z=T&&c(k)?k:y,O=T&&_||b,L=T&&j||x,M=v(u(S)?S.enter:S);0;var D=!1!==a&&!Y,q=Ca(z),F=t._enterCb=R((function(){D&&(xa(t,A),xa(t,I)),F.cancelled?(D&&xa(t,C),L&&L(t)):O&&O(t),t._enterCb=null}));n.data.show||Gn(n,"insert",(function(){var e=t.parentNode,r=e&&e._pending&&e._pending[n.key];r&&r.tag===n.tag&&r.elm._leaveCb&&r.elm._leaveCb(),z&&z(t,F)})),E&&E(t),D&&(ba(t,C),ba(t,I),ya((function(){xa(t,C),F.cancelled||(ba(t,A),q||(Ta(M)?setTimeout(F,M):wa(t,s,F)))}))),n.data.show&&(e&&e(),z&&z(t,F)),D||q||F()}}}function Pa(n,e){var t=n.elm;i(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var r=ua(n.data.transition);if(o(r)||1!==t.nodeType)return e();if(!i(t._leaveCb)){var a=r.css,s=r.type,l=r.leaveClass,c=r.leaveToClass,d=r.leaveActiveClass,p=r.beforeLeave,h=r.leave,f=r.afterLeave,m=r.leaveCancelled,g=r.delayLeave,y=r.duration,b=!1!==a&&!Y,x=Ca(h),w=v(u(y)?y.leave:y);0;var k=t._leaveCb=R((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),b&&(xa(t,c),xa(t,d)),k.cancelled?(b&&xa(t,l),m&&m(t)):(e(),f&&f(t)),t._leaveCb=null}));g?g(_):_()}function _(){k.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),p&&p(t),b&&(ba(t,l),ba(t,d),ya((function(){xa(t,l),k.cancelled||(ba(t,c),x||(Ta(w)?setTimeout(k,w):wa(t,s,k)))}))),h&&h(t,k),b||x||k())}}function Ta(n){return"number"==typeof n&&!isNaN(n)}function Ca(n){if(o(n))return!1;var e=n.fns;return i(e)?Ca(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function Ia(n,e){!0!==e.data.show&&Na(e)}var Aa=function(n){var e,t,r={},c=n.modules,u=n.nodeOps;for(e=0;e<_r.length;++e)for(r[_r[e]]=[],t=0;t<c.length;++t)i(c[t][_r[e]])&&r[_r[e]].push(c[t][_r[e]]);function d(n){var e=u.parentNode(n);i(e)&&u.removeChild(e,n)}function p(n,e,t,a,o,l,c){if(i(n.elm)&&i(l)&&(n=l[c]=gn(n)),n.isRootInsert=!o,!function(n,e,t,a){var o=n.data;if(i(o)){var l=i(n.componentInstance)&&o.keepAlive;if(i(o=o.hook)&&i(o=o.init)&&o(n,!1),i(n.componentInstance))return h(n,e),f(t,n.elm,a),s(l)&&function(n,e,t,a){var o,s=n;for(;s.componentInstance;)if(s=s.componentInstance._vnode,i(o=s.data)&&i(o=o.transition)){for(o=0;o<r.activate.length;++o)r.activate[o](kr,s);e.push(s);break}f(t,n.elm,a)}(n,e,t,a),!0}}(n,e,t,a)){var d=n.data,p=n.children,g=n.tag;i(g)?(n.elm=n.ns?u.createElementNS(n.ns,g):u.createElement(g,n),b(n),m(n,p,e),i(d)&&v(n,e),f(t,n.elm,a)):s(n.isComment)?(n.elm=u.createComment(n.text),f(t,n.elm,a)):(n.elm=u.createTextNode(n.text),f(t,n.elm,a))}}function h(n,e){i(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,g(n)?(v(n,e),b(n)):(xr(n),e.push(n))}function f(n,e,t){i(n)&&(i(t)?u.parentNode(t)===n&&u.insertBefore(n,e,t):u.appendChild(n,e))}function m(n,e,t){if(a(e)){0;for(var r=0;r<e.length;++r)p(e[r],t,n.elm,null,!0,e,r)}else l(n.text)&&u.appendChild(n.elm,u.createTextNode(String(n.text)))}function g(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return i(n.tag)}function v(n,t){for(var a=0;a<r.create.length;++a)r.create[a](kr,n);i(e=n.data.hook)&&(i(e.create)&&e.create(kr,n),i(e.insert)&&t.push(n))}function b(n){var e;if(i(e=n.fnScopeId))u.setStyleScope(n.elm,e);else for(var t=n;t;)i(e=t.context)&&i(e=e.$options._scopeId)&&u.setStyleScope(n.elm,e),t=t.parent;i(e=We)&&e!==n.context&&e!==n.fnContext&&i(e=e.$options._scopeId)&&u.setStyleScope(n.elm,e)}function x(n,e,t,r,a,o){for(;r<=a;++r)p(t[r],o,n,e,!1,t,r)}function w(n){var e,t,a=n.data;if(i(a))for(i(e=a.hook)&&i(e=e.destroy)&&e(n),e=0;e<r.destroy.length;++e)r.destroy[e](n);if(i(e=n.children))for(t=0;t<n.children.length;++t)w(n.children[t])}function k(n,e,t){for(;e<=t;++e){var r=n[e];i(r)&&(i(r.tag)?(_(r),w(r)):d(r.elm))}}function _(n,e){if(i(e)||i(n.data)){var t,a=r.remove.length+1;for(i(e)?e.listeners+=a:e=function(n,e){function t(){0==--t.listeners&&d(n)}return t.listeners=e,t}(n.elm,a),i(t=n.componentInstance)&&i(t=t._vnode)&&i(t.data)&&_(t,e),t=0;t<r.remove.length;++t)r.remove[t](n,e);i(t=n.data.hook)&&i(t=t.remove)?t(n,e):e()}else d(n.elm)}function j(n,e,t,r){for(var a=t;a<r;a++){var o=e[a];if(i(o)&&jr(n,o))return a}}function S(n,e,t,a,l,c){if(n!==e){i(e.elm)&&i(a)&&(e=a[l]=gn(e));var d=e.elm=n.elm;if(s(n.isAsyncPlaceholder))i(e.asyncFactory.resolved)?T(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(s(e.isStatic)&&s(n.isStatic)&&e.key===n.key&&(s(e.isCloned)||s(e.isOnce)))e.componentInstance=n.componentInstance;else{var h,f=e.data;i(f)&&i(h=f.hook)&&i(h=h.prepatch)&&h(n,e);var m=n.children,v=e.children;if(i(f)&&g(e)){for(h=0;h<r.update.length;++h)r.update[h](n,e);i(h=f.hook)&&i(h=h.update)&&h(n,e)}o(e.text)?i(m)&&i(v)?m!==v&&function(n,e,t,r,a){var s,l,c,d=0,h=0,f=e.length-1,m=e[0],g=e[f],v=t.length-1,y=t[0],b=t[v],w=!a;for(0;d<=f&&h<=v;)o(m)?m=e[++d]:o(g)?g=e[--f]:jr(m,y)?(S(m,y,r,t,h),m=e[++d],y=t[++h]):jr(g,b)?(S(g,b,r,t,v),g=e[--f],b=t[--v]):jr(m,b)?(S(m,b,r,t,v),w&&u.insertBefore(n,m.elm,u.nextSibling(g.elm)),m=e[++d],b=t[--v]):jr(g,y)?(S(g,y,r,t,h),w&&u.insertBefore(n,g.elm,m.elm),g=e[--f],y=t[++h]):(o(s)&&(s=Sr(e,d,f)),o(l=i(y.key)?s[y.key]:j(y,e,d,f))?p(y,r,n,m.elm,!1,t,h):jr(c=e[l],y)?(S(c,y,r,t,h),e[l]=void 0,w&&u.insertBefore(n,c.elm,m.elm)):p(y,r,n,m.elm,!1,t,h),y=t[++h]);d>f?x(n,o(t[v+1])?null:t[v+1].elm,t,h,v,r):h>v&&k(e,d,f)}(d,m,v,t,c):i(v)?(i(n.text)&&u.setTextContent(d,""),x(d,null,v,0,v.length-1,t)):i(m)?k(m,0,m.length-1):i(n.text)&&u.setTextContent(d,""):n.text!==e.text&&u.setTextContent(d,e.text),i(f)&&i(h=f.hook)&&i(h=h.postpatch)&&h(n,e)}}}function N(n,e,t){if(s(t)&&i(n.parent))n.parent.data.pendingInsert=e;else for(var r=0;r<e.length;++r)e[r].data.hook.insert(e[r])}var P=y("attrs,class,staticClass,staticStyle,key");function T(n,e,t,r){var a,o=e.tag,l=e.data,c=e.children;if(r=r||l&&l.pre,e.elm=n,s(e.isComment)&&i(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(i(l)&&(i(a=l.hook)&&i(a=a.init)&&a(e,!0),i(a=e.componentInstance)))return h(e,t),!0;if(i(o)){if(i(c))if(n.hasChildNodes())if(i(a=l)&&i(a=a.domProps)&&i(a=a.innerHTML)){if(a!==n.innerHTML)return!1}else{for(var u=!0,d=n.firstChild,p=0;p<c.length;p++){if(!d||!T(d,c[p],t,r)){u=!1;break}d=d.nextSibling}if(!u||d)return!1}else m(e,c,t);if(i(l)){var f=!1;for(var g in l)if(!P(g)){f=!0,v(e,t);break}!f&&l.class&&$e(l.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,a){if(!o(e)){var l,c=!1,d=[];if(o(n))c=!0,p(e,d);else{var h=i(n.nodeType);if(!h&&jr(n,e))S(n,e,d,null,null,a);else{if(h){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),s(t)&&T(n,e,d))return N(e,d,!0),n;l=n,n=new hn(u.tagName(l).toLowerCase(),{},[],void 0,l)}var f=n.elm,m=u.parentNode(f);if(p(e,d,f._leaveCb?null:m,u.nextSibling(f)),i(e.parent))for(var v=e.parent,y=g(e);v;){for(var b=0;b<r.destroy.length;++b)r.destroy[b](v);if(v.elm=e.elm,y){for(var x=0;x<r.create.length;++x)r.create[x](kr,v);var _=v.data.hook.insert;if(_.merged)for(var j=1;j<_.fns.length;j++)_.fns[j]()}else xr(v);v=v.parent}i(m)?k([n],0,0):i(n.tag)&&w(n)}}return N(e,d,c),e.elm}i(n)&&w(n)}}({nodeOps:yr,modules:[Mr,qr,Gr,Wr,ia,J?{create:Ia,activate:Ia,remove:function(n,e){!0!==n.data.show?Pa(n,e):e()}}:{}].concat(Er)});Y&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&qa(n,"input")}));var Ea={inserted:function(n,e,t,r){"select"===t.tag?(r.elm&&!r.elm._vOptions?Gn(t,"postpatch",(function(){Ea.componentUpdated(n,e,t)})):za(n,e,t.context),n._vOptions=[].map.call(n.options,Ma)):("textarea"===t.tag||vr(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",Da),n.addEventListener("compositionend",Ra),n.addEventListener("change",Ra),Y&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){za(n,e,t.context);var r=n._vOptions,a=n._vOptions=[].map.call(n.options,Ma);if(a.some((function(n,e){return!M(n,r[e])})))(n.multiple?e.value.some((function(n){return La(n,a)})):e.value!==e.oldValue&&La(e.value,a))&&qa(n,"change")}}};function za(n,e,t){Oa(n,e,t),(Q||X)&&setTimeout((function(){Oa(n,e,t)}),0)}function Oa(n,e,t){var r=e.value,a=n.multiple;if(!a||Array.isArray(r)){for(var o,i,s=0,l=n.options.length;s<l;s++)if(i=n.options[s],a)o=D(r,Ma(i))>-1,i.selected!==o&&(i.selected=o);else if(M(Ma(i),r))return void(n.selectedIndex!==s&&(n.selectedIndex=s));a||(n.selectedIndex=-1)}}function La(n,e){return e.every((function(e){return!M(e,n)}))}function Ma(n){return"_value"in n?n._value:n.value}function Da(n){n.target.composing=!0}function Ra(n){n.target.composing&&(n.target.composing=!1,qa(n.target,"input"))}function qa(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function Fa(n){return!n.componentInstance||n.data&&n.data.transition?n:Fa(n.componentInstance._vnode)}var $a={model:Ea,show:{bind:function(n,e,t){var r=e.value,a=(t=Fa(t)).data&&t.data.transition,o=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;r&&a?(t.data.show=!0,Na(t,(function(){n.style.display=o}))):n.style.display=r?o:"none"},update:function(n,e,t){var r=e.value;!r!=!e.oldValue&&((t=Fa(t)).data&&t.data.transition?(t.data.show=!0,r?Na(t,(function(){n.style.display=n.__vOriginalDisplay})):Pa(t,(function(){n.style.display="none"}))):n.style.display=r?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,r,a){a||(n.style.display=n.__vOriginalDisplay)}}},Va={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function Ba(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?Ba(_e(e.children)):n}function Ha(n){var e={},t=n.$options;for(var r in t.propsData)e[r]=n[r];var a=t._parentListeners;for(var r in a)e[S(r)]=a[r];return e}function Ua(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var Ga=function(n){return n.tag||he(n)},Ka=function(n){return"show"===n.name},Ja={name:"transition",props:Va,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(Ga)).length){0;var r=this.mode;0;var a=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return a;var o=Ba(a);if(!o)return a;if(this._leaving)return Ua(n,a);var i="__transition-".concat(this._uid,"-");o.key=null==o.key?o.isComment?i+"comment":i+o.tag:l(o.key)?0===String(o.key).indexOf(i)?o.key:i+o.key:o.key;var s=(o.data||(o.data={})).transition=Ha(this),c=this._vnode,u=Ba(c);if(o.data.directives&&o.data.directives.some(Ka)&&(o.data.show=!0),u&&u.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(o,u)&&!he(u)&&(!u.componentInstance||!u.componentInstance._vnode.isComment)){var d=u.data.transition=A({},s);if("out-in"===r)return this._leaving=!0,Gn(d,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),Ua(n,a);if("in-out"===r){if(he(o))return c;var p,h=function(){p()};Gn(s,"afterEnter",h),Gn(s,"enterCancelled",h),Gn(d,"delayLeave",(function(n){p=n}))}}return a}}},Wa=A({tag:String,moveClass:String},Va);function Qa(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Ya(n){n.data.newPos=n.elm.getBoundingClientRect()}function Xa(n){var e=n.data.pos,t=n.data.newPos,r=e.left-t.left,a=e.top-t.top;if(r||a){n.data.moved=!0;var o=n.elm.style;o.transform=o.WebkitTransform="translate(".concat(r,"px,").concat(a,"px)"),o.transitionDuration="0s"}}delete Wa.mode;var Za={Transition:Ja,TransitionGroup:{props:Wa,beforeMount:function(){var n=this,e=this._update;this._update=function(t,r){var a=Qe(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,a(),e.call(n,t,r)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),r=this.prevChildren=this.children,a=this.$slots.default||[],o=this.children=[],i=Ha(this),s=0;s<a.length;s++){if((u=a[s]).tag)if(null!=u.key&&0!==String(u.key).indexOf("__vlist"))o.push(u),t[u.key]=u,(u.data||(u.data={})).transition=i;else;}if(r){var l=[],c=[];for(s=0;s<r.length;s++){var u;(u=r[s]).data.transition=i,u.data.pos=u.elm.getBoundingClientRect(),t[u.key]?l.push(u):c.push(u)}this.kept=n(e,null,l),this.removed=c}return n(e,null,o)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Qa),n.forEach(Ya),n.forEach(Xa),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,r=t.style;ba(t,e),r.transform=r.WebkitTransform=r.transitionDuration="",t.addEventListener(fa,t._moveCb=function n(r){r&&r.target!==t||r&&!/transform$/.test(r.propertyName)||(t.removeEventListener(fa,n),t._moveCb=null,xa(t,e))})}})))},methods:{hasMove:function(n,e){if(!pa)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){ca(t,n)})),la(t,e),t.style.display="none",this.$el.appendChild(t);var r=_a(t);return this.$el.removeChild(t),this._hasMove=r.hasTransform}}}};Ut.config.mustUseProp=function(n,e,t){return"value"===t&&nr(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},Ut.config.isReservedTag=mr,Ut.config.isReservedAttr=Zt,Ut.config.getTagNamespace=function(n){return fr(n)?"svg":"math"===n?"math":void 0},Ut.config.isUnknownElement=function(n){if(!J)return!0;if(mr(n))return!1;if(n=n.toLowerCase(),null!=gr[n])return gr[n];var e=document.createElement(n);return n.indexOf("-")>-1?gr[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:gr[n]=/HTMLUnknownElement/.test(e.toString())},A(Ut.options.directives,$a),A(Ut.options.components,Za),Ut.prototype.__patch__=J?Aa:z,Ut.prototype.$mount=function(n,e){return function(n,e,t){var r;n.$el=e,n.$options.render||(n.$options.render=fn),Ze(n,"beforeMount"),r=function(){n._update(n._render(),t)},new He(n,r,z,{before:function(){n._isMounted&&!n._isDestroyed&&Ze(n,"beforeUpdate")}},!0),t=!1;var a=n._preWatchers;if(a)for(var o=0;o<a.length;o++)a[o].run();return null==n.$vnode&&(n._isMounted=!0,Ze(n,"mounted")),n}(this,n=n&&J?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},J&&setTimeout((function(){V.devtools&&sn&&sn.emit("init",Ut)}),0)},function(n,e){n.exports=function(n){return"function"==typeof n}},function(n,e,t){var r=t(25),a=Function.prototype,o=a.bind,i=a.call,s=r&&o.bind(i,i);n.exports=r?function(n){return n&&s(n)}:function(n){return n&&function(){return i.apply(n,arguments)}}},function(n,e){var t=function(n){return n&&n.Math==Math&&n};n.exports=t("object"==typeof globalThis&&globalThis)||t("object"==typeof window&&window)||t("object"==typeof self&&self)||t("object"==typeof global&&global)||function(){return this}()||Function("return this")()},function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){var r=t(66),a="object"==typeof self&&self&&self.Object===Object&&self,o=r||a||Function("return this")();n.exports=o},function(n,e,t){var r=t(4);n.exports=!r((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e,t){var r=t(2),a=t(45),o=r({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return o(a(n),e)}},function(n,e,t){var r=t(1);n.exports=function(n){return"object"==typeof n?null!==n:r(n)}},function(n,e,t){var r=t(151),a=t(154);n.exports=function(n,e){var t=a(n,e);return r(t)?t:void 0}},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){var r=t(13),a=t(136),o=t(137),i=r?r.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":i&&i in Object(n)?a(n):o(n)}},function(n,e,t){var r=t(6).Symbol;n.exports=r},function(n,e,t){"use strict";function r(n,e,t,r,a,o,i,s){var l,c="function"==typeof n?n.options:n;if(e&&(c.render=e,c.staticRenderFns=t,c._compiled=!0),r&&(c.functional=!0),o&&(c._scopeId="data-v-"+o),i?(l=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),a&&a.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(i)},c._ssrRegister=l):a&&(l=s?function(){a.call(this,(c.functional?this.parent:this).$root.$options.shadowRoot)}:a),l)if(c.functional){c._injectStyles=l;var u=c.render;c.render=function(n,e){return l.call(e),u(n,e)}}else{var d=c.beforeCreate;c.beforeCreate=d?[].concat(d,l):[l]}return{exports:n,options:c}}t.d(e,"a",(function(){return r}))},function(n,e,t){var r=t(7),a=t(60),o=t(92),i=t(24),s=t(51),l=TypeError,c=Object.defineProperty,u=Object.getOwnPropertyDescriptor;e.f=r?o?function(n,e,t){if(i(n),e=s(e),i(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var r=u(n,e);r&&r.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:r.configurable,enumerable:"enumerable"in t?t.enumerable:r.enumerable,writable:!1})}return c(n,e,t)}:c:function(n,e,t){if(i(n),e=s(e),i(t),a)try{return c(n,e,t)}catch(n){}if("get"in t||"set"in t)throw l("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var r=t(3),a=t(1),o=function(n){return a(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?o(r[n]):r[n]&&r[n][e]}},function(n,e,t){var r=t(7),a=t(15),o=t(29);n.exports=r?function(n,e,t){return a.f(n,e,o(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){var r=t(141),a=t(142),o=t(143),i=t(144),s=t(145);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=a,l.prototype.get=o,l.prototype.has=i,l.prototype.set=s,n.exports=l},function(n,e,t){var r=t(68);n.exports=function(n,e){for(var t=n.length;t--;)if(r(n[t][0],e))return t;return-1}},function(n,e,t){var r=t(10)(Object,"create");n.exports=r},function(n,e,t){var r=t(163);n.exports=function(n,e){var t=n.__data__;return r(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var r=t(40);n.exports=function(n){if("string"==typeof n||r(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){var r,a;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(a="function"==typeof(r=function(){var n,e,t={version:"0.2.0"},r=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function a(n,e,t){return n<e?e:n>t?t:n}function o(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(r[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=a(n,r.minimum,1),t.status=1===n?null:n;var l=t.render(!e),c=l.querySelector(r.barSelector),u=r.speed,d=r.easing;return l.offsetWidth,i((function(e){""===r.positionUsing&&(r.positionUsing=t.getPositioningCSS()),s(c,function(n,e,t){var a;return(a="translate3d"===r.positionUsing?{transform:"translate3d("+o(n)+"%,0,0)"}:"translate"===r.positionUsing?{transform:"translate("+o(n)+"%,0)"}:{"margin-left":o(n)+"%"}).transition="all "+e+"ms "+t,a}(n,u,d)),1===n?(s(l,{transition:"none",opacity:1}),l.offsetWidth,setTimeout((function(){s(l,{transition:"all "+u+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),u)}),u)):setTimeout(e,u)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),r.trickleSpeed)};return r.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*a(Math.random()*e,.1,.95)),e=a(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*r.trickleRate)},n=0,e=0,t.promise=function(r){return r&&"resolved"!==r.state()?(0===e&&t.start(),n++,e++,r.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");c(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=r.template;var a,i=e.querySelector(r.barSelector),l=n?"-100":o(t.status||0),u=document.querySelector(r.parent);return s(i,{transition:"all 0 linear",transform:"translate3d("+l+"%,0,0)"}),r.showSpinner||(a=e.querySelector(r.spinnerSelector))&&p(a),u!=document.body&&c(u,"nprogress-custom-parent"),u.appendChild(e),e},t.remove=function(){u(document.documentElement,"nprogress-busy"),u(document.querySelector(r.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&p(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var i=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),s=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var r,a=n.length,o=e.charAt(0).toUpperCase()+e.slice(1);a--;)if((r=n[a]+o)in t)return r;return e}(t))}function r(n,e,r){e=t(e),n.style[e]=r}return function(n,e){var t,a,o=arguments;if(2==o.length)for(t in e)void 0!==(a=e[t])&&e.hasOwnProperty(t)&&r(n,t,a);else r(n,o[1],o[2])}}();function l(n,e){return("string"==typeof n?n:d(n)).indexOf(" "+e+" ")>=0}function c(n,e){var t=d(n),r=t+e;l(t,e)||(n.className=r.substring(1))}function u(n,e){var t,r=d(n);l(n,e)&&(t=r.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function d(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function p(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?r.call(e,t,e,n):r)||(n.exports=a)},function(n,e,t){var r=t(9),a=String,o=TypeError;n.exports=function(n){if(r(n))return n;throw o(a(n)+" is not an object")}},function(n,e,t){var r=t(4);n.exports=!r((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e,t){var r=t(43),a=t(50);n.exports=function(n){return r(a(n))}},function(n,e,t){var r=t(3),a=t(57),o=t(8),i=t(59),s=t(55),l=t(54),c=a("wks"),u=r.Symbol,d=u&&u.for,p=l?u:u&&u.withoutSetter||i;n.exports=function(n){if(!o(c,n)||!s&&"string"!=typeof c[n]){var e="Symbol."+n;s&&o(u,n)?c[n]=u[n]:c[n]=l&&d?d(e):p(e)}return c[n]}},function(n,e,t){var r=t(25),a=Function.prototype.call;n.exports=r?a.bind(a):function(){return a.apply(a,arguments)}},function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){var r=t(2),a=r({}.toString),o=r("".slice);n.exports=function(n){return o(a(n),8,-1)}},function(n,e,t){var r=t(3),a=t(32),o=r["__core-js_shared__"]||a("__core-js_shared__",{});n.exports=o},function(n,e,t){var r=t(3),a=Object.defineProperty;n.exports=function(n,e){try{a(r,n,{value:e,configurable:!0,writable:!0})}catch(t){r[n]=e}return e}},function(n,e,t){var r=t(135),a=t(11),o=Object.prototype,i=o.hasOwnProperty,s=o.propertyIsEnumerable,l=r(function(){return arguments}())?r:function(n){return a(n)&&i.call(n,"callee")&&!s.call(n,"callee")};n.exports=l},function(n,e,t){var r=t(10)(t(6),"Map");n.exports=r},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var r=t(155),a=t(162),o=t(164),i=t(165),s=t(166);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=a,l.prototype.get=o,l.prototype.has=i,l.prototype.set=s,n.exports=l},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var r=t(5),a=t(40),o=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,i=/^\w*$/;n.exports=function(n,e){if(r(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!a(n))||(i.test(n)||!o.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var r=t(12),a=t(11);n.exports=function(n){return"symbol"==typeof n||a(n)&&"[object Symbol]"==r(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){var r=t(3),a=t(49).f,o=t(17),i=t(105),s=t(32),l=t(62),c=t(117);n.exports=function(n,e){var t,u,d,p,h,f=n.target,m=n.global,g=n.stat;if(t=m?r:g?r[f]||s(f,{}):(r[f]||{}).prototype)for(u in e){if(p=e[u],d=n.dontCallGetSet?(h=a(t,u))&&h.value:t[u],!c(m?u:f+(g?".":"#")+u,n.forced)&&void 0!==d){if(typeof p==typeof d)continue;l(p,d)}(n.sham||d&&d.sham)&&o(p,"sham",!0),i(t,u,p,n)}}},function(n,e,t){var r=t(2),a=t(4),o=t(30),i=Object,s=r("".split);n.exports=a((function(){return!i("z").propertyIsEnumerable(0)}))?function(n){return"String"==o(n)?s(n,""):i(n)}:i},function(n,e,t){var r=t(1),a=t(103),o=TypeError;n.exports=function(n){if(r(n))return n;throw o(a(n)+" is not a function")}},function(n,e,t){var r=t(50),a=Object;n.exports=function(n){return a(r(n))}},function(n,e){n.exports={}},function(n,e,t){var r=t(115);n.exports=function(n){return r(n.length)}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e,t){var r=t(7),a=t(28),o=t(99),i=t(29),s=t(26),l=t(51),c=t(8),u=t(60),d=Object.getOwnPropertyDescriptor;e.f=r?d:function(n,e){if(n=s(n),e=l(e),u)try{return d(n,e)}catch(n){}if(c(n,e))return i(!a(o.f,n,e),n[e])}},function(n,e){var t=TypeError;n.exports=function(n){if(null==n)throw t("Can't call method on "+n);return n}},function(n,e,t){var r=t(100),a=t(52);n.exports=function(n){var e=r(n,"string");return a(e)?e:e+""}},function(n,e,t){var r=t(16),a=t(1),o=t(53),i=t(54),s=Object;n.exports=i?function(n){return"symbol"==typeof n}:function(n){var e=r("Symbol");return a(e)&&o(e.prototype,s(n))}},function(n,e,t){var r=t(2);n.exports=r({}.isPrototypeOf)},function(n,e,t){var r=t(55);n.exports=r&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){var r=t(56),a=t(4);n.exports=!!Object.getOwnPropertySymbols&&!a((function(){var n=Symbol();return!String(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&r&&r<41}))},function(n,e,t){var r,a,o=t(3),i=t(101),s=o.process,l=o.Deno,c=s&&s.versions||l&&l.version,u=c&&c.v8;u&&(a=(r=u.split("."))[0]>0&&r[0]<4?1:+(r[0]+r[1])),!a&&i&&(!(r=i.match(/Edge\/(\d+)/))||r[1]>=74)&&(r=i.match(/Chrome\/(\d+)/))&&(a=+r[1]),n.exports=a},function(n,e,t){var r=t(58),a=t(31);(n.exports=function(n,e){return a[n]||(a[n]=void 0!==e?e:{})})("versions",[]).push({version:"3.24.0",mode:r?"pure":"global",copyright:"© 2014-2022 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.24.0/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e){n.exports=!1},function(n,e,t){var r=t(2),a=0,o=Math.random(),i=r(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+i(++a+o,36)}},function(n,e,t){var r=t(7),a=t(4),o=t(91);n.exports=!r&&!a((function(){return 7!=Object.defineProperty(o("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){var r=t(2),a=t(1),o=t(31),i=r(Function.toString);a(o.inspectSource)||(o.inspectSource=function(n){return i(n)}),n.exports=o.inspectSource},function(n,e,t){var r=t(8),a=t(110),o=t(49),i=t(15);n.exports=function(n,e,t){for(var s=a(e),l=i.f,c=o.f,u=0;u<s.length;u++){var d=s[u];r(n,d)||t&&r(t,d)||l(n,d,c(e,d))}}},function(n,e,t){var r=t(114);n.exports=function(n){var e=+n;return e!=e||0===e?0:r(e)}},function(n,e,t){var r=t(2),a=t(24),o=t(123);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=r(Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set))(t,[]),e=t instanceof Array}catch(n){}return function(t,r){return a(t),o(r),e?n(t,r):t.__proto__=r,t}}():void 0)},function(n,e){n.exports=function(n,e){for(var t=-1,r=e.length,a=n.length;++t<r;)n[a+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var r=t(18),a=t(146),o=t(147),i=t(148),s=t(149),l=t(150);function c(n){var e=this.__data__=new r(n);this.size=e.size}c.prototype.clear=a,c.prototype.delete=o,c.prototype.get=i,c.prototype.has=s,c.prototype.set=l,n.exports=c},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var r=t(12),a=t(35);n.exports=function(n){if(!a(n))return!1;var e=r(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var r=t(167),a=t(11);n.exports=function n(e,t,o,i,s){return e===t||(null==e||null==t||!a(e)&&!a(t)?e!=e&&t!=t:r(e,t,o,i,n,s))}},function(n,e,t){var r=t(73),a=t(170),o=t(74);n.exports=function(n,e,t,i,s,l){var c=1&t,u=n.length,d=e.length;if(u!=d&&!(c&&d>u))return!1;var p=l.get(n),h=l.get(e);if(p&&h)return p==e&&h==n;var f=-1,m=!0,g=2&t?new r:void 0;for(l.set(n,e),l.set(e,n);++f<u;){var v=n[f],y=e[f];if(i)var b=c?i(y,v,f,e,n,l):i(v,y,f,n,e,l);if(void 0!==b){if(b)continue;m=!1;break}if(g){if(!a(e,(function(n,e){if(!o(g,e)&&(v===n||s(v,n,t,i,l)))return g.push(e)}))){m=!1;break}}else if(v!==y&&!s(v,y,t,i,l)){m=!1;break}}return l.delete(n),l.delete(e),m}},function(n,e,t){var r=t(36),a=t(168),o=t(169);function i(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new r;++e<t;)this.add(n[e])}i.prototype.add=i.prototype.push=a,i.prototype.has=o,n.exports=i},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var r=t(180),a=t(186),o=t(79);n.exports=function(n){return o(n)?r(n):a(n)}},function(n,e,t){(function(n){var r=t(6),a=t(182),o=e&&!e.nodeType&&e,i=o&&"object"==typeof n&&n&&!n.nodeType&&n,s=i&&i.exports===o?r.Buffer:void 0,l=(s?s.isBuffer:void 0)||a;n.exports=l}).call(this,t(48)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var r=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==r||"symbol"!=r&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var r=t(183),a=t(184),o=t(185),i=o&&o.isTypedArray,s=i?a(i):r;n.exports=s},function(n,e,t){var r=t(69),a=t(38);n.exports=function(n){return null!=n&&a(n.length)&&!r(n)}},function(n,e,t){var r=t(10)(t(6),"Set");n.exports=r},function(n,e,t){var r=t(35);n.exports=function(n){return n==n&&!r(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var r=t(84),a=t(22);n.exports=function(n,e){for(var t=0,o=(e=r(e,n)).length;null!=n&&t<o;)n=n[a(e[t++])];return t&&t==o?n:void 0}},function(n,e,t){var r=t(5),a=t(39),o=t(197),i=t(200);n.exports=function(n,e){return r(n)?n:a(n,e)?[n]:o(i(n))}},function(n,e,t){},function(n,e,t){},function(n,e,t){var r=t(133),a=t(138),o=t(209),i=t(217),s=t(226),l=t(96),c=o((function(n){var e=l(n);return s(e)&&(e=void 0),i(r(n,1,s,!0),a(e,2))}));n.exports=c},function(n,e,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var r=/["'&<>]/;n.exports=function(n){var e,t=""+n,a=r.exec(t);if(!a)return t;var o="",i=0,s=0;for(i=a.index;i<t.length;i++){switch(t.charCodeAt(i)){case 34:e="&quot;";break;case 38:e="&amp;";break;case 39:e="&#39;";break;case 60:e="&lt;";break;case 62:e="&gt;";break;default:continue}s!==i&&(o+=t.substring(s,i)),s=i+1,o+=e}return s!==i?o+t.substring(s,i):o}},function(n,e){var t=/^\s+|\s+$/g,r=/^[-+]0x[0-9a-f]+$/i,a=/^0b[01]+$/i,o=/^0o[0-7]+$/i,i=parseInt,s="object"==typeof global&&global&&global.Object===Object&&global,l="object"==typeof self&&self&&self.Object===Object&&self,c=s||l||Function("return this")(),u=Object.prototype.toString,d=Math.max,p=Math.min,h=function(){return c.Date.now()};function f(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function m(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==u.call(n)}(n))return NaN;if(f(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=f(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var s=a.test(n);return s||o.test(n)?i(n.slice(2),s?2:8):r.test(n)?NaN:+n}n.exports=function(n,e,t){var r,a,o,i,s,l,c=0,u=!1,g=!1,v=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function y(e){var t=r,o=a;return r=a=void 0,c=e,i=n.apply(o,t)}function b(n){return c=n,s=setTimeout(w,e),u?y(n):i}function x(n){var t=n-l;return void 0===l||t>=e||t<0||g&&n-c>=o}function w(){var n=h();if(x(n))return k(n);s=setTimeout(w,function(n){var t=e-(n-l);return g?p(t,o-(n-c)):t}(n))}function k(n){return s=void 0,v&&r?y(n):(r=a=void 0,i)}function _(){var n=h(),t=x(n);if(r=arguments,a=this,l=n,t){if(void 0===s)return b(l);if(g)return s=setTimeout(w,e),y(l)}return void 0===s&&(s=setTimeout(w,e)),i}return e=m(e)||0,f(t)&&(u=!!t.leading,o=(g="maxWait"in t)?d(m(t.maxWait)||0,e):o,v="trailing"in t?!!t.trailing:v),_.cancel=function(){void 0!==s&&clearTimeout(s),c=0,r=l=a=s=void 0},_.flush=function(){return void 0===s?i:k(h())},_}},function(n,e){n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){var r=t(3),a=t(9),o=r.document,i=a(o)&&a(o.createElement);n.exports=function(n){return i?o.createElement(n):{}}},function(n,e,t){var r=t(7),a=t(4);n.exports=r&&a((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){var r=t(57),a=t(59),o=r("keys");n.exports=function(n){return o[n]||(o[n]=a(n))}},function(n,e,t){var r=t(2),a=t(8),o=t(26),i=t(112).indexOf,s=t(46),l=r([].push);n.exports=function(n,e){var t,r=o(n),c=0,u=[];for(t in r)!a(s,t)&&a(r,t)&&l(u,t);for(;e.length>c;)a(r,t=e[c++])&&(~i(u,t)||l(u,t));return u}},function(n,e,t){var r=t(42),a=t(3),o=t(121),i=t(122),s=a.WebAssembly,l=7!==Error("e",{cause:7}).cause,c=function(n,e){var t={};t[n]=i(n,e,l),r({global:!0,constructor:!0,arity:1,forced:l},t)},u=function(n,e){if(s&&s[n]){var t={};t[n]=i("WebAssembly."+n,e,l),r({target:"WebAssembly",stat:!0,constructor:!0,arity:1,forced:l},t)}};c("Error",(function(n){return function(e){return o(n,this,arguments)}})),c("EvalError",(function(n){return function(e){return o(n,this,arguments)}})),c("RangeError",(function(n){return function(e){return o(n,this,arguments)}})),c("ReferenceError",(function(n){return function(e){return o(n,this,arguments)}})),c("SyntaxError",(function(n){return function(e){return o(n,this,arguments)}})),c("TypeError",(function(n){return function(e){return o(n,this,arguments)}})),c("URIError",(function(n){return function(e){return o(n,this,arguments)}})),u("CompileError",(function(n){return function(e){return o(n,this,arguments)}})),u("LinkError",(function(n){return function(e){return o(n,this,arguments)}})),u("RuntimeError",(function(n){return function(e){return o(n,this,arguments)}}))},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){n.exports=t(232)},function(n,e,t){"use strict";var r=t(42),a=t(118).left,o=t(119),i=t(56),s=t(120);r({target:"Array",proto:!0,forced:!o("reduce")||!s&&i>79&&i<83},{reduce:function(n){var e=arguments.length;return a(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var r={}.propertyIsEnumerable,a=Object.getOwnPropertyDescriptor,o=a&&!r.call({1:2},1);e.f=o?function(n){var e=a(this,n);return!!e&&e.enumerable}:r},function(n,e,t){var r=t(28),a=t(9),o=t(52),i=t(102),s=t(104),l=t(27),c=TypeError,u=l("toPrimitive");n.exports=function(n,e){if(!a(n)||o(n))return n;var t,l=i(n,u);if(l){if(void 0===e&&(e="default"),t=r(l,n,e),!a(t)||o(t))return t;throw c("Can't convert object to primitive value")}return void 0===e&&(e="number"),s(n,e)}},function(n,e,t){var r=t(16);n.exports=r("navigator","userAgent")||""},function(n,e,t){var r=t(44);n.exports=function(n,e){var t=n[e];return null==t?void 0:r(t)}},function(n,e){var t=String;n.exports=function(n){try{return t(n)}catch(n){return"Object"}}},function(n,e,t){var r=t(28),a=t(1),o=t(9),i=TypeError;n.exports=function(n,e){var t,s;if("string"===e&&a(t=n.toString)&&!o(s=r(t,n)))return s;if(a(t=n.valueOf)&&!o(s=r(t,n)))return s;if("string"!==e&&a(t=n.toString)&&!o(s=r(t,n)))return s;throw i("Can't convert object to primitive value")}},function(n,e,t){var r=t(1),a=t(15),o=t(106),i=t(32);n.exports=function(n,e,t,s){s||(s={});var l=s.enumerable,c=void 0!==s.name?s.name:e;if(r(t)&&o(t,c,s),s.global)l?n[e]=t:i(e,t);else{try{s.unsafe?n[e]&&(l=!0):delete n[e]}catch(n){}l?n[e]=t:a.f(n,e,{value:t,enumerable:!1,configurable:!s.nonConfigurable,writable:!s.nonWritable})}return n}},function(n,e,t){var r=t(4),a=t(1),o=t(8),i=t(7),s=t(107).CONFIGURABLE,l=t(61),c=t(108),u=c.enforce,d=c.get,p=Object.defineProperty,h=i&&!r((function(){return 8!==p((function(){}),"length",{value:8}).length})),f=String(String).split("String"),m=n.exports=function(n,e,t){"Symbol("===String(e).slice(0,7)&&(e="["+String(e).replace(/^Symbol\(([^)]*)\)/,"$1")+"]"),t&&t.getter&&(e="get "+e),t&&t.setter&&(e="set "+e),(!o(n,"name")||s&&n.name!==e)&&(i?p(n,"name",{value:e,configurable:!0}):n.name=e),h&&t&&o(t,"arity")&&n.length!==t.arity&&p(n,"length",{value:t.arity});try{t&&o(t,"constructor")&&t.constructor?i&&p(n,"prototype",{writable:!1}):n.prototype&&(n.prototype=void 0)}catch(n){}var r=u(n);return o(r,"source")||(r.source=f.join("string"==typeof e?e:"")),n};Function.prototype.toString=m((function(){return a(this)&&d(this).source||l(this)}),"toString")},function(n,e,t){var r=t(7),a=t(8),o=Function.prototype,i=r&&Object.getOwnPropertyDescriptor,s=a(o,"name"),l=s&&"something"===function(){}.name,c=s&&(!r||r&&i(o,"name").configurable);n.exports={EXISTS:s,PROPER:l,CONFIGURABLE:c}},function(n,e,t){var r,a,o,i=t(109),s=t(3),l=t(2),c=t(9),u=t(17),d=t(8),p=t(31),h=t(93),f=t(46),m=s.TypeError,g=s.WeakMap;if(i||p.state){var v=p.state||(p.state=new g),y=l(v.get),b=l(v.has),x=l(v.set);r=function(n,e){if(b(v,n))throw new m("Object already initialized");return e.facade=n,x(v,n,e),e},a=function(n){return y(v,n)||{}},o=function(n){return b(v,n)}}else{var w=h("state");f[w]=!0,r=function(n,e){if(d(n,w))throw new m("Object already initialized");return e.facade=n,u(n,w,e),e},a=function(n){return d(n,w)?n[w]:{}},o=function(n){return d(n,w)}}n.exports={set:r,get:a,has:o,enforce:function(n){return o(n)?a(n):r(n,{})},getterFor:function(n){return function(e){var t;if(!c(e)||(t=a(e)).type!==n)throw m("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){var r=t(3),a=t(1),o=t(61),i=r.WeakMap;n.exports=a(i)&&/native code/.test(o(i))},function(n,e,t){var r=t(16),a=t(2),o=t(111),i=t(116),s=t(24),l=a([].concat);n.exports=r("Reflect","ownKeys")||function(n){var e=o.f(s(n)),t=i.f;return t?l(e,t(n)):e}},function(n,e,t){var r=t(94),a=t(90).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return r(n,a)}},function(n,e,t){var r=t(26),a=t(113),o=t(47),i=function(n){return function(e,t,i){var s,l=r(e),c=o(l),u=a(i,c);if(n&&t!=t){for(;c>u;)if((s=l[u++])!=s)return!0}else for(;c>u;u++)if((n||u in l)&&l[u]===t)return n||u||0;return!n&&-1}};n.exports={includes:i(!0),indexOf:i(!1)}},function(n,e,t){var r=t(63),a=Math.max,o=Math.min;n.exports=function(n,e){var t=r(n);return t<0?a(t+e,0):o(t,e)}},function(n,e){var t=Math.ceil,r=Math.floor;n.exports=Math.trunc||function(n){var e=+n;return(e>0?r:t)(e)}},function(n,e,t){var r=t(63),a=Math.min;n.exports=function(n){return n>0?a(r(n),9007199254740991):0}},function(n,e){e.f=Object.getOwnPropertySymbols},function(n,e,t){var r=t(4),a=t(1),o=/#|\.prototype\./,i=function(n,e){var t=l[s(n)];return t==u||t!=c&&(a(e)?r(e):!!e)},s=i.normalize=function(n){return String(n).replace(o,".").toLowerCase()},l=i.data={},c=i.NATIVE="N",u=i.POLYFILL="P";n.exports=i},function(n,e,t){var r=t(44),a=t(45),o=t(43),i=t(47),s=TypeError,l=function(n){return function(e,t,l,c){r(t);var u=a(e),d=o(u),p=i(u),h=n?p-1:0,f=n?-1:1;if(l<2)for(;;){if(h in d){c=d[h],h+=f;break}if(h+=f,n?h<0:p<=h)throw s("Reduce of empty array with no initial value")}for(;n?h>=0:p>h;h+=f)h in d&&(c=t(c,d[h],h,u));return c}};n.exports={left:l(!1),right:l(!0)}},function(n,e,t){"use strict";var r=t(4);n.exports=function(n,e){var t=[][n];return!!t&&r((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){var r=t(30),a=t(3);n.exports="process"==r(a.process)},function(n,e,t){var r=t(25),a=Function.prototype,o=a.apply,i=a.call;n.exports="object"==typeof Reflect&&Reflect.apply||(r?i.bind(o):function(){return i.apply(o,arguments)})},function(n,e,t){"use strict";var r=t(16),a=t(8),o=t(17),i=t(53),s=t(64),l=t(62),c=t(124),u=t(125),d=t(126),p=t(130),h=t(131),f=t(132),m=t(7),g=t(58);n.exports=function(n,e,t,v){var y=v?2:1,b=n.split("."),x=b[b.length-1],w=r.apply(null,b);if(w){var k=w.prototype;if(!g&&a(k,"cause")&&delete k.cause,!t)return w;var _=r("Error"),j=e((function(n,e){var t=d(v?e:n,void 0),r=v?new w(n):new w;return void 0!==t&&o(r,"message",t),f&&o(r,"stack",h(r.stack,2)),this&&i(k,this)&&u(r,this,j),arguments.length>y&&p(r,arguments[y]),r}));if(j.prototype=k,"Error"!==x?s?s(j,_):l(j,_,{name:!0}):m&&"stackTraceLimit"in w&&(c(j,w,"stackTraceLimit"),c(j,w,"prepareStackTrace")),l(j,w),!g)try{k.name!==x&&o(k,"name",x),k.constructor=j}catch(n){}return j}}},function(n,e,t){var r=t(1),a=String,o=TypeError;n.exports=function(n){if("object"==typeof n||r(n))return n;throw o("Can't set "+a(n)+" as a prototype")}},function(n,e,t){var r=t(15).f;n.exports=function(n,e,t){t in n||r(n,t,{configurable:!0,get:function(){return e[t]},set:function(n){e[t]=n}})}},function(n,e,t){var r=t(1),a=t(9),o=t(64);n.exports=function(n,e,t){var i,s;return o&&r(i=e.constructor)&&i!==t&&a(s=i.prototype)&&s!==t.prototype&&o(n,s),n}},function(n,e,t){var r=t(127);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:r(n)}},function(n,e,t){var r=t(128),a=String;n.exports=function(n){if("Symbol"===r(n))throw TypeError("Cannot convert a Symbol value to a string");return a(n)}},function(n,e,t){var r=t(129),a=t(1),o=t(30),i=t(27)("toStringTag"),s=Object,l="Arguments"==o(function(){return arguments}());n.exports=r?o:function(n){var e,t,r;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=s(n),i))?t:l?o(e):"Object"==(r=o(e))&&a(e.callee)?"Arguments":r}},function(n,e,t){var r={};r[t(27)("toStringTag")]="z",n.exports="[object z]"===String(r)},function(n,e,t){var r=t(9),a=t(17);n.exports=function(n,e){r(e)&&"cause"in e&&a(n,"cause",e.cause)}},function(n,e,t){var r=t(2),a=Error,o=r("".replace),i=String(a("zxcasd").stack),s=/\n\s*at [^:]*:[^\n]*/,l=s.test(i);n.exports=function(n,e){if(l&&"string"==typeof n&&!a.prepareStackTrace)for(;e--;)n=o(n,s,"");return n}},function(n,e,t){var r=t(4),a=t(29);n.exports=!r((function(){var n=Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",a(1,7)),7!==n.stack)}))},function(n,e,t){var r=t(65),a=t(134);n.exports=function n(e,t,o,i,s){var l=-1,c=e.length;for(o||(o=a),s||(s=[]);++l<c;){var u=e[l];t>0&&o(u)?t>1?n(u,t-1,o,i,s):r(s,u):i||(s[s.length]=u)}return s}},function(n,e,t){var r=t(13),a=t(33),o=t(5),i=r?r.isConcatSpreadable:void 0;n.exports=function(n){return o(n)||a(n)||!!(i&&n&&n[i])}},function(n,e,t){var r=t(12),a=t(11);n.exports=function(n){return a(n)&&"[object Arguments]"==r(n)}},function(n,e,t){var r=t(13),a=Object.prototype,o=a.hasOwnProperty,i=a.toString,s=r?r.toStringTag:void 0;n.exports=function(n){var e=o.call(n,s),t=n[s];try{n[s]=void 0;var r=!0}catch(n){}var a=i.call(n);return r&&(e?n[s]=t:delete n[s]),a}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var r=t(139),a=t(195),o=t(41),i=t(5),s=t(206);n.exports=function(n){return"function"==typeof n?n:null==n?o:"object"==typeof n?i(n)?a(n[0],n[1]):r(n):s(n)}},function(n,e,t){var r=t(140),a=t(194),o=t(82);n.exports=function(n){var e=a(n);return 1==e.length&&e[0][2]?o(e[0][0],e[0][1]):function(t){return t===n||r(t,n,e)}}},function(n,e,t){var r=t(67),a=t(71);n.exports=function(n,e,t,o){var i=t.length,s=i,l=!o;if(null==n)return!s;for(n=Object(n);i--;){var c=t[i];if(l&&c[2]?c[1]!==n[c[0]]:!(c[0]in n))return!1}for(;++i<s;){var u=(c=t[i])[0],d=n[u],p=c[1];if(l&&c[2]){if(void 0===d&&!(u in n))return!1}else{var h=new r;if(o)var f=o(d,p,u,n,e,h);if(!(void 0===f?a(p,d,3,o,h):f))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var r=t(19),a=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=r(e,n);return!(t<0)&&(t==e.length-1?e.pop():a.call(e,t,1),--this.size,!0)}},function(n,e,t){var r=t(19);n.exports=function(n){var e=this.__data__,t=r(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var r=t(19);n.exports=function(n){return r(this.__data__,n)>-1}},function(n,e,t){var r=t(19);n.exports=function(n,e){var t=this.__data__,a=r(t,n);return a<0?(++this.size,t.push([n,e])):t[a][1]=e,this}},function(n,e,t){var r=t(18);n.exports=function(){this.__data__=new r,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var r=t(18),a=t(34),o=t(36);n.exports=function(n,e){var t=this.__data__;if(t instanceof r){var i=t.__data__;if(!a||i.length<199)return i.push([n,e]),this.size=++t.size,this;t=this.__data__=new o(i)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var r=t(69),a=t(152),o=t(35),i=t(70),s=/^\[object .+?Constructor\]$/,l=Function.prototype,c=Object.prototype,u=l.toString,d=c.hasOwnProperty,p=RegExp("^"+u.call(d).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!o(n)||a(n))&&(r(n)?p:s).test(i(n))}},function(n,e,t){var r,a=t(153),o=(r=/[^.]+$/.exec(a&&a.keys&&a.keys.IE_PROTO||""))?"Symbol(src)_1."+r:"";n.exports=function(n){return!!o&&o in n}},function(n,e,t){var r=t(6)["__core-js_shared__"];n.exports=r},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var r=t(156),a=t(18),o=t(34);n.exports=function(){this.size=0,this.__data__={hash:new r,map:new(o||a),string:new r}}},function(n,e,t){var r=t(157),a=t(158),o=t(159),i=t(160),s=t(161);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=a,l.prototype.get=o,l.prototype.has=i,l.prototype.set=s,n.exports=l},function(n,e,t){var r=t(20);n.exports=function(){this.__data__=r?r(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var r=t(20),a=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(r){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return a.call(e,n)?e[n]:void 0}},function(n,e,t){var r=t(20),a=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return r?void 0!==e[n]:a.call(e,n)}},function(n,e,t){var r=t(20);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=r&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var r=t(21);n.exports=function(n){var e=r(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var r=t(21);n.exports=function(n){return r(this,n).get(n)}},function(n,e,t){var r=t(21);n.exports=function(n){return r(this,n).has(n)}},function(n,e,t){var r=t(21);n.exports=function(n,e){var t=r(this,n),a=t.size;return t.set(n,e),this.size+=t.size==a?0:1,this}},function(n,e,t){var r=t(67),a=t(72),o=t(171),i=t(174),s=t(190),l=t(5),c=t(76),u=t(78),d="[object Object]",p=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,h,f,m){var g=l(n),v=l(e),y=g?"[object Array]":s(n),b=v?"[object Array]":s(e),x=(y="[object Arguments]"==y?d:y)==d,w=(b="[object Arguments]"==b?d:b)==d,k=y==b;if(k&&c(n)){if(!c(e))return!1;g=!0,x=!1}if(k&&!x)return m||(m=new r),g||u(n)?a(n,e,t,h,f,m):o(n,e,y,t,h,f,m);if(!(1&t)){var _=x&&p.call(n,"__wrapped__"),j=w&&p.call(e,"__wrapped__");if(_||j){var S=_?n.value():n,N=j?e.value():e;return m||(m=new r),f(S,N,t,h,m)}}return!!k&&(m||(m=new r),i(n,e,t,h,f,m))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length;++t<r;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var r=t(13),a=t(172),o=t(68),i=t(72),s=t(173),l=t(37),c=r?r.prototype:void 0,u=c?c.valueOf:void 0;n.exports=function(n,e,t,r,c,d,p){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!d(new a(n),new a(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return o(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var h=s;case"[object Set]":var f=1&r;if(h||(h=l),n.size!=e.size&&!f)return!1;var m=p.get(n);if(m)return m==e;r|=2,p.set(n,e);var g=i(h(n),h(e),r,c,d,p);return p.delete(n),g;case"[object Symbol]":if(u)return u.call(n)==u.call(e)}return!1}},function(n,e,t){var r=t(6).Uint8Array;n.exports=r},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,r){t[++e]=[r,n]})),t}},function(n,e,t){var r=t(175),a=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,o,i,s){var l=1&t,c=r(n),u=c.length;if(u!=r(e).length&&!l)return!1;for(var d=u;d--;){var p=c[d];if(!(l?p in e:a.call(e,p)))return!1}var h=s.get(n),f=s.get(e);if(h&&f)return h==e&&f==n;var m=!0;s.set(n,e),s.set(e,n);for(var g=l;++d<u;){var v=n[p=c[d]],y=e[p];if(o)var b=l?o(y,v,p,e,n,s):o(v,y,p,n,e,s);if(!(void 0===b?v===y||i(v,y,t,o,s):b)){m=!1;break}g||(g="constructor"==p)}if(m&&!g){var x=n.constructor,w=e.constructor;x==w||!("constructor"in n)||!("constructor"in e)||"function"==typeof x&&x instanceof x&&"function"==typeof w&&w instanceof w||(m=!1)}return s.delete(n),s.delete(e),m}},function(n,e,t){var r=t(176),a=t(177),o=t(75);n.exports=function(n){return r(n,o,a)}},function(n,e,t){var r=t(65),a=t(5);n.exports=function(n,e,t){var o=e(n);return a(n)?o:r(o,t(n))}},function(n,e,t){var r=t(178),a=t(179),o=Object.prototype.propertyIsEnumerable,i=Object.getOwnPropertySymbols,s=i?function(n){return null==n?[]:(n=Object(n),r(i(n),(function(e){return o.call(n,e)})))}:a;n.exports=s},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,a=0,o=[];++t<r;){var i=n[t];e(i,t,n)&&(o[a++]=i)}return o}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var r=t(181),a=t(33),o=t(5),i=t(76),s=t(77),l=t(78),c=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=o(n),u=!t&&a(n),d=!t&&!u&&i(n),p=!t&&!u&&!d&&l(n),h=t||u||d||p,f=h?r(n.length,String):[],m=f.length;for(var g in n)!e&&!c.call(n,g)||h&&("length"==g||d&&("offset"==g||"parent"==g)||p&&("buffer"==g||"byteLength"==g||"byteOffset"==g)||s(g,m))||f.push(g);return f}},function(n,e){n.exports=function(n,e){for(var t=-1,r=Array(n);++t<n;)r[t]=e(t);return r}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var r=t(12),a=t(38),o=t(11),i={};i["[object Float32Array]"]=i["[object Float64Array]"]=i["[object Int8Array]"]=i["[object Int16Array]"]=i["[object Int32Array]"]=i["[object Uint8Array]"]=i["[object Uint8ClampedArray]"]=i["[object Uint16Array]"]=i["[object Uint32Array]"]=!0,i["[object Arguments]"]=i["[object Array]"]=i["[object ArrayBuffer]"]=i["[object Boolean]"]=i["[object DataView]"]=i["[object Date]"]=i["[object Error]"]=i["[object Function]"]=i["[object Map]"]=i["[object Number]"]=i["[object Object]"]=i["[object RegExp]"]=i["[object Set]"]=i["[object String]"]=i["[object WeakMap]"]=!1,n.exports=function(n){return o(n)&&a(n.length)&&!!i[r(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var r=t(66),a=e&&!e.nodeType&&e,o=a&&"object"==typeof n&&n&&!n.nodeType&&n,i=o&&o.exports===a&&r.process,s=function(){try{var n=o&&o.require&&o.require("util").types;return n||i&&i.binding&&i.binding("util")}catch(n){}}();n.exports=s}).call(this,t(48)(n))},function(n,e,t){var r=t(187),a=t(188),o=Object.prototype.hasOwnProperty;n.exports=function(n){if(!r(n))return a(n);var e=[];for(var t in Object(n))o.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var r=t(189)(Object.keys,Object);n.exports=r},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var r=t(191),a=t(34),o=t(192),i=t(80),s=t(193),l=t(12),c=t(70),u=c(r),d=c(a),p=c(o),h=c(i),f=c(s),m=l;(r&&"[object DataView]"!=m(new r(new ArrayBuffer(1)))||a&&"[object Map]"!=m(new a)||o&&"[object Promise]"!=m(o.resolve())||i&&"[object Set]"!=m(new i)||s&&"[object WeakMap]"!=m(new s))&&(m=function(n){var e=l(n),t="[object Object]"==e?n.constructor:void 0,r=t?c(t):"";if(r)switch(r){case u:return"[object DataView]";case d:return"[object Map]";case p:return"[object Promise]";case h:return"[object Set]";case f:return"[object WeakMap]"}return e}),n.exports=m},function(n,e,t){var r=t(10)(t(6),"DataView");n.exports=r},function(n,e,t){var r=t(10)(t(6),"Promise");n.exports=r},function(n,e,t){var r=t(10)(t(6),"WeakMap");n.exports=r},function(n,e,t){var r=t(81),a=t(75);n.exports=function(n){for(var e=a(n),t=e.length;t--;){var o=e[t],i=n[o];e[t]=[o,i,r(i)]}return e}},function(n,e,t){var r=t(71),a=t(196),o=t(203),i=t(39),s=t(81),l=t(82),c=t(22);n.exports=function(n,e){return i(n)&&s(e)?l(c(n),e):function(t){var i=a(t,n);return void 0===i&&i===e?o(t,n):r(e,i,3)}}},function(n,e,t){var r=t(83);n.exports=function(n,e,t){var a=null==n?void 0:r(n,e);return void 0===a?t:a}},function(n,e,t){var r=t(198),a=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,o=/\\(\\)?/g,i=r((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(a,(function(n,t,r,a){e.push(r?a.replace(o,"$1"):t||n)})),e}));n.exports=i},function(n,e,t){var r=t(199);n.exports=function(n){var e=r(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var r=t(36);function a(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var r=arguments,a=e?e.apply(this,r):r[0],o=t.cache;if(o.has(a))return o.get(a);var i=n.apply(this,r);return t.cache=o.set(a,i)||o,i};return t.cache=new(a.Cache||r),t}a.Cache=r,n.exports=a},function(n,e,t){var r=t(201);n.exports=function(n){return null==n?"":r(n)}},function(n,e,t){var r=t(13),a=t(202),o=t(5),i=t(40),s=r?r.prototype:void 0,l=s?s.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(o(e))return a(e,n)+"";if(i(e))return l?l.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,a=Array(r);++t<r;)a[t]=e(n[t],t,n);return a}},function(n,e,t){var r=t(204),a=t(205);n.exports=function(n,e){return null!=n&&a(n,e,r)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var r=t(84),a=t(33),o=t(5),i=t(77),s=t(38),l=t(22);n.exports=function(n,e,t){for(var c=-1,u=(e=r(e,n)).length,d=!1;++c<u;){var p=l(e[c]);if(!(d=null!=n&&t(n,p)))break;n=n[p]}return d||++c!=u?d:!!(u=null==n?0:n.length)&&s(u)&&i(p,u)&&(o(n)||a(n))}},function(n,e,t){var r=t(207),a=t(208),o=t(39),i=t(22);n.exports=function(n){return o(n)?r(i(n)):a(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var r=t(83);n.exports=function(n){return function(e){return r(e,n)}}},function(n,e,t){var r=t(41),a=t(210),o=t(212);n.exports=function(n,e){return o(a(n,e,r),n+"")}},function(n,e,t){var r=t(211),a=Math.max;n.exports=function(n,e,t){return e=a(void 0===e?n.length-1:e,0),function(){for(var o=arguments,i=-1,s=a(o.length-e,0),l=Array(s);++i<s;)l[i]=o[e+i];i=-1;for(var c=Array(e+1);++i<e;)c[i]=o[i];return c[e]=t(l),r(n,this,c)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var r=t(213),a=t(216)(r);n.exports=a},function(n,e,t){var r=t(214),a=t(215),o=t(41),i=a?function(n,e){return a(n,"toString",{configurable:!0,enumerable:!1,value:r(e),writable:!0})}:o;n.exports=i},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var r=t(10),a=function(){try{var n=r(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=a},function(n,e){var t=Date.now;n.exports=function(n){var e=0,r=0;return function(){var a=t(),o=16-(a-r);if(r=a,o>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var r=t(73),a=t(218),o=t(223),i=t(74),s=t(224),l=t(37);n.exports=function(n,e,t){var c=-1,u=a,d=n.length,p=!0,h=[],f=h;if(t)p=!1,u=o;else if(d>=200){var m=e?null:s(n);if(m)return l(m);p=!1,u=i,f=new r}else f=e?[]:h;n:for(;++c<d;){var g=n[c],v=e?e(g):g;if(g=t||0!==g?g:0,p&&v==v){for(var y=f.length;y--;)if(f[y]===v)continue n;e&&f.push(v),h.push(g)}else u(f,v,t)||(f!==h&&f.push(v),h.push(g))}return h}},function(n,e,t){var r=t(219);n.exports=function(n,e){return!!(null==n?0:n.length)&&r(n,e,0)>-1}},function(n,e,t){var r=t(220),a=t(221),o=t(222);n.exports=function(n,e,t){return e==e?o(n,e,t):r(n,a,t)}},function(n,e){n.exports=function(n,e,t,r){for(var a=n.length,o=t+(r?1:-1);r?o--:++o<a;)if(e(n[o],o,n))return o;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var r=t-1,a=n.length;++r<a;)if(n[r]===e)return r;return-1}},function(n,e){n.exports=function(n,e,t){for(var r=-1,a=null==n?0:n.length;++r<a;)if(t(e,n[r]))return!0;return!1}},function(n,e,t){var r=t(80),a=t(225),o=t(37),i=r&&1/o(new r([,-0]))[1]==1/0?function(n){return new r(n)}:a;n.exports=i},function(n,e){n.exports=function(){}},function(n,e,t){var r=t(79),a=t(11);n.exports=function(n){return a(n)&&r(n)}},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(85)},function(n,e,t){"use strict";t(86)},function(n,e,t){"use strict";t.r(e);var r=t(0);
/*!
  * vue-router v3.5.4
  * (c) 2022 Evan You
  * @license MIT
  */function a(n,e){for(var t in e)n[t]=e[t];return n}var o=/[!'()*]/g,i=function(n){return"%"+n.charCodeAt(0).toString(16)},s=/%2C/g,l=function(n){return encodeURIComponent(n).replace(o,i).replace(s,",")};function c(n){try{return decodeURIComponent(n)}catch(n){0}return n}var u=function(n){return null==n||"object"==typeof n?n:String(n)};function d(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),r=c(t.shift()),a=t.length>0?c(t.join("=")):null;void 0===e[r]?e[r]=a:Array.isArray(e[r])?e[r].push(a):e[r]=[e[r],a]})),e):e}function p(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return l(e);if(Array.isArray(t)){var r=[];return t.forEach((function(n){void 0!==n&&(null===n?r.push(l(e)):r.push(l(e)+"="+l(n)))})),r.join("&")}return l(e)+"="+l(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var h=/\/?$/;function f(n,e,t,r){var a=r&&r.options.stringifyQuery,o=e.query||{};try{o=m(o)}catch(n){}var i={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:o,params:e.params||{},fullPath:y(e,a),matched:n?v(n):[]};return t&&(i.redirectedFrom=y(t,a)),Object.freeze(i)}function m(n){if(Array.isArray(n))return n.map(m);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=m(n[t]);return e}return n}var g=f(null,{path:"/"});function v(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function y(n,e){var t=n.path,r=n.query;void 0===r&&(r={});var a=n.hash;return void 0===a&&(a=""),(t||"/")+(e||p)(r)+a}function b(n,e,t){return e===g?n===e:!!e&&(n.path&&e.path?n.path.replace(h,"")===e.path.replace(h,"")&&(t||n.hash===e.hash&&x(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&x(n.query,e.query)&&x(n.params,e.params))))}function x(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),r=Object.keys(e).sort();return t.length===r.length&&t.every((function(t,a){var o=n[t];if(r[a]!==t)return!1;var i=e[t];return null==o||null==i?o===i:"object"==typeof o&&"object"==typeof i?x(o,i):String(o)===String(i)}))}function w(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var r in t.instances){var a=t.instances[r],o=t.enteredCbs[r];if(a&&o){delete t.enteredCbs[r];for(var i=0;i<o.length;i++)a._isBeingDestroyed||o[i](a)}}}}var k={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,r=e.children,o=e.parent,i=e.data;i.routerView=!0;for(var s=o.$createElement,l=t.name,c=o.$route,u=o._routerViewCache||(o._routerViewCache={}),d=0,p=!1;o&&o._routerRoot!==o;){var h=o.$vnode?o.$vnode.data:{};h.routerView&&d++,h.keepAlive&&o._directInactive&&o._inactive&&(p=!0),o=o.$parent}if(i.routerViewDepth=d,p){var f=u[l],m=f&&f.component;return m?(f.configProps&&_(m,i,f.route,f.configProps),s(m,i,r)):s()}var g=c.matched[d],v=g&&g.components[l];if(!g||!v)return u[l]=null,s();u[l]={component:v},i.registerRouteInstance=function(n,e){var t=g.instances[l];(e&&t!==n||!e&&t===n)&&(g.instances[l]=e)},(i.hook||(i.hook={})).prepatch=function(n,e){g.instances[l]=e.componentInstance},i.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==g.instances[l]&&(g.instances[l]=n.componentInstance),w(c)};var y=g.props&&g.props[l];return y&&(a(u[l],{route:c,configProps:y}),_(v,i,c,y)),s(v,i,r)}};function _(n,e,t,r){var o=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,r);if(o){o=e.props=a({},o);var i=e.attrs=e.attrs||{};for(var s in o)n.props&&s in n.props||(i[s]=o[s],delete o[s])}}function j(n,e,t){var r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;var a=e.split("/");t&&a[a.length-1]||a.pop();for(var o=n.replace(/^\//,"").split("/"),i=0;i<o.length;i++){var s=o[i];".."===s?a.pop():"."!==s&&a.push(s)}return""!==a[0]&&a.unshift(""),a.join("/")}function S(n){return n.replace(/\/(?:\s*\/)+/g,"/")}var N=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},P=$,T=z,C=function(n,e){return L(z(n,e),e)},I=L,A=F,E=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function z(n,e){for(var t,r=[],a=0,o=0,i="",s=e&&e.delimiter||"/";null!=(t=E.exec(n));){var l=t[0],c=t[1],u=t.index;if(i+=n.slice(o,u),o=u+l.length,c)i+=c[1];else{var d=n[o],p=t[2],h=t[3],f=t[4],m=t[5],g=t[6],v=t[7];i&&(r.push(i),i="");var y=null!=p&&null!=d&&d!==p,b="+"===g||"*"===g,x="?"===g||"*"===g,w=t[2]||s,k=f||m;r.push({name:h||a++,prefix:p||"",delimiter:w,optional:x,repeat:b,partial:y,asterisk:!!v,pattern:k?D(k):v?".*":"[^"+M(w)+"]+?"})}}return o<n.length&&(i+=n.substr(o)),i&&r.push(i),r}function O(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function L(n,e){for(var t=new Array(n.length),r=0;r<n.length;r++)"object"==typeof n[r]&&(t[r]=new RegExp("^(?:"+n[r].pattern+")$",q(e)));return function(e,r){for(var a="",o=e||{},i=(r||{}).pretty?O:encodeURIComponent,s=0;s<n.length;s++){var l=n[s];if("string"!=typeof l){var c,u=o[l.name];if(null==u){if(l.optional){l.partial&&(a+=l.prefix);continue}throw new TypeError('Expected "'+l.name+'" to be defined')}if(N(u)){if(!l.repeat)throw new TypeError('Expected "'+l.name+'" to not repeat, but received `'+JSON.stringify(u)+"`");if(0===u.length){if(l.optional)continue;throw new TypeError('Expected "'+l.name+'" to not be empty')}for(var d=0;d<u.length;d++){if(c=i(u[d]),!t[s].test(c))throw new TypeError('Expected all "'+l.name+'" to match "'+l.pattern+'", but received `'+JSON.stringify(c)+"`");a+=(0===d?l.prefix:l.delimiter)+c}}else{if(c=l.asterisk?encodeURI(u).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):i(u),!t[s].test(c))throw new TypeError('Expected "'+l.name+'" to match "'+l.pattern+'", but received "'+c+'"');a+=l.prefix+c}}else a+=l}return a}}function M(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function D(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function R(n,e){return n.keys=e,n}function q(n){return n&&n.sensitive?"":"i"}function F(n,e,t){N(e)||(t=e||t,e=[]);for(var r=(t=t||{}).strict,a=!1!==t.end,o="",i=0;i<n.length;i++){var s=n[i];if("string"==typeof s)o+=M(s);else{var l=M(s.prefix),c="(?:"+s.pattern+")";e.push(s),s.repeat&&(c+="(?:"+l+c+")*"),o+=c=s.optional?s.partial?l+"("+c+")?":"(?:"+l+"("+c+"))?":l+"("+c+")"}}var u=M(t.delimiter||"/"),d=o.slice(-u.length)===u;return r||(o=(d?o.slice(0,-u.length):o)+"(?:"+u+"(?=$))?"),o+=a?"$":r&&d?"":"(?="+u+"|$)",R(new RegExp("^"+o,q(t)),e)}function $(n,e,t){return N(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var r=0;r<t.length;r++)e.push({name:r,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return R(n,e)}(n,e):N(n)?function(n,e,t){for(var r=[],a=0;a<n.length;a++)r.push($(n[a],e,t).source);return R(new RegExp("(?:"+r.join("|")+")",q(t)),e)}(n,e,t):function(n,e,t){return F(z(n,t),e,t)}(n,e,t)}P.parse=T,P.compile=C,P.tokensToFunction=I,P.tokensToRegExp=A;var V=Object.create(null);function B(n,e,t){e=e||{};try{var r=V[n]||(V[n]=P.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),r(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function H(n,e,t,r){var o="string"==typeof n?{path:n}:n;if(o._normalized)return o;if(o.name){var i=(o=a({},n)).params;return i&&"object"==typeof i&&(o.params=a({},i)),o}if(!o.path&&o.params&&e){(o=a({},o))._normalized=!0;var s=a(a({},e.params),o.params);if(e.name)o.name=e.name,o.params=s;else if(e.matched.length){var l=e.matched[e.matched.length-1].path;o.path=B(l,s,e.path)}else 0;return o}var c=function(n){var e="",t="",r=n.indexOf("#");r>=0&&(e=n.slice(r),n=n.slice(0,r));var a=n.indexOf("?");return a>=0&&(t=n.slice(a+1),n=n.slice(0,a)),{path:n,query:t,hash:e}}(o.path||""),p=e&&e.path||"/",h=c.path?j(c.path,p,t||o.append):p,f=function(n,e,t){void 0===e&&(e={});var r,a=t||d;try{r=a(n||"")}catch(n){r={}}for(var o in e){var i=e[o];r[o]=Array.isArray(i)?i.map(u):u(i)}return r}(c.query,o.query,r&&r.options.parseQuery),m=o.hash||c.hash;return m&&"#"!==m.charAt(0)&&(m="#"+m),{_normalized:!0,path:h,query:f,hash:m}}var U,G=function(){},K={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,r=this.$route,o=t.resolve(this.to,r,this.append),i=o.location,s=o.route,l=o.href,c={},u=t.options.linkActiveClass,d=t.options.linkExactActiveClass,p=null==u?"router-link-active":u,m=null==d?"router-link-exact-active":d,g=null==this.activeClass?p:this.activeClass,v=null==this.exactActiveClass?m:this.exactActiveClass,y=s.redirectedFrom?f(null,H(s.redirectedFrom),null,t):s;c[v]=b(r,y,this.exactPath),c[g]=this.exact||this.exactPath?c[v]:function(n,e){return 0===n.path.replace(h,"/").indexOf(e.path.replace(h,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(r,y);var x=c[v]?this.ariaCurrentValue:null,w=function(n){J(n)&&(e.replace?t.replace(i,G):t.push(i,G))},k={click:J};Array.isArray(this.event)?this.event.forEach((function(n){k[n]=w})):k[this.event]=w;var _={class:c},j=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:l,route:s,navigate:w,isActive:c[g],isExactActive:c[v]});if(j){if(1===j.length)return j[0];if(j.length>1||!j.length)return 0===j.length?n():n("span",{},j)}if("a"===this.tag)_.on=k,_.attrs={href:l,"aria-current":x};else{var S=function n(e){var t;if(e)for(var r=0;r<e.length;r++){if("a"===(t=e[r]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(S){S.isStatic=!1;var N=S.data=a({},S.data);for(var P in N.on=N.on||{},N.on){var T=N.on[P];P in k&&(N.on[P]=Array.isArray(T)?T:[T])}for(var C in k)C in N.on?N.on[C].push(k[C]):N.on[C]=w;var I=S.data.attrs=a({},S.data.attrs);I.href=l,I["aria-current"]=x}else _.on=k}return n(this.tag,_,this.$slots.default)}};function J(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var W="undefined"!=typeof window;function Q(n,e,t,r,a){var o=e||[],i=t||Object.create(null),s=r||Object.create(null);n.forEach((function(n){!function n(e,t,r,a,o,i){var s=a.path,l=a.name;0;var c=a.pathToRegexpOptions||{},u=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return S(e.path+"/"+n)}(s,o,c.strict);"boolean"==typeof a.caseSensitive&&(c.sensitive=a.caseSensitive);var d={path:u,regex:Y(u,c),components:a.components||{default:a.component},alias:a.alias?"string"==typeof a.alias?[a.alias]:a.alias:[],instances:{},enteredCbs:{},name:l,parent:o,matchAs:i,redirect:a.redirect,beforeEnter:a.beforeEnter,meta:a.meta||{},props:null==a.props?{}:a.components?a.props:{default:a.props}};a.children&&a.children.forEach((function(a){var o=i?S(i+"/"+a.path):void 0;n(e,t,r,a,d,o)}));t[d.path]||(e.push(d.path),t[d.path]=d);if(void 0!==a.alias)for(var p=Array.isArray(a.alias)?a.alias:[a.alias],h=0;h<p.length;++h){0;var f={path:p[h],children:a.children};n(e,t,r,f,o,d.path||"/")}l&&(r[l]||(r[l]=d))}(o,i,s,n,a)}));for(var l=0,c=o.length;l<c;l++)"*"===o[l]&&(o.push(o.splice(l,1)[0]),c--,l--);return{pathList:o,pathMap:i,nameMap:s}}function Y(n,e){return P(n,[],e)}function X(n,e){var t=Q(n),r=t.pathList,a=t.pathMap,o=t.nameMap;function i(n,t,i){var s=H(n,t,!1,e),c=s.name;if(c){var u=o[c];if(!u)return l(null,s);var d=u.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof s.params&&(s.params={}),t&&"object"==typeof t.params)for(var p in t.params)!(p in s.params)&&d.indexOf(p)>-1&&(s.params[p]=t.params[p]);return s.path=B(u.path,s.params),l(u,s,i)}if(s.path){s.params={};for(var h=0;h<r.length;h++){var f=r[h],m=a[f];if(Z(m.regex,s.path,s.params))return l(m,s,i)}}return l(null,s)}function s(n,t){var r=n.redirect,a="function"==typeof r?r(f(n,t,null,e)):r;if("string"==typeof a&&(a={path:a}),!a||"object"!=typeof a)return l(null,t);var s=a,c=s.name,u=s.path,d=t.query,p=t.hash,h=t.params;if(d=s.hasOwnProperty("query")?s.query:d,p=s.hasOwnProperty("hash")?s.hash:p,h=s.hasOwnProperty("params")?s.params:h,c){o[c];return i({_normalized:!0,name:c,query:d,hash:p,params:h},void 0,t)}if(u){var m=function(n,e){return j(n,e.parent?e.parent.path:"/",!0)}(u,n);return i({_normalized:!0,path:B(m,h),query:d,hash:p},void 0,t)}return l(null,t)}function l(n,t,r){return n&&n.redirect?s(n,r||t):n&&n.matchAs?function(n,e,t){var r=i({_normalized:!0,path:B(t,e.params)});if(r){var a=r.matched,o=a[a.length-1];return e.params=r.params,l(o,e)}return l(null,e)}(0,t,n.matchAs):f(n,t,r,e)}return{match:i,addRoute:function(n,e){var t="object"!=typeof n?o[n]:void 0;Q([e||n],r,a,o,t),t&&t.alias.length&&Q(t.alias.map((function(n){return{path:n,children:[e]}})),r,a,o,t)},getRoutes:function(){return r.map((function(n){return a[n]}))},addRoutes:function(n){Q(n,r,a,o)}}}function Z(n,e,t){var r=e.match(n);if(!r)return!1;if(!t)return!0;for(var a=1,o=r.length;a<o;++a){var i=n.keys[a-1];i&&(t[i.name||"pathMatch"]="string"==typeof r[a]?c(r[a]):r[a])}return!0}var nn=W&&window.performance&&window.performance.now?window.performance:Date;function en(){return nn.now().toFixed(3)}var tn=en();function rn(){return tn}function an(n){return tn=n}var on=Object.create(null);function sn(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=a({},window.history.state);return t.key=rn(),window.history.replaceState(t,"",e),window.addEventListener("popstate",un),function(){window.removeEventListener("popstate",un)}}function ln(n,e,t,r){if(n.app){var a=n.options.scrollBehavior;a&&n.app.$nextTick((function(){var o=function(){var n=rn();if(n)return on[n]}(),i=a.call(n,e,t,r?o:null);i&&("function"==typeof i.then?i.then((function(n){mn(n,o)})).catch((function(n){0})):mn(i,o))}))}}function cn(){var n=rn();n&&(on[n]={x:window.pageXOffset,y:window.pageYOffset})}function un(n){cn(),n.state&&n.state.key&&an(n.state.key)}function dn(n){return hn(n.x)||hn(n.y)}function pn(n){return{x:hn(n.x)?n.x:window.pageXOffset,y:hn(n.y)?n.y:window.pageYOffset}}function hn(n){return"number"==typeof n}var fn=/^#\d/;function mn(n,e){var t,r="object"==typeof n;if(r&&"string"==typeof n.selector){var a=fn.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(a){var o=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),r=n.getBoundingClientRect();return{x:r.left-t.left-e.x,y:r.top-t.top-e.y}}(a,o={x:hn((t=o).x)?t.x:0,y:hn(t.y)?t.y:0})}else dn(n)&&(e=pn(n))}else r&&dn(n)&&(e=pn(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var gn,vn=W&&((-1===(gn=window.navigator.userAgent).indexOf("Android 2.")&&-1===gn.indexOf("Android 4.0")||-1===gn.indexOf("Mobile Safari")||-1!==gn.indexOf("Chrome")||-1!==gn.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function yn(n,e){cn();var t=window.history;try{if(e){var r=a({},t.state);r.key=rn(),t.replaceState(r,"",n)}else t.pushState({key:an(en())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function bn(n){yn(n,!0)}function xn(n,e,t){var r=function(a){a>=n.length?t():n[a]?e(n[a],(function(){r(a+1)})):r(a+1)};r(0)}var wn={redirected:2,aborted:4,cancelled:8,duplicated:16};function kn(n,e){return jn(n,e,wn.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return Sn.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function _n(n,e){return jn(n,e,wn.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function jn(n,e,t,r){var a=new Error(r);return a._isRouter=!0,a.from=n,a.to=e,a.type=t,a}var Sn=["params","query","hash"];function Nn(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function Pn(n,e){return Nn(n)&&n._isRouter&&(null==e||n.type===e)}function Tn(n){return function(e,t,r){var a=!1,o=0,i=null;Cn(n,(function(n,e,t,s){if("function"==typeof n&&void 0===n.cid){a=!0,o++;var l,c=En((function(e){var a;((a=e).__esModule||An&&"Module"===a[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:U.extend(e),t.components[s]=e,--o<=0&&r()})),u=En((function(n){var e="Failed to resolve async component "+s+": "+n;i||(i=Nn(n)?n:new Error(e),r(i))}));try{l=n(c,u)}catch(n){u(n)}if(l)if("function"==typeof l.then)l.then(c,u);else{var d=l.component;d&&"function"==typeof d.then&&d.then(c,u)}}})),a||r()}}function Cn(n,e){return In(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function In(n){return Array.prototype.concat.apply([],n)}var An="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function En(n){var e=!1;return function(){for(var t=[],r=arguments.length;r--;)t[r]=arguments[r];if(!e)return e=!0,n.apply(this,t)}}var zn=function(n,e){this.router=n,this.base=function(n){if(!n)if(W){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=g,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function On(n,e,t,r){var a=Cn(n,(function(n,r,a,o){var i=function(n,e){"function"!=typeof n&&(n=U.extend(n));return n.options[e]}(n,e);if(i)return Array.isArray(i)?i.map((function(n){return t(n,r,a,o)})):t(i,r,a,o)}));return In(r?a.reverse():a)}function Ln(n,e){if(e)return function(){return n.apply(e,arguments)}}zn.prototype.listen=function(n){this.cb=n},zn.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},zn.prototype.onError=function(n){this.errorCbs.push(n)},zn.prototype.transitionTo=function(n,e,t){var r,a=this;try{r=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var o=this.current;this.confirmTransition(r,(function(){a.updateRoute(r),e&&e(r),a.ensureURL(),a.router.afterHooks.forEach((function(n){n&&n(r,o)})),a.ready||(a.ready=!0,a.readyCbs.forEach((function(n){n(r)})))}),(function(n){t&&t(n),n&&!a.ready&&(Pn(n,wn.redirected)&&o===g||(a.ready=!0,a.readyErrorCbs.forEach((function(e){e(n)}))))}))},zn.prototype.confirmTransition=function(n,e,t){var r=this,a=this.current;this.pending=n;var o,i,s=function(n){!Pn(n)&&Nn(n)&&(r.errorCbs.length?r.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},l=n.matched.length-1,c=a.matched.length-1;if(b(n,a)&&l===c&&n.matched[l]===a.matched[c])return this.ensureURL(),n.hash&&ln(this.router,a,n,!1),s(((i=jn(o=a,n,wn.duplicated,'Avoided redundant navigation to current location: "'+o.fullPath+'".')).name="NavigationDuplicated",i));var u=function(n,e){var t,r=Math.max(n.length,e.length);for(t=0;t<r&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),d=u.updated,p=u.deactivated,h=u.activated,f=[].concat(function(n){return On(n,"beforeRouteLeave",Ln,!0)}(p),this.router.beforeHooks,function(n){return On(n,"beforeRouteUpdate",Ln)}(d),h.map((function(n){return n.beforeEnter})),Tn(h)),m=function(e,t){if(r.pending!==n)return s(_n(a,n));try{e(n,a,(function(e){!1===e?(r.ensureURL(!0),s(function(n,e){return jn(n,e,wn.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(a,n))):Nn(e)?(r.ensureURL(!0),s(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(s(kn(a,n)),"object"==typeof e&&e.replace?r.replace(e):r.push(e)):t(e)}))}catch(n){s(n)}};xn(f,m,(function(){xn(function(n){return On(n,"beforeRouteEnter",(function(n,e,t,r){return function(n,e,t){return function(r,a,o){return n(r,a,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),o(n)}))}}(n,t,r)}))}(h).concat(r.router.resolveHooks),m,(function(){if(r.pending!==n)return s(_n(a,n));r.pending=null,e(n),r.router.app&&r.router.app.$nextTick((function(){w(n)}))}))}))},zn.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},zn.prototype.setupListeners=function(){},zn.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=g,this.pending=null};var Mn=function(n){function e(e,t){n.call(this,e,t),this._startLocation=Dn(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,r=vn&&t;r&&this.listeners.push(sn());var a=function(){var t=n.current,a=Dn(n.base);n.current===g&&a===n._startLocation||n.transitionTo(a,(function(n){r&&ln(e,n,t,!0)}))};window.addEventListener("popstate",a),this.listeners.push((function(){window.removeEventListener("popstate",a)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){yn(S(r.base+n.fullPath)),ln(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){bn(S(r.base+n.fullPath)),ln(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(Dn(this.base)!==this.current.fullPath){var e=S(this.base+this.current.fullPath);n?yn(e):bn(e)}},e.prototype.getCurrentLocation=function(){return Dn(this.base)},e}(zn);function Dn(n){var e=window.location.pathname,t=e.toLowerCase(),r=n.toLowerCase();return!n||t!==r&&0!==t.indexOf(S(r+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var Rn=function(n){function e(e,t,r){n.call(this,e,t),r&&function(n){var e=Dn(n);if(!/^\/#/.test(e))return window.location.replace(S(n+"/#"+e)),!0}(this.base)||qn()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=vn&&e;t&&this.listeners.push(sn());var r=function(){var e=n.current;qn()&&n.transitionTo(Fn(),(function(r){t&&ln(n.router,r,e,!0),vn||Bn(r.fullPath)}))},a=vn?"popstate":"hashchange";window.addEventListener(a,r),this.listeners.push((function(){window.removeEventListener(a,r)}))}},e.prototype.push=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){Vn(n.fullPath),ln(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){Bn(n.fullPath),ln(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;Fn()!==e&&(n?Vn(e):Bn(e))},e.prototype.getCurrentLocation=function(){return Fn()},e}(zn);function qn(){var n=Fn();return"/"===n.charAt(0)||(Bn("/"+n),!1)}function Fn(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function $n(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function Vn(n){vn?yn($n(n)):window.location.hash=n}function Bn(n){vn?bn($n(n)):window.location.replace($n(n))}var Hn=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index+1).concat(n),r.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var r=this.stack[t];this.confirmTransition(r,(function(){var n=e.current;e.index=t,e.updateRoute(r),e.router.afterHooks.forEach((function(e){e&&e(r,n)}))}),(function(n){Pn(n,wn.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(zn),Un=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=X(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!vn&&!1!==n.fallback,this.fallback&&(e="hash"),W||(e="abstract"),this.mode=e,e){case"history":this.history=new Mn(this,n.base);break;case"hash":this.history=new Rn(this,n.base,this.fallback);break;case"abstract":this.history=new Hn(this,n.base);break;default:0}},Gn={currentRoute:{configurable:!0}};function Kn(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}Un.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},Gn.currentRoute.get=function(){return this.history&&this.history.current},Un.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof Mn||t instanceof Rn){var r=function(n){t.setupListeners(),function(n){var r=t.current,a=e.options.scrollBehavior;vn&&a&&"fullPath"in n&&ln(e,n,r,!1)}(n)};t.transitionTo(t.getCurrentLocation(),r,r)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},Un.prototype.beforeEach=function(n){return Kn(this.beforeHooks,n)},Un.prototype.beforeResolve=function(n){return Kn(this.resolveHooks,n)},Un.prototype.afterEach=function(n){return Kn(this.afterHooks,n)},Un.prototype.onReady=function(n,e){this.history.onReady(n,e)},Un.prototype.onError=function(n){this.history.onError(n)},Un.prototype.push=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.push(n,e,t)}));this.history.push(n,e,t)},Un.prototype.replace=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.replace(n,e,t)}));this.history.replace(n,e,t)},Un.prototype.go=function(n){this.history.go(n)},Un.prototype.back=function(){this.go(-1)},Un.prototype.forward=function(){this.go(1)},Un.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},Un.prototype.resolve=function(n,e,t){var r=H(n,e=e||this.history.current,t,this),a=this.match(r,e),o=a.redirectedFrom||a.fullPath;return{location:r,route:a,href:function(n,e,t){var r="hash"===t?"#"+e:e;return n?S(n+"/"+r):r}(this.history.base,o,this.mode),normalizedTo:r,resolved:a}},Un.prototype.getRoutes=function(){return this.matcher.getRoutes()},Un.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==g&&this.history.transitionTo(this.history.getCurrentLocation())},Un.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==g&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(Un.prototype,Gn),Un.install=function n(e){if(!n.installed||U!==e){n.installed=!0,U=e;var t=function(n){return void 0!==n},r=function(n,e){var r=n.$options._parentVnode;t(r)&&t(r=r.data)&&t(r=r.registerRouteInstance)&&r(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,r(this,this)},destroyed:function(){r(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",k),e.component("RouterLink",K);var a=e.config.optionMergeStrategies;a.beforeRouteEnter=a.beforeRouteLeave=a.beforeRouteUpdate=a.created}},Un.version="3.5.4",Un.isNavigationFailure=Pn,Un.NavigationFailureType=wn,Un.START_LOCATION=g,W&&window.Vue&&window.Vue.use(Un);var Jn=Un;t(98);t(95);var Wn={NotFound:()=>t.e(13).then(t.bind(null,316)),Layout:()=>Promise.all([t.e(0),t.e(2)]).then(t.bind(null,314))},Qn={"v-3ad4456b":()=>t.e(14).then(t.bind(null,321)),"v-79ce3195":()=>t.e(15).then(t.bind(null,322)),"v-0bddd3a4":()=>t.e(91).then(t.bind(null,323)),"v-07d34d7a":()=>t.e(16).then(t.bind(null,324)),"v-1c6e3f95":()=>t.e(17).then(t.bind(null,325)),"v-9751b882":()=>t.e(18).then(t.bind(null,326)),"v-a65f4076":()=>t.e(19).then(t.bind(null,327)),"v-41a4fc5e":()=>t.e(20).then(t.bind(null,328)),"v-76a57669":()=>t.e(21).then(t.bind(null,329)),"v-217dde16":()=>t.e(22).then(t.bind(null,330)),"v-e036e756":()=>t.e(23).then(t.bind(null,331)),"v-9139b18a":()=>t.e(24).then(t.bind(null,332)),"v-49904405":()=>t.e(25).then(t.bind(null,333)),"v-649ccb56":()=>t.e(26).then(t.bind(null,334)),"v-2ef6a612":()=>t.e(27).then(t.bind(null,335)),"v-3b24155e":()=>t.e(28).then(t.bind(null,336)),"v-7f8a6bd5":()=>t.e(30).then(t.bind(null,337)),"v-57159cad":()=>t.e(31).then(t.bind(null,338)),"v-65084bb4":()=>t.e(29).then(t.bind(null,339)),"v-c99dd316":()=>t.e(32).then(t.bind(null,340)),"v-f3c1e4e2":()=>t.e(33).then(t.bind(null,341)),"v-7af007f5":()=>t.e(34).then(t.bind(null,342)),"v-03d8873b":()=>t.e(35).then(t.bind(null,343)),"v-23be0695":()=>t.e(36).then(t.bind(null,344)),"v-ea677b16":()=>t.e(37).then(t.bind(null,345)),"v-42bdb895":()=>t.e(38).then(t.bind(null,346)),"v-bbc4fa82":()=>t.e(39).then(t.bind(null,347)),"v-79b9b1d7":()=>t.e(40).then(t.bind(null,348)),"v-45875829":()=>t.e(41).then(t.bind(null,349)),"v-390e2f26":()=>t.e(42).then(t.bind(null,350)),"v-bb0e9124":()=>t.e(45).then(t.bind(null,351)),"v-162bf415":()=>t.e(43).then(t.bind(null,352)),"v-6e866b56":()=>t.e(46).then(t.bind(null,353)),"v-1696c5b5":()=>t.e(47).then(t.bind(null,354)),"v-ce31282e":()=>t.e(44).then(t.bind(null,355)),"v-0e9221d6":()=>t.e(48).then(t.bind(null,356)),"v-1a0d3835":()=>t.e(50).then(t.bind(null,357)),"v-1fd34c35":()=>t.e(49).then(t.bind(null,358)),"v-f36ef296":()=>t.e(51).then(t.bind(null,359)),"v-3feaf1d5":()=>t.e(52).then(t.bind(null,360)),"v-5428026a":()=>t.e(53).then(t.bind(null,361)),"v-21516316":()=>t.e(54).then(t.bind(null,362)),"v-495d0d29":()=>t.e(55).then(t.bind(null,363)),"v-78408355":()=>t.e(56).then(t.bind(null,364)),"v-0f60c256":()=>t.e(57).then(t.bind(null,365)),"v-02a48cf5":()=>t.e(58).then(t.bind(null,366)),"v-0171d335":()=>t.e(59).then(t.bind(null,367)),"v-3a2914f5":()=>t.e(60).then(t.bind(null,368)),"v-0352edef":()=>t.e(62).then(t.bind(null,369)),"v-f3313c56":()=>t.e(61).then(t.bind(null,370)),"v-f5497496":()=>t.e(63).then(t.bind(null,371)),"v-23d56c5b":()=>t.e(64).then(t.bind(null,372)),"v-a66e355c":()=>t.e(65).then(t.bind(null,373)),"v-aaa51dc2":()=>t.e(66).then(t.bind(null,374)),"v-785b8656":()=>t.e(67).then(t.bind(null,375)),"v-4ff83756":()=>t.e(70).then(t.bind(null,376)),"v-20aeabe7":()=>t.e(71).then(t.bind(null,377)),"v-56edd5c6":()=>t.e(68).then(t.bind(null,378)),"v-d039a31a":()=>t.e(69).then(t.bind(null,379)),"v-e73b2872":()=>t.e(72).then(t.bind(null,380)),"v-0d51cfe9":()=>t.e(73).then(t.bind(null,381)),"v-73b8d232":()=>t.e(74).then(t.bind(null,382)),"v-3a2a67dc":()=>t.e(75).then(t.bind(null,383)),"v-1690bca1":()=>t.e(77).then(t.bind(null,384)),"v-5659b1b5":()=>t.e(78).then(t.bind(null,385)),"v-2b5eefb2":()=>t.e(79).then(t.bind(null,386)),"v-04c70155":()=>t.e(76).then(t.bind(null,387)),"v-57365d1b":()=>t.e(80).then(t.bind(null,388)),"v-ebee5d56":()=>t.e(81).then(t.bind(null,389)),"v-475cd856":()=>t.e(82).then(t.bind(null,390)),"v-2264f0f6":()=>t.e(83).then(t.bind(null,391)),"v-404f375b":()=>t.e(84).then(t.bind(null,392)),"v-6ed9ba4a":()=>t.e(85).then(t.bind(null,393)),"v-19a2deaa":()=>t.e(89).then(t.bind(null,394)),"v-f4d886fc":()=>t.e(86).then(t.bind(null,395)),"v-c218caaa":()=>t.e(88).then(t.bind(null,396)),"v-3e081066":()=>t.e(87).then(t.bind(null,397)),"v-e18b4c64":()=>t.e(90).then(t.bind(null,398)),"v-c0792b56":()=>t.e(92).then(t.bind(null,399)),"v-fa7f0416":()=>t.e(93).then(t.bind(null,400)),"v-03ef4303":()=>t.e(94).then(t.bind(null,401)),"v-5ed5b2a2":()=>t.e(95).then(t.bind(null,402)),"v-a865930a":()=>t.e(96).then(t.bind(null,403)),"v-1ec4367d":()=>t.e(100).then(t.bind(null,404)),"v-f49eb2e6":()=>t.e(98).then(t.bind(null,405)),"v-b548d0fa":()=>t.e(97).then(t.bind(null,406)),"v-865a99d6":()=>t.e(99).then(t.bind(null,407)),"v-2006ac96":()=>t.e(103).then(t.bind(null,408)),"v-900bc0e2":()=>t.e(101).then(t.bind(null,409)),"v-099d0615":()=>t.e(102).then(t.bind(null,410)),"v-4b62e23a":()=>t.e(104).then(t.bind(null,411)),"v-5da62161":()=>t.e(105).then(t.bind(null,412)),"v-8d7c3a16":()=>t.e(107).then(t.bind(null,413)),"v-20439003":()=>t.e(110).then(t.bind(null,414)),"v-0f9649d6":()=>t.e(108).then(t.bind(null,415)),"v-26e99c3f":()=>t.e(109).then(t.bind(null,416)),"v-6852a215":()=>t.e(106).then(t.bind(null,417)),"v-a3a42c32":()=>t.e(113).then(t.bind(null,418)),"v-4cd85745":()=>t.e(111).then(t.bind(null,419)),"v-654cbf67":()=>t.e(114).then(t.bind(null,420)),"v-397682b5":()=>t.e(116).then(t.bind(null,421)),"v-4cfc62f5":()=>t.e(117).then(t.bind(null,422)),"v-aedfab56":()=>t.e(112).then(t.bind(null,423)),"v-f1681116":()=>t.e(119).then(t.bind(null,424)),"v-7625b92b":()=>t.e(121).then(t.bind(null,425)),"v-25066837":()=>t.e(115).then(t.bind(null,426)),"v-07d1a15a":()=>t.e(118).then(t.bind(null,427)),"v-4577a42b":()=>t.e(120).then(t.bind(null,428)),"v-7e8a4b55":()=>t.e(126).then(t.bind(null,429)),"v-49363b4b":()=>t.e(122).then(t.bind(null,430)),"v-2772ede1":()=>t.e(123).then(t.bind(null,431)),"v-5f78be15":()=>t.e(124).then(t.bind(null,432)),"v-482ede15":()=>t.e(125).then(t.bind(null,433)),"v-1eba418f":()=>t.e(127).then(t.bind(null,434)),"v-6a3acd75":()=>t.e(129).then(t.bind(null,435)),"v-778a4b06":()=>t.e(128).then(t.bind(null,436)),"v-20d19b16":()=>t.e(130).then(t.bind(null,437)),"v-2e578055":()=>t.e(131).then(t.bind(null,438)),"v-bfa91d62":()=>t.e(132).then(t.bind(null,439)),"v-321f0ff5":()=>t.e(134).then(t.bind(null,440)),"v-2ad68845":()=>t.e(133).then(t.bind(null,441)),"v-3c1db7b5":()=>t.e(138).then(t.bind(null,442)),"v-6a2ff5b5":()=>t.e(139).then(t.bind(null,443)),"v-f58eb5be":()=>t.e(136).then(t.bind(null,444)),"v-c740fce2":()=>t.e(135).then(t.bind(null,445)),"v-e2f77296":()=>t.e(137).then(t.bind(null,446)),"v-571ef5f5":()=>t.e(140).then(t.bind(null,447)),"v-31509cce":()=>t.e(141).then(t.bind(null,448)),"v-ef606112":()=>t.e(142).then(t.bind(null,449))};function Yn(n){const e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}const Xn=/-(\w)/g,Zn=Yn(n=>n.replace(Xn,(n,e)=>e?e.toUpperCase():"")),ne=/\B([A-Z])/g,ee=Yn(n=>n.replace(ne,"-$1").toLowerCase()),te=Yn(n=>n.charAt(0).toUpperCase()+n.slice(1));function re(n,e){if(!e)return;if(n(e))return n(e);return e.includes("-")?n(te(Zn(e))):n(te(e))||n(ee(e))}const ae=Object.assign({},Wn,Qn),oe=n=>ae[n],ie=n=>Qn[n],se=n=>Wn[n],le=n=>r.a.component(n);function ce(n){return re(ie,n)}function ue(n){return re(se,n)}function de(n){return re(oe,n)}function pe(n){return re(le,n)}function he(...n){return Promise.all(n.filter(n=>n).map(async n=>{if(!pe(n)&&de(n)){const e=await de(n)();r.a.component(n,e.default)}}))}function fe(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}var me=t(87),ge=t.n(me),ve=t(88),ye=t.n(ve),be={created(){if(this.siteMeta=this.$site.headTags.filter(([n])=>"meta"===n).map(([n,e])=>e),this.$ssrContext){const e=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(n=e)?n.map(n=>{let e="<meta";return Object.keys(n).forEach(t=>{e+=` ${t}="${ye()(n[t])}"`}),e+">"}).join("\n    "):"",this.$ssrContext.canonicalLink=we(this.$canonicalUrl)}var n},mounted(){this.currentMetaTags=[...document.querySelectorAll("meta")],this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta(){document.title=this.$title,document.documentElement.lang=this.$lang;const n=this.getMergedMetaTags();this.currentMetaTags=ke(n,this.currentMetaTags)},getMergedMetaTags(){const n=this.$page.frontmatter.meta||[];return ge()([{name:"description",content:this.$description}],n,this.siteMeta,_e)},updateCanonicalLink(){xe(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",we(this.$canonicalUrl))}},watch:{$page(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy(){ke(null,this.currentMetaTags),xe()}};function xe(){const n=document.querySelector("link[rel='canonical']");n&&n.remove()}function we(n=""){return n?`<link href="${n}" rel="canonical" />`:""}function ke(n,e){if(e&&[...e].filter(n=>n.parentNode===document.head).forEach(n=>document.head.removeChild(n)),n)return n.map(n=>{const e=document.createElement("meta");return Object.keys(n).forEach(t=>{e.setAttribute(t,n[t])}),document.head.appendChild(e),e})}function _e(n){for(const e of["name","property","itemprop"])if(n.hasOwnProperty(e))return n[e]+e;return JSON.stringify(n)}var je=t(89),Se={mounted(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(je)()((function(){this.setActiveHash()}),300),setActiveHash(){const n=[].slice.call(document.querySelectorAll(".sidebar-link")),e=[].slice.call(document.querySelectorAll(".header-anchor")).filter(e=>n.some(n=>n.hash===e.hash)),t=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),r=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),a=window.innerHeight+t;for(let n=0;n<e.length;n++){const o=e[n],i=e[n+1],s=0===n&&0===t||t>=o.parentElement.offsetTop+10&&(!i||t<i.parentElement.offsetTop-10),l=decodeURIComponent(this.$route.hash);if(s&&l!==decodeURIComponent(o.hash)){const t=o;if(a===r)for(let t=n+1;t<e.length;t++)if(l===decodeURIComponent(e[t].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(t.hash),()=>{this.$nextTick(()=>{this.$vuepress.$set("disableScrollBehavior",!1)})})}}}},beforeDestroy(){window.removeEventListener("scroll",this.onScroll)}},Ne=(t(227),{data:()=>({zoom:null}),mounted(){this.updateCopy()},updated(){this.updateCopy()},methods:{updateCopy(){setTimeout(()=>{document.querySelectorAll('div[class*="language-"]').forEach(this.generateCopyButton)},1e3)},generateCopyButton:function(n){if(n.classList.contains("codecopy-enabled"))return;const e=document.createElement("span");e.className="code-copy",e.title="Click to Copy to Clipboard",e.addEventListener("click",()=>{this.copyToClipboard(n.innerText),e.classList.add("copied");const t=setTimeout(()=>{e.classList.remove("copied"),clearTimeout(t)},2e3)}),n.appendChild(e),n.classList.add("codecopy-enabled")},copyToClipboard:function(n){const e=document.createElement("textarea");e.value=n,e.setAttribute("readonly",""),e.style.position="absolute",e.style.left="-9999px",document.body.appendChild(e);const t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);e.select(),document.execCommand("copy"),document.body.removeChild(e),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))}}}),Pe=t(23),Te=t.n(Pe),Ce=[be,Se,Ne,{mounted(){Te.a.configure({showSpinner:!1}),this.$router.beforeEach((n,e,t)=>{n.path===e.path||r.a.component(n.name)||Te.a.start(),t()}),this.$router.afterEach(()=>{Te.a.done(),this.isSidebarOpen=!1})}}],Ie={name:"GlobalLayout",computed:{layout(){const n=this.getLayout();return fe("layout",n),r.a.component(n)}},methods:{getLayout(){if(this.$page.path){const n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},Ae=t(14),Ee=Object(Ae.a)(Ie,(function(){return(0,this._self._c)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),n[e].push(...t);break;default:throw new Error("Unknown option name.")}}(Ee,"mixins",Ce);const ze=[{name:"v-3ad4456b",path:"/cloud-server.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-3ad4456b").then(t)}},{name:"v-79ce3195",path:"/command.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-79ce3195").then(t)}},{name:"v-0bddd3a4",path:"/",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-0bddd3a4").then(t)}},{path:"/index.html",redirect:"/"},{name:"v-07d34d7a",path:"/data-structure/graph/bfs.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-07d34d7a").then(t)}},{name:"v-1c6e3f95",path:"/data-structure/graph/desc.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-1c6e3f95").then(t)}},{name:"v-9751b882",path:"/data-structure/graph/dfs.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-9751b882").then(t)}},{name:"v-a65f4076",path:"/data-structure/graph/minimum-spanning-tree.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-a65f4076").then(t)}},{name:"v-41a4fc5e",path:"/data-structure/graph/shortest-path.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-41a4fc5e").then(t)}},{name:"v-76a57669",path:"/data-structure/graph/topology-sort.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-76a57669").then(t)}},{name:"v-217dde16",path:"/data-structure/hash/buildTree.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-217dde16").then(t)}},{name:"v-e036e756",path:"/data-structure/hash/deepClone.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-e036e756").then(t)}},{name:"v-9139b18a",path:"/data-structure/hash/desc.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-9139b18a").then(t)}},{name:"v-49904405",path:"/data-structure/hash/removeZero.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-49904405").then(t)}},{name:"v-649ccb56",path:"/data-structure/hash/sum.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-649ccb56").then(t)}},{name:"v-2ef6a612",path:"/data-structure/heap/desc.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-2ef6a612").then(t)}},{name:"v-3b24155e",path:"/data-structure/heap/topKFrequent.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-3b24155e").then(t)}},{name:"v-7f8a6bd5",path:"/data-structure/list/array.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-7f8a6bd5").then(t)}},{name:"v-57159cad",path:"/data-structure/list/doubleLinkedList.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-57159cad").then(t)}},{name:"v-65084bb4",path:"/data-structure/",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-65084bb4").then(t)}},{path:"/data-structure/index.html",redirect:"/data-structure/"},{name:"v-c99dd316",path:"/data-structure/list/lfu-cache.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-c99dd316").then(t)}},{name:"v-f3c1e4e2",path:"/data-structure/list/linkedList.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-f3c1e4e2").then(t)}},{name:"v-7af007f5",path:"/data-structure/list/lru-cache.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-7af007f5").then(t)}},{name:"v-03d8873b",path:"/data-structure/list/mergeArray.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-03d8873b").then(t)}},{name:"v-23be0695",path:"/data-structure/list/shuffle.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-23be0695").then(t)}},{name:"v-ea677b16",path:"/data-structure/queue/desc.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-ea677b16").then(t)}},{name:"v-42bdb895",path:"/data-structure/search/avlTree.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-42bdb895").then(t)}},{name:"v-bbc4fa82",path:"/data-structure/search/binarySearch.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-bbc4fa82").then(t)}},{name:"v-79b9b1d7",path:"/data-structure/search/skipList.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-79b9b1d7").then(t)}},{name:"v-45875829",path:"/data-structure/sort/bubbleSort.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-45875829").then(t)}},{name:"v-390e2f26",path:"/data-structure/sort/bucketSort.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-390e2f26").then(t)}},{name:"v-bb0e9124",path:"/data-structure/sort/",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-bb0e9124").then(t)}},{path:"/data-structure/sort/index.html",redirect:"/data-structure/sort/"},{name:"v-162bf415",path:"/data-structure/sort/compare.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-162bf415").then(t)}},{name:"v-6e866b56",path:"/data-structure/sort/insertionSort.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-6e866b56").then(t)}},{name:"v-1696c5b5",path:"/data-structure/sort/mergeSort.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-1696c5b5").then(t)}},{name:"v-ce31282e",path:"/data-structure/sort/heapSort.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-ce31282e").then(t)}},{name:"v-0e9221d6",path:"/data-structure/sort/quickSort.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-0e9221d6").then(t)}},{name:"v-1a0d3835",path:"/data-structure/sort/selectionSort.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-1a0d3835").then(t)}},{name:"v-1fd34c35",path:"/data-structure/sort/radixSort.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-1fd34c35").then(t)}},{name:"v-f36ef296",path:"/data-structure/sort/shellSort.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-f36ef296").then(t)}},{name:"v-3feaf1d5",path:"/data-structure/stack/desc.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-3feaf1d5").then(t)}},{name:"v-5428026a",path:"/data-structure/stack/dfs.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-5428026a").then(t)}},{name:"v-21516316",path:"/data-structure/stack/monotonous-stack.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-21516316").then(t)}},{name:"v-495d0d29",path:"/data-structure/stack/reverse.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-495d0d29").then(t)}},{name:"v-78408355",path:"/data-structure/stack/syntaxAnalysis.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-78408355").then(t)}},{name:"v-0f60c256",path:"/data-structure/string/KMP.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-0f60c256").then(t)}},{name:"v-02a48cf5",path:"/data-structure/tree/N-Tree/Trie.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-02a48cf5").then(t)}},{name:"v-0171d335",path:"/data-structure/tree/N-Tree/bfsVisit.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-0171d335").then(t)}},{name:"v-3a2914f5",path:"/data-structure/tree/N-Tree/dfsVisit.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-3a2914f5").then(t)}},{name:"v-0352edef",path:"/data-structure/tree/binaryTree/construct.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-0352edef").then(t)}},{name:"v-f3313c56",path:"/data-structure/tree/binarySearchTree/desc.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-f3313c56").then(t)}},{name:"v-f5497496",path:"/data-structure/tree/binaryTree/inOrderVisit.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-f5497496").then(t)}},{name:"v-23d56c5b",path:"/data-structure/tree/binaryTree/levelOrderVisit.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-23d56c5b").then(t)}},{name:"v-a66e355c",path:"/data-structure/tree/binaryTree/morrisVisit%20copy.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-a66e355c").then(t)}},{path:"/data-structure/tree/binaryTree/morrisVisit copy.html",redirect:"/data-structure/tree/binaryTree/morrisVisit%20copy.html"},{path:"/data-structure/tree/binaryTree/morrisVisit copy.html",redirect:"/data-structure/tree/binaryTree/morrisVisit%20copy.html"},{name:"v-aaa51dc2",path:"/data-structure/tree/binaryTree/morrisVisit.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-aaa51dc2").then(t)}},{name:"v-785b8656",path:"/data-structure/tree/binaryTree/postOrderVisit.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-785b8656").then(t)}},{name:"v-4ff83756",path:"/design-pattern/bridge.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-4ff83756").then(t)}},{name:"v-20aeabe7",path:"/design-pattern/command.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-20aeabe7").then(t)}},{name:"v-56edd5c6",path:"/data-structure/tree/binaryTree/preOrderVisit.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-56edd5c6").then(t)}},{name:"v-d039a31a",path:"/design-pattern/adaptor.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-d039a31a").then(t)}},{name:"v-e73b2872",path:"/design-pattern/decorator.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-e73b2872").then(t)}},{name:"v-0d51cfe9",path:"/design-pattern/factory.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-0d51cfe9").then(t)}},{name:"v-73b8d232",path:"/design-pattern/flyweight.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-73b8d232").then(t)}},{name:"v-3a2a67dc",path:"/design-pattern/",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-3a2a67dc").then(t)}},{path:"/design-pattern/index.html",redirect:"/design-pattern/"},{name:"v-1690bca1",path:"/design-pattern/proxy.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-1690bca1").then(t)}},{name:"v-5659b1b5",path:"/design-pattern/responsibility-chain.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-5659b1b5").then(t)}},{name:"v-2b5eefb2",path:"/design-pattern/singleton.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-2b5eefb2").then(t)}},{name:"v-04c70155",path:"/design-pattern/mediator.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-04c70155").then(t)}},{name:"v-57365d1b",path:"/design-pattern/state.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-57365d1b").then(t)}},{name:"v-ebee5d56",path:"/design-pattern/strategy.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-ebee5d56").then(t)}},{name:"v-475cd856",path:"/design-pattern/template-method.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-475cd856").then(t)}},{name:"v-2264f0f6",path:"/design-pattern/watcher.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-2264f0f6").then(t)}},{name:"v-404f375b",path:"/design-pattern/%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-404f375b").then(t)}},{path:"/design-pattern/依赖倒置原则.html",redirect:"/design-pattern/%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99.html"},{path:"/design-pattern/依赖倒置原则.html",redirect:"/design-pattern/%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99.html"},{name:"v-6ed9ba4a",path:"/design-pattern/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-6ed9ba4a").then(t)}},{path:"/design-pattern/开闭原则.html",redirect:"/design-pattern/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99.html"},{path:"/design-pattern/开闭原则.html",redirect:"/design-pattern/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99.html"},{name:"v-19a2deaa",path:"/frameworks/",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-19a2deaa").then(t)}},{path:"/frameworks/index.html",redirect:"/frameworks/"},{name:"v-f4d886fc",path:"/design-pattern/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-f4d886fc").then(t)}},{path:"/design-pattern/接口隔离原则.html",redirect:"/design-pattern/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99.html"},{path:"/design-pattern/接口隔离原则.html",redirect:"/design-pattern/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99.html"},{name:"v-c218caaa",path:"/design-pattern/%E9%87%8C%E6%B0%8F%E4%BB%A3%E6%8D%A2%E5%8E%9F%E5%88%99.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-c218caaa").then(t)}},{path:"/design-pattern/里氏代换原则.html",redirect:"/design-pattern/%E9%87%8C%E6%B0%8F%E4%BB%A3%E6%8D%A2%E5%8E%9F%E5%88%99.html"},{path:"/design-pattern/里氏代换原则.html",redirect:"/design-pattern/%E9%87%8C%E6%B0%8F%E4%BB%A3%E6%8D%A2%E5%8E%9F%E5%88%99.html"},{name:"v-3e081066",path:"/design-pattern/%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-3e081066").then(t)}},{path:"/design-pattern/迪米特法则.html",redirect:"/design-pattern/%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99.html"},{path:"/design-pattern/迪米特法则.html",redirect:"/design-pattern/%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99.html"},{name:"v-e18b4c64",path:"/guide/",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-e18b4c64").then(t)}},{path:"/guide/index.html",redirect:"/guide/"},{name:"v-c0792b56",path:"/javascript/RegExp.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-c0792b56").then(t)}},{name:"v-fa7f0416",path:"/javascript/ajax.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-fa7f0416").then(t)}},{name:"v-03ef4303",path:"/javascript/async-development-history.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-03ef4303").then(t)}},{name:"v-5ed5b2a2",path:"/javascript/closure.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-5ed5b2a2").then(t)}},{name:"v-a865930a",path:"/javascript/es6/async.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-a865930a").then(t)}},{name:"v-1ec4367d",path:"/javascript/es6/promise.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-1ec4367d").then(t)}},{name:"v-f49eb2e6",path:"/javascript/es6/generator.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-f49eb2e6").then(t)}},{name:"v-b548d0fa",path:"/javascript/es6/class.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-b548d0fa").then(t)}},{name:"v-865a99d6",path:"/javascript/es6/iterator.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-865a99d6").then(t)}},{name:"v-2006ac96",path:"/javascript/extend.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-2006ac96").then(t)}},{name:"v-900bc0e2",path:"/javascript/es6/spread-symbol.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-900bc0e2").then(t)}},{name:"v-099d0615",path:"/javascript/event-loop.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-099d0615").then(t)}},{name:"v-4b62e23a",path:"/javascript/",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-4b62e23a").then(t)}},{path:"/javascript/index.html",redirect:"/javascript/"},{name:"v-5da62161",path:"/javascript/prototype.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-5da62161").then(t)}},{name:"v-8d7c3a16",path:"/javascript/snippets/copy-into-clipboard.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-8d7c3a16").then(t)}},{name:"v-20439003",path:"/javascript/snippets/money-transfer.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-20439003").then(t)}},{name:"v-0f9649d6",path:"/javascript/snippets/date-format.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-0f9649d6").then(t)}},{name:"v-26e99c3f",path:"/javascript/snippets/lazyload.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-26e99c3f").then(t)}},{name:"v-6852a215",path:"/javascript/snippets/color-transform.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-6852a215").then(t)}},{name:"v-a3a42c32",path:"/javascript/snippets/safety-add.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-a3a42c32").then(t)}},{name:"v-4cd85745",path:"/javascript/snippets/repeatable-request.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-4cd85745").then(t)}},{name:"v-654cbf67",path:"/javascript/snippets/safety-getandset.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-654cbf67").then(t)}},{name:"v-397682b5",path:"/javascript/this.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-397682b5").then(t)}},{name:"v-4cfc62f5",path:"/javascript/write/JSON.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-4cfc62f5").then(t)}},{name:"v-aedfab56",path:"/javascript/snippets/reserve.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-aedfab56").then(t)}},{name:"v-f1681116",path:"/javascript/write/async-task-scheduler.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-f1681116").then(t)}},{name:"v-7625b92b",path:"/javascript/write/chunk.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-7625b92b").then(t)}},{name:"v-25066837",path:"/javascript/snippets/thousand.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-25066837").then(t)}},{name:"v-07d1a15a",path:"/javascript/write/array.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-07d1a15a").then(t)}},{name:"v-4577a42b",path:"/javascript/write/call&bind&apply.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-4577a42b").then(t)}},{name:"v-7e8a4b55",path:"/javascript/write/debounce.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-7e8a4b55").then(t)}},{name:"v-49363b4b",path:"/javascript/write/clone.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-49363b4b").then(t)}},{name:"v-2772ede1",path:"/javascript/write/compose.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-2772ede1").then(t)}},{name:"v-5f78be15",path:"/javascript/write/conversion-of-number-systems.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-5f78be15").then(t)}},{name:"v-482ede15",path:"/javascript/write/currying.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-482ede15").then(t)}},{name:"v-1eba418f",path:"/javascript/write/event-emitter.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-1eba418f").then(t)}},{name:"v-6a3acd75",path:"/javascript/write/instanceof.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-6a3acd75").then(t)}},{name:"v-778a4b06",path:"/javascript/write/flatten.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-778a4b06").then(t)}},{name:"v-20d19b16",path:"/javascript/write/jsonp.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-20d19b16").then(t)}},{name:"v-2e578055",path:"/javascript/write/lazy-man.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-2e578055").then(t)}},{name:"v-bfa91d62",path:"/javascript/write/map-and-set.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-bfa91d62").then(t)}},{name:"v-321f0ff5",path:"/javascript/write/parallel-pk-serial.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-321f0ff5").then(t)}},{name:"v-2ad68845",path:"/javascript/write/new.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-2ad68845").then(t)}},{name:"v-3c1db7b5",path:"/javascript/write/throttle.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-3c1db7b5").then(t)}},{name:"v-6a2ff5b5",path:"/javascript/write/trim.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-6a2ff5b5").then(t)}},{name:"v-f58eb5be",path:"/javascript/write/promisify.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-f58eb5be").then(t)}},{name:"v-c740fce2",path:"/javascript/write/promise.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-c740fce2").then(t)}},{name:"v-e2f77296",path:"/javascript/write/remove-duplicate.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-e2f77296").then(t)}},{name:"v-571ef5f5",path:"/mysql.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-571ef5f5").then(t)}},{name:"v-31509cce",path:"/others/",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-31509cce").then(t)}},{path:"/others/index.html",redirect:"/others/"},{name:"v-ef606112",path:"/others/interview.html",component:Ee,beforeEnter:(n,e,t)=>{he("Layout","v-ef606112").then(t)}},{path:"*",component:Ee}],Oe={title:"awesome-frontend-code",description:"HsuYang的个人博客，主要对于平时学习知识的理解与记录",base:"/",headTags:[["meta",{name:"referrer",content:"no-referrer-when-downgrade"}],["link",{rel:"icon",href:"/favicon.ico"}]],pages:[{title:"云服务器相关",frontmatter:{},regularPath:"/cloud-server.html",relativePath:"cloud-server.md",key:"v-3ad4456b",path:"/cloud-server.html",headersStr:null,content:"# 云服务器相关\n\n使用命令行登录\n\nssh [user]@[ip]\n\n\n使得服务器可以支持root账号登录，修改root账号登录\n\nUbuntu安装docker\n\ndocker ps [-a]\ndocker rmi [镜像ID]\ndocker pull [镜像源名称]\ndocker rm -f [容器实例]\ndocker build -t [TagName] [dir]\ndocker run -d -p [端口映射关系] [容器ID]\ndocker exec -it [容器实例，如gitlab] [内部的bin名称]\n\n\ndocker run -d --name yapi --restart=always --privileged=true -p 3000:3000 -e YAPI_ADMIN_ACCOUNT=admin@yangxu.com -e YAPI_ADMIN_PASSWORD=123456 -e YAPI_CLOSE_REGISTER=true -e YAPI_DB_SERVERNAME=1.12.243.15 -e YAPI_DB_PORT=27017 -e YAPI_DB_DATABASE=yapi -e YAPI_DB_USER=admin -e YAPI_DB_PASS=123456 -e YAPI_DB_AUTH_SOURCE=admin -e YAPI_MAIL_ENABLE=false -e YAPI_PLUGINS=[] jayfong/yapi\n\ndocker run -itd --name redis -p 6379:6379 redis\n\ndocker run -d -p 8443:443 -p 8090:80 -p 8022:22 --restart always --name gitlab -v /usr/local/gitlab/etc:/etc/gitlab -v /usr/local/gitlab/log:/var/log/gitlab -v /usr/local/gitlab/data:/var/opt/gitlab --privileged=true --platform linux/amd64 twang2218/gitlab-ce-zh\n\ndocker run --name nginx -p 8080:80 -d nginx",normalizedContent:"# 云服务器相关\n\n使用命令行登录\n\nssh [user]@[ip]\n\n\n使得服务器可以支持root账号登录，修改root账号登录\n\nubuntu安装docker\n\ndocker ps [-a]\ndocker rmi [镜像id]\ndocker pull [镜像源名称]\ndocker rm -f [容器实例]\ndocker build -t [tagname] [dir]\ndocker run -d -p [端口映射关系] [容器id]\ndocker exec -it [容器实例，如gitlab] [内部的bin名称]\n\n\ndocker run -d --name yapi --restart=always --privileged=true -p 3000:3000 -e yapi_admin_account=admin@yangxu.com -e yapi_admin_password=123456 -e yapi_close_register=true -e yapi_db_servername=1.12.243.15 -e yapi_db_port=27017 -e yapi_db_database=yapi -e yapi_db_user=admin -e yapi_db_pass=123456 -e yapi_db_auth_source=admin -e yapi_mail_enable=false -e yapi_plugins=[] jayfong/yapi\n\ndocker run -itd --name redis -p 6379:6379 redis\n\ndocker run -d -p 8443:443 -p 8090:80 -p 8022:22 --restart always --name gitlab -v /usr/local/gitlab/etc:/etc/gitlab -v /usr/local/gitlab/log:/var/log/gitlab -v /usr/local/gitlab/data:/var/opt/gitlab --privileged=true --platform linux/amd64 twang2218/gitlab-ce-zh\n\ndocker run --name nginx -p 8080:80 -d nginx",charsets:{cjk:!0}},{title:"常用的Linux命令",frontmatter:{},regularPath:"/command.html",relativePath:"command.md",key:"v-79ce3195",path:"/command.html",headers:[{level:2,title:"常用的Linux命令",slug:"常用的linux命令",normalizedTitle:"常用的linux命令",charIndex:2},{level:3,title:"文件管理",slug:"文件管理",normalizedTitle:"文件管理",charIndex:154},{level:3,title:"文档编辑",slug:"文档编辑",normalizedTitle:"文档编辑",charIndex:166},{level:3,title:"文件传输",slug:"文件传输",normalizedTitle:"文件传输",charIndex:178}],headersStr:"常用的Linux命令 文件管理 文档编辑 文件传输",content:"# 常用的Linux命令\n\npwd\n# 获取当前目录\nwhereis\n# 获取程序的安装目录 whereis git\nwhatis\n# 获取某个命令的使用方法 whatis whereis\nls\n# 展示当前文件下面的所有文件夹 参数：-a所有文件  -l展示详细信息 -h 以人类可读的形式展示\n\n\n\n# 文件管理\n\n\n\n\n\n# 文档编辑\n\n\n\n\n\n# 文件传输\n\n\n",normalizedContent:"# 常用的linux命令\n\npwd\n# 获取当前目录\nwhereis\n# 获取程序的安装目录 whereis git\nwhatis\n# 获取某个命令的使用方法 whatis whereis\nls\n# 展示当前文件下面的所有文件夹 参数：-a所有文件  -l展示详细信息 -h 以人类可读的形式展示\n\n\n\n# 文件管理\n\n\n\n\n\n# 文档编辑\n\n\n\n\n\n# 文件传输\n\n\n",charsets:{cjk:!0}},{title:"Home",frontmatter:{home:!0,actionText:"开始阅读",actionLink:"/guide/",features:[{title:"数据结构专题",details:"常见数据结构和算法（树、图、数组、堆、栈，队列）的基本使用以及典型题目分析。"},{title:"设计模式专题",details:"常见的设计模式基于 JavaScript 的实现。"},{title:"JavaScript API 专题",details:"JavaScript常见的一些核心概念以及部分API的手写实现。"},{title:"杂项专题",details:"常见的前端八股文等。"}]},regularPath:"/",relativePath:"index.md",key:"v-0bddd3a4",path:"/",headersStr:null,content:"awesome-frontend-code\n\n盘点前端常见的知识点总结\n\nReleased under the MIT License.\nCopyright © 2022 HsuYang",normalizedContent:"awesome-frontend-code\n\n盘点前端常见的知识点总结\n\nreleased under the mit license.\ncopyright © 2022 hsuyang",charsets:{cjk:!0}},{title:"广度优先搜索",frontmatter:{},regularPath:"/data-structure/graph/bfs.html",relativePath:"data-structure/graph/bfs.md",key:"v-07d34d7a",path:"/data-structure/graph/bfs.html",headers:[{level:2,title:"广度优先搜索",slug:"广度优先搜索",normalizedTitle:"广度优先搜索",charIndex:2},{level:3,title:"BFS 的标准范式",slug:"bfs-的标准范式",normalizedTitle:"bfs 的标准范式",charIndex:267},{level:3,title:"BFS 的应用",slug:"bfs-的应用",normalizedTitle:"bfs 的应用",charIndex:717}],headersStr:"广度优先搜索 BFS 的标准范式 BFS 的应用",content:'# 广度优先搜索\n\n广度优先搜索算法（Breadth-First Search，缩写为 BFS），又称为宽度优先搜索，是一种图形搜索算法。简单的说，BFS 是从根结点开始，沿着树的宽度遍历树的结点。如果所有结点均被访问，则算法中止。\n\n下图生动形象的为我们展示了BFS的处理流程。\n\n\n\n它总是一圈一圈的从内往外处理，每次都是一滴不漏的处理完每个角落，才会开始下一圈的处理。\n\n比如下图展示的就是一个使用 BFS 遍历二叉树的过程：\n\n\n\n由于本文和DFS有着非常强的关联，请各位读者在阅读之前，请确保已经阅读深度优先搜索。\n\n\n# BFS 的标准范式\n\nBFS，从一个给定的节点开始，每遍历一个节点，将当前节点标记为已遍历，并且将当前节点的未处理过的所有邻接节点加入队列中，若队列为空则遍历完成，若不为空，则从队列中再取出一个节点继续上述流程，直到遍历完成。\n\nfunction bfs(v, visited) {\n  // 将当前节点标记为已处理\n  visited[v] = true;\n  // 将当前节点入队\n  enqueue(v, Q);\n  // 当队列中存在元素\n  while (!isEmpty(Q)) {\n    // 从队列中取出一个节点\n    v = dequeue(v, Q);\n    for(v 的每个邻接点 W) {\n      // 若当前邻接点没有处理过，则将其标记为处理过，并且加入队列中去\n      if(!visited[W]) {\n        visited[W] = true;\n        enqueue(v, w);\n      }\n    }\n  }\n}\n\n\n\n# BFS 的应用\n\n一般来说，能够使用DFS进行处理的问题都可以使用BFS处理，我们还是以之前DFS节讨论过的问题为例，看看使用 BFS 的话，可以怎么样实现它。因为BFS是非递归的算法，如果在数据量比较大的时候，请考虑要非递归实现DFS或直接使用BFS。\n\n# 拍平数组（flat）\n\n假设有这样的数组： [1,[2,3,[[4]]],[5],[[[[[6],7,8]]],9], 10]，请将其展平为[1,2,3,4,5,6,7,8,9,10]。\n\n/**\n * 以广度优先的方式拍平数组\n * @param {any[]} arr\n */\nfunction flat(arr) {\n  const results = [];\n  // 将数据加入到队列中\n  const queue = [];\n  if (Array.isArray(arr)) {\n    queue.push(arr);\n  }\n  // 当队列内容不为空时，继续拍平数据\n  while (queue.length) {\n    // 从队列中取出一个元素，并且这个出队的一定是数组\n    const ele = queue.shift();\n    ele.forEach((subEle) => {\n      if (Array.isArray(subEle)) {\n        queue.push(subEle);\n      } else {\n        results.push(subEle);\n      }\n    });\n  }\n  return results.sort((a, b) => a - b);\n}\n\n\n为什么需要排序呢，因为在拍平的过程中，对于嵌套较深的元素，它的处理过程是滞后于不嵌套的元素的，比如先处理了 1，然后立马处理的是 10，所以 10 就跑到了 2,3 的前面去了。所以说，在根据实际情况，选择使用DFS或DFS，显然本例就不适合使用BFS。\n\n# 深拷贝对象\n\n使用广度优先深拷贝一个对象有个比较不容易想到的地方，就是对象的key，不同于像普通的树或图那样，你持有某个引用，你可以方便的使用curObj.xxx获取到它的邻接点。所以我经过思考后，每次入队的都是一对的源对象和被拷贝对象，这样就可以很方便的直接根据当前源对象进行遍历然后依次给拷贝对象添加属性了。\n\n注意，在此处我实现的深拷贝并没有完整考虑所有的情况，如果对深拷贝感兴趣的同学，请移步 lodash 的源码参考其实现。\n\n/**\n * 使用广度优先深拷贝一个对象\n * @param {Array<any> | object} obj\n * @returns\n */\nfunction deepClone(obj) {\n  // 根据目标对象确定拷贝是数组还是对象\n  let cloneObj = Array.isArray(obj) ? [] : {};\n  // 用一个map用以记住被拷贝过的内容\n  const map = new Map();\n  // 记住当前对象已经被拷贝过了\n  map.set(obj, cloneObj);\n  // 把原始内容和拷贝的内容追加到队列中去，准备开始以广度优先的方式进行深拷贝\n  const queue = [\n    {\n      source: obj,\n      clone: cloneObj,\n    },\n  ];\n  while (queue.length > 0) {\n    const { source, clone } = queue.shift();\n    for (let prop in source) {\n      if (source[prop] instanceof Object) {\n        // 如果已经拷贝过，则直接将内容复制到目标对象上去\n        if (map.get(source[prop])) {\n          clone[prop] = map.get(source[prop]);\n        } else {\n          // 把当前对象和拷贝的空对象加入到队列中去，准备后序的深拷贝\n          const nextClone = Array.isArray(source[prop]) ? [] : {};\n          queue.push({\n            source: source[prop],\n            clone: nextClone,\n          });\n          // 建立拷贝关系，本轮还是空内容（可以理解为拷贝一个容器），待下一轮循环才拷贝值\n          clone[prop] = nextClone;\n          // 将已经拷贝的内容加入到map中去，防止循环拷贝\n          map.set(source[prop], nextClone);\n        }\n      } else {\n        // 基本类型，可直接拷贝\n        clone[prop] = source[prop];\n      }\n    }\n  }\n  return cloneObj;\n}\n\n\n# 迷宫问题\n\n这是华为的一道机考题。\n\n定义一个二维数组 N*M ，如 5 × 5 数组下所示：\n\n[\n  [0, 1, 0, 0, 0],\n  [0, 1, 1, 1, 0],\n  [0, 0, 0, 0, 0],\n  [0, 1, 1, 1, 0],\n  [0, 0, 0, 1, 0],\n];\n\n\n它表示一个迷宫，其中的 1 表示墙壁，0 表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的路线。入口点为[0,0],既第一格是可以走的路。\n\n输入两个整数，分别表示二维数组的行数，列数。再输入相应的数组，其中的 1 表示墙壁，0 表示可以走的路。数据保证有唯一解,不考虑有多解的情况，即迷宫只有一条通道。\n\n/**\n * 以BFS的形式找迷宫的出口\n * @param {number[]} matrix\n */\nfunction findPath(matrix) {\n  const height = matrix.length;\n  const width = matrix[0].length;\n  // 定义一个队列\n  const queue = [];\n  // 定义一个标记数组\n  const maker = Array.from({\n    length: height,\n  }).map(() => {\n    return Array.from({\n      length: width,\n    }).fill(0);\n  });\n  // 先将开始节点加入到队列中去\n  queue.push({\n    x: 0,\n    y: 0,\n    path: [[0, 0]],\n  });\n  // 将起始节点标记为已处理\n  maker[0][0] = true;\n  let distPath = null;\n  while (queue.length) {\n    const { x, y, path } = queue.shift();\n    if (x === width - 1 && y === height - 1) {\n      distPath = path;\n    }\n    // 上边的点，存在且没有被访问过，并且不是障碍物\n    const topPoint =\n      isExist(matrix, x, y - 1) && !maker[y - 1][x] && matrix[y - 1][x] !== 1\n        ? { x, y: y - 1 }\n        : null;\n    if (topPoint) {\n      queue.push({\n        x: topPoint.x,\n        y: topPoint.y,\n        path: [...path, [topPoint.y, topPoint.x]],\n      });\n      maker[y - 1][x] = true;\n    }\n    // 右边的点，存在且没有被访问过，并且不是障碍物\n    const rightPoint =\n      isExist(matrix, x + 1, y) && !maker[y][x + 1] && matrix[y][x + 1] !== 1\n        ? { x: x + 1, y }\n        : null;\n    if (rightPoint) {\n      queue.push({\n        x: rightPoint.x,\n        y: rightPoint.y,\n        path: [...path, [rightPoint.y, rightPoint.x]],\n      });\n      maker[y][x + 1] = true;\n    }\n    // 下边的点，存在且没有被访问过，并且不是障碍物\n    const bottomPoint =\n      isExist(matrix, x, y + 1) && !maker[y + 1][x] && matrix[y + 1][x] !== 1\n        ? { x, y: y + 1 }\n        : null;\n    if (bottomPoint) {\n      queue.push({\n        x: bottomPoint.x,\n        y: bottomPoint.y,\n        path: [...path, [bottomPoint.y, bottomPoint.x]],\n      });\n      maker[y + 1][x] = true;\n    }\n    // 左边的点 存在且没有被访问过，并且不是障碍物\n    const leftPoint =\n      isExist(matrix, x - 1, y) && !maker[y][x - 1] && matrix[y][x - 1] !== 1\n        ? { x: x - 1, y }\n        : null;\n    if (leftPoint) {\n      queue.push({\n        x: leftPoint.x,\n        y: leftPoint.y,\n        path: [...path, [leftPoint.y, leftPoint.x]],\n      });\n      maker[y][x - 1] = true;\n    }\n  }\n  return distPath;\n}\n\n/**\n * 判断当前元素是否存在于迷宫中\n * @param {number[][]} matrix\n * @param {number} x\n * @param {number} y\n */\nfunction isExist(matrix, x, y) {\n  return Array.isArray(matrix[y]) && typeof matrix[y][x] !== "undefined";\n}\n\n\n使用BFS查找迷宫的出路有个问题，虽然我们在找路的时候比较方便，但是怎么把这个路径记录下来却是个问题。\n\n因此，我在上述搜索过程中把对应已经走过的 path 一并加入到了队列中，在取出节点进行判断的时候，可以很方便的知道之前走过的路径是怎么样的，但是问题就是这样会占用大量的内存空间，所以对于这个问题，我实现的BFS是不如DFS的，如果读者有更好的解法，欢迎提出，大家一起交流，把它完善的更美好，以传递更好的知识。\n\n在后来，我学习并理解了最短路径算法之后，发现可以有一个比较优雅的解法，其做法和无权图的最短路径求解手段类似，在求解过程中利用哈希表把当前节点和它对应的父节点记录下来，这样就可以从终点一直倒推到起点，再反序输出即可得到正序的路径。\n\n下面的实现相对于上面的实现占用的内存空间占用会小的多。\n\n/**\n * 以BFS的形式找迷宫的出口\n * @param {number[]} matrix\n */\nfunction findPath(matrix) {\n  const height = matrix.length;\n  const width = matrix[0].length;\n  /* 定义一个哈希表，用于记住经过的路径 */\n  const pathMap = new Map();\n  // 定义一个队列\n  const queue = [];\n  // 定义一个标记数组\n  const maker = Array.from({\n    length: height,\n  }).map(() => {\n    return Array.from({\n      length: width,\n    }).fill(0);\n  });\n  // 先将开始节点加入到队列中去\n  queue.push({\n    node: { x: 0, y: 0 },\n    /* 入口的父节点为空 */\n    parent: null,\n  });\n  // 将起始节点标记为已处理\n  maker[0][0] = true;\n  let distNode = null;\n  while (queue.length) {\n    const { node, parent } = queue.shift();\n    /* 将当前节点记录在到终点的路径上 */\n    pathMap.set(node, parent);\n    const { x, y } = node;\n    if (x === width - 1 && y === height - 1) {\n      distNode = node;\n      break;\n    }\n    // 上边的点，存在且没有被访问过，并且不是障碍物\n    const topPoint =\n      isExist(matrix, x, y - 1) && !maker[y - 1][x] && matrix[y - 1][x] !== 1\n        ? { x, y: y - 1 }\n        : null;\n    if (topPoint) {\n      queue.push({\n        node: topPoint,\n        parent: node,\n      });\n      maker[y - 1][x] = true;\n    }\n    // 右边的点，存在且没有被访问过，并且不是障碍物\n    const rightPoint =\n      isExist(matrix, x + 1, y) && !maker[y][x + 1] && matrix[y][x + 1] !== 1\n        ? { x: x + 1, y }\n        : null;\n    if (rightPoint) {\n      queue.push({\n        node: rightPoint,\n        parent: node,\n      });\n      maker[y][x + 1] = true;\n    }\n    // 下边的点，存在且没有被访问过，并且不是障碍物\n    const bottomPoint =\n      isExist(matrix, x, y + 1) && !maker[y + 1][x] && matrix[y + 1][x] !== 1\n        ? { x, y: y + 1 }\n        : null;\n    if (bottomPoint) {\n      queue.push({\n        node: bottomPoint,\n        parent: node,\n      });\n      maker[y + 1][x] = true;\n    }\n    // 左边的点 存在且没有被访问过，并且不是障碍物\n    const leftPoint =\n      isExist(matrix, x - 1, y) && !maker[y][x - 1] && matrix[y][x - 1] !== 1\n        ? { x: x - 1, y }\n        : null;\n    if (leftPoint) {\n      queue.push({\n        node: leftPoint,\n        parent: node,\n      });\n      maker[y][x - 1] = true;\n    }\n  }\n  /* 本来正常的做法是需要使用栈记录逆序的路径，但是我们直接利用JS的方法反向插入最终得到的即可是一个正序的路径，可以少一个循环 */\n  /* 注意不要把distNode记录掉了 */\n  const path = [distNode];\n  let parent = pathMap.get(distNode);\n  /* 直到找到入口节点，循环终止 */\n  while (parent) {\n    path.unshift(parent);\n    distNode = parent;\n    parent = pathMap.get(distNode);\n  }\n\n  return path.map((node) => {\n    return [node.x, node.y];\n  });\n}\n\n/**\n * 判断当前元素是否存在于迷宫中\n * @param {number[][]} matrix\n * @param {number} x\n * @param {number} y\n */\nfunction isExist(matrix, x, y) {\n  return Array.isArray(matrix[y]) && typeof matrix[y][x] !== "undefined";\n}\n\n\n关于 BFS 还有很多有趣的问题，我暂时就先为大家介绍这几种常见的用法，欢迎大家补充。',normalizedContent:'# 广度优先搜索\n\n广度优先搜索算法（breadth-first search，缩写为 bfs），又称为宽度优先搜索，是一种图形搜索算法。简单的说，bfs 是从根结点开始，沿着树的宽度遍历树的结点。如果所有结点均被访问，则算法中止。\n\n下图生动形象的为我们展示了bfs的处理流程。\n\n\n\n它总是一圈一圈的从内往外处理，每次都是一滴不漏的处理完每个角落，才会开始下一圈的处理。\n\n比如下图展示的就是一个使用 bfs 遍历二叉树的过程：\n\n\n\n由于本文和dfs有着非常强的关联，请各位读者在阅读之前，请确保已经阅读深度优先搜索。\n\n\n# bfs 的标准范式\n\nbfs，从一个给定的节点开始，每遍历一个节点，将当前节点标记为已遍历，并且将当前节点的未处理过的所有邻接节点加入队列中，若队列为空则遍历完成，若不为空，则从队列中再取出一个节点继续上述流程，直到遍历完成。\n\nfunction bfs(v, visited) {\n  // 将当前节点标记为已处理\n  visited[v] = true;\n  // 将当前节点入队\n  enqueue(v, q);\n  // 当队列中存在元素\n  while (!isempty(q)) {\n    // 从队列中取出一个节点\n    v = dequeue(v, q);\n    for(v 的每个邻接点 w) {\n      // 若当前邻接点没有处理过，则将其标记为处理过，并且加入队列中去\n      if(!visited[w]) {\n        visited[w] = true;\n        enqueue(v, w);\n      }\n    }\n  }\n}\n\n\n\n# bfs 的应用\n\n一般来说，能够使用dfs进行处理的问题都可以使用bfs处理，我们还是以之前dfs节讨论过的问题为例，看看使用 bfs 的话，可以怎么样实现它。因为bfs是非递归的算法，如果在数据量比较大的时候，请考虑要非递归实现dfs或直接使用bfs。\n\n# 拍平数组（flat）\n\n假设有这样的数组： [1,[2,3,[[4]]],[5],[[[[[6],7,8]]],9], 10]，请将其展平为[1,2,3,4,5,6,7,8,9,10]。\n\n/**\n * 以广度优先的方式拍平数组\n * @param {any[]} arr\n */\nfunction flat(arr) {\n  const results = [];\n  // 将数据加入到队列中\n  const queue = [];\n  if (array.isarray(arr)) {\n    queue.push(arr);\n  }\n  // 当队列内容不为空时，继续拍平数据\n  while (queue.length) {\n    // 从队列中取出一个元素，并且这个出队的一定是数组\n    const ele = queue.shift();\n    ele.foreach((subele) => {\n      if (array.isarray(subele)) {\n        queue.push(subele);\n      } else {\n        results.push(subele);\n      }\n    });\n  }\n  return results.sort((a, b) => a - b);\n}\n\n\n为什么需要排序呢，因为在拍平的过程中，对于嵌套较深的元素，它的处理过程是滞后于不嵌套的元素的，比如先处理了 1，然后立马处理的是 10，所以 10 就跑到了 2,3 的前面去了。所以说，在根据实际情况，选择使用dfs或dfs，显然本例就不适合使用bfs。\n\n# 深拷贝对象\n\n使用广度优先深拷贝一个对象有个比较不容易想到的地方，就是对象的key，不同于像普通的树或图那样，你持有某个引用，你可以方便的使用curobj.xxx获取到它的邻接点。所以我经过思考后，每次入队的都是一对的源对象和被拷贝对象，这样就可以很方便的直接根据当前源对象进行遍历然后依次给拷贝对象添加属性了。\n\n注意，在此处我实现的深拷贝并没有完整考虑所有的情况，如果对深拷贝感兴趣的同学，请移步 lodash 的源码参考其实现。\n\n/**\n * 使用广度优先深拷贝一个对象\n * @param {array<any> | object} obj\n * @returns\n */\nfunction deepclone(obj) {\n  // 根据目标对象确定拷贝是数组还是对象\n  let cloneobj = array.isarray(obj) ? [] : {};\n  // 用一个map用以记住被拷贝过的内容\n  const map = new map();\n  // 记住当前对象已经被拷贝过了\n  map.set(obj, cloneobj);\n  // 把原始内容和拷贝的内容追加到队列中去，准备开始以广度优先的方式进行深拷贝\n  const queue = [\n    {\n      source: obj,\n      clone: cloneobj,\n    },\n  ];\n  while (queue.length > 0) {\n    const { source, clone } = queue.shift();\n    for (let prop in source) {\n      if (source[prop] instanceof object) {\n        // 如果已经拷贝过，则直接将内容复制到目标对象上去\n        if (map.get(source[prop])) {\n          clone[prop] = map.get(source[prop]);\n        } else {\n          // 把当前对象和拷贝的空对象加入到队列中去，准备后序的深拷贝\n          const nextclone = array.isarray(source[prop]) ? [] : {};\n          queue.push({\n            source: source[prop],\n            clone: nextclone,\n          });\n          // 建立拷贝关系，本轮还是空内容（可以理解为拷贝一个容器），待下一轮循环才拷贝值\n          clone[prop] = nextclone;\n          // 将已经拷贝的内容加入到map中去，防止循环拷贝\n          map.set(source[prop], nextclone);\n        }\n      } else {\n        // 基本类型，可直接拷贝\n        clone[prop] = source[prop];\n      }\n    }\n  }\n  return cloneobj;\n}\n\n\n# 迷宫问题\n\n这是华为的一道机考题。\n\n定义一个二维数组 n*m ，如 5 × 5 数组下所示：\n\n[\n  [0, 1, 0, 0, 0],\n  [0, 1, 1, 1, 0],\n  [0, 0, 0, 0, 0],\n  [0, 1, 1, 1, 0],\n  [0, 0, 0, 1, 0],\n];\n\n\n它表示一个迷宫，其中的 1 表示墙壁，0 表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的路线。入口点为[0,0],既第一格是可以走的路。\n\n输入两个整数，分别表示二维数组的行数，列数。再输入相应的数组，其中的 1 表示墙壁，0 表示可以走的路。数据保证有唯一解,不考虑有多解的情况，即迷宫只有一条通道。\n\n/**\n * 以bfs的形式找迷宫的出口\n * @param {number[]} matrix\n */\nfunction findpath(matrix) {\n  const height = matrix.length;\n  const width = matrix[0].length;\n  // 定义一个队列\n  const queue = [];\n  // 定义一个标记数组\n  const maker = array.from({\n    length: height,\n  }).map(() => {\n    return array.from({\n      length: width,\n    }).fill(0);\n  });\n  // 先将开始节点加入到队列中去\n  queue.push({\n    x: 0,\n    y: 0,\n    path: [[0, 0]],\n  });\n  // 将起始节点标记为已处理\n  maker[0][0] = true;\n  let distpath = null;\n  while (queue.length) {\n    const { x, y, path } = queue.shift();\n    if (x === width - 1 && y === height - 1) {\n      distpath = path;\n    }\n    // 上边的点，存在且没有被访问过，并且不是障碍物\n    const toppoint =\n      isexist(matrix, x, y - 1) && !maker[y - 1][x] && matrix[y - 1][x] !== 1\n        ? { x, y: y - 1 }\n        : null;\n    if (toppoint) {\n      queue.push({\n        x: toppoint.x,\n        y: toppoint.y,\n        path: [...path, [toppoint.y, toppoint.x]],\n      });\n      maker[y - 1][x] = true;\n    }\n    // 右边的点，存在且没有被访问过，并且不是障碍物\n    const rightpoint =\n      isexist(matrix, x + 1, y) && !maker[y][x + 1] && matrix[y][x + 1] !== 1\n        ? { x: x + 1, y }\n        : null;\n    if (rightpoint) {\n      queue.push({\n        x: rightpoint.x,\n        y: rightpoint.y,\n        path: [...path, [rightpoint.y, rightpoint.x]],\n      });\n      maker[y][x + 1] = true;\n    }\n    // 下边的点，存在且没有被访问过，并且不是障碍物\n    const bottompoint =\n      isexist(matrix, x, y + 1) && !maker[y + 1][x] && matrix[y + 1][x] !== 1\n        ? { x, y: y + 1 }\n        : null;\n    if (bottompoint) {\n      queue.push({\n        x: bottompoint.x,\n        y: bottompoint.y,\n        path: [...path, [bottompoint.y, bottompoint.x]],\n      });\n      maker[y + 1][x] = true;\n    }\n    // 左边的点 存在且没有被访问过，并且不是障碍物\n    const leftpoint =\n      isexist(matrix, x - 1, y) && !maker[y][x - 1] && matrix[y][x - 1] !== 1\n        ? { x: x - 1, y }\n        : null;\n    if (leftpoint) {\n      queue.push({\n        x: leftpoint.x,\n        y: leftpoint.y,\n        path: [...path, [leftpoint.y, leftpoint.x]],\n      });\n      maker[y][x - 1] = true;\n    }\n  }\n  return distpath;\n}\n\n/**\n * 判断当前元素是否存在于迷宫中\n * @param {number[][]} matrix\n * @param {number} x\n * @param {number} y\n */\nfunction isexist(matrix, x, y) {\n  return array.isarray(matrix[y]) && typeof matrix[y][x] !== "undefined";\n}\n\n\n使用bfs查找迷宫的出路有个问题，虽然我们在找路的时候比较方便，但是怎么把这个路径记录下来却是个问题。\n\n因此，我在上述搜索过程中把对应已经走过的 path 一并加入到了队列中，在取出节点进行判断的时候，可以很方便的知道之前走过的路径是怎么样的，但是问题就是这样会占用大量的内存空间，所以对于这个问题，我实现的bfs是不如dfs的，如果读者有更好的解法，欢迎提出，大家一起交流，把它完善的更美好，以传递更好的知识。\n\n在后来，我学习并理解了最短路径算法之后，发现可以有一个比较优雅的解法，其做法和无权图的最短路径求解手段类似，在求解过程中利用哈希表把当前节点和它对应的父节点记录下来，这样就可以从终点一直倒推到起点，再反序输出即可得到正序的路径。\n\n下面的实现相对于上面的实现占用的内存空间占用会小的多。\n\n/**\n * 以bfs的形式找迷宫的出口\n * @param {number[]} matrix\n */\nfunction findpath(matrix) {\n  const height = matrix.length;\n  const width = matrix[0].length;\n  /* 定义一个哈希表，用于记住经过的路径 */\n  const pathmap = new map();\n  // 定义一个队列\n  const queue = [];\n  // 定义一个标记数组\n  const maker = array.from({\n    length: height,\n  }).map(() => {\n    return array.from({\n      length: width,\n    }).fill(0);\n  });\n  // 先将开始节点加入到队列中去\n  queue.push({\n    node: { x: 0, y: 0 },\n    /* 入口的父节点为空 */\n    parent: null,\n  });\n  // 将起始节点标记为已处理\n  maker[0][0] = true;\n  let distnode = null;\n  while (queue.length) {\n    const { node, parent } = queue.shift();\n    /* 将当前节点记录在到终点的路径上 */\n    pathmap.set(node, parent);\n    const { x, y } = node;\n    if (x === width - 1 && y === height - 1) {\n      distnode = node;\n      break;\n    }\n    // 上边的点，存在且没有被访问过，并且不是障碍物\n    const toppoint =\n      isexist(matrix, x, y - 1) && !maker[y - 1][x] && matrix[y - 1][x] !== 1\n        ? { x, y: y - 1 }\n        : null;\n    if (toppoint) {\n      queue.push({\n        node: toppoint,\n        parent: node,\n      });\n      maker[y - 1][x] = true;\n    }\n    // 右边的点，存在且没有被访问过，并且不是障碍物\n    const rightpoint =\n      isexist(matrix, x + 1, y) && !maker[y][x + 1] && matrix[y][x + 1] !== 1\n        ? { x: x + 1, y }\n        : null;\n    if (rightpoint) {\n      queue.push({\n        node: rightpoint,\n        parent: node,\n      });\n      maker[y][x + 1] = true;\n    }\n    // 下边的点，存在且没有被访问过，并且不是障碍物\n    const bottompoint =\n      isexist(matrix, x, y + 1) && !maker[y + 1][x] && matrix[y + 1][x] !== 1\n        ? { x, y: y + 1 }\n        : null;\n    if (bottompoint) {\n      queue.push({\n        node: bottompoint,\n        parent: node,\n      });\n      maker[y + 1][x] = true;\n    }\n    // 左边的点 存在且没有被访问过，并且不是障碍物\n    const leftpoint =\n      isexist(matrix, x - 1, y) && !maker[y][x - 1] && matrix[y][x - 1] !== 1\n        ? { x: x - 1, y }\n        : null;\n    if (leftpoint) {\n      queue.push({\n        node: leftpoint,\n        parent: node,\n      });\n      maker[y][x - 1] = true;\n    }\n  }\n  /* 本来正常的做法是需要使用栈记录逆序的路径，但是我们直接利用js的方法反向插入最终得到的即可是一个正序的路径，可以少一个循环 */\n  /* 注意不要把distnode记录掉了 */\n  const path = [distnode];\n  let parent = pathmap.get(distnode);\n  /* 直到找到入口节点，循环终止 */\n  while (parent) {\n    path.unshift(parent);\n    distnode = parent;\n    parent = pathmap.get(distnode);\n  }\n\n  return path.map((node) => {\n    return [node.x, node.y];\n  });\n}\n\n/**\n * 判断当前元素是否存在于迷宫中\n * @param {number[][]} matrix\n * @param {number} x\n * @param {number} y\n */\nfunction isexist(matrix, x, y) {\n  return array.isarray(matrix[y]) && typeof matrix[y][x] !== "undefined";\n}\n\n\n关于 bfs 还有很多有趣的问题，我暂时就先为大家介绍这几种常见的用法，欢迎大家补充。',charsets:{cjk:!0}},{title:"图",frontmatter:{},regularPath:"/data-structure/graph/desc.html",relativePath:"data-structure/graph/desc.md",key:"v-1c6e3f95",path:"/data-structure/graph/desc.html",headers:[{level:2,title:"图",slug:"图",normalizedTitle:"图",charIndex:2},{level:3,title:"图中的概念",slug:"图中的概念",normalizedTitle:"图中的概念",charIndex:171},{level:3,title:"图在计算机中的表示",slug:"图在计算机中的表示",normalizedTitle:"图在计算机中的表示",charIndex:611}],headersStr:"图 图中的概念 图在计算机中的表示",content:'# 图\n\n在我们日常生活中，线性表表示一对一的关系，树表示一对多的关系，图表示的是多对多的关系，线性表和树相当于是图的子集。\n\n图是我们现实生活中连接关系的抽象，例如朋友圈、微博的关注关系，互联网的连接等。\n\n在前端的实际开发中，如果当你遇到和流程图相关的业务时，可能会用到图；若你从事和地图相关的业务，那可能你得天天和图打交道了。\n\n\n# 图中的概念\n\n图中的专业术语特别的多，我们只列一些在实际开发中可能会用到的一些关键词。\n\n图中的两点如果存在权重的话，则称为带权图，图的两个顶点中间如果不存在方向的话，则称为无向图，有向的话则称为有向图\n\n对于图中任意一个顶点与该顶点相关联的边的条数，称为图的度；\n\n对于有向图来说的话，从顶点引出的边叫它的出度，别的顶点指向它的边叫做它的入度。\n\n在无向图中，如果从顶点 vi 到顶点 vj 有路径，则称 vi 和 vj 连通，如果图中任意两个顶点之间都连通，则称该图为连通图，否则，将其中的极大连通子图称为连通分量。（我觉得用同俗易懂的语言来理解这个概念就是说这个图里面是否有一个或几个顶点单着呢。）\n\n\n\n在有向图中，如果对于每一对顶点 vi 和 vj，从 vi 到 vj 和从 vj 到 vi 都有路径，则称该图为强连通图；否则，将其中的极大连通子图称为强连通分量。\n\n目前我在实际开发中所用到的关于图的名词就如上所述，对于图有兴趣的同学，可以自行查阅相关资料。\n\n\n# 图在计算机中的表示\n\n首先，大家一定不要拘泥于老师所讲述的邻接矩阵和邻接表的表示方法。曾经我就是对老师所授内容囫囵吞枣，导致理解上产生了偏差。只要你能够表示逻辑的关系（不管是一对一，多对一还是多对多），只要你的这个标识方法能够最快的解决你的问题，那就是一个好的表示方法。\n\n举个前端实际开发中的例子，像一个对象中可能存在一个或者多个循环引用，那就是图。\n\n但是，我们还是需要讲一下图的两种最常见的表示法：邻接矩阵和邻接表法。\n\n对于下面这个图，我们分别尝试用邻接矩阵和邻接表来表示它。\n\n\n\n我们对这些城市分别编个号\n\nconst cities = [\n  "北京",\n  "南京",\n  "广州",\n  "深圳",\n  "香港",\n  "成都",\n  "西安",\n  "乌鲁木齐",\n];\n\n\n# 邻接矩阵表示法\n\n一个二维数组，数组的长度和宽度为图的顶点数，若两点之间存在路径，则matrix[i][j]不为零，否则为零。\n\n对角线全部为 0，因为城市不需要自己和自己连接\n\n北京和南京存在连接，则 matrix[0][1]=1，matrix[1][0] = 1，因为我们是无向图，如果想表达仅可以从北京到南京，则matrix[0][1]=1\n\n南京和广州存在连接，matrix[1][2]=1，matrix[2][1] = 1\n\n深圳和广州存在连接，matrix[3][2]=1，matrix[2][3] = 1\n\n深圳和香港存在连接，matrix[3][4]=1，matrix[4][3] = 1\n\n广州和香港存在连接，matrix[2][4]=1，matrix[4][2] = 1\n\n广州和成都存在连接，matrix[2][5]=1，matrix[5][2] = 1\n\n西安和成都存在连接，matrix[5][6]=1，matrix[6][5] = 1\n\n西安和乌鲁木齐存在连接，matrix[6][7]=1，matrix[7][6] = 1\n\n西安和北京存在连接，matrix[0][7]=1，matrix[7][0] = 1\n\n[\n  [0, 1, 0, 0, 0, 0, 0, 1],\n  [1, 0, 0, 1, 1, 1, 0, 0],\n  [0, 0, 0, 0, 0, 0, 0, 0],\n  [0, 1, 0, 0, 1, 0, 0, 0],\n  [0, 1, 0, 1, 0, 0, 0, 0],\n  [0, 1, 0, 0, 0, 0, 1, 0],\n  [0, 0, 0, 0, 0, 1, 0, 1],\n  [1, 0, 0, 0, 0, 0, 1, 0],\n];\n\n\n若两点之间需要表示权重，需要将 1 改为权重即可。\n\n# 邻接表表示法\n\n一个一维数组，数组的每个元素为一个链表，链表指向当前顶点的所有邻接点。\n\ninterface Vertex {\n  cityName: string;\n  next: Vertex | null;\n}\n\n\n[\n  {\n    cityName: "北京",\n    next: {\n      cityName: "西安",\n      next: {\n        cityName: "南京",\n        next: {\n          cityName: "乌鲁木齐",\n          next: null,\n        },\n      },\n    },\n  },\n  {\n    cityName: "南京",\n    next: {\n      cityName: "北京",\n      next: {\n        cityName: "广州",\n        next: null,\n      },\n    },\n  },\n  {\n    cityName: "广州",\n    next: {\n      cityName: "成都",\n      next: {\n        cityName: "南京",\n        next: {\n          cityName: "深圳",\n          next: null,\n        },\n      },\n    },\n  },\n  {\n    cityName: "香港",\n    next: {\n      cityName: "深圳",\n      next: {\n        cityName: "广州",\n        next: null,\n      },\n    },\n  },\n  {\n    cityName: "深圳",\n    next: {\n      cityName: "广州",\n      next: {\n        cityName: "香港",\n        next: null,\n      },\n    },\n  },\n  {\n    cityName: "成都",\n    next: {\n      cityName: "西安",\n      next: {\n        cityName: "广州",\n        next: null,\n      },\n    },\n  },\n  {\n    cityName: "西安",\n    next: {\n      cityName: "成都",\n      next: {\n        cityName: "北京",\n        next: {\n          cityName: "乌鲁木齐",\n          next: null,\n        },\n      },\n    },\n  },\n  {\n    cityName: "乌鲁木齐",\n    next: {\n      cityName: "西安",\n      next: {\n        cityName: "北京",\n        next: null,\n      },\n    },\n  },\n];\n\n\n使用邻接表表示，若两点之间需要表示权重，还需要额外在链表节点增加一个域用以表示权重。\n\n上面两种表示法都把同一条边存了 2 次的，我们也之前也介绍了，图的表示方法有很多种，选择一种适合你的就好，接下来我介绍一下我个人在开发中的表示法。 首先定义图和顶点\n\nclass Edge {\n  constructor(name) {\n    this.name = name;\n  }\n  /**\n   * 边的编号\n   */\n  name;\n  /**\n   * 起始点\n   * @type {Vertex}\n   */\n  from;\n  /**\n   * 终止点\n   * @type {Vertex}\n   */\n  to;\n}\n\nclass Vertex {\n  /**\n   * 城市名称\n   */\n  cityName;\n  /**\n   * 邻接点\n   */\n  siblings = [];\n  constructor(cityName) {\n    this.cityName = cityName;\n  }\n}\n\nclass Graph {\n  vertexList = [];\n  edgeList = [];\n  addVertex(v) {\n    this.vertexList.push(v);\n  }\n\n  /**\n   * 增加边\n   * @param {Vertex} from\n   * @param {Vertex} to\n   */\n  addEdge(from, to) {\n    const name = `${from.cityName}至${to.cityName}`;\n    const edge = new Edge(name);\n    this.edgeList.push(edge);\n    from.siblings.push(to);\n    to.siblings.push(from);\n  }\n}\n\n\n接着，初始化数据：\n\nconst g = new Graph();\nconst beijing = new Vertex("北京");\nconst nanjing = new Vertex("南京");\nconst guangzhou = new Vertex("广州");\nconst shenzhen = new Vertex("深圳");\nconst hongkong = new Vertex("香港");\nconst chengdu = new Vertex("成都");\nconst xian = new Vertex("西安");\nconst urumchi = new Vertex("乌鲁木齐");\n\n/**\n * 将城市加入到图中\n */\ng.addVertex(beijing);\ng.addVertex(nanjing);\ng.addVertex(guangzhou);\ng.addVertex(shenzhen);\ng.addVertex(hongkong);\ng.addVertex(chengdu);\ng.addVertex(xian);\ng.addVertex(urumchi);\n/**\n * 建立连接关系\n */\ng.addEdge(beijing, nanjing);\ng.addEdge(beijing, xian);\ng.addEdge(nanjing, guangzhou);\ng.addEdge(guangzhou, shenzhen);\ng.addEdge(guangzhou, hongkong);\ng.addEdge(hongkong, shenzhen);\ng.addEdge(chengdu, guangzhou);\ng.addEdge(chengdu, xian);\ng.addEdge(urumchi, xian);\ng.addEdge(urumchi, beijing);\n\n\n上述这种方法是大家在实际开发中最可能用到的。后面，一些图的算法，我们还会基于这个例子阐述。',normalizedContent:'# 图\n\n在我们日常生活中，线性表表示一对一的关系，树表示一对多的关系，图表示的是多对多的关系，线性表和树相当于是图的子集。\n\n图是我们现实生活中连接关系的抽象，例如朋友圈、微博的关注关系，互联网的连接等。\n\n在前端的实际开发中，如果当你遇到和流程图相关的业务时，可能会用到图；若你从事和地图相关的业务，那可能你得天天和图打交道了。\n\n\n# 图中的概念\n\n图中的专业术语特别的多，我们只列一些在实际开发中可能会用到的一些关键词。\n\n图中的两点如果存在权重的话，则称为带权图，图的两个顶点中间如果不存在方向的话，则称为无向图，有向的话则称为有向图\n\n对于图中任意一个顶点与该顶点相关联的边的条数，称为图的度；\n\n对于有向图来说的话，从顶点引出的边叫它的出度，别的顶点指向它的边叫做它的入度。\n\n在无向图中，如果从顶点 vi 到顶点 vj 有路径，则称 vi 和 vj 连通，如果图中任意两个顶点之间都连通，则称该图为连通图，否则，将其中的极大连通子图称为连通分量。（我觉得用同俗易懂的语言来理解这个概念就是说这个图里面是否有一个或几个顶点单着呢。）\n\n\n\n在有向图中，如果对于每一对顶点 vi 和 vj，从 vi 到 vj 和从 vj 到 vi 都有路径，则称该图为强连通图；否则，将其中的极大连通子图称为强连通分量。\n\n目前我在实际开发中所用到的关于图的名词就如上所述，对于图有兴趣的同学，可以自行查阅相关资料。\n\n\n# 图在计算机中的表示\n\n首先，大家一定不要拘泥于老师所讲述的邻接矩阵和邻接表的表示方法。曾经我就是对老师所授内容囫囵吞枣，导致理解上产生了偏差。只要你能够表示逻辑的关系（不管是一对一，多对一还是多对多），只要你的这个标识方法能够最快的解决你的问题，那就是一个好的表示方法。\n\n举个前端实际开发中的例子，像一个对象中可能存在一个或者多个循环引用，那就是图。\n\n但是，我们还是需要讲一下图的两种最常见的表示法：邻接矩阵和邻接表法。\n\n对于下面这个图，我们分别尝试用邻接矩阵和邻接表来表示它。\n\n\n\n我们对这些城市分别编个号\n\nconst cities = [\n  "北京",\n  "南京",\n  "广州",\n  "深圳",\n  "香港",\n  "成都",\n  "西安",\n  "乌鲁木齐",\n];\n\n\n# 邻接矩阵表示法\n\n一个二维数组，数组的长度和宽度为图的顶点数，若两点之间存在路径，则matrix[i][j]不为零，否则为零。\n\n对角线全部为 0，因为城市不需要自己和自己连接\n\n北京和南京存在连接，则 matrix[0][1]=1，matrix[1][0] = 1，因为我们是无向图，如果想表达仅可以从北京到南京，则matrix[0][1]=1\n\n南京和广州存在连接，matrix[1][2]=1，matrix[2][1] = 1\n\n深圳和广州存在连接，matrix[3][2]=1，matrix[2][3] = 1\n\n深圳和香港存在连接，matrix[3][4]=1，matrix[4][3] = 1\n\n广州和香港存在连接，matrix[2][4]=1，matrix[4][2] = 1\n\n广州和成都存在连接，matrix[2][5]=1，matrix[5][2] = 1\n\n西安和成都存在连接，matrix[5][6]=1，matrix[6][5] = 1\n\n西安和乌鲁木齐存在连接，matrix[6][7]=1，matrix[7][6] = 1\n\n西安和北京存在连接，matrix[0][7]=1，matrix[7][0] = 1\n\n[\n  [0, 1, 0, 0, 0, 0, 0, 1],\n  [1, 0, 0, 1, 1, 1, 0, 0],\n  [0, 0, 0, 0, 0, 0, 0, 0],\n  [0, 1, 0, 0, 1, 0, 0, 0],\n  [0, 1, 0, 1, 0, 0, 0, 0],\n  [0, 1, 0, 0, 0, 0, 1, 0],\n  [0, 0, 0, 0, 0, 1, 0, 1],\n  [1, 0, 0, 0, 0, 0, 1, 0],\n];\n\n\n若两点之间需要表示权重，需要将 1 改为权重即可。\n\n# 邻接表表示法\n\n一个一维数组，数组的每个元素为一个链表，链表指向当前顶点的所有邻接点。\n\ninterface vertex {\n  cityname: string;\n  next: vertex | null;\n}\n\n\n[\n  {\n    cityname: "北京",\n    next: {\n      cityname: "西安",\n      next: {\n        cityname: "南京",\n        next: {\n          cityname: "乌鲁木齐",\n          next: null,\n        },\n      },\n    },\n  },\n  {\n    cityname: "南京",\n    next: {\n      cityname: "北京",\n      next: {\n        cityname: "广州",\n        next: null,\n      },\n    },\n  },\n  {\n    cityname: "广州",\n    next: {\n      cityname: "成都",\n      next: {\n        cityname: "南京",\n        next: {\n          cityname: "深圳",\n          next: null,\n        },\n      },\n    },\n  },\n  {\n    cityname: "香港",\n    next: {\n      cityname: "深圳",\n      next: {\n        cityname: "广州",\n        next: null,\n      },\n    },\n  },\n  {\n    cityname: "深圳",\n    next: {\n      cityname: "广州",\n      next: {\n        cityname: "香港",\n        next: null,\n      },\n    },\n  },\n  {\n    cityname: "成都",\n    next: {\n      cityname: "西安",\n      next: {\n        cityname: "广州",\n        next: null,\n      },\n    },\n  },\n  {\n    cityname: "西安",\n    next: {\n      cityname: "成都",\n      next: {\n        cityname: "北京",\n        next: {\n          cityname: "乌鲁木齐",\n          next: null,\n        },\n      },\n    },\n  },\n  {\n    cityname: "乌鲁木齐",\n    next: {\n      cityname: "西安",\n      next: {\n        cityname: "北京",\n        next: null,\n      },\n    },\n  },\n];\n\n\n使用邻接表表示，若两点之间需要表示权重，还需要额外在链表节点增加一个域用以表示权重。\n\n上面两种表示法都把同一条边存了 2 次的，我们也之前也介绍了，图的表示方法有很多种，选择一种适合你的就好，接下来我介绍一下我个人在开发中的表示法。 首先定义图和顶点\n\nclass edge {\n  constructor(name) {\n    this.name = name;\n  }\n  /**\n   * 边的编号\n   */\n  name;\n  /**\n   * 起始点\n   * @type {vertex}\n   */\n  from;\n  /**\n   * 终止点\n   * @type {vertex}\n   */\n  to;\n}\n\nclass vertex {\n  /**\n   * 城市名称\n   */\n  cityname;\n  /**\n   * 邻接点\n   */\n  siblings = [];\n  constructor(cityname) {\n    this.cityname = cityname;\n  }\n}\n\nclass graph {\n  vertexlist = [];\n  edgelist = [];\n  addvertex(v) {\n    this.vertexlist.push(v);\n  }\n\n  /**\n   * 增加边\n   * @param {vertex} from\n   * @param {vertex} to\n   */\n  addedge(from, to) {\n    const name = `${from.cityname}至${to.cityname}`;\n    const edge = new edge(name);\n    this.edgelist.push(edge);\n    from.siblings.push(to);\n    to.siblings.push(from);\n  }\n}\n\n\n接着，初始化数据：\n\nconst g = new graph();\nconst beijing = new vertex("北京");\nconst nanjing = new vertex("南京");\nconst guangzhou = new vertex("广州");\nconst shenzhen = new vertex("深圳");\nconst hongkong = new vertex("香港");\nconst chengdu = new vertex("成都");\nconst xian = new vertex("西安");\nconst urumchi = new vertex("乌鲁木齐");\n\n/**\n * 将城市加入到图中\n */\ng.addvertex(beijing);\ng.addvertex(nanjing);\ng.addvertex(guangzhou);\ng.addvertex(shenzhen);\ng.addvertex(hongkong);\ng.addvertex(chengdu);\ng.addvertex(xian);\ng.addvertex(urumchi);\n/**\n * 建立连接关系\n */\ng.addedge(beijing, nanjing);\ng.addedge(beijing, xian);\ng.addedge(nanjing, guangzhou);\ng.addedge(guangzhou, shenzhen);\ng.addedge(guangzhou, hongkong);\ng.addedge(hongkong, shenzhen);\ng.addedge(chengdu, guangzhou);\ng.addedge(chengdu, xian);\ng.addedge(urumchi, xian);\ng.addedge(urumchi, beijing);\n\n\n上述这种方法是大家在实际开发中最可能用到的。后面，一些图的算法，我们还会基于这个例子阐述。',charsets:{cjk:!0}},{title:"深度优先搜索",frontmatter:{},regularPath:"/data-structure/graph/dfs.html",relativePath:"data-structure/graph/dfs.md",key:"v-9751b882",path:"/data-structure/graph/dfs.html",headers:[{level:2,title:"深度优先搜索",slug:"深度优先搜索",normalizedTitle:"深度优先搜索",charIndex:2},{level:3,title:"DFS 的标准范式",slug:"dfs-的标准范式",normalizedTitle:"dfs 的标准范式",charIndex:245},{level:3,title:"DFS 的应用",slug:"dfs-的应用",normalizedTitle:"dfs 的应用",charIndex:650}],headersStr:"深度优先搜索 DFS 的标准范式 DFS 的应用",content:'# 深度优先搜索\n\n深度优先搜索算法（英语：Depth-First-Search，简称 DFS）是一种用于遍历或搜索树或图的算法。其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个结点只能访问一次.\n\n比如下图展示的就是一个使用 DFS 遍历二叉树的过程：\n\n\n\n对于图的遍历来说，不管采用DFS还是BFS(Breadth First Search，简称 BFS)，都是可以的。\n\n注意事项\n\n必须在某些特定的情况下，比较BFS还是DFS两者的遍历效果才有意义。\n\n\n# DFS 的标准范式\n\nDFS每次都是在先按照特定的规则（比如从第一个邻接点处理到第 N 个邻接点），每遍历一个节点，将当前节点标记为已遍历，若不能再继续向下处理，则向上回溯，继续处理这个交叉路口的下一个分支，重复这个过程，直到所有的节点都被处理，则遍历完成。\n\nDFS 的伪代码实现如下：\n\nfunction DFS(v, visited) {\n  visited[v] = true;\n  for(v 的每个邻接点 w ) {\n    if(!visited[w]) {\n      DFS(w, visited);\n    }\n  }\n}\n\n\n为什么需要一个标记呢，因为图的关系是四通八达的，如果没有标记的话，就好比人迷失了方向，遍历将无法找到退出的出口，会出现最大堆栈调用的错误或死循环。一般我们这个标记的遍历会考虑使用哈希表，但是有些时候使用数组也可以，主要取决于你的图采用什么样的表示方法。\n\n\n# DFS 的应用\n\n# 拍平数组（flat）\n\n这题几乎是各大中小厂面试题的常客了。\n\n假设有这样的数组： [1,[2,3,[[4]]],[5],[[[[[6],7,8]]],9], 10]，请将其展平为[1,2,3,4,5,6,7,8,9,10]。\n\n主要有 3 种方法对数组进行拍平。\n\n首先是最朴素的算法，将数组toString，然后将其中的[和,]替换掉，然后再将数组转换回数字类型，这个算法有一定的局限性，但是在你实在想不起来怎么样用DFS处理这个问题的时候，也可以使用。\n\n为什么说这个方法有局限性呢，因为你toString注定了已知数据的类型必须是一样的，无法记录特值，并且如果数据源里面包含[或]，这个办法就歇菜，并且这个方法是无法指定拍平多少层的。\n\n/**\n * 拍平数组\n * @param {number[]} arr\n */\nfunction flat(arr) {\n  return arr\n    .toString()\n    .replace(/\\[|\\]/g, "")\n    .split(",")\n    .map((ele) => {\n      return Number.parseInt(ele);\n    });\n}\n\n\n说完了花里胡哨的操作，然后还是回到本质的东西，使用DFS拍平数组，并且支持拍平深度。\n\n/**\n * 拍平数组\n * @param {any[]} arr 源数据\n * @param {number} depth 指定拍平深度\n * @param {number} curDepth 当前的深度\n */\nfunction flat(arr/*,*depth = Infinity, curDepth = 1*/) {\n  const results = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (Array.isArray(arr[i]) /*&& curDepth < depth*/) {\n      results.push(...flat(arr[i]/*, depth, curDepth + 1)*/);\n    } else {\n      results.push(arr[i]);\n    }\n  }\n  return results;\n}\n\n\n上述使用的是push的方式flat。\n\n在有些时候，如果你写的过快，面试官还会问你有没有别更好的方法，稍微好一点儿的方法是使用reduce，如下：\n\n/**\n * 拍平数组\n * @param {any[]} arr\n * @returns\n */\nfunction flat(arr) {\n  return arr.reduce((preVal, curVal) => {\n    return Array.isArray(curVal)\n      ? preVal.concat(flat(curVal))\n      : preVal.concat(curVal);\n  }, []);\n}\n\n\n思维方式和上面的DFS一致，但是写法更简洁，需要注意的是，在reduce的时候，一定要提供默认参数[]。\n\n# 深拷贝对象\n\n在深拷贝的时候为了防止循环引用，把已经拷贝过的对象和新生成的对象映射加入到哈希表中去，并且递归拷贝的时候，要带上这个哈希表递归。需要注意一点就是，拷贝过程中，一旦新生成的对象产生，就需要建立映射，而不是，等拷贝完成再建立映射，否则就无法区分当前对象是否已经被拷贝了，出现最大调用堆栈报错。\n\n注意，在此处我实现的深拷贝并没有完整考虑所有的情况，如果对深拷贝感兴趣的同学，请移步 lodash 的源码参考其实现。\n\n/**\n * 使用深度优先深拷贝对象\n * @param {Array<any> | object} obj\n * @param { Map<Array<any> | object, Array<any> | object> } map\n * @returns\n */\nfunction deepClone(obj, map = new Map()) {\n  // 如果已经拷贝过，则可以直接返回拷贝过的值，主要是为了防止循环引用\n  let cloneObj = map.get(obj);\n  if (typeof cloneObj !== "undefined") {\n    return cloneObj;\n  }\n  // 初始化拷贝的对象\n  cloneObj = Array.isArray(obj) ? [] : {};\n  // 建立已经拷贝的引用，不能再开始拷贝属性了再建立拷贝引用，否则将会导致递归最大调用栈的问题发生\n  map.set(obj, cloneObj);\n  // 对拷贝对象挨个赋值\n  for (let prop in obj) {\n    // 遇到对象，则递归拷贝\n    if (obj[prop] instanceof Object) {\n      cloneObj[prop] = deepClone(obj[prop], map);\n      // 拷贝完成后，还要将其加入引用Map中去\n      map.set(obj[prop], cloneObj[obj]);\n    } else {\n      cloneObj[prop] = obj[prop];\n    }\n  }\n  return cloneObj;\n}\n\n\n# 迷宫问题\n\n这是华为的一道机考题。\n\n定义一个二维数组 N*M ，如 5 × 5 数组下所示：\n\n[\n  [0, 1, 0, 0, 0],\n  [0, 1, 1, 1, 0],\n  [0, 0, 0, 0, 0],\n  [0, 1, 1, 1, 0],\n  [0, 0, 0, 1, 0],\n];\n\n\n它表示一个迷宫，其中的 1 表示墙壁，0 表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的路线。入口点为[0,0],既第一格是可以走的路。\n\n输入两个整数，分别表示二维数组的行数，列数。再输入相应的数组，其中的 1 表示墙壁，0 表示可以走的路。数据保证有唯一解,不考虑有多解的情况，即迷宫只有一条通道。\n\n/**\n * 寻找迷宫的出路\n * @param {number[][]} matrix\n * @param {number} startX\n * @param {number} startY\n * @param {boolean[][]} visited\n */\nfunction findSolution(matrix, startX, startY, distX, distY, visited) {\n  // 如果遇到边界，或者当前节点已经被处理过，此路不通\n  if (!isEdge(matrix, startX, startY) || visited[startX][startY]) {\n    return [];\n  }\n  // 将当前节点标记为已处理\n  visited[startX][startY] = true;\n  // 如果遇到障碍物，此路不通\n  if (matrix[startX][startY] === 1) {\n    return [];\n  }\n  // 定义当前节点\n  let point = [startX, startY];\n  // 如果已经找到了出口\n  if (startX === distX && startY === distY) {\n    return [point];\n  }\n  let viaLeft = [],\n    viaRight = [],\n    viaTop = [],\n    viaBottom = [];\n  // 向左处理路径\n  if (isEdge(matrix, startX - 1, startY) && !visited[startX - 1][startY]) {\n    viaLeft = findSolution(matrix, startX - 1, startY, distX, distY, visited);\n  }\n  // 向右处理路径\n  if (isEdge(matrix, startX + 1, startY) && !visited[startX + 1][startY]) {\n    viaRight = findSolution(matrix, startX + 1, startY, distX, distY, visited);\n  }\n  // 向下处理路径\n  if (isEdge(matrix, startX, startY + 1) && !visited[startX][startY + 1]) {\n    viaBottom = findSolution(matrix, startX, startY + 1, distX, distY, visited);\n  }\n  // 向上处理路径\n  if (isEdge(matrix, startX, startY - 1) && !visited[startX][startY - 1]) {\n    viaTop = findSolution(matrix, startX, startY - 1, distX, distY, visited);\n  }\n  // 从有用的路径中选择一个返回\n  if (viaLeft.length) {\n    return [point, ...viaLeft];\n  } else if (viaRight.length) {\n    return [point, ...viaRight];\n  } else if (viaBottom.length) {\n    return [point, ...viaBottom];\n  } else if (viaTop.length) {\n    return [point, ...viaTop];\n  } else {\n    return [];\n  }\n}\n\n/**\n * 是否是边界\n * @param {number[][]} matrix\n * @param {number} x\n * @param {number} y\n */\nfunction isEdge(matrix, x, y) {\n  return Array.isArray(matrix[x]) && typeof matrix[x][y] !== "undefined";\n}\n\n/**\n * 从一个矩阵的左上角走到右下角\n * @param {number[][]} matrix\n */\nfunction findPath(matrix, distX, distY) {\n  // 生成一个标记数组，用于标记当前节点已处理\n  const visited = matrix.map((row) => {\n    return row.map(() => false);\n  });\n  const steps = findSolution(matrix, 0, 0, distX, distY, visited);\n  return steps;\n}\n\n\n关于 DFS 还有很多有趣的问题，我暂时就先为大家介绍这几种常见的用法，欢迎大家补充。',normalizedContent:'# 深度优先搜索\n\n深度优先搜索算法（英语：depth-first-search，简称 dfs）是一种用于遍历或搜索树或图的算法。其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个结点只能访问一次.\n\n比如下图展示的就是一个使用 dfs 遍历二叉树的过程：\n\n\n\n对于图的遍历来说，不管采用dfs还是bfs(breadth first search，简称 bfs)，都是可以的。\n\n注意事项\n\n必须在某些特定的情况下，比较bfs还是dfs两者的遍历效果才有意义。\n\n\n# dfs 的标准范式\n\ndfs每次都是在先按照特定的规则（比如从第一个邻接点处理到第 n 个邻接点），每遍历一个节点，将当前节点标记为已遍历，若不能再继续向下处理，则向上回溯，继续处理这个交叉路口的下一个分支，重复这个过程，直到所有的节点都被处理，则遍历完成。\n\ndfs 的伪代码实现如下：\n\nfunction dfs(v, visited) {\n  visited[v] = true;\n  for(v 的每个邻接点 w ) {\n    if(!visited[w]) {\n      dfs(w, visited);\n    }\n  }\n}\n\n\n为什么需要一个标记呢，因为图的关系是四通八达的，如果没有标记的话，就好比人迷失了方向，遍历将无法找到退出的出口，会出现最大堆栈调用的错误或死循环。一般我们这个标记的遍历会考虑使用哈希表，但是有些时候使用数组也可以，主要取决于你的图采用什么样的表示方法。\n\n\n# dfs 的应用\n\n# 拍平数组（flat）\n\n这题几乎是各大中小厂面试题的常客了。\n\n假设有这样的数组： [1,[2,3,[[4]]],[5],[[[[[6],7,8]]],9], 10]，请将其展平为[1,2,3,4,5,6,7,8,9,10]。\n\n主要有 3 种方法对数组进行拍平。\n\n首先是最朴素的算法，将数组tostring，然后将其中的[和,]替换掉，然后再将数组转换回数字类型，这个算法有一定的局限性，但是在你实在想不起来怎么样用dfs处理这个问题的时候，也可以使用。\n\n为什么说这个方法有局限性呢，因为你tostring注定了已知数据的类型必须是一样的，无法记录特值，并且如果数据源里面包含[或]，这个办法就歇菜，并且这个方法是无法指定拍平多少层的。\n\n/**\n * 拍平数组\n * @param {number[]} arr\n */\nfunction flat(arr) {\n  return arr\n    .tostring()\n    .replace(/\\[|\\]/g, "")\n    .split(",")\n    .map((ele) => {\n      return number.parseint(ele);\n    });\n}\n\n\n说完了花里胡哨的操作，然后还是回到本质的东西，使用dfs拍平数组，并且支持拍平深度。\n\n/**\n * 拍平数组\n * @param {any[]} arr 源数据\n * @param {number} depth 指定拍平深度\n * @param {number} curdepth 当前的深度\n */\nfunction flat(arr/*,*depth = infinity, curdepth = 1*/) {\n  const results = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (array.isarray(arr[i]) /*&& curdepth < depth*/) {\n      results.push(...flat(arr[i]/*, depth, curdepth + 1)*/);\n    } else {\n      results.push(arr[i]);\n    }\n  }\n  return results;\n}\n\n\n上述使用的是push的方式flat。\n\n在有些时候，如果你写的过快，面试官还会问你有没有别更好的方法，稍微好一点儿的方法是使用reduce，如下：\n\n/**\n * 拍平数组\n * @param {any[]} arr\n * @returns\n */\nfunction flat(arr) {\n  return arr.reduce((preval, curval) => {\n    return array.isarray(curval)\n      ? preval.concat(flat(curval))\n      : preval.concat(curval);\n  }, []);\n}\n\n\n思维方式和上面的dfs一致，但是写法更简洁，需要注意的是，在reduce的时候，一定要提供默认参数[]。\n\n# 深拷贝对象\n\n在深拷贝的时候为了防止循环引用，把已经拷贝过的对象和新生成的对象映射加入到哈希表中去，并且递归拷贝的时候，要带上这个哈希表递归。需要注意一点就是，拷贝过程中，一旦新生成的对象产生，就需要建立映射，而不是，等拷贝完成再建立映射，否则就无法区分当前对象是否已经被拷贝了，出现最大调用堆栈报错。\n\n注意，在此处我实现的深拷贝并没有完整考虑所有的情况，如果对深拷贝感兴趣的同学，请移步 lodash 的源码参考其实现。\n\n/**\n * 使用深度优先深拷贝对象\n * @param {array<any> | object} obj\n * @param { map<array<any> | object, array<any> | object> } map\n * @returns\n */\nfunction deepclone(obj, map = new map()) {\n  // 如果已经拷贝过，则可以直接返回拷贝过的值，主要是为了防止循环引用\n  let cloneobj = map.get(obj);\n  if (typeof cloneobj !== "undefined") {\n    return cloneobj;\n  }\n  // 初始化拷贝的对象\n  cloneobj = array.isarray(obj) ? [] : {};\n  // 建立已经拷贝的引用，不能再开始拷贝属性了再建立拷贝引用，否则将会导致递归最大调用栈的问题发生\n  map.set(obj, cloneobj);\n  // 对拷贝对象挨个赋值\n  for (let prop in obj) {\n    // 遇到对象，则递归拷贝\n    if (obj[prop] instanceof object) {\n      cloneobj[prop] = deepclone(obj[prop], map);\n      // 拷贝完成后，还要将其加入引用map中去\n      map.set(obj[prop], cloneobj[obj]);\n    } else {\n      cloneobj[prop] = obj[prop];\n    }\n  }\n  return cloneobj;\n}\n\n\n# 迷宫问题\n\n这是华为的一道机考题。\n\n定义一个二维数组 n*m ，如 5 × 5 数组下所示：\n\n[\n  [0, 1, 0, 0, 0],\n  [0, 1, 1, 1, 0],\n  [0, 0, 0, 0, 0],\n  [0, 1, 1, 1, 0],\n  [0, 0, 0, 1, 0],\n];\n\n\n它表示一个迷宫，其中的 1 表示墙壁，0 表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的路线。入口点为[0,0],既第一格是可以走的路。\n\n输入两个整数，分别表示二维数组的行数，列数。再输入相应的数组，其中的 1 表示墙壁，0 表示可以走的路。数据保证有唯一解,不考虑有多解的情况，即迷宫只有一条通道。\n\n/**\n * 寻找迷宫的出路\n * @param {number[][]} matrix\n * @param {number} startx\n * @param {number} starty\n * @param {boolean[][]} visited\n */\nfunction findsolution(matrix, startx, starty, distx, disty, visited) {\n  // 如果遇到边界，或者当前节点已经被处理过，此路不通\n  if (!isedge(matrix, startx, starty) || visited[startx][starty]) {\n    return [];\n  }\n  // 将当前节点标记为已处理\n  visited[startx][starty] = true;\n  // 如果遇到障碍物，此路不通\n  if (matrix[startx][starty] === 1) {\n    return [];\n  }\n  // 定义当前节点\n  let point = [startx, starty];\n  // 如果已经找到了出口\n  if (startx === distx && starty === disty) {\n    return [point];\n  }\n  let vialeft = [],\n    viaright = [],\n    viatop = [],\n    viabottom = [];\n  // 向左处理路径\n  if (isedge(matrix, startx - 1, starty) && !visited[startx - 1][starty]) {\n    vialeft = findsolution(matrix, startx - 1, starty, distx, disty, visited);\n  }\n  // 向右处理路径\n  if (isedge(matrix, startx + 1, starty) && !visited[startx + 1][starty]) {\n    viaright = findsolution(matrix, startx + 1, starty, distx, disty, visited);\n  }\n  // 向下处理路径\n  if (isedge(matrix, startx, starty + 1) && !visited[startx][starty + 1]) {\n    viabottom = findsolution(matrix, startx, starty + 1, distx, disty, visited);\n  }\n  // 向上处理路径\n  if (isedge(matrix, startx, starty - 1) && !visited[startx][starty - 1]) {\n    viatop = findsolution(matrix, startx, starty - 1, distx, disty, visited);\n  }\n  // 从有用的路径中选择一个返回\n  if (vialeft.length) {\n    return [point, ...vialeft];\n  } else if (viaright.length) {\n    return [point, ...viaright];\n  } else if (viabottom.length) {\n    return [point, ...viabottom];\n  } else if (viatop.length) {\n    return [point, ...viatop];\n  } else {\n    return [];\n  }\n}\n\n/**\n * 是否是边界\n * @param {number[][]} matrix\n * @param {number} x\n * @param {number} y\n */\nfunction isedge(matrix, x, y) {\n  return array.isarray(matrix[x]) && typeof matrix[x][y] !== "undefined";\n}\n\n/**\n * 从一个矩阵的左上角走到右下角\n * @param {number[][]} matrix\n */\nfunction findpath(matrix, distx, disty) {\n  // 生成一个标记数组，用于标记当前节点已处理\n  const visited = matrix.map((row) => {\n    return row.map(() => false);\n  });\n  const steps = findsolution(matrix, 0, 0, distx, disty, visited);\n  return steps;\n}\n\n\n关于 dfs 还有很多有趣的问题，我暂时就先为大家介绍这几种常见的用法，欢迎大家补充。',charsets:{cjk:!0}},{title:"最小生成树",frontmatter:{},regularPath:"/data-structure/graph/minimum-spanning-tree.html",relativePath:"data-structure/graph/minimum-spanning-tree.md",key:"v-a65f4076",path:"/data-structure/graph/minimum-spanning-tree.html",headers:[{level:2,title:"最小生成树",slug:"最小生成树",normalizedTitle:"最小生成树",charIndex:2}],headersStr:"最小生成树",content:"# 最小生成树\n\n建设中，敬请期待...",normalizedContent:"# 最小生成树\n\n建设中，敬请期待...",charsets:{cjk:!0}},{title:"最短路径",frontmatter:{},regularPath:"/data-structure/graph/shortest-path.html",relativePath:"data-structure/graph/shortest-path.md",key:"v-41a4fc5e",path:"/data-structure/graph/shortest-path.html",headers:[{level:2,title:"最短路径",slug:"最短路径",normalizedTitle:"最短路径",charIndex:2},{level:3,title:"无权图单源最短路",slug:"无权图单源最短路",normalizedTitle:"无权图单源最短路",charIndex:465},{level:3,title:"带权图单源最短路径算法",slug:"带权图单源最短路径算法",normalizedTitle:"带权图单源最短路径算法",charIndex:4451},{level:3,title:"带权图多源最短路径算法",slug:"带权图多源最短路径算法",normalizedTitle:"带权图多源最短路径算法",charIndex:11312}],headersStr:"最短路径 无权图单源最短路 带权图单源最短路径算法 带权图多源最短路径算法",content:'# 最短路径\n\n最短路径问题，这个问题几乎是我们每天必定会接触到的问题了吧。\n\n当你打开高德地图，输入目的地，高德地图一下就可以给你计算出来了怎么走，甚至还能让你选条件，比如途经点，用时最短，里程最短等条件。我一直感叹其中的神奇，在我没有接触图这章的知识的时候，想破脑袋也不知道其中的原理，但是我从未放弃过要去搞明白计算机是怎么样解决这类问题的。\n\n曾经我有一个朋友，他是银行职员，当时正值炎炎夏日，他需要在一周内拜访成都市区几百家客户，他来求助我，是否可以帮忙写一个程序算一下怎么安排这些客户的拜访顺序，囿于当时我的水平有限，只能遗憾的告诉他我不会啊，真实心疼他。他的这个需求其实是结合了图的最短路径问题和最小生成树问题的场景。\n\n如果你掌握了本节内容，将来和朋友们出去玩儿的时候，编程求解旅行的规划，那应该可以狠狠地秀大家一把吧；\n\n如果你不仅掌握了本节内容，还掌握了后面将会介绍的最小生成树问题，将来某一天大家有类似我朋友这种极端的需求的时候，一定可以帮到他哟，这就是程序员的力量，代码的魅力，加油，拿下这节知识。\n\n\n# 无权图单源最短路\n\n无权图的单源最短路问题，跟我们的广度优先遍历的思路非常相似，我们从起点出发，依次操作当前节点的邻接点，若其还没有处理过，则处理，并且更新起点到这个点的距离，然后还要把这个点加到我们记录的一个路径数据集里面去。重复上述操作，直到处理完图中所有的点。\n\n我们以这个图为例：\n\n\n\n并且以如下表示方法表示图：\n\n/**\n * 边类\n */\nclass Edge {\n  constructor(name) {\n    this.name = name;\n  }\n  /**\n   * 边的编号\n   */\n  name;\n  /**\n   * 起始点\n   * @type {Vertex}\n   */\n  from;\n  /**\n   * 终止点\n   * @type {Vertex}\n   */\n  to;\n}\n\n/**\n * 顶点类\n */\nclass Vertex {\n  /**\n   * 城市名称\n   */\n  cityName;\n  /**\n   * 邻接点\n   */\n  siblings = [];\n  constructor(cityName) {\n    this.cityName = cityName;\n  }\n}\n\n/**\n * 图类\n */\nclass Graph {\n  /**\n   * 顶点集合\n   * @type {Vertex[]}\n   */\n  vertexList = [];\n  /**\n   * 边集合\n   * @type {Edge[]}\n   */\n  edgeList = [];\n  /**\n   * 向图中插入一个顶点\n   */\n  addVertex(v) {\n    this.vertexList.push(v);\n  }\n  /**\n   * 增加边，连接from和to两个顶点\n   * @param {Vertex} from\n   * @param {Vertex} to\n   */\n  addEdge(from, to) {\n    const name = `${from.cityName}至${to.cityName}`;\n    const edge = new Edge(name);\n    this.edgeList.push(edge);\n    from.siblings.push(to);\n    to.siblings.push(from);\n  }\n}\n\n\n接着，根据上面的那个图，构建出我们想要的连接关系：\n\nconst g = new Graph();\nconst beijing = new Vertex("北京");\nconst nanjing = new Vertex("南京");\nconst guangzhou = new Vertex("广州");\nconst shenzhen = new Vertex("深圳");\nconst hongkong = new Vertex("香港");\nconst chengdu = new Vertex("成都");\nconst xian = new Vertex("西安");\nconst urumchi = new Vertex("乌鲁木齐");\n/**\n * 将城市加入到图中\n */\ng.addVertex(beijing);\ng.addVertex(nanjing);\ng.addVertex(guangzhou);\ng.addVertex(shenzhen);\ng.addVertex(hongkong);\ng.addVertex(chengdu);\ng.addVertex(xian);\ng.addVertex(urumchi);\n/**\n * 建立连接关系\n */\ng.addEdge(beijing, nanjing);\ng.addEdge(beijing, xian);\ng.addEdge(nanjing, guangzhou);\ng.addEdge(guangzhou, shenzhen);\ng.addEdge(guangzhou, hongkong);\ng.addEdge(hongkong, shenzhen);\ng.addEdge(chengdu, guangzhou);\ng.addEdge(chengdu, xian);\ng.addEdge(urumchi, xian);\ng.addEdge(urumchi, beijing);\n\n\n那么，最短路径求解算法如下：\n\n/**\n * 单源无权图的最短路算法\n * @param {Vertex} start\n * @param {Vertex} end\n */\nfunction unweightedShortestPath(start, end) {\n  const queue = [];\n  /* 距离哈希表，用于存储开始顶点到任意节点的距离 */\n  const dist = new Map();\n  /* 路径哈希表，用于存储开始顶点到任意节点所经过的顶点 */\n  const path = new Map();\n  dist.set(start, 0);\n  queue.push(start);\n  while (queue.length > 0) {\n    let vertex = queue.shift();\n    for (let i = 0; i < vertex.siblings.length; i++) {\n      // 取出当前正在处理的顶点的邻接点进行处理\n      let adjoinVertex = vertex.siblings[i];\n      /* 若adjoinVertex未被访问过 */\n      if (typeof dist.get(adjoinVertex) === "undefined") {\n        /* 将这个点到start的距离更新 */\n        dist.set(adjoinVertex, dist.get(vertex) + 1);\n        /* 将这个点记录在S到adjoinVertex的路径上 */\n        path.set(adjoinVertex, vertex);\n        // 并且将当前邻接点入队\n        queue.push(adjoinVertex);\n      }\n    }\n  }\n  // 获取终点的最短路径长度\n  const distance = dist.get(end);\n  // 使用栈记住终点\n  const stack = [end];\n  let preVertex = path.get(end);\n  // 沿途处理从终点到起点所经过的路径\n  while (preVertex) {\n    stack.push(preVertex);\n    // 继续向上迭代，寻找经过的顶点\n    preVertex = path.get(preVertex);\n  }\n  // 经过逆序，得到了正确的路径\n  let via = "";\n  while (stack.length) {\n    const city = stack.pop();\n    via += "->" + city.cityName;\n  }\n  return { distance, path: via.replace(/(^->)|(->$)/g, "") };\n}\n\n\n假设我们想求出成都到北京的最短距离，并且需要求出是怎么样达到北京的，如下：\n\nconst { path, distance } = unweightedShortestPath(chengdu, beijing);\n// path 成都->西安->北京\n// distance 3\n\n\n下面，我们画图描述一下这个处理流程。\n\n首先，在开始时将成都入队，同时设置距离为0，因为我们设置了它的距离，其实际上就相当于之前我们在广度优先遍历节的时候所提到的标记当前的节点已经被处理的手段，一举两得。接着，我们把成都出队，准备处理它的邻接点。\n\n\n\n紧接着，我们把西安和广州入队\n\n\n\n接着，把西安出队，同时标记成都到西安的最短距离，然后将西安的邻接节点乌鲁木齐和北京入队。\n\n\n\n接着，把广州出队，同时标记成都到广州的最短距离，然后将广州的邻接节点深圳、香港和南京入队。\n\n\n\n接着，把乌鲁木齐出队，同时标记成都到乌鲁木齐的最短距离，然后把乌鲁木齐的邻接节点加入队列（虽然会将其邻接点加入队列，但是因为后面其实这些邻接点并不会重复处理，为了简便起见，我们在图上就不体现其邻接节点加入队列的过程）。\n\n乌鲁木齐到成都需要经过西安，已知成都到西安的距离，故可以求得成都到乌鲁木齐的距离。\n\n\n\n接着，把北京出队，同时标记成都到北京的最短距离，然后把北京的邻接节点加入队列，同理，邻接节点入队这个过程我们图上就没有体现了。\n\n北京到成都需要经过西安，已知成都到西安的距离，故可以求得成都到北京的距离。\n\n\n\n同理可以求得深圳、香港、南京的最短距离。\n\n即最终结果如下：\n\n\n\n因为我们在求解过程中把经过的路径已经计算出来了，类同于链表的原理，我们可以从终点倒推到起点，便可以求得经过的节点，因为这个是一个逆序的结果，所以我们需要使用栈再次将其逆序，即可求得最终的结果。\n\n不管是有向还是无向图，我们都可以使用上述算法求得从某个指定的开始节点到所有节点的最短路径。\n\n\n# 带权图单源最短路径算法\n\n对于这个问题，我们还是基于上面我们使用的那个城市相对位置的例子来阐述，不过，需要引入权重。\n\n\n\n因为增加了权重，上面的表示方法也有一定的调整：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n\n\n\nclass Edge {\n  constructor(name, cost) {\n    this.name = name;\n    this.cost = cost;\n  }\n  /**\n   * 边的编号\n   */\n  name;\n  /**\n   * 起始点\n   * @type {Vertex}\n   */\n  from;\n  /**\n   * 终止点\n   * @type {Vertex}\n   */\n  to;\n  /**\n   * @type {number}\n   */\n  cost;\n}\n\nclass Vertex {\n  constructor(cityName) {\n    this.cityName = cityName;\n  }\n  /**\n   * 城市名称\n   */\n  cityName;\n  /**\n   * 邻接边\n   */\n  edges = [];\n}\n\nclass Graph {\n  /**\n   * 顶点列表\n   */\n  vertexList = [];\n\n  addVertex(v) {\n    this.vertexList.push(v);\n  }\n  /**\n   * 增加边\n   * @param {Vertex} from\n   * @param {Vertex} to\n   * @param {number} cost\n   */\n  addEdge(from, to, cost) {\n    const into = new Edge(`${from.cityName}至${to.cityName}`, cost);\n    const outside = new Edge(`${to.cityName}至${from.cityName}`, cost);\n    // 建立两个城市的指向关系\n    from.edges.push(outside);\n    to.edges.push(into);\n  }\n}\n\n\n然后，初始化数据：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n\n\nconst g = new Graph();\nconst beijing = new Vertex("北京");\nconst nanjing = new Vertex("南京");\nconst guangzhou = new Vertex("广州");\nconst shenzhen = new Vertex("深圳");\nconst hongkong = new Vertex("香港");\nconst chengdu = new Vertex("成都");\nconst xian = new Vertex("西安");\nconst urumchi = new Vertex("乌鲁木齐");\n\n/**\n * 将城市加入到图中\n */\ng.addVertex(beijing);\ng.addVertex(nanjing);\ng.addVertex(guangzhou);\ng.addVertex(shenzhen);\ng.addVertex(hongkong);\ng.addVertex(chengdu);\ng.addVertex(xian);\ng.addVertex(urumchi);\n/**\n * 建立连接关系\n */\ng.addEdge(beijing, nanjing, 35);\ng.addEdge(beijing, xian, 1000);\ng.addEdge(nanjing, guangzhou, 15);\ng.addEdge(guangzhou, shenzhen, 10);\ng.addEdge(guangzhou, hongkong, 10);\ng.addEdge(hongkong, shenzhen, 10);\ng.addEdge(chengdu, guangzhou, 50);\ng.addEdge(chengdu, xian, 120);\ng.addEdge(urumchi, xian, 100);\ng.addEdge(urumchi, beijing, 300);\n\n\n接下来是根据上面图的表示方法给出的对应求解的核心代码，也就是大名鼎鼎的迪杰斯特拉算法：\n\n/**\n * 在图中返回未被收录顶点中dist最小者\n * @param {Graph} graph\n * @param {Map<number, number>} distance\n * @param {Map<Vertex, boolean>} collected\n * @returns {Vertex | null}\n */\nfunction findMinDist(graph, distance, collected) {\n  /* 返回未被收录顶点中dist最小顶点 */\n  let minVertex;\n  let minDist = Infinity;\n  for (let i = 0; i < graph.vertexList.length; i++) {\n    const curVertex = graph.vertexList[i];\n    /* 若curVertex未被收录，且dist.get(curVertex)更小 */\n    if (!collected.get(curVertex) && distance.get(curVertex) < minDist) {\n      /* 更新最小距离 */\n      minDist = distance.get(curVertex);\n      /* 更新对应顶点 */\n      minVertex = curVertex;\n    }\n  }\n  // 如果能够找到这样的顶点，则返回最小的距离，否则，这样的距离不存在\n  return minDist < Infinity ? minVertex : null;\n}\n\n/**\n * 迪杰斯特拉算法求解最短路径\n * @param {Graph} graph\n * @param {Vertex} start\n * @returns\n */\nfunction dijkstra(graph, start) {\n  let collected = new Map();\n  let distance = new Map();\n  let path = new Map();\n  /* 先将起点收入集合 */\n  distance.set(start, 0);\n  collected.set(start, true);\n  graph.vertexList.forEach((vertex) => {\n    if (vertex === start) {\n      // 对start节点本身除外\n      return;\n    }\n    // 找到start节点的邻接点，如果当前节点存在出度指向起点，则证明当前节点是开始节点的邻接点\n    const neighborEdge = vertex.edges.find((v) => v.to === start);\n    // 若存在连接的话，则按权重初试化，否则初始化为无穷大\n    if (neighborEdge) {\n      distance.set(vertex, neighborEdge.cost);\n      path.set(vertex, start);\n    } else {\n      distance.set(vertex, Infinity);\n    }\n  });\n  while (true) {\n    /* vertex为未被收录顶点中distance最小者 */\n    let vertex = findMinDist(graph, distance, collected);\n    /* 若这样的vertex不存在，流程结束 */\n    if (!vertex) {\n      break;\n    }\n    /* 收录vertex */\n    collected.set(vertex, true);\n    /* 遍历图中的每个顶点 */\n    for (let i = 0; i < graph.vertexList.length; i++) {\n      let curVertex = graph.vertexList[i];\n      /* 若curVertex是vertex的邻接点并且未被收录 */\n      const linkEdge = curVertex.edges.find((edge) => edge.to === vertex);\n      if (!collected.get(curVertex) && linkEdge) {\n        /* 若有负边 */\n        if (linkEdge < 0) {\n          /* 不能正确解决，返回错误标记 */\n          return { distance: null, path: null };\n        }\n        /* 若收录vertex使得distance变小 */\n        if (distance.get(vertex) + linkEdge.cost < distance.get(curVertex)) {\n          /* 更新dist */\n          distance.set(curVertex, distance.get(vertex) + linkEdge.cost);\n          /* 更新start到curVertex的路径 */\n          path.set(curVertex, vertex);\n        }\n      }\n    }\n  }\n  return { distance, path };\n}\n\n/**\n * 根据迪杰斯特拉算法求解结果求最终的结果\n * @param {Map<Vertex, number>} distance\n * @param {Map<Vertex, Vertex>} path\n * @param {Vertex} destination\n */\nfunction getShortestPath(path, distance, destination) {\n  if (path === null || distance === null) {\n    return { cost: -1, path: null };\n  }\n  const stack = [destination];\n  let preVertex = path.get(destination);\n  while (preVertex) {\n    stack.push(preVertex);\n    preVertex = path.get(preVertex);\n  }\n  let via = "";\n  let cost = distance.get(destination);\n  while (stack.length) {\n    via += "->" + stack.pop().cityName;\n  }\n  return { path: via.replace(/(^->)|(->$)/g, ""), cost };\n}\n\n\n我们来分析一下迪杰斯特拉算法的求解过程：\n\n首先，将起始节点收录，然后找到它的所有邻接点，如果找的到邻接点的话，初始化该邻接点到起点的距离，并且将该邻接点更新在起始节点的路径上，西安和广州是成都的邻接点，因此可以得到如下图：\n\n\n\n接着，我们找到未收录节点中的最小的节点，经过查找，找到的是广州，因为发现成都到南京，香港，深圳的距离由原来的无穷大变成经过广州再到对应的城市，因此可以更新距离和路径，可以得到如下图：\n\n\n\n接着，继续找到未收录节点中的最小节点，经过查找，找到的是香港，因为发现成都到香港的距离可以保持不变，其邻接点深圳也是处理过的，因此，仅仅需要将香港收录，可以得到下图：\n\n\n\n接着，继续找到未收录节点中的最小节点，经过查找，找到的是深圳，和香港同理，因此可以得到下图：\n\n\n\n接着，我们找到未收录节点中的最小的节点，经过查找，找到的是南京，因为发现成都到北京的距离由原来的无穷大变成经过南京再到北京，因此可以更新距离和路径，可以得到如下图：\n\n\n\n接着，我们找到未收录节点中的最小的节点，经过查找，找到的是北京，因为发现成都到乌鲁木齐的距离由原来的无穷大变成经过北京再到乌鲁木齐，因此可以更新距离和路径，可以得到如下图：\n\n\n\n接着，我们找到未收录节点中的最小的节点，经过查找，找到的是乌鲁木齐，因为发现成都到西安的距离可以保持不变，因此可以不更新距离和路径，可以得到如下图：\n\n\n\n接着，我们找到未收录节点中的最小的节点，经过查找，找到的是西安，因为发现成都到乌鲁木齐的距离可以变得更小，因此可以更新成都到乌鲁木齐距离，并且把西安更新到成都到乌鲁木齐的路径上，可以得到如下图：\n\n\n\n到现在，我们已经把所有的顶点都收录完成了，因此，找不到未收录的最小顶点，退出循环，程序结束。\n\n分析了上面的流程，我们就可以写出迪杰斯特拉算法的伪代码了，如下：\n\n/* 单源有权最短路径算法 */\nfunction dijkstra(vertex) {\n  collected[vertex] = true;\n  for(图中所有顶点 V) {\n    if(当前 V 是 vertex的邻接点) {\n      distance[V] = vertex到V的权重\n      把 V 更新在 vertex的路径上\n    } else {\n      distance[V] = 无穷大\n    }\n  }\n  while(true) {\n    minVertex = 找出未收录顶点的最小者；\n    if(找不到这样的minVertex) {\n      break;\n    }\n    collected[minVertex] = true;\n    for(minVertex 的每个邻接点 neighborVertex) {\n      if(!collected[neighborVertex]) {\n        if(存在负值圈) {\n          return false;\n        }\n        if(distance[minVertex] + minVertex到neighborVertex的权重 < distance[neighborVertex]) {\n          distance[neighborVertex] = distance[neighborVertex] + minVertex到neighborVertex的权重\n          path[neighborVertex] = minVertex\n        }\n      }\n    }\n  }\n  return true;\n}\n\n\n可以看到的是，迪杰斯特拉算法还是基于广度优先的思想在做的，不过神奇的是却没有用到队列，是基于贪心算法的思想，对此有兴趣的同学可以自行查阅相关资料。\n\n需要注意的是，迪杰斯特拉算法是不能解决负值圈的问题的，就好比，你每在那个地方兜一下，不仅不花钱，别人还要倒给你钱，只要你不断兜圈子，那这儿的权重就会变成负无穷。\n\n还有一个需要大家注意的问题是，对于辅助函数findMinDist，每次都找最小值，这个操作我们是否已经在哪儿见过了呀？很容易就联想到，可以引入最小堆来加快每次查找最小未收录节点的效率。\n\n和无权图的情况类似，不管是有向图还是无向图，都可以使用迪杰斯特拉算法进行求解。\n\n\n# 带权图多源最短路径算法\n\n迪杰斯特拉算法解决的是单源最短路径的问题，如何求多源最短路径呢，有的朋友会说，那直接把迪杰斯特拉算法对每个顶点都进行一次求解就可以了啊，这个确实是可以的，但是，还可以有更高明的算法，这就是接下来要阐述的弗洛伊德算法。\n\n不幸的消息又来了，弗洛伊德算法是基于动态规划思想的，在前文我们阐述KMP的时候提到过next数组的求解过程也是基于动态规划的，这是一个老大难问题，这方面比较小白的朋友，可以先尝试学习这门课程，然后再回过来看这篇博客较好。\n\n既然是基于动态规划，那么就一定是存在递推关系的，接下来就看一看这个递推关系是怎么建立的。\n\n令：Dpk[i][j] = 路径 {i->{l<=k}->j}的最小长度，和迪杰斯特拉算法一样，这儿只是表示已经收进到集合中的当前编号小于等于k的顶点从i到j的最短路径。\n\n那么，Dp0[i][j]，Dp1[i][j]，... Dpsize-1[i][j]给出了i到j真正的最短距离，size为图中的顶点个数。\n\n当 Dpk-1[i][j]已经完成，递推到 Dpk[i][j]时，存在下面两种情况：\n\n如果 k∉ 最短路径{i->{l<=k}->j}，则 Dpk-1[i][j] = Dpk[i][j]\n\n如果 k∈ 最短路径{i->{l<=k}->j}，则该路径必定由两段最短路径组成，即： Dpk[i][j] = Dpk-1[i][k] + Dpk-1[k][i](最外层循环控制序列，内两层循环控制两点，所以在求 Dpk[i][j]时，一定已经求出了 Dpk-1[i][k] 和 Dpk-1[k][i])\n\n如果使用邻接矩阵表示图的话，弗洛伊德算法代码看起来会比较简洁，但是我们依然使用上面的那种表示方法，那么实现就如下：\n\n/**\n * 弗洛伊德算法\n * @param {Graph} graph\n */\nfunction floyd(graph) {\n  // 根据图中最大的顶点数初始化dp数组\n  let size = graph.vertexList.length;\n  // 初始化无穷大，为了在日后的计算中将最短距离缩小，dp[i][j]的意义就是任意两点i和j之间的最短距离\n  const dp = Array.from({\n    length: size,\n  }).map(() => {\n    return Array.from({\n      length: size,\n    }).fill(Infinity);\n  });\n  // 初始化为-1，代表两点之间不存在中间节点\n  const path = Array.from({\n    length: size,\n  }).map(() => {\n    return Array.from({\n      length: size,\n    }).fill(-1);\n  });\n  /**\n   * 定义一个求两点之间最短路径的函数\n   * @param {Vertex} start\n   * @param {Vertex} end\n   * @returns\n   */\n  const getShortestPath = (start, end) => {\n    const shortestPath = (i, j) => {\n      let k = path[i][j];\n      // 如果两点之间不存在中间节点\n      if (k < 0) {\n        return (\n          graph.vertexList[i].cityName + "->" + graph.vertexList[j].cityName\n        );\n      }\n      // 从i到k的路径\n      const leftVia = shortestPath(i, k);\n      // 从k到j的路径\n      const rightVia = shortestPath(k, j);\n      // 因为计算途径路径的时候，多算了一个k节点，因此，需要给它替换掉\n      const via = leftVia + "->" + rightVia.replace(/^[\\u4e00-\\u9fa5]+->/, "");\n      return via;\n    };\n    const i = graph.vertexList.findIndex((v) => v === start);\n    const j = graph.vertexList.findIndex((v) => v === end);\n    if (i < 0 || j < 0) {\n      return "";\n    }\n    return shortestPath(i, j);\n  };\n  /**\n   * 定义一个求两点之间最小化肥的函数\n   * @param {Vertex} start\n   * @param {Vertex} end\n   */\n  const getShortestDistance = (start, end) => {\n    const i = graph.vertexList.findIndex((v) => v === start);\n    const j = graph.vertexList.findIndex((v) => v === end);\n    return i >= 0 && j >= 0 ? dp[i][j] : null;\n  };\n  // 初始化dp的值，若两点之间存在边，则初始化为权重，若不存在边，则初始为无穷大\n  for (let i = 0; i < size; i++) {\n    // 将对角线初始化为0，因为不允许自回路\n    dp[i][i] = 0;\n    const v1 = graph.vertexList[i];\n    // 将存在邻接点的点初始化为两点之间的权重，若不存在则初始化为无穷大\n    v1.edges.forEach((edge) => {\n      const j = graph.vertexList.findIndex((x) => x === edge.to);\n      dp[i][j] = edge.cost;\n    });\n  }\n  /**\n   * 错误断言函数\n   */\n  const assertError = () => {\n    throw new Error("存在负值圈，无法计算");\n  };\n  for (k = 0; k < size; k++) {\n    for (i = 0; i < size; i++) {\n      for (j = 0; j < size; j++) {\n        // 将下标为k的节点加入{i->{l<=k}->j}的集合中，如果从i到k的距离和k到j的距离比当前的小，则更新i到j的最短距离，并且i和j之间的最短距离是从i到k再到k到j\n        if (dp[i][k] + dp[k][j] < dp[i][j]) {\n          dp[i][j] = dp[i][k] + dp[k][j];\n          if (i == j && dp[i][j] < 0) {\n            /* 若发现负值圈，不能正确解决，返回错误标记 */\n            return {\n              distance: assertError,\n              path: assertError,\n            };\n          }\n          // 将k更新在i和j之间，表示从i到j必须要途径k节点\n          path[i][j] = k;\n        }\n      }\n    }\n  }\n  return {\n    distance: getShortestDistance,\n    path: getShortestPath,\n  };\n}\n\n\n可以看到，我们一直都在不断地去找顶点的序号，因此，使用邻接矩阵表示的话，这个过程是可以省略的，所以代码会更简洁一些。\n\n上述是对于动态规划的理论描述，如果有同学看起来觉得困难的话，不如先看下文，然后再回过头来看理论描述。\n\n弗洛伊德算法首先先求出任意两点A和B间的距离，然后两点之间加入一个新的点C，原来A和B的距离是否能够被A+C和B+C替换（这就好比把一段线段逐渐打成由几个线段组成的一个过程）。\n\n最外层的循环k其实控制的是对于开始节点i和结束节点j，加入新的节点的个数，随着节点不断地被加入，便可以不断的优化i到j之间的最短距离，最终解出两点之间的最短距离。\n\n比如我们求成都到北京的距离，首先，我们已知北京到西安，西安到成都，南京到北京，南京到广州，广州到成都等城市之间的距离。\n\n首先将北京和成都不存在邻接关系，因此两者之间的距离初始化为正无穷，假设现在我们加入深圳，对北京到成都的距离没有影响（别的城市距离有影响，但我们现在只阐述北京到成都，后续将不再赘述），接着加入南京，可以将北京到广州的距离更新为 50，紧接着，我们加入乌鲁木齐，对于北京到成都的距离没有影响，接着我们加入西安，此时北京到成都的距离可以更新为 1120，假设现在我们加入广州，成都到北京的距离可以更新为 100，后面，我们再加入香港，对于北京到成都的距离已经没有影响了，因此，北京到成都的距离就求解完毕了。\n\n由于这是一个动态的过程，每时每刻都在求以k个顶点为集合中的任意两点间距离，当所有的顶点都加入完毕的时候，就可以求得所有的任意两点间的距离。',normalizedContent:'# 最短路径\n\n最短路径问题，这个问题几乎是我们每天必定会接触到的问题了吧。\n\n当你打开高德地图，输入目的地，高德地图一下就可以给你计算出来了怎么走，甚至还能让你选条件，比如途经点，用时最短，里程最短等条件。我一直感叹其中的神奇，在我没有接触图这章的知识的时候，想破脑袋也不知道其中的原理，但是我从未放弃过要去搞明白计算机是怎么样解决这类问题的。\n\n曾经我有一个朋友，他是银行职员，当时正值炎炎夏日，他需要在一周内拜访成都市区几百家客户，他来求助我，是否可以帮忙写一个程序算一下怎么安排这些客户的拜访顺序，囿于当时我的水平有限，只能遗憾的告诉他我不会啊，真实心疼他。他的这个需求其实是结合了图的最短路径问题和最小生成树问题的场景。\n\n如果你掌握了本节内容，将来和朋友们出去玩儿的时候，编程求解旅行的规划，那应该可以狠狠地秀大家一把吧；\n\n如果你不仅掌握了本节内容，还掌握了后面将会介绍的最小生成树问题，将来某一天大家有类似我朋友这种极端的需求的时候，一定可以帮到他哟，这就是程序员的力量，代码的魅力，加油，拿下这节知识。\n\n\n# 无权图单源最短路\n\n无权图的单源最短路问题，跟我们的广度优先遍历的思路非常相似，我们从起点出发，依次操作当前节点的邻接点，若其还没有处理过，则处理，并且更新起点到这个点的距离，然后还要把这个点加到我们记录的一个路径数据集里面去。重复上述操作，直到处理完图中所有的点。\n\n我们以这个图为例：\n\n\n\n并且以如下表示方法表示图：\n\n/**\n * 边类\n */\nclass edge {\n  constructor(name) {\n    this.name = name;\n  }\n  /**\n   * 边的编号\n   */\n  name;\n  /**\n   * 起始点\n   * @type {vertex}\n   */\n  from;\n  /**\n   * 终止点\n   * @type {vertex}\n   */\n  to;\n}\n\n/**\n * 顶点类\n */\nclass vertex {\n  /**\n   * 城市名称\n   */\n  cityname;\n  /**\n   * 邻接点\n   */\n  siblings = [];\n  constructor(cityname) {\n    this.cityname = cityname;\n  }\n}\n\n/**\n * 图类\n */\nclass graph {\n  /**\n   * 顶点集合\n   * @type {vertex[]}\n   */\n  vertexlist = [];\n  /**\n   * 边集合\n   * @type {edge[]}\n   */\n  edgelist = [];\n  /**\n   * 向图中插入一个顶点\n   */\n  addvertex(v) {\n    this.vertexlist.push(v);\n  }\n  /**\n   * 增加边，连接from和to两个顶点\n   * @param {vertex} from\n   * @param {vertex} to\n   */\n  addedge(from, to) {\n    const name = `${from.cityname}至${to.cityname}`;\n    const edge = new edge(name);\n    this.edgelist.push(edge);\n    from.siblings.push(to);\n    to.siblings.push(from);\n  }\n}\n\n\n接着，根据上面的那个图，构建出我们想要的连接关系：\n\nconst g = new graph();\nconst beijing = new vertex("北京");\nconst nanjing = new vertex("南京");\nconst guangzhou = new vertex("广州");\nconst shenzhen = new vertex("深圳");\nconst hongkong = new vertex("香港");\nconst chengdu = new vertex("成都");\nconst xian = new vertex("西安");\nconst urumchi = new vertex("乌鲁木齐");\n/**\n * 将城市加入到图中\n */\ng.addvertex(beijing);\ng.addvertex(nanjing);\ng.addvertex(guangzhou);\ng.addvertex(shenzhen);\ng.addvertex(hongkong);\ng.addvertex(chengdu);\ng.addvertex(xian);\ng.addvertex(urumchi);\n/**\n * 建立连接关系\n */\ng.addedge(beijing, nanjing);\ng.addedge(beijing, xian);\ng.addedge(nanjing, guangzhou);\ng.addedge(guangzhou, shenzhen);\ng.addedge(guangzhou, hongkong);\ng.addedge(hongkong, shenzhen);\ng.addedge(chengdu, guangzhou);\ng.addedge(chengdu, xian);\ng.addedge(urumchi, xian);\ng.addedge(urumchi, beijing);\n\n\n那么，最短路径求解算法如下：\n\n/**\n * 单源无权图的最短路算法\n * @param {vertex} start\n * @param {vertex} end\n */\nfunction unweightedshortestpath(start, end) {\n  const queue = [];\n  /* 距离哈希表，用于存储开始顶点到任意节点的距离 */\n  const dist = new map();\n  /* 路径哈希表，用于存储开始顶点到任意节点所经过的顶点 */\n  const path = new map();\n  dist.set(start, 0);\n  queue.push(start);\n  while (queue.length > 0) {\n    let vertex = queue.shift();\n    for (let i = 0; i < vertex.siblings.length; i++) {\n      // 取出当前正在处理的顶点的邻接点进行处理\n      let adjoinvertex = vertex.siblings[i];\n      /* 若adjoinvertex未被访问过 */\n      if (typeof dist.get(adjoinvertex) === "undefined") {\n        /* 将这个点到start的距离更新 */\n        dist.set(adjoinvertex, dist.get(vertex) + 1);\n        /* 将这个点记录在s到adjoinvertex的路径上 */\n        path.set(adjoinvertex, vertex);\n        // 并且将当前邻接点入队\n        queue.push(adjoinvertex);\n      }\n    }\n  }\n  // 获取终点的最短路径长度\n  const distance = dist.get(end);\n  // 使用栈记住终点\n  const stack = [end];\n  let prevertex = path.get(end);\n  // 沿途处理从终点到起点所经过的路径\n  while (prevertex) {\n    stack.push(prevertex);\n    // 继续向上迭代，寻找经过的顶点\n    prevertex = path.get(prevertex);\n  }\n  // 经过逆序，得到了正确的路径\n  let via = "";\n  while (stack.length) {\n    const city = stack.pop();\n    via += "->" + city.cityname;\n  }\n  return { distance, path: via.replace(/(^->)|(->$)/g, "") };\n}\n\n\n假设我们想求出成都到北京的最短距离，并且需要求出是怎么样达到北京的，如下：\n\nconst { path, distance } = unweightedshortestpath(chengdu, beijing);\n// path 成都->西安->北京\n// distance 3\n\n\n下面，我们画图描述一下这个处理流程。\n\n首先，在开始时将成都入队，同时设置距离为0，因为我们设置了它的距离，其实际上就相当于之前我们在广度优先遍历节的时候所提到的标记当前的节点已经被处理的手段，一举两得。接着，我们把成都出队，准备处理它的邻接点。\n\n\n\n紧接着，我们把西安和广州入队\n\n\n\n接着，把西安出队，同时标记成都到西安的最短距离，然后将西安的邻接节点乌鲁木齐和北京入队。\n\n\n\n接着，把广州出队，同时标记成都到广州的最短距离，然后将广州的邻接节点深圳、香港和南京入队。\n\n\n\n接着，把乌鲁木齐出队，同时标记成都到乌鲁木齐的最短距离，然后把乌鲁木齐的邻接节点加入队列（虽然会将其邻接点加入队列，但是因为后面其实这些邻接点并不会重复处理，为了简便起见，我们在图上就不体现其邻接节点加入队列的过程）。\n\n乌鲁木齐到成都需要经过西安，已知成都到西安的距离，故可以求得成都到乌鲁木齐的距离。\n\n\n\n接着，把北京出队，同时标记成都到北京的最短距离，然后把北京的邻接节点加入队列，同理，邻接节点入队这个过程我们图上就没有体现了。\n\n北京到成都需要经过西安，已知成都到西安的距离，故可以求得成都到北京的距离。\n\n\n\n同理可以求得深圳、香港、南京的最短距离。\n\n即最终结果如下：\n\n\n\n因为我们在求解过程中把经过的路径已经计算出来了，类同于链表的原理，我们可以从终点倒推到起点，便可以求得经过的节点，因为这个是一个逆序的结果，所以我们需要使用栈再次将其逆序，即可求得最终的结果。\n\n不管是有向还是无向图，我们都可以使用上述算法求得从某个指定的开始节点到所有节点的最短路径。\n\n\n# 带权图单源最短路径算法\n\n对于这个问题，我们还是基于上面我们使用的那个城市相对位置的例子来阐述，不过，需要引入权重。\n\n\n\n因为增加了权重，上面的表示方法也有一定的调整：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n\n\n\nclass edge {\n  constructor(name, cost) {\n    this.name = name;\n    this.cost = cost;\n  }\n  /**\n   * 边的编号\n   */\n  name;\n  /**\n   * 起始点\n   * @type {vertex}\n   */\n  from;\n  /**\n   * 终止点\n   * @type {vertex}\n   */\n  to;\n  /**\n   * @type {number}\n   */\n  cost;\n}\n\nclass vertex {\n  constructor(cityname) {\n    this.cityname = cityname;\n  }\n  /**\n   * 城市名称\n   */\n  cityname;\n  /**\n   * 邻接边\n   */\n  edges = [];\n}\n\nclass graph {\n  /**\n   * 顶点列表\n   */\n  vertexlist = [];\n\n  addvertex(v) {\n    this.vertexlist.push(v);\n  }\n  /**\n   * 增加边\n   * @param {vertex} from\n   * @param {vertex} to\n   * @param {number} cost\n   */\n  addedge(from, to, cost) {\n    const into = new edge(`${from.cityname}至${to.cityname}`, cost);\n    const outside = new edge(`${to.cityname}至${from.cityname}`, cost);\n    // 建立两个城市的指向关系\n    from.edges.push(outside);\n    to.edges.push(into);\n  }\n}\n\n\n然后，初始化数据：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n\n\nconst g = new graph();\nconst beijing = new vertex("北京");\nconst nanjing = new vertex("南京");\nconst guangzhou = new vertex("广州");\nconst shenzhen = new vertex("深圳");\nconst hongkong = new vertex("香港");\nconst chengdu = new vertex("成都");\nconst xian = new vertex("西安");\nconst urumchi = new vertex("乌鲁木齐");\n\n/**\n * 将城市加入到图中\n */\ng.addvertex(beijing);\ng.addvertex(nanjing);\ng.addvertex(guangzhou);\ng.addvertex(shenzhen);\ng.addvertex(hongkong);\ng.addvertex(chengdu);\ng.addvertex(xian);\ng.addvertex(urumchi);\n/**\n * 建立连接关系\n */\ng.addedge(beijing, nanjing, 35);\ng.addedge(beijing, xian, 1000);\ng.addedge(nanjing, guangzhou, 15);\ng.addedge(guangzhou, shenzhen, 10);\ng.addedge(guangzhou, hongkong, 10);\ng.addedge(hongkong, shenzhen, 10);\ng.addedge(chengdu, guangzhou, 50);\ng.addedge(chengdu, xian, 120);\ng.addedge(urumchi, xian, 100);\ng.addedge(urumchi, beijing, 300);\n\n\n接下来是根据上面图的表示方法给出的对应求解的核心代码，也就是大名鼎鼎的迪杰斯特拉算法：\n\n/**\n * 在图中返回未被收录顶点中dist最小者\n * @param {graph} graph\n * @param {map<number, number>} distance\n * @param {map<vertex, boolean>} collected\n * @returns {vertex | null}\n */\nfunction findmindist(graph, distance, collected) {\n  /* 返回未被收录顶点中dist最小顶点 */\n  let minvertex;\n  let mindist = infinity;\n  for (let i = 0; i < graph.vertexlist.length; i++) {\n    const curvertex = graph.vertexlist[i];\n    /* 若curvertex未被收录，且dist.get(curvertex)更小 */\n    if (!collected.get(curvertex) && distance.get(curvertex) < mindist) {\n      /* 更新最小距离 */\n      mindist = distance.get(curvertex);\n      /* 更新对应顶点 */\n      minvertex = curvertex;\n    }\n  }\n  // 如果能够找到这样的顶点，则返回最小的距离，否则，这样的距离不存在\n  return mindist < infinity ? minvertex : null;\n}\n\n/**\n * 迪杰斯特拉算法求解最短路径\n * @param {graph} graph\n * @param {vertex} start\n * @returns\n */\nfunction dijkstra(graph, start) {\n  let collected = new map();\n  let distance = new map();\n  let path = new map();\n  /* 先将起点收入集合 */\n  distance.set(start, 0);\n  collected.set(start, true);\n  graph.vertexlist.foreach((vertex) => {\n    if (vertex === start) {\n      // 对start节点本身除外\n      return;\n    }\n    // 找到start节点的邻接点，如果当前节点存在出度指向起点，则证明当前节点是开始节点的邻接点\n    const neighboredge = vertex.edges.find((v) => v.to === start);\n    // 若存在连接的话，则按权重初试化，否则初始化为无穷大\n    if (neighboredge) {\n      distance.set(vertex, neighboredge.cost);\n      path.set(vertex, start);\n    } else {\n      distance.set(vertex, infinity);\n    }\n  });\n  while (true) {\n    /* vertex为未被收录顶点中distance最小者 */\n    let vertex = findmindist(graph, distance, collected);\n    /* 若这样的vertex不存在，流程结束 */\n    if (!vertex) {\n      break;\n    }\n    /* 收录vertex */\n    collected.set(vertex, true);\n    /* 遍历图中的每个顶点 */\n    for (let i = 0; i < graph.vertexlist.length; i++) {\n      let curvertex = graph.vertexlist[i];\n      /* 若curvertex是vertex的邻接点并且未被收录 */\n      const linkedge = curvertex.edges.find((edge) => edge.to === vertex);\n      if (!collected.get(curvertex) && linkedge) {\n        /* 若有负边 */\n        if (linkedge < 0) {\n          /* 不能正确解决，返回错误标记 */\n          return { distance: null, path: null };\n        }\n        /* 若收录vertex使得distance变小 */\n        if (distance.get(vertex) + linkedge.cost < distance.get(curvertex)) {\n          /* 更新dist */\n          distance.set(curvertex, distance.get(vertex) + linkedge.cost);\n          /* 更新start到curvertex的路径 */\n          path.set(curvertex, vertex);\n        }\n      }\n    }\n  }\n  return { distance, path };\n}\n\n/**\n * 根据迪杰斯特拉算法求解结果求最终的结果\n * @param {map<vertex, number>} distance\n * @param {map<vertex, vertex>} path\n * @param {vertex} destination\n */\nfunction getshortestpath(path, distance, destination) {\n  if (path === null || distance === null) {\n    return { cost: -1, path: null };\n  }\n  const stack = [destination];\n  let prevertex = path.get(destination);\n  while (prevertex) {\n    stack.push(prevertex);\n    prevertex = path.get(prevertex);\n  }\n  let via = "";\n  let cost = distance.get(destination);\n  while (stack.length) {\n    via += "->" + stack.pop().cityname;\n  }\n  return { path: via.replace(/(^->)|(->$)/g, ""), cost };\n}\n\n\n我们来分析一下迪杰斯特拉算法的求解过程：\n\n首先，将起始节点收录，然后找到它的所有邻接点，如果找的到邻接点的话，初始化该邻接点到起点的距离，并且将该邻接点更新在起始节点的路径上，西安和广州是成都的邻接点，因此可以得到如下图：\n\n\n\n接着，我们找到未收录节点中的最小的节点，经过查找，找到的是广州，因为发现成都到南京，香港，深圳的距离由原来的无穷大变成经过广州再到对应的城市，因此可以更新距离和路径，可以得到如下图：\n\n\n\n接着，继续找到未收录节点中的最小节点，经过查找，找到的是香港，因为发现成都到香港的距离可以保持不变，其邻接点深圳也是处理过的，因此，仅仅需要将香港收录，可以得到下图：\n\n\n\n接着，继续找到未收录节点中的最小节点，经过查找，找到的是深圳，和香港同理，因此可以得到下图：\n\n\n\n接着，我们找到未收录节点中的最小的节点，经过查找，找到的是南京，因为发现成都到北京的距离由原来的无穷大变成经过南京再到北京，因此可以更新距离和路径，可以得到如下图：\n\n\n\n接着，我们找到未收录节点中的最小的节点，经过查找，找到的是北京，因为发现成都到乌鲁木齐的距离由原来的无穷大变成经过北京再到乌鲁木齐，因此可以更新距离和路径，可以得到如下图：\n\n\n\n接着，我们找到未收录节点中的最小的节点，经过查找，找到的是乌鲁木齐，因为发现成都到西安的距离可以保持不变，因此可以不更新距离和路径，可以得到如下图：\n\n\n\n接着，我们找到未收录节点中的最小的节点，经过查找，找到的是西安，因为发现成都到乌鲁木齐的距离可以变得更小，因此可以更新成都到乌鲁木齐距离，并且把西安更新到成都到乌鲁木齐的路径上，可以得到如下图：\n\n\n\n到现在，我们已经把所有的顶点都收录完成了，因此，找不到未收录的最小顶点，退出循环，程序结束。\n\n分析了上面的流程，我们就可以写出迪杰斯特拉算法的伪代码了，如下：\n\n/* 单源有权最短路径算法 */\nfunction dijkstra(vertex) {\n  collected[vertex] = true;\n  for(图中所有顶点 v) {\n    if(当前 v 是 vertex的邻接点) {\n      distance[v] = vertex到v的权重\n      把 v 更新在 vertex的路径上\n    } else {\n      distance[v] = 无穷大\n    }\n  }\n  while(true) {\n    minvertex = 找出未收录顶点的最小者；\n    if(找不到这样的minvertex) {\n      break;\n    }\n    collected[minvertex] = true;\n    for(minvertex 的每个邻接点 neighborvertex) {\n      if(!collected[neighborvertex]) {\n        if(存在负值圈) {\n          return false;\n        }\n        if(distance[minvertex] + minvertex到neighborvertex的权重 < distance[neighborvertex]) {\n          distance[neighborvertex] = distance[neighborvertex] + minvertex到neighborvertex的权重\n          path[neighborvertex] = minvertex\n        }\n      }\n    }\n  }\n  return true;\n}\n\n\n可以看到的是，迪杰斯特拉算法还是基于广度优先的思想在做的，不过神奇的是却没有用到队列，是基于贪心算法的思想，对此有兴趣的同学可以自行查阅相关资料。\n\n需要注意的是，迪杰斯特拉算法是不能解决负值圈的问题的，就好比，你每在那个地方兜一下，不仅不花钱，别人还要倒给你钱，只要你不断兜圈子，那这儿的权重就会变成负无穷。\n\n还有一个需要大家注意的问题是，对于辅助函数findmindist，每次都找最小值，这个操作我们是否已经在哪儿见过了呀？很容易就联想到，可以引入最小堆来加快每次查找最小未收录节点的效率。\n\n和无权图的情况类似，不管是有向图还是无向图，都可以使用迪杰斯特拉算法进行求解。\n\n\n# 带权图多源最短路径算法\n\n迪杰斯特拉算法解决的是单源最短路径的问题，如何求多源最短路径呢，有的朋友会说，那直接把迪杰斯特拉算法对每个顶点都进行一次求解就可以了啊，这个确实是可以的，但是，还可以有更高明的算法，这就是接下来要阐述的弗洛伊德算法。\n\n不幸的消息又来了，弗洛伊德算法是基于动态规划思想的，在前文我们阐述kmp的时候提到过next数组的求解过程也是基于动态规划的，这是一个老大难问题，这方面比较小白的朋友，可以先尝试学习这门课程，然后再回过来看这篇博客较好。\n\n既然是基于动态规划，那么就一定是存在递推关系的，接下来就看一看这个递推关系是怎么建立的。\n\n令：dpk[i][j] = 路径 {i->{l<=k}->j}的最小长度，和迪杰斯特拉算法一样，这儿只是表示已经收进到集合中的当前编号小于等于k的顶点从i到j的最短路径。\n\n那么，dp0[i][j]，dp1[i][j]，... dpsize-1[i][j]给出了i到j真正的最短距离，size为图中的顶点个数。\n\n当 dpk-1[i][j]已经完成，递推到 dpk[i][j]时，存在下面两种情况：\n\n如果 k∈ 最短路径{i->{l<=k}->j}，则 dpk-1[i][j] = dpk[i][j]\n\n如果 k∈ 最短路径{i->{l<=k}->j}，则该路径必定由两段最短路径组成，即： dpk[i][j] = dpk-1[i][k] + dpk-1[k][i](最外层循环控制序列，内两层循环控制两点，所以在求 dpk[i][j]时，一定已经求出了 dpk-1[i][k] 和 dpk-1[k][i])\n\n如果使用邻接矩阵表示图的话，弗洛伊德算法代码看起来会比较简洁，但是我们依然使用上面的那种表示方法，那么实现就如下：\n\n/**\n * 弗洛伊德算法\n * @param {graph} graph\n */\nfunction floyd(graph) {\n  // 根据图中最大的顶点数初始化dp数组\n  let size = graph.vertexlist.length;\n  // 初始化无穷大，为了在日后的计算中将最短距离缩小，dp[i][j]的意义就是任意两点i和j之间的最短距离\n  const dp = array.from({\n    length: size,\n  }).map(() => {\n    return array.from({\n      length: size,\n    }).fill(infinity);\n  });\n  // 初始化为-1，代表两点之间不存在中间节点\n  const path = array.from({\n    length: size,\n  }).map(() => {\n    return array.from({\n      length: size,\n    }).fill(-1);\n  });\n  /**\n   * 定义一个求两点之间最短路径的函数\n   * @param {vertex} start\n   * @param {vertex} end\n   * @returns\n   */\n  const getshortestpath = (start, end) => {\n    const shortestpath = (i, j) => {\n      let k = path[i][j];\n      // 如果两点之间不存在中间节点\n      if (k < 0) {\n        return (\n          graph.vertexlist[i].cityname + "->" + graph.vertexlist[j].cityname\n        );\n      }\n      // 从i到k的路径\n      const leftvia = shortestpath(i, k);\n      // 从k到j的路径\n      const rightvia = shortestpath(k, j);\n      // 因为计算途径路径的时候，多算了一个k节点，因此，需要给它替换掉\n      const via = leftvia + "->" + rightvia.replace(/^[\\u4e00-\\u9fa5]+->/, "");\n      return via;\n    };\n    const i = graph.vertexlist.findindex((v) => v === start);\n    const j = graph.vertexlist.findindex((v) => v === end);\n    if (i < 0 || j < 0) {\n      return "";\n    }\n    return shortestpath(i, j);\n  };\n  /**\n   * 定义一个求两点之间最小化肥的函数\n   * @param {vertex} start\n   * @param {vertex} end\n   */\n  const getshortestdistance = (start, end) => {\n    const i = graph.vertexlist.findindex((v) => v === start);\n    const j = graph.vertexlist.findindex((v) => v === end);\n    return i >= 0 && j >= 0 ? dp[i][j] : null;\n  };\n  // 初始化dp的值，若两点之间存在边，则初始化为权重，若不存在边，则初始为无穷大\n  for (let i = 0; i < size; i++) {\n    // 将对角线初始化为0，因为不允许自回路\n    dp[i][i] = 0;\n    const v1 = graph.vertexlist[i];\n    // 将存在邻接点的点初始化为两点之间的权重，若不存在则初始化为无穷大\n    v1.edges.foreach((edge) => {\n      const j = graph.vertexlist.findindex((x) => x === edge.to);\n      dp[i][j] = edge.cost;\n    });\n  }\n  /**\n   * 错误断言函数\n   */\n  const asserterror = () => {\n    throw new error("存在负值圈，无法计算");\n  };\n  for (k = 0; k < size; k++) {\n    for (i = 0; i < size; i++) {\n      for (j = 0; j < size; j++) {\n        // 将下标为k的节点加入{i->{l<=k}->j}的集合中，如果从i到k的距离和k到j的距离比当前的小，则更新i到j的最短距离，并且i和j之间的最短距离是从i到k再到k到j\n        if (dp[i][k] + dp[k][j] < dp[i][j]) {\n          dp[i][j] = dp[i][k] + dp[k][j];\n          if (i == j && dp[i][j] < 0) {\n            /* 若发现负值圈，不能正确解决，返回错误标记 */\n            return {\n              distance: asserterror,\n              path: asserterror,\n            };\n          }\n          // 将k更新在i和j之间，表示从i到j必须要途径k节点\n          path[i][j] = k;\n        }\n      }\n    }\n  }\n  return {\n    distance: getshortestdistance,\n    path: getshortestpath,\n  };\n}\n\n\n可以看到，我们一直都在不断地去找顶点的序号，因此，使用邻接矩阵表示的话，这个过程是可以省略的，所以代码会更简洁一些。\n\n上述是对于动态规划的理论描述，如果有同学看起来觉得困难的话，不如先看下文，然后再回过头来看理论描述。\n\n弗洛伊德算法首先先求出任意两点a和b间的距离，然后两点之间加入一个新的点c，原来a和b的距离是否能够被a+c和b+c替换（这就好比把一段线段逐渐打成由几个线段组成的一个过程）。\n\n最外层的循环k其实控制的是对于开始节点i和结束节点j，加入新的节点的个数，随着节点不断地被加入，便可以不断的优化i到j之间的最短距离，最终解出两点之间的最短距离。\n\n比如我们求成都到北京的距离，首先，我们已知北京到西安，西安到成都，南京到北京，南京到广州，广州到成都等城市之间的距离。\n\n首先将北京和成都不存在邻接关系，因此两者之间的距离初始化为正无穷，假设现在我们加入深圳，对北京到成都的距离没有影响（别的城市距离有影响，但我们现在只阐述北京到成都，后续将不再赘述），接着加入南京，可以将北京到广州的距离更新为 50，紧接着，我们加入乌鲁木齐，对于北京到成都的距离没有影响，接着我们加入西安，此时北京到成都的距离可以更新为 1120，假设现在我们加入广州，成都到北京的距离可以更新为 100，后面，我们再加入香港，对于北京到成都的距离已经没有影响了，因此，北京到成都的距离就求解完毕了。\n\n由于这是一个动态的过程，每时每刻都在求以k个顶点为集合中的任意两点间距离，当所有的顶点都加入完毕的时候，就可以求得所有的任意两点间的距离。',charsets:{cjk:!0}},{title:"拓扑排序",frontmatter:{},regularPath:"/data-structure/graph/topology-sort.html",relativePath:"data-structure/graph/topology-sort.md",key:"v-76a57669",path:"/data-structure/graph/topology-sort.html",headers:[{level:2,title:"拓扑排序",slug:"拓扑排序",normalizedTitle:"拓扑排序",charIndex:2}],headersStr:"拓扑排序",content:"# 拓扑排序\n\n建设中，敬请期待...",normalizedContent:"# 拓扑排序\n\n建设中，敬请期待...",charsets:{cjk:!0}},{title:"构建树",frontmatter:{},regularPath:"/data-structure/hash/buildTree.html",relativePath:"data-structure/hash/buildTree.md",key:"v-217dde16",path:"/data-structure/hash/buildTree.html",headers:[{level:2,title:"构建树",slug:"构建树",normalizedTitle:"构建树",charIndex:2},{level:3,title:"递归法",slug:"递归法",normalizedTitle:"递归法",charIndex:585},{level:3,title:"哈希法",slug:"哈希法",normalizedTitle:"哈希法",charIndex:1385}],headersStr:"构建树 递归法 哈希法",content:"# 构建树\n\n这是一个在实际开发中相当常见的一个需求了。\n\n有些时候，是因为后端直接返回树结构的话，序列化时i/o开销比较大，在高并发场景下，会使得服务器的效率降低，因此不得不让前端自行构建树型结构的数据。\n\n还有一种情况就比较搞笑了，这种情况一般出现在小公司，你的后端因为某些不可告人的秘密，告诉你只能给你返回数组。但是我们前端又必须需要一个树状结构。此时为了避免尴尬，前端可能会要求后端怎么样操作简单就怎么样约定数据格式了，然后前端按照相应的规格自己将其构建成树。\n\n一般，后端给到前端的数据是这样的，我就以文件列表的例子来举例。\n\n/**\n * 文件信息\n */\ninterface File {\n  /**\n   * 文件的ID，需要使用string类型，若使用number类型，当id特别大的时候，前端解析的结果将不正确\n   */\n  id: string;\n\n  /**\n   * 文件的父级ID, 可能不存在\n   */\n  pid: string | null;\n\n  /**\n   * 文件名\n   */\n  filename: string;\n\n  /**\n   * 文件类型，比如是文件还是文件夹\n   */\n  type: number;\n\n  /**\n   * 子文件列表\n   */\n  children?: File[];\n}\n\n\n\n# 递归法\n\n/**\n * 构建文件树\n * @param file 文件信息\n * @param file 文件列表信息\n */\nfunction buildTree(file: File, files: File[]) {\n  // 找到当前文件的子文件列表\n  let children = files.filter((fileEle: File) => {\n    return fileEle.pid === file.id;\n  });\n  // 递归的处理当前文件子文件列表的子文件\n  file.children =\n    children.length === 0\n      ? undefined\n      : children.map((subFile: File) => buildTree(subFile, files));\n  return file;\n}\n\n/**\n * 将文件列表转为文件树，并且返回根节点\n * @param files 文件列表\n */\nfunction build(files: File[]) {\n  // 构建结果\n  const roots = files\n    .filter((file) => {\n      // 这一步操作是为了找到所有的根节点\n      return file.pid === null;\n    })\n    .map((file) => {\n      // 对根节点的数据进行构建\n      return buildTree(file, files);\n    });\n  return roots;\n}\n\n\n递归法的时间复杂度为O(n)，并且还有一个额外的O(h)的空间复杂度（递归调用时的堆栈空间占用），而且这个是有一定的风险的，当数据量比较大的时候，JS 可能会出最大调用栈的报错。\n\n\n# 哈希法\n\n这个方案是有点儿取巧的一种做法了，因为其完美的利用了引用类型数据的特征，因为引用数据类型，大家都同时持有一块相同的内存区域，不同的人对它进行修改，都会在它的身上得到体现。\n\n这是我曾经偶然一次自己写代码时发现的，后来在论坛上发现了大佬们也是这样做的，心里面还稍稍的窃喜了一下。\n\n/**\n * 将文件列表转换成为哈希表\n * @param {File[]} files\n */\nfunction makeHashMap(files) {\n  const map = new Map();\n  files.forEach((file) => {\n    // 以ID为主键建立哈希映射\n    map.set(file.id, file);\n  });\n  return map;\n}\n\nfunction buildTree(files) {\n  // 将文件构建成哈希表，主要是为了后续的查找方便\n  const fileMap = makeHashMap(files);\n  const roots = [];\n  // 逐个的对每个文件增加子元素\n  files.forEach((file) => {\n    // 找父级文件，如果找不到的话，说明是根节点\n    const parentFile = fileMap.get(file.pid);\n    if (parentFile) {\n      if (!Array.isArray(parentFile.children)) {\n        parentFile.children = [file];\n      } else {\n        parentFile.children.push(file);\n      }\n    } else {\n      roots.push(file);\n    }\n  });\n  // 最后只需要找出根节点的文件列表即可完成构建\n  return roots;\n}\n\n\n哈希法，将文件列表建立哈希，时间复杂度为O(N)，空间复杂度是O(N)，在构建时一次遍历，时间复杂度为O(N)，申明了一个用于存根节点存储的数组，最坏情况下，全部都是根节点，空间复杂度是O(N)，因此，哈希法的时间复杂度为O(N)，空间复杂度是O(N)，完爆递归法，而且代码也简洁易懂，不用担心在数据量较大的时候爆栈的风险。",normalizedContent:"# 构建树\n\n这是一个在实际开发中相当常见的一个需求了。\n\n有些时候，是因为后端直接返回树结构的话，序列化时i/o开销比较大，在高并发场景下，会使得服务器的效率降低，因此不得不让前端自行构建树型结构的数据。\n\n还有一种情况就比较搞笑了，这种情况一般出现在小公司，你的后端因为某些不可告人的秘密，告诉你只能给你返回数组。但是我们前端又必须需要一个树状结构。此时为了避免尴尬，前端可能会要求后端怎么样操作简单就怎么样约定数据格式了，然后前端按照相应的规格自己将其构建成树。\n\n一般，后端给到前端的数据是这样的，我就以文件列表的例子来举例。\n\n/**\n * 文件信息\n */\ninterface file {\n  /**\n   * 文件的id，需要使用string类型，若使用number类型，当id特别大的时候，前端解析的结果将不正确\n   */\n  id: string;\n\n  /**\n   * 文件的父级id, 可能不存在\n   */\n  pid: string | null;\n\n  /**\n   * 文件名\n   */\n  filename: string;\n\n  /**\n   * 文件类型，比如是文件还是文件夹\n   */\n  type: number;\n\n  /**\n   * 子文件列表\n   */\n  children?: file[];\n}\n\n\n\n# 递归法\n\n/**\n * 构建文件树\n * @param file 文件信息\n * @param file 文件列表信息\n */\nfunction buildtree(file: file, files: file[]) {\n  // 找到当前文件的子文件列表\n  let children = files.filter((fileele: file) => {\n    return fileele.pid === file.id;\n  });\n  // 递归的处理当前文件子文件列表的子文件\n  file.children =\n    children.length === 0\n      ? undefined\n      : children.map((subfile: file) => buildtree(subfile, files));\n  return file;\n}\n\n/**\n * 将文件列表转为文件树，并且返回根节点\n * @param files 文件列表\n */\nfunction build(files: file[]) {\n  // 构建结果\n  const roots = files\n    .filter((file) => {\n      // 这一步操作是为了找到所有的根节点\n      return file.pid === null;\n    })\n    .map((file) => {\n      // 对根节点的数据进行构建\n      return buildtree(file, files);\n    });\n  return roots;\n}\n\n\n递归法的时间复杂度为o(n)，并且还有一个额外的o(h)的空间复杂度（递归调用时的堆栈空间占用），而且这个是有一定的风险的，当数据量比较大的时候，js 可能会出最大调用栈的报错。\n\n\n# 哈希法\n\n这个方案是有点儿取巧的一种做法了，因为其完美的利用了引用类型数据的特征，因为引用数据类型，大家都同时持有一块相同的内存区域，不同的人对它进行修改，都会在它的身上得到体现。\n\n这是我曾经偶然一次自己写代码时发现的，后来在论坛上发现了大佬们也是这样做的，心里面还稍稍的窃喜了一下。\n\n/**\n * 将文件列表转换成为哈希表\n * @param {file[]} files\n */\nfunction makehashmap(files) {\n  const map = new map();\n  files.foreach((file) => {\n    // 以id为主键建立哈希映射\n    map.set(file.id, file);\n  });\n  return map;\n}\n\nfunction buildtree(files) {\n  // 将文件构建成哈希表，主要是为了后续的查找方便\n  const filemap = makehashmap(files);\n  const roots = [];\n  // 逐个的对每个文件增加子元素\n  files.foreach((file) => {\n    // 找父级文件，如果找不到的话，说明是根节点\n    const parentfile = filemap.get(file.pid);\n    if (parentfile) {\n      if (!array.isarray(parentfile.children)) {\n        parentfile.children = [file];\n      } else {\n        parentfile.children.push(file);\n      }\n    } else {\n      roots.push(file);\n    }\n  });\n  // 最后只需要找出根节点的文件列表即可完成构建\n  return roots;\n}\n\n\n哈希法，将文件列表建立哈希，时间复杂度为o(n)，空间复杂度是o(n)，在构建时一次遍历，时间复杂度为o(n)，申明了一个用于存根节点存储的数组，最坏情况下，全部都是根节点，空间复杂度是o(n)，因此，哈希法的时间复杂度为o(n)，空间复杂度是o(n)，完爆递归法，而且代码也简洁易懂，不用担心在数据量较大的时候爆栈的风险。",charsets:{cjk:!0}},{title:"深克隆",frontmatter:{},regularPath:"/data-structure/hash/deepClone.html",relativePath:"data-structure/hash/deepClone.md",key:"v-e036e756",path:"/data-structure/hash/deepClone.html",headers:[{level:2,title:"深克隆",slug:"深克隆",normalizedTitle:"深克隆",charIndex:2}],headersStr:"深克隆",content:'# 深克隆\n\n本文不介绍深克隆和浅克隆的区别，若对此有疑惑的朋友请自行查阅资料\n\n另外，本文主要是阐述哈希表的应用，给出的实现并没有完全考虑深克隆中各种可能的问题，如果对此感兴趣的朋友可以自行查阅lodash的源码。\n\n再者，在深拷贝中，我们使用哈希表，需要使用Map或者WeakMap，因为使用对象作为哈希表的话，无法用对象作为key。\n\n深拷贝的算法实现思路，最简单的就是递归了，把已经拷贝过的对象和新生成的对象映射加入到哈希表中去，并且递归拷贝的时候，要带上这个哈希表递归。需要注意一点就是，拷贝过程中，一旦新生成的对象产生，就需要建立映射，而不是，等拷贝完成再建立映射，否则就无法区分当前对象是否已经被拷贝了，出现最大调用堆栈报错。\n\n算法实现如下：\n\n/**\n * 使用深度优先深克隆对象\n * @param {Array<any> | object} obj\n * @param { Map<Array<any> | object, Array<any> | object> } map\n * @returns\n */\nfunction deepClone(obj, map = new Map()) {\n  // 如果已经拷贝过，则可以直接返回拷贝过的值，主要是为了防止循环引用\n  let cloneObj = map.get(obj);\n  if (typeof cloneObj !== "undefined") {\n    return cloneObj;\n  }\n  // 初始化拷贝的对象\n  cloneObj = Array.isArray(obj) ? [] : {};\n  // 建立已经拷贝的引用，不能再开始拷贝属性了再建立拷贝引用，否则将会导致递归最大调用栈的问题发生\n  map.set(obj, cloneObj);\n  // 对拷贝对象挨个赋值\n  for (let prop in obj) {\n    // 遇到对象，则递归拷贝\n    if (obj[prop] instanceof Object) {\n      cloneObj[prop] = deepClone(obj[prop], map);\n      // 拷贝完成后，还要将其加入引用Map中去\n      map.set(obj[prop], cloneObj[prop]);\n    } else {\n      cloneObj[prop] = obj[prop];\n    }\n  }\n  return cloneObj;\n}\n',normalizedContent:'# 深克隆\n\n本文不介绍深克隆和浅克隆的区别，若对此有疑惑的朋友请自行查阅资料\n\n另外，本文主要是阐述哈希表的应用，给出的实现并没有完全考虑深克隆中各种可能的问题，如果对此感兴趣的朋友可以自行查阅lodash的源码。\n\n再者，在深拷贝中，我们使用哈希表，需要使用map或者weakmap，因为使用对象作为哈希表的话，无法用对象作为key。\n\n深拷贝的算法实现思路，最简单的就是递归了，把已经拷贝过的对象和新生成的对象映射加入到哈希表中去，并且递归拷贝的时候，要带上这个哈希表递归。需要注意一点就是，拷贝过程中，一旦新生成的对象产生，就需要建立映射，而不是，等拷贝完成再建立映射，否则就无法区分当前对象是否已经被拷贝了，出现最大调用堆栈报错。\n\n算法实现如下：\n\n/**\n * 使用深度优先深克隆对象\n * @param {array<any> | object} obj\n * @param { map<array<any> | object, array<any> | object> } map\n * @returns\n */\nfunction deepclone(obj, map = new map()) {\n  // 如果已经拷贝过，则可以直接返回拷贝过的值，主要是为了防止循环引用\n  let cloneobj = map.get(obj);\n  if (typeof cloneobj !== "undefined") {\n    return cloneobj;\n  }\n  // 初始化拷贝的对象\n  cloneobj = array.isarray(obj) ? [] : {};\n  // 建立已经拷贝的引用，不能再开始拷贝属性了再建立拷贝引用，否则将会导致递归最大调用栈的问题发生\n  map.set(obj, cloneobj);\n  // 对拷贝对象挨个赋值\n  for (let prop in obj) {\n    // 遇到对象，则递归拷贝\n    if (obj[prop] instanceof object) {\n      cloneobj[prop] = deepclone(obj[prop], map);\n      // 拷贝完成后，还要将其加入引用map中去\n      map.set(obj[prop], cloneobj[prop]);\n    } else {\n      cloneobj[prop] = obj[prop];\n    }\n  }\n  return cloneobj;\n}\n',charsets:{cjk:!0}},{title:"哈希表的概念",frontmatter:{},regularPath:"/data-structure/hash/desc.html",relativePath:"data-structure/hash/desc.md",key:"v-9139b18a",path:"/data-structure/hash/desc.html",headers:[{level:2,title:"哈希表的概念",slug:"哈希表的概念",normalizedTitle:"哈希表的概念",charIndex:2},{level:2,title:"实际开发中的哈希表",slug:"实际开发中的哈希表",normalizedTitle:"实际开发中的哈希表",charIndex:421}],headersStr:"哈希表的概念 实际开发中的哈希表",content:"# 哈希表的概念\n\n散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。（copy 自百度百科）\n\n在实际的开发中，我们并不需要真正的去编写哈希函数，不会去实现关键字到地址的映射，或者知道怎么去处理哈希冲突这类操作。\n\n每当存储的每一个关键字，表中就会多加入用相应的内容，因此增加一条映射空间复杂度计为O(1)；每次我们对数据的访问是一次直接的常数运算，因此时间复杂度计为O(1)。\n\n因为哈希表的查找非常快速，所以在实际开发中我们经常用它空间换时间（现在的计算机的性能都非常可观的，因此，我们会更加追求程序的运行速度）降低程序的时间复杂度。比如我们会根据数据的唯一性标识建立映射关系，后面在需要用到这个数据的时候，直接用它的唯一性标识从哈希表中读取。\n\n\n# 实际开发中的哈希表\n\n在 JS 中，我们的对象本身就是一个哈希表，因此经常我们可以在代码中看到这样的代码.\n\nconst map = Object.create(null);\n\n\n在 JS 中，使用对象做哈希表存在一个问题，只能使用字符串或者Symbol作为key。\n\nES6 中引入了两个新的结构，Map和WeakMap，可以支持任意类型做 key。关于 ES 的语法的问题，我们不在这儿细讲，后面会在专门的专题细讲。\n\n关于哈希表没有什么特别多的概念可讲，因此，哈希表这一章节，我们主要是阐述其应用。",normalizedContent:"# 哈希表的概念\n\n散列表（hash table，也叫哈希表），是根据关键码值(key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。（copy 自百度百科）\n\n在实际的开发中，我们并不需要真正的去编写哈希函数，不会去实现关键字到地址的映射，或者知道怎么去处理哈希冲突这类操作。\n\n每当存储的每一个关键字，表中就会多加入用相应的内容，因此增加一条映射空间复杂度计为o(1)；每次我们对数据的访问是一次直接的常数运算，因此时间复杂度计为o(1)。\n\n因为哈希表的查找非常快速，所以在实际开发中我们经常用它空间换时间（现在的计算机的性能都非常可观的，因此，我们会更加追求程序的运行速度）降低程序的时间复杂度。比如我们会根据数据的唯一性标识建立映射关系，后面在需要用到这个数据的时候，直接用它的唯一性标识从哈希表中读取。\n\n\n# 实际开发中的哈希表\n\n在 js 中，我们的对象本身就是一个哈希表，因此经常我们可以在代码中看到这样的代码.\n\nconst map = object.create(null);\n\n\n在 js 中，使用对象做哈希表存在一个问题，只能使用字符串或者symbol作为key。\n\nes6 中引入了两个新的结构，map和weakmap，可以支持任意类型做 key。关于 es 的语法的问题，我们不在这儿细讲，后面会在专门的专题细讲。\n\n关于哈希表没有什么特别多的概念可讲，因此，哈希表这一章节，我们主要是阐述其应用。",charsets:{cjk:!0}},{title:"从链表中删去总和值为零的连续节点",frontmatter:{},regularPath:"/data-structure/hash/removeZero.html",relativePath:"data-structure/hash/removeZero.md",key:"v-49904405",path:"/data-structure/hash/removeZero.html",headers:[{level:2,title:"从链表中删去总和值为零的连续节点",slug:"从链表中删去总和值为零的连续节点",normalizedTitle:"从链表中删去总和值为零的连续节点",charIndex:2}],headersStr:"从链表中删去总和值为零的连续节点",content:"# 从链表中删去总和值为零的连续节点\n\n给你一个链表的头节点 head，请你编写代码，反复删去链表中由 总和值为 0 的连续节点组成的序列，直到不存在这样的序列为止。\n\n删除完毕后，请你返回最终结果链表的头节点。\n\n> 输入：head = [1,2,-3,3,1] 输出：[3,1] 提示：答案 [1,2,1] 也是正确的。\n> >\n> 输入：head = [1,2,3,-3,4] 输出：[1,2,4]\n\n这题难就难在我们操作的对象是个链表，如果是数组的话，一下就变得特别简单了，从第一个数开始出发，遇到 0 可以直接删除，或者总和为 0 的时候，也可以把之前累加的都删除掉。如果一直加到最后都没有和为 0 的结果，那么就从第二个出发，以此类推，直到遍历到最后一个数。\n\n关键是现在换成了链表，不过想一下，还是可以把一个链表变成像数组那样操作，那么自然而然就可以联系到用哈希表来解决这个问题。\n\n首先，先遍历链表建立哈希，得到一个类数组对象，接着开始遍历这个类数组对象，求和，如果遇到和为 0 了，就把之前的节点全部丢弃，对剩余的节点递归进行上述操作。\n\n算法实现如下：\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar removeZeroSumSublists = function (head) {\n  if (!head) {\n    return null;\n  }\n  let newHead = head;\n  let preNode = null;\n  // 根据链表生成映射\n  const posMap = makeHash(head);\n  for (let i = 0; posMap[i]; i++) {\n    let currentNode = posMap[i];\n    let node = currentNode;\n    let sum = 0;\n    // 对从当前节点开始到最后一个节点求和，若为0，则丢弃这期间的所有节点，并且递归的进行删除操作\n    while (node) {\n      sum += node.val;\n      if (sum == 0) {\n        if (preNode === null) {\n          head = node.next;\n        } else {\n          preNode.next = node.next;\n        }\n        return removeZeroSumSublists(head);\n      } else {\n        node = node.next;\n      }\n    }\n    // 没有和为0的连续节点，将当前节点保留下来\n    preNode = currentNode;\n  }\n\n  return newHead;\n};\n\n/**\n * 将链表生成类数组对象\n * @param {ListNode} head\n * @returns\n */\nvar makeHash = function (head) {\n  let node = head;\n  let map = Object.create(null);\n  let counter = 0;\n  while (node) {\n    map[counter] = node;\n    node = node.next;\n    counter++;\n  }\n  map.length = counter;\n  return map;\n};\n",normalizedContent:"# 从链表中删去总和值为零的连续节点\n\n给你一个链表的头节点 head，请你编写代码，反复删去链表中由 总和值为 0 的连续节点组成的序列，直到不存在这样的序列为止。\n\n删除完毕后，请你返回最终结果链表的头节点。\n\n> 输入：head = [1,2,-3,3,1] 输出：[3,1] 提示：答案 [1,2,1] 也是正确的。\n> >\n> 输入：head = [1,2,3,-3,4] 输出：[1,2,4]\n\n这题难就难在我们操作的对象是个链表，如果是数组的话，一下就变得特别简单了，从第一个数开始出发，遇到 0 可以直接删除，或者总和为 0 的时候，也可以把之前累加的都删除掉。如果一直加到最后都没有和为 0 的结果，那么就从第二个出发，以此类推，直到遍历到最后一个数。\n\n关键是现在换成了链表，不过想一下，还是可以把一个链表变成像数组那样操作，那么自然而然就可以联系到用哈希表来解决这个问题。\n\n首先，先遍历链表建立哈希，得到一个类数组对象，接着开始遍历这个类数组对象，求和，如果遇到和为 0 了，就把之前的节点全部丢弃，对剩余的节点递归进行上述操作。\n\n算法实现如下：\n\n/**\n * definition for singly-linked list.\n * function listnode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {listnode} head\n * @return {listnode}\n */\nvar removezerosumsublists = function (head) {\n  if (!head) {\n    return null;\n  }\n  let newhead = head;\n  let prenode = null;\n  // 根据链表生成映射\n  const posmap = makehash(head);\n  for (let i = 0; posmap[i]; i++) {\n    let currentnode = posmap[i];\n    let node = currentnode;\n    let sum = 0;\n    // 对从当前节点开始到最后一个节点求和，若为0，则丢弃这期间的所有节点，并且递归的进行删除操作\n    while (node) {\n      sum += node.val;\n      if (sum == 0) {\n        if (prenode === null) {\n          head = node.next;\n        } else {\n          prenode.next = node.next;\n        }\n        return removezerosumsublists(head);\n      } else {\n        node = node.next;\n      }\n    }\n    // 没有和为0的连续节点，将当前节点保留下来\n    prenode = currentnode;\n  }\n\n  return newhead;\n};\n\n/**\n * 将链表生成类数组对象\n * @param {listnode} head\n * @returns\n */\nvar makehash = function (head) {\n  let node = head;\n  let map = object.create(null);\n  let counter = 0;\n  while (node) {\n    map[counter] = node;\n    node = node.next;\n    counter++;\n  }\n  map.length = counter;\n  return map;\n};\n",charsets:{cjk:!0}},{title:"两数之和",frontmatter:{},regularPath:"/data-structure/hash/sum.html",relativePath:"data-structure/hash/sum.md",key:"v-649ccb56",path:"/data-structure/hash/sum.html",headers:[{level:2,title:"两数之和",slug:"两数之和",normalizedTitle:"两数之和",charIndex:2},{level:3,title:"朴素法",slug:"朴素法",normalizedTitle:"朴素法",charIndex:171},{level:3,title:"哈希法",slug:"哈希法",normalizedTitle:"哈希法",charIndex:546}],headersStr:"两数之和 朴素法 哈希法",content:'# 两数之和\n\n给定一个整数数组 nums  和一个整数目标值 target，请你在该数组中找出和为目标值 target 的那两个整数，并返回它们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n\n你可以按任意顺序返回答案。\n\n这应该是绝大部分人人生中的第一道 LeetCode 题吧\n\n\n# 朴素法\n\n朴素法的思路和选择排序的思路差不多，反正只要我找到了两个能够满足题目要求的组合就可以了，所以，算法的实现如下：\n\nvar twoSum = function (nums, target) {\n  if (nums.length < 2) {\n    return;\n  }\n  for (let i = 0; i < nums.length - 1; i++) {\n    for (let j = i + 1; j < nums.length; j++) {\n      if (nums[i] + nums[j] === target) {\n        return [i, j];\n      }\n    }\n  }\n};\n\n\n可以看到，朴素法的时间复杂度是O(n²)，因为没有用到额外的空间，所以空间复杂度为O(1)。\n\n\n# 哈希法\n\n这题能够使用哈希表进行解答的人一定是动过脑筋的人。\n\n首先遍历是肯定少不了的，在遍历的时候，我们既然知道当前的数字，也知道总和，那我们我们可以算出差值，如果这个差值在数组中存在，那么就可以得到结果，如果不存在，继续尝试。\n\n怎么样快速的检索一个东西是否存在，根据我们之前学过的理论，哈希表能够在O(1)的时间内检索，平衡二叉树和二分查找能够在O(log n)的时间内检索，二分查找肯定是搞不定的，二分查找必须要在有序的条件下才能使用，如果用平衡二叉树，我们还要根据其值的大小建立树，不仅非常麻烦，复杂度还不如哈希表，显然这题，用哈希表才比较符合场景。\n\nvar twoSum = function (nums, target) {\n  if (nums.length < 2) {\n    return;\n  }\n  // 根据值建立哈希映射\n  const map = Object.create(null);\n  nums.forEach((num, idx) => {\n    map[num] = idx;\n  });\n  for (let i = 0; i < nums.length; i++) {\n    let a = nums[i];\n    let b = target - a;\n    let otherIdx = map[b];\n    // 存在并且不是自己，自己跟自己肯定不行\n    if (typeof otherIdx !== "undefined" && otherIdx !== i) {\n      return [i, otherIdx];\n    }\n  }\n};\n\n\n建立哈希的时间复杂度是O(N)，空间复杂度是O(N)；\n\n循环查找的时间复杂度是O(N)；\n\n最终得时间复杂度是 2*O(N)，省略系数，得O(N)，空间复杂度是O(N)。',normalizedContent:'# 两数之和\n\n给定一个整数数组 nums  和一个整数目标值 target，请你在该数组中找出和为目标值 target 的那两个整数，并返回它们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n\n你可以按任意顺序返回答案。\n\n这应该是绝大部分人人生中的第一道 leetcode 题吧\n\n\n# 朴素法\n\n朴素法的思路和选择排序的思路差不多，反正只要我找到了两个能够满足题目要求的组合就可以了，所以，算法的实现如下：\n\nvar twosum = function (nums, target) {\n  if (nums.length < 2) {\n    return;\n  }\n  for (let i = 0; i < nums.length - 1; i++) {\n    for (let j = i + 1; j < nums.length; j++) {\n      if (nums[i] + nums[j] === target) {\n        return [i, j];\n      }\n    }\n  }\n};\n\n\n可以看到，朴素法的时间复杂度是o(n²)，因为没有用到额外的空间，所以空间复杂度为o(1)。\n\n\n# 哈希法\n\n这题能够使用哈希表进行解答的人一定是动过脑筋的人。\n\n首先遍历是肯定少不了的，在遍历的时候，我们既然知道当前的数字，也知道总和，那我们我们可以算出差值，如果这个差值在数组中存在，那么就可以得到结果，如果不存在，继续尝试。\n\n怎么样快速的检索一个东西是否存在，根据我们之前学过的理论，哈希表能够在o(1)的时间内检索，平衡二叉树和二分查找能够在o(log n)的时间内检索，二分查找肯定是搞不定的，二分查找必须要在有序的条件下才能使用，如果用平衡二叉树，我们还要根据其值的大小建立树，不仅非常麻烦，复杂度还不如哈希表，显然这题，用哈希表才比较符合场景。\n\nvar twosum = function (nums, target) {\n  if (nums.length < 2) {\n    return;\n  }\n  // 根据值建立哈希映射\n  const map = object.create(null);\n  nums.foreach((num, idx) => {\n    map[num] = idx;\n  });\n  for (let i = 0; i < nums.length; i++) {\n    let a = nums[i];\n    let b = target - a;\n    let otheridx = map[b];\n    // 存在并且不是自己，自己跟自己肯定不行\n    if (typeof otheridx !== "undefined" && otheridx !== i) {\n      return [i, otheridx];\n    }\n  }\n};\n\n\n建立哈希的时间复杂度是o(n)，空间复杂度是o(n)；\n\n循环查找的时间复杂度是o(n)；\n\n最终得时间复杂度是 2*o(n)，省略系数，得o(n)，空间复杂度是o(n)。',charsets:{cjk:!0}},{title:"堆",frontmatter:{},regularPath:"/data-structure/heap/desc.html",relativePath:"data-structure/heap/desc.md",key:"v-2ef6a612",path:"/data-structure/heap/desc.html",headers:[{level:2,title:"堆",slug:"堆",normalizedTitle:"堆",charIndex:2},{level:2,title:"堆的操作",slug:"堆的操作",normalizedTitle:"堆的操作",charIndex:279},{level:3,title:"插入",slug:"插入",normalizedTitle:"插入",charIndex:302},{level:3,title:"调整和删除",slug:"调整和删除",normalizedTitle:"调整和删除",charIndex:611},{level:3,title:"构建",slug:"构建",normalizedTitle:"构建",charIndex:1227},{level:3,title:"带哨兵的堆的操作",slug:"带哨兵的堆的操作",normalizedTitle:"带哨兵的堆的操作",charIndex:3674},{level:2,title:"进阶",slug:"进阶",normalizedTitle:"进阶",charIndex:6236},{level:2,title:"应用场景",slug:"应用场景",normalizedTitle:"应用场景",charIndex:9786}],headersStr:"堆 堆的操作 插入 调整和删除 构建 带哨兵的堆的操作 进阶 应用场景",content:'# 堆\n\n堆(Heap)是一类特殊的数据结构，是最高效的优先级队列。\n\n堆通常是一个可以被看做一棵树的数组对象(即用数组实现的树).\n\n堆总是一棵完全二叉树。\n\n从堆的根节点到任意叶节点画路径，总能得到从小到大（最小堆）的顺序或者从大到小（最大堆）的顺序。\n\n由于堆是一颗完全二叉树，对于一个索引为 k 的节点，那么其左右儿子的索引则分别为 2k+1 和 2k+2（若存在）。\n\n最大堆\n\n最小堆\n\n不满足完全二叉树，所以不是堆（值为19的节点缺失右儿子）\n\n不是堆，堆一定满足从根节点画任意路径到一节点，其节点值总满足从大到小或者从小到大的顺序。\n\n\n# 堆的操作\n\n以下，我们就以最大堆为例，阐述堆的插入、删除、调整。\n\n\n# 插入\n\n因为堆中元素需要满足有序性，我们插入的值不一定就是这条路径中最小的，那么我们需要为元素找到合适的位置。 根据前文提到的堆的性质，我们可以确定当前节点的父节点所在位置是 i/2（对于 JavaScript 语言来说，需要向下取整）\n\n假设我们现在要在这个堆中插入 98。\n\n整个过程如下图所示：\n\n首先扩展堆的容量 沿着父节点一直比较，直到找到合适的位置，这一过程中 i 一直不断的往上提，因为每次我们每次都是 i/2，这是一个类似二分查找的操作。 最终找到了合适的位置 完成插入 对于了解过排序算法的同学，对于这个过程是否感觉有些似曾相识？没错，这个过程就是直接插入排序。\n\n\n# 调整和删除\n\n为什么我们会把调整和删除一起讨论呢，主要是为了避免编写重复的代码。\n\n假设，我们删除堆的一个元素，那么我们把数组下标为 0 的元素提出来，因为这个元素空出来了，相当于我们要把后面的元素往前挪动。但是 这儿可不能像数组那节说的那样挪动，否则会丢失顺序性。我们只能把最后一个元素交换到下标 0 的这个位置上来。然后重新调整堆。\n\n好了，首先，我们先把看看当前节点(假设当前节点所在位置为 i)有没有左儿子(有的话，即2*i<length)，如果有，那我们看看当前节点是否有右儿子(有的话，即2*i+1<length)，若有的话，我们从两个儿子中取一个比较大的节点跟当前节点的值比较，如果大的儿子节点值大于 i 节点，那么把儿子节点较大的那个值拷贝到位置 i 上。并且把这个值放到大的儿子节点的那个位置上，然后 i 指向儿子节点较大者的那个索引；如果父节点比儿子节点的值还大，说明本来就保持了这个有序性，则可以不用变动。\n\n因为我们刚才的操作其实是把影响下沉给了儿子节点，儿子节点现在不满足路径的顺序性质了，那么我们重复刚才的操作，直到调整到叶节点为止。\n\n这一系列的过程，大概如下图所示：\n\n首先准备删除 然后将节点值拷贝到根节点，然后把已经拷贝好值的节点拿掉； 因为子节点比跟节点的值大，所以，将子节点向上提，parent 指针指向被影响的儿子节点的位置 重复这个过程，直到把这个影响传递到叶节点，则完成调整。\n\n\n# 构建\n\n之前我们已经理解了怎么样以根节点 p 把一个被破坏了的堆还原。如何把一个数组调整成堆呢，我们首先知道一个数组的最后一个节点的，那么根据这个节点，可以推算出它的父节点。我们首先把它们俩调整成堆。接着，我们把这个父节点的左边兄弟节点调整成堆，然后再把父节点的左边的兄弟左边的兄弟节点调整成堆，重复这个操作，直到调整到数组的第 1 个节点，就可以使得我们整个数组调整为堆。这个过程是个线性的时间复杂度，具体推导，读者可自行查阅资料，本节不做具体分析。\n\n上述过程的算法实现如下：\n\n/*\n * 最大堆\n */\nclass Heap {\n  /**\n   * 定义一个存储数据的内存空间\n   */\n  _data = [];\n\n  get size() {\n    return this._data.length;\n  }\n\n  constructor(...nums) {\n    // 初始化数组元素\n    nums.forEach((v) => {\n      this._data.push(v);\n    });\n    this.buildHeap();\n  }\n\n  /**\n   * 获取堆顶的元素\n   */\n  getTop() {\n    return this._data[0];\n  }\n\n  /**\n   * 按断堆是否是空\n   */\n  isEmpty() {\n    return this._data.length === 0;\n  }\n\n  /**\n   * 向堆中插入一个合法值\n   * @param {number} val\n   */\n  insert(val) {\n    // 如果当前数组没有元素，直接插入即可\n    if (this._data.length === 0) {\n      this._data[0] = val;\n    } else {\n      // 让i指向当前新位置，因为没有哨兵的关系，最后一个元素是length - 1，所以新位置就是length\n      let i = this.size;\n      while (val > this._data[Math.floor(i / 2)] && i > 0) {\n        this._data[i] = this._data[Math.floor(i / 2)];\n        i = Math.floor(i / 2);\n      }\n      // 在合适的位置插入新的值\n      this._data[i] = val;\n    }\n  }\n\n  /**\n   * 获取堆中的最大元素\n   * @returns\n   */\n  deleteMax() {\n    if (this.isEmpty()) {\n      console.warn("can not delete max from empty heap");\n      return;\n    }\n    // 取出堆顶的元素\n    let minVal = this._data[0];\n    // 把堆最后的元素交换到堆顶去\n    let temp = this._data[this.size - 1];\n    this._data[0] = temp;\n    // JavaScript语言需要进行这一步，让数组的规模缩小，释放空间\n    this._data.length--;\n    // 将数组调整成堆\n    this.percDown(0);\n    return minVal;\n  }\n\n  /**\n   * 下滤：将堆中以堆data[p]为根的子堆调整为最小堆\n   * @param {number} p 根节点索引\n   */\n  percDown(p) {\n    // 如果当前堆元素小于1个，就不执行调整操作\n    if (this.size <= 1) {\n      return;\n    }\n    let parent, child;\n    /* 取出根结点存放的值 */\n    let temp = this._data[p];\n    for (parent = p; parent * 2 < this.size; parent = child) {\n      child = parent * 2;\n      /* 如果右儿子存在 child指向左右子结点的较大者 */\n      if (child + 1 < this.size && this._data[child + 1] > this._data[child]) {\n        child++;\n      }\n      /* 找到了合适位置 */\n      if (temp >= this._data[child]) {\n        break;\n      } else {\n        /* 下滤X */\n        this._data[parent] = this._data[child];\n      }\n    }\n    this._data[parent] = temp;\n  }\n\n  /**\n   * 构建最大堆\n   */\n  buildHeap() {\n    /* 调整data中的元素，使满足最小堆的有序性  */\n    /* 这里所有size个元素已经存在data[]中 */\n    /* 从最后一个结点的父节点开始，到根结点1 */\n    for (let i = Math.floor((this.size - 1) / 2); i >= 0; i--) {\n      this.percDown(i);\n    }\n  }\n}\n\n\n\n# 带哨兵的堆的操作\n\n# 哨兵\n\n在查找时，通过设置哨兵能够省去对一些边界条件的判断，减少比较次数，有利于提高程序的效率和健壮性。\n\n# 堆带哨兵和不带哨兵的区别\n\n * 不能在堆中插入大于哨兵的元素，否则哨兵失去意义还会给程序带来问题。\n * 对于索引为 k 的节点，左右儿子的下标索引也有变化，分别为 2k 和 2k+1(若存在)\n * 在堆的插入操作时，不需要判断 i 的下标大于 0，因为哨兵自带判断依据，也不需要判断堆内元素为空的情况。\n * 在删除堆的最大值之后，需要将最后一个节点的元素拷贝到下标为 1 的位置，而不是 0\n * 在下滤时，外层循环终止条件发生变化，需要取到length，原为[0，length-1]。\n * 在构建堆时，是从length/2开始到 1 结束\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n\n/*\n * 最大堆\n */\nclass Heap {\n  /**\n   * 定义哨兵的最大值，所有插入堆的元素都必须比这个值小\n   */\n  #MAX_VAL = 1000;\n\n  /**\n   * 定义一个存储数据的内存空间\n   */\n  #data = [];\n\n  /**\n   * 当前堆的元素个数\n   */\n  #size = 0;\n\n  constructor(...nums) {\n    // 设置哨兵\n    this.#data[0] = this.#MAX_VAL;\n    // 初始化数组元素\n    nums.forEach((v, i) => {\n      this.#data[i + 1] = v;\n      this.#size++;\n    });\n    this.buildHeap();\n  }\n\n  isEmpty() {\n    return this.#size === 0;\n  }\n\n  /**\n   * 向堆中插入一个合法值\n   * @param {number} val\n   */\n  insert(val) {\n    if (this.MAX_VAL <= val) {\n      throw `can not insert val bigger than ${this.#MAX_VAL}`;\n    }\n    // 堆的容量扩充1\n    this.#size++;\n    // 让i指向当前新位置\n    let i = this.#size;\n    // 因为有哨兵的关系，不需要添加约束条件 i > 0\n    while (this.#data[Math.floor(i / 2)] < val) {\n      this.#data[i] = this.#data[Math.floor(i / 2)];\n      i = Math.floor(i / 2);\n    }\n    this.#data[i] = val;\n  }\n\n  deleteMax() {\n    if (this.isEmpty()) {\n      console.warn("can not delete max from empty heap");\n      return;\n    }\n    // 取出堆顶的元素\n    let maxVal = this.#data[1];\n    // 取出堆最后一个元素 取出来之后则把堆的规模减小\n    let temp = this.#data[this.#size--];\n    this.#data[1] = temp;\n    this.percDown(1);\n    // JavaScript语言需要进行这一步，让数组的规模缩小，释放空间\n    this.#data.length--;\n    return maxVal;\n  }\n\n  /* 下滤：将堆中以堆data[p]为根的子堆调整为最大堆 */\n  percDown(p) {\n    let parent, child;\n    let temp = this.#data[p]; /* 取出根结点存放的值 */\n    // 虽然不带哨兵，但是因为外界传递的索引是预期的，所以还是只能按不带索引的计算方式计算\n    for (parent = p; parent * 2 <= this.#size; parent = child) {\n      child = parent * 2;\n      if (child != this.#size && this.#data[child] < this.#data[child + 1]) {\n        child++; /* child指向左右子结点的较大者 */\n      }\n      /* 找到了合适位置 */\n      if (temp >= this.#data[child]) {\n        break;\n      } else {\n        /* 下滤X */\n        this.#data[parent] = this.#data[child];\n      }\n    }\n    this.#data[parent] = temp;\n  }\n\n  /*----------- 建造最大堆 -----------*/\n  buildHeap() {\n    /* 调整data中的元素，使满足最大堆的有序性  */\n    /* 这里所有size个元素已经存在data[]中 */\n    /* 从最后一个结点的父节点开始，到根结点1 */\n    for (let i = Math.floor(this.#size / 2); i > 0; i--) {\n      this.percDown(i);\n    }\n  }\n}\n\n\n\n# 进阶\n\n在上述堆的代码实现中，我们可以看到，想控制一个堆的性质（最大堆还是最小堆），仅仅改变一下判断依据就好了。\n\n那么，上述的代码就可以进行抽象，我们将它封装成一个通用的堆，移植到成熟的代码库中去，这样就可以避免每次都复制粘贴代码了。\n\n/*\n * 抽象堆\n */\nclass Heap {\n  /**\n   * 定义一个存储数据的内存空间\n   */\n  _data = [];\n\n  /**\n   * 比较函数\n   */\n  _compare = null;\n\n  get size() {\n    return this._data.length;\n  }\n\n  _selfCompare = (compareVal, currentVal) => {\n    if (typeof this._compare !== "function") {\n      throw `cannot compare without a compare function`;\n    }\n    return this._compare(compareVal, currentVal);\n  };\n\n  /**\n   * 设置比较函数\n   * @param {(compareVal, currentVal) => boolean} compareFunc\n   */\n  setCompare(compareFunc) {\n    this._compare = compareFunc;\n  }\n\n  /**\n   * 获取堆顶的元素\n   */\n  getTop() {\n    return this._data[0];\n  }\n\n  /**\n   * 按断堆是否是空\n   */\n  isEmpty() {\n    return this._data.length === 0;\n  }\n\n  /**\n   * 向堆中插入一个合法值\n   * @param {number} val\n   */\n  insert(val) {\n    // 如果当前数组没有元素，直接插入即可\n    if (this._data.length === 0) {\n      this._data[0] = val;\n    } else {\n      // 让i指向当前新位置，因为没有哨兵的关系，最后一个元素是length - 1，所以新位置就是length\n      let i = this.size;\n      while (this._selfCompare(val, this._data[Math.floor(i / 2)]) && i > 0) {\n        this._data[i] = this._data[Math.floor(i / 2)];\n        i = Math.floor(i / 2);\n      }\n      // 在合适的位置插入新的值\n      this._data[i] = val;\n    }\n  }\n\n  /**\n   * 获取堆中的最值元素\n   * @returns\n   */\n  deleteTop() {\n    if (this.isEmpty()) {\n      console.warn("can not delete max from empty heap");\n      return;\n    }\n    // 取出堆顶的元素\n    let minVal = this._data[0];\n    let temp = this._data[this.size - 1];\n    this._data[0] = temp;\n    // JavaScript语言需要进行这一步，让数组的规模缩小，释放空间\n    this._data.length--;\n    // 如果当前堆里面还存在元素的话，将\n    this.percDown(0);\n    return minVal;\n  }\n\n  /**\n   * 下滤：将堆中以堆data[p]为根的子堆调整为最小堆\n   * @param {number} p 根节点索引\n   */\n  percDown(p) {\n    // 如果当前堆元素小于1个，就不执行调整操作\n    if (this.size <= 1) {\n      return;\n    }\n    let parent, child;\n    /* 取出根结点存放的值 */\n    let temp = this._data[p];\n    for (parent = p; parent * 2 < this.size; parent = child) {\n      child = parent * 2;\n      if (\n        child + 1 < this.size &&\n        this._selfCompare(this._data[child + 1], this._data[child])\n      ) {\n        child++; /* child指向左右子结点的较大者 最大堆 较小者 最小堆 */\n      }\n      /* 找到了合适位置 */\n      // 注意这儿一定要取得等号 temp <= this.#data[child] 最小堆 temp >= this.#data[child] 最大堆\n      if (this._selfCompare(temp, this._data[child])) {\n        break;\n      } else {\n        /* 下滤X */\n        this._data[parent] = this._data[child];\n      }\n    }\n    this._data[parent] = temp;\n  }\n\n  /**\n   * 构建最小堆\n   */\n  buildHeap() {\n    /* 调整data中的元素，使满足最小堆的有序性  */\n    /* 这里所有size个元素已经存在data[]中 */\n    /* 从最后一个结点的父节点开始，到根结点1 */\n    for (let i = Math.floor((this.size - 1) / 2); i >= 0; i--) {\n      this.percDown(i);\n    }\n  }\n}\n\nclass MinHeap extends Heap {\n  constructor() {\n    super();\n    this.setCompare((compareVal, currentVal) => {\n      return compareVal - currentVal <= 0;\n    });\n  }\n\n  getMin() {\n    return this.getTop();\n  }\n\n  deleteMin() {\n    return this.deleteTop();\n  }\n}\n\nclass MaxHeap extends Heap {\n  constructor() {\n    super();\n    this.setCompare((compareVal, currentVal) => {\n      return compareVal - currentVal >= 0;\n    });\n  }\n\n  getMax() {\n    return this.getTop();\n  }\n\n  deleteMax() {\n    return this.deleteTop();\n  }\n}\n\n\n如果堆的元素是个对象，我们可以手动设置比较函数，也可以达到相应的效果\n\n比如：\n\n// 假设我们将这个抽象堆封装至代码库中了\nimport { Heap } from "awesome-frontend-code";\nconst maxHeap = new Heap();\n// 现在需要根据学生的成绩建堆。\nmaxHeap.setCompare((compareStudent, currentStudent) => {\n  return compareStudent.score - currentStudent.score >= 0;\n});\n\n\n\n# 应用场景\n\n堆的应用场景比较模糊，但是我根据自己的实际体验和与朋友们的交流大致总结了 2 个场景：\n\n * 想让序列保持有序，但是又不想直接使用排序算法。\n * 动态的数据，无法每次数据改变都进行排序，但是最终却需要有序的序列。',normalizedContent:'# 堆\n\n堆(heap)是一类特殊的数据结构，是最高效的优先级队列。\n\n堆通常是一个可以被看做一棵树的数组对象(即用数组实现的树).\n\n堆总是一棵完全二叉树。\n\n从堆的根节点到任意叶节点画路径，总能得到从小到大（最小堆）的顺序或者从大到小（最大堆）的顺序。\n\n由于堆是一颗完全二叉树，对于一个索引为 k 的节点，那么其左右儿子的索引则分别为 2k+1 和 2k+2（若存在）。\n\n最大堆\n\n最小堆\n\n不满足完全二叉树，所以不是堆（值为19的节点缺失右儿子）\n\n不是堆，堆一定满足从根节点画任意路径到一节点，其节点值总满足从大到小或者从小到大的顺序。\n\n\n# 堆的操作\n\n以下，我们就以最大堆为例，阐述堆的插入、删除、调整。\n\n\n# 插入\n\n因为堆中元素需要满足有序性，我们插入的值不一定就是这条路径中最小的，那么我们需要为元素找到合适的位置。 根据前文提到的堆的性质，我们可以确定当前节点的父节点所在位置是 i/2（对于 javascript 语言来说，需要向下取整）\n\n假设我们现在要在这个堆中插入 98。\n\n整个过程如下图所示：\n\n首先扩展堆的容量 沿着父节点一直比较，直到找到合适的位置，这一过程中 i 一直不断的往上提，因为每次我们每次都是 i/2，这是一个类似二分查找的操作。 最终找到了合适的位置 完成插入 对于了解过排序算法的同学，对于这个过程是否感觉有些似曾相识？没错，这个过程就是直接插入排序。\n\n\n# 调整和删除\n\n为什么我们会把调整和删除一起讨论呢，主要是为了避免编写重复的代码。\n\n假设，我们删除堆的一个元素，那么我们把数组下标为 0 的元素提出来，因为这个元素空出来了，相当于我们要把后面的元素往前挪动。但是 这儿可不能像数组那节说的那样挪动，否则会丢失顺序性。我们只能把最后一个元素交换到下标 0 的这个位置上来。然后重新调整堆。\n\n好了，首先，我们先把看看当前节点(假设当前节点所在位置为 i)有没有左儿子(有的话，即2*i<length)，如果有，那我们看看当前节点是否有右儿子(有的话，即2*i+1<length)，若有的话，我们从两个儿子中取一个比较大的节点跟当前节点的值比较，如果大的儿子节点值大于 i 节点，那么把儿子节点较大的那个值拷贝到位置 i 上。并且把这个值放到大的儿子节点的那个位置上，然后 i 指向儿子节点较大者的那个索引；如果父节点比儿子节点的值还大，说明本来就保持了这个有序性，则可以不用变动。\n\n因为我们刚才的操作其实是把影响下沉给了儿子节点，儿子节点现在不满足路径的顺序性质了，那么我们重复刚才的操作，直到调整到叶节点为止。\n\n这一系列的过程，大概如下图所示：\n\n首先准备删除 然后将节点值拷贝到根节点，然后把已经拷贝好值的节点拿掉； 因为子节点比跟节点的值大，所以，将子节点向上提，parent 指针指向被影响的儿子节点的位置 重复这个过程，直到把这个影响传递到叶节点，则完成调整。\n\n\n# 构建\n\n之前我们已经理解了怎么样以根节点 p 把一个被破坏了的堆还原。如何把一个数组调整成堆呢，我们首先知道一个数组的最后一个节点的，那么根据这个节点，可以推算出它的父节点。我们首先把它们俩调整成堆。接着，我们把这个父节点的左边兄弟节点调整成堆，然后再把父节点的左边的兄弟左边的兄弟节点调整成堆，重复这个操作，直到调整到数组的第 1 个节点，就可以使得我们整个数组调整为堆。这个过程是个线性的时间复杂度，具体推导，读者可自行查阅资料，本节不做具体分析。\n\n上述过程的算法实现如下：\n\n/*\n * 最大堆\n */\nclass heap {\n  /**\n   * 定义一个存储数据的内存空间\n   */\n  _data = [];\n\n  get size() {\n    return this._data.length;\n  }\n\n  constructor(...nums) {\n    // 初始化数组元素\n    nums.foreach((v) => {\n      this._data.push(v);\n    });\n    this.buildheap();\n  }\n\n  /**\n   * 获取堆顶的元素\n   */\n  gettop() {\n    return this._data[0];\n  }\n\n  /**\n   * 按断堆是否是空\n   */\n  isempty() {\n    return this._data.length === 0;\n  }\n\n  /**\n   * 向堆中插入一个合法值\n   * @param {number} val\n   */\n  insert(val) {\n    // 如果当前数组没有元素，直接插入即可\n    if (this._data.length === 0) {\n      this._data[0] = val;\n    } else {\n      // 让i指向当前新位置，因为没有哨兵的关系，最后一个元素是length - 1，所以新位置就是length\n      let i = this.size;\n      while (val > this._data[math.floor(i / 2)] && i > 0) {\n        this._data[i] = this._data[math.floor(i / 2)];\n        i = math.floor(i / 2);\n      }\n      // 在合适的位置插入新的值\n      this._data[i] = val;\n    }\n  }\n\n  /**\n   * 获取堆中的最大元素\n   * @returns\n   */\n  deletemax() {\n    if (this.isempty()) {\n      console.warn("can not delete max from empty heap");\n      return;\n    }\n    // 取出堆顶的元素\n    let minval = this._data[0];\n    // 把堆最后的元素交换到堆顶去\n    let temp = this._data[this.size - 1];\n    this._data[0] = temp;\n    // javascript语言需要进行这一步，让数组的规模缩小，释放空间\n    this._data.length--;\n    // 将数组调整成堆\n    this.percdown(0);\n    return minval;\n  }\n\n  /**\n   * 下滤：将堆中以堆data[p]为根的子堆调整为最小堆\n   * @param {number} p 根节点索引\n   */\n  percdown(p) {\n    // 如果当前堆元素小于1个，就不执行调整操作\n    if (this.size <= 1) {\n      return;\n    }\n    let parent, child;\n    /* 取出根结点存放的值 */\n    let temp = this._data[p];\n    for (parent = p; parent * 2 < this.size; parent = child) {\n      child = parent * 2;\n      /* 如果右儿子存在 child指向左右子结点的较大者 */\n      if (child + 1 < this.size && this._data[child + 1] > this._data[child]) {\n        child++;\n      }\n      /* 找到了合适位置 */\n      if (temp >= this._data[child]) {\n        break;\n      } else {\n        /* 下滤x */\n        this._data[parent] = this._data[child];\n      }\n    }\n    this._data[parent] = temp;\n  }\n\n  /**\n   * 构建最大堆\n   */\n  buildheap() {\n    /* 调整data中的元素，使满足最小堆的有序性  */\n    /* 这里所有size个元素已经存在data[]中 */\n    /* 从最后一个结点的父节点开始，到根结点1 */\n    for (let i = math.floor((this.size - 1) / 2); i >= 0; i--) {\n      this.percdown(i);\n    }\n  }\n}\n\n\n\n# 带哨兵的堆的操作\n\n# 哨兵\n\n在查找时，通过设置哨兵能够省去对一些边界条件的判断，减少比较次数，有利于提高程序的效率和健壮性。\n\n# 堆带哨兵和不带哨兵的区别\n\n * 不能在堆中插入大于哨兵的元素，否则哨兵失去意义还会给程序带来问题。\n * 对于索引为 k 的节点，左右儿子的下标索引也有变化，分别为 2k 和 2k+1(若存在)\n * 在堆的插入操作时，不需要判断 i 的下标大于 0，因为哨兵自带判断依据，也不需要判断堆内元素为空的情况。\n * 在删除堆的最大值之后，需要将最后一个节点的元素拷贝到下标为 1 的位置，而不是 0\n * 在下滤时，外层循环终止条件发生变化，需要取到length，原为[0，length-1]。\n * 在构建堆时，是从length/2开始到 1 结束\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n\n/*\n * 最大堆\n */\nclass heap {\n  /**\n   * 定义哨兵的最大值，所有插入堆的元素都必须比这个值小\n   */\n  #max_val = 1000;\n\n  /**\n   * 定义一个存储数据的内存空间\n   */\n  #data = [];\n\n  /**\n   * 当前堆的元素个数\n   */\n  #size = 0;\n\n  constructor(...nums) {\n    // 设置哨兵\n    this.#data[0] = this.#max_val;\n    // 初始化数组元素\n    nums.foreach((v, i) => {\n      this.#data[i + 1] = v;\n      this.#size++;\n    });\n    this.buildheap();\n  }\n\n  isempty() {\n    return this.#size === 0;\n  }\n\n  /**\n   * 向堆中插入一个合法值\n   * @param {number} val\n   */\n  insert(val) {\n    if (this.max_val <= val) {\n      throw `can not insert val bigger than ${this.#max_val}`;\n    }\n    // 堆的容量扩充1\n    this.#size++;\n    // 让i指向当前新位置\n    let i = this.#size;\n    // 因为有哨兵的关系，不需要添加约束条件 i > 0\n    while (this.#data[math.floor(i / 2)] < val) {\n      this.#data[i] = this.#data[math.floor(i / 2)];\n      i = math.floor(i / 2);\n    }\n    this.#data[i] = val;\n  }\n\n  deletemax() {\n    if (this.isempty()) {\n      console.warn("can not delete max from empty heap");\n      return;\n    }\n    // 取出堆顶的元素\n    let maxval = this.#data[1];\n    // 取出堆最后一个元素 取出来之后则把堆的规模减小\n    let temp = this.#data[this.#size--];\n    this.#data[1] = temp;\n    this.percdown(1);\n    // javascript语言需要进行这一步，让数组的规模缩小，释放空间\n    this.#data.length--;\n    return maxval;\n  }\n\n  /* 下滤：将堆中以堆data[p]为根的子堆调整为最大堆 */\n  percdown(p) {\n    let parent, child;\n    let temp = this.#data[p]; /* 取出根结点存放的值 */\n    // 虽然不带哨兵，但是因为外界传递的索引是预期的，所以还是只能按不带索引的计算方式计算\n    for (parent = p; parent * 2 <= this.#size; parent = child) {\n      child = parent * 2;\n      if (child != this.#size && this.#data[child] < this.#data[child + 1]) {\n        child++; /* child指向左右子结点的较大者 */\n      }\n      /* 找到了合适位置 */\n      if (temp >= this.#data[child]) {\n        break;\n      } else {\n        /* 下滤x */\n        this.#data[parent] = this.#data[child];\n      }\n    }\n    this.#data[parent] = temp;\n  }\n\n  /*----------- 建造最大堆 -----------*/\n  buildheap() {\n    /* 调整data中的元素，使满足最大堆的有序性  */\n    /* 这里所有size个元素已经存在data[]中 */\n    /* 从最后一个结点的父节点开始，到根结点1 */\n    for (let i = math.floor(this.#size / 2); i > 0; i--) {\n      this.percdown(i);\n    }\n  }\n}\n\n\n\n# 进阶\n\n在上述堆的代码实现中，我们可以看到，想控制一个堆的性质（最大堆还是最小堆），仅仅改变一下判断依据就好了。\n\n那么，上述的代码就可以进行抽象，我们将它封装成一个通用的堆，移植到成熟的代码库中去，这样就可以避免每次都复制粘贴代码了。\n\n/*\n * 抽象堆\n */\nclass heap {\n  /**\n   * 定义一个存储数据的内存空间\n   */\n  _data = [];\n\n  /**\n   * 比较函数\n   */\n  _compare = null;\n\n  get size() {\n    return this._data.length;\n  }\n\n  _selfcompare = (compareval, currentval) => {\n    if (typeof this._compare !== "function") {\n      throw `cannot compare without a compare function`;\n    }\n    return this._compare(compareval, currentval);\n  };\n\n  /**\n   * 设置比较函数\n   * @param {(compareval, currentval) => boolean} comparefunc\n   */\n  setcompare(comparefunc) {\n    this._compare = comparefunc;\n  }\n\n  /**\n   * 获取堆顶的元素\n   */\n  gettop() {\n    return this._data[0];\n  }\n\n  /**\n   * 按断堆是否是空\n   */\n  isempty() {\n    return this._data.length === 0;\n  }\n\n  /**\n   * 向堆中插入一个合法值\n   * @param {number} val\n   */\n  insert(val) {\n    // 如果当前数组没有元素，直接插入即可\n    if (this._data.length === 0) {\n      this._data[0] = val;\n    } else {\n      // 让i指向当前新位置，因为没有哨兵的关系，最后一个元素是length - 1，所以新位置就是length\n      let i = this.size;\n      while (this._selfcompare(val, this._data[math.floor(i / 2)]) && i > 0) {\n        this._data[i] = this._data[math.floor(i / 2)];\n        i = math.floor(i / 2);\n      }\n      // 在合适的位置插入新的值\n      this._data[i] = val;\n    }\n  }\n\n  /**\n   * 获取堆中的最值元素\n   * @returns\n   */\n  deletetop() {\n    if (this.isempty()) {\n      console.warn("can not delete max from empty heap");\n      return;\n    }\n    // 取出堆顶的元素\n    let minval = this._data[0];\n    let temp = this._data[this.size - 1];\n    this._data[0] = temp;\n    // javascript语言需要进行这一步，让数组的规模缩小，释放空间\n    this._data.length--;\n    // 如果当前堆里面还存在元素的话，将\n    this.percdown(0);\n    return minval;\n  }\n\n  /**\n   * 下滤：将堆中以堆data[p]为根的子堆调整为最小堆\n   * @param {number} p 根节点索引\n   */\n  percdown(p) {\n    // 如果当前堆元素小于1个，就不执行调整操作\n    if (this.size <= 1) {\n      return;\n    }\n    let parent, child;\n    /* 取出根结点存放的值 */\n    let temp = this._data[p];\n    for (parent = p; parent * 2 < this.size; parent = child) {\n      child = parent * 2;\n      if (\n        child + 1 < this.size &&\n        this._selfcompare(this._data[child + 1], this._data[child])\n      ) {\n        child++; /* child指向左右子结点的较大者 最大堆 较小者 最小堆 */\n      }\n      /* 找到了合适位置 */\n      // 注意这儿一定要取得等号 temp <= this.#data[child] 最小堆 temp >= this.#data[child] 最大堆\n      if (this._selfcompare(temp, this._data[child])) {\n        break;\n      } else {\n        /* 下滤x */\n        this._data[parent] = this._data[child];\n      }\n    }\n    this._data[parent] = temp;\n  }\n\n  /**\n   * 构建最小堆\n   */\n  buildheap() {\n    /* 调整data中的元素，使满足最小堆的有序性  */\n    /* 这里所有size个元素已经存在data[]中 */\n    /* 从最后一个结点的父节点开始，到根结点1 */\n    for (let i = math.floor((this.size - 1) / 2); i >= 0; i--) {\n      this.percdown(i);\n    }\n  }\n}\n\nclass minheap extends heap {\n  constructor() {\n    super();\n    this.setcompare((compareval, currentval) => {\n      return compareval - currentval <= 0;\n    });\n  }\n\n  getmin() {\n    return this.gettop();\n  }\n\n  deletemin() {\n    return this.deletetop();\n  }\n}\n\nclass maxheap extends heap {\n  constructor() {\n    super();\n    this.setcompare((compareval, currentval) => {\n      return compareval - currentval >= 0;\n    });\n  }\n\n  getmax() {\n    return this.gettop();\n  }\n\n  deletemax() {\n    return this.deletetop();\n  }\n}\n\n\n如果堆的元素是个对象，我们可以手动设置比较函数，也可以达到相应的效果\n\n比如：\n\n// 假设我们将这个抽象堆封装至代码库中了\nimport { heap } from "awesome-frontend-code";\nconst maxheap = new heap();\n// 现在需要根据学生的成绩建堆。\nmaxheap.setcompare((comparestudent, currentstudent) => {\n  return comparestudent.score - currentstudent.score >= 0;\n});\n\n\n\n# 应用场景\n\n堆的应用场景比较模糊，但是我根据自己的实际体验和与朋友们的交流大致总结了 2 个场景：\n\n * 想让序列保持有序，但是又不想直接使用排序算法。\n * 动态的数据，无法每次数据改变都进行排序，但是最终却需要有序的序列。',charsets:{cjk:!0}},{title:"前 K 个高频元素",frontmatter:{},regularPath:"/data-structure/heap/topKFrequent.html",relativePath:"data-structure/heap/topKFrequent.md",key:"v-3b24155e",path:"/data-structure/heap/topKFrequent.html",headers:[{level:2,title:"前 K 个高频元素",slug:"前-k-个高频元素",normalizedTitle:"前 k 个高频元素",charIndex:2},{level:3,title:"思路分析",slug:"思路分析",normalizedTitle:"思路分析",charIndex:299},{level:3,title:"算法实现",slug:"算法实现",normalizedTitle:"算法实现",charIndex:993}],headersStr:"前 K 个高频元素 思路分析 算法实现",content:'# 前 K 个高频元素\n\n给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。\n\n> 输入: nums = [1,1,1,2,2,3], k = 2 输出: [1,2]\n> \n> 输入: nums = [1], k = 1 输出: [1]\n\n * 1 <= nums.length <= 105\n * k 的取值范围是 [1, 数组中不相同的元素的个数]\n * 题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的\n\n注意：你所设计算法的时间复杂度 必须 优于 O(n*log n) ，其中 n 是数组大小。\n\n\n# 思路分析\n\n首先，题目要求出现频率，那么，我们自然会想到建立哈希表，来统计每个整数出现的次数，在这儿，至少会有个遍历，那么这儿的时间复杂度是 O(n)，空间复杂度 O(n);\n\n接下来就是比较关键的问题了，频率求出来了，我们要求 TOP K，有个问题就是最快的排序算法至少是O(n*log n)，所以通过排序求肯定是无法满足性能要求的。那么，在这种想有序，但是又不能排序的场景下，我们自然而然会想到堆，但是是采用最大堆还是最小堆呢，我们要取的是前面 K 个，堆的大小是比数组小的，那必须是最小堆，因为这样你才能知道当前元素是否应该入堆。\n\n假设当前堆的内容还没有达到 K，随便加入内容，如果达到了，要判断一下当前堆顶的元素是比当前元素大还是小，如果比当前元素小，说明当前元素才应该进去，堆顶的元素应该丢弃，否则保持堆不动。\n\n因为堆内的元素在最终输出的时候是能保证有序性的，所以说，我们就遍历这个记录次数的对象(最坏情况是每个元素都只出现一次)，因此外层循环是 O(N)，堆在插入的时候，建堆的操作是基于二分查找的，所以其时间复杂度是 O(logK)，因为最多 K 个元素，因此空间复杂度是O(K)，因为两个套在一起使用的，所以时间复杂度是 O(N*logK)。\n\n最后再将堆里面的内容全部输出，这儿需要牵涉到堆的调整，已知数组能够在线性的时间复杂度内调整成堆，那么这儿的时间复杂度是O(K);\n\n总的时间复杂度就是O(K) + O(N*logK)，去掉小的O(K)，时间复杂度是O(N*logK); 空间复杂度是: O(K)+O(N)，去掉小的O(K)，空间复杂度是O(N)。\n\n\n# 算法实现\n\n/*\n * 抽象堆\n */\nclass Heap {\n  /**\n   * 定义一个存储数据的内存空间\n   */\n  _data = [];\n\n  /**\n   * 比较函数\n   */\n  _compare = null;\n\n  get size() {\n    return this._data.length;\n  }\n\n  constructor(...nums) {\n    // 初始化数组元素\n    nums.forEach((v) => {\n      this._data.push(v);\n    });\n    this.buildHeap();\n  }\n\n  _selfCompare = (compareVal, currentVal) => {\n    if(typeof this._compare !== \'function\') {\n      throw `cannot compare without a compare function`;\n    }\n    return this._compare(compareVal, currentVal);\n  };\n\n  /**\n   * 设置比较函数\n   * @param {(compareVal, currentVal) => boolean} compareFunc\n   */\n  setCompare(compareFunc) {\n    this._compare = compareFunc;\n  }\n\n  /**\n   * 获取堆顶的元素\n   */\n  getTop() {\n    return this._data[0];\n  }\n\n  /**\n   * 按断堆是否是空\n   */\n  isEmpty() {\n    return this._data.length === 0;\n  }\n\n  /**\n   * 向堆中插入一个合法值\n   * @param {number} val\n   */\n  insert(val) {\n    // 如果当前数组没有元素，直接插入即可\n    if (this._data.length === 0) {\n      this._data[0] = val;\n    } else {\n      // 让i指向当前新位置，因为没有哨兵的关系，最后一个元素是length - 1，所以新位置就是length\n      let i = this.size;\n      while (this._selfCompare(val, this._data[Math.floor(i / 2)]) && i > 0) {\n        this._data[i] = this._data[Math.floor(i / 2)];\n        i = Math.floor(i / 2);\n      }\n      // 在合适的位置插入新的值\n      this._data[i] = val;\n    }\n  }\n\n  /**\n   * 获取堆中的最小元素\n   * @returns\n   */\n  deleteMin() {\n    if (this.isEmpty()) {\n      console.warn("can not delete max from empty heap");\n      return;\n    }\n    // 取出堆顶的元素\n    let minVal = this._data[0];\n    let temp = this._data[this.size - 1];\n    this._data[0] = temp;\n    // JavaScript语言需要进行这一步，让数组的规模缩小，释放空间\n    this._data.length--;\n    // 如果当前堆里面还存在元素的话，将\n    this.percDown(0);\n    return minVal;\n  }\n\n  /**\n   * 下滤：将堆中以堆data[p]为根的子堆调整为最小堆\n   * @param {number} p 根节点索引\n   */\n  percDown(p) {\n    // 如果当前堆元素小于1个，就不执行调整操作\n    if (this.size <= 1) {\n      return;\n    }\n    let parent, child;\n    /* 取出根结点存放的值 */\n    let temp = this._data[p];\n    for (parent = p; parent * 2 < this.size; parent = child) {\n      child = parent * 2;\n      if (\n        child + 1 < this.size &&\n        this._selfCompare(this._data[child + 1], this._data[child])\n      ) {\n        child++; /* child指向左右子结点的较大者 最大堆 较小者 最小堆 */\n      }\n      /* 找到了合适位置 */\n      // 注意这儿一定要取得等号 temp <= this.#data[child] 最小堆 temp >= this.#data[child] 最大堆\n      if (this._selfCompare(temp, this._data[child])) {\n        break;\n      } else {\n        /* 下滤X */\n        this._data[parent] = this._data[child];\n      }\n    }\n    this._data[parent] = temp;\n  }\n\n  /**\n   * 构建最小堆\n   */\n  buildHeap() {\n    /* 调整data中的元素，使满足最小堆的有序性  */\n    /* 这里所有size个元素已经存在data[]中 */\n    /* 从最后一个结点的父节点开始，到根结点1 */\n    for (let i = Math.floor(this.size / 2); i > 0; i--) {\n      this.percDown(i);\n    }\n  }\n}\n\n\n/**\n * 求TOP K个高频元素\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar topKFrequent = function (nums, k) {\n  const map = Object.create(null);\n  // 建立出现频率的哈希表\n  nums.forEach((num) => {\n    if (typeof map[num] === "undefined") {\n      map[num] = 1;\n    } else {\n      map[num]++;\n    }\n  });\n  // 将哈希表转成出现频率数组\n  let frequentNumbers = [];\n  Object.entries(map).forEach(([prop, value]) => {\n    frequentNumbers.push({\n      prop: Number.parseInt(prop),\n      value,\n    });\n  });\n  let minHeap = new Heap();\n  minHeap.setCompare((compareVal, currentVal) => {\n    return currentVal.frequent - compareVal.frequent >=0;\n  });\n  // 遍历频率建立哈希\n  frequentNumbers.forEach(({ prop, value: frequent }) => {\n    if (minHeap.size < k) {\n      minHeap.insert({\n        prop,\n        frequent,\n      });\n    } else {\n      // 获取堆顶的最小值\n      let { frequent: minFrequent } = minHeap.getTop();\n      // 如果堆顶的小，说明当前元素才应该进堆，堆顶元素应该丢弃\n      if (minFrequent < frequent) {\n        minHeap.deleteMin();\n        minHeap.insert({\n          prop,\n          frequent,\n        });\n      }\n    }\n  });\n  // 依次输出堆顶元素\n  let results = [];\n  while (!minHeap.isEmpty()) {\n    let { prop } = minHeap.deleteMin();\n    results.push(prop);\n  }\n  return results;\n};\n\n\n# 算法复杂度\n\n时间复杂度：O(N*logK);\n\n空间复杂度：O(N)',normalizedContent:'# 前 k 个高频元素\n\n给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。\n\n> 输入: nums = [1,1,1,2,2,3], k = 2 输出: [1,2]\n> \n> 输入: nums = [1], k = 1 输出: [1]\n\n * 1 <= nums.length <= 105\n * k 的取值范围是 [1, 数组中不相同的元素的个数]\n * 题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的\n\n注意：你所设计算法的时间复杂度 必须 优于 o(n*log n) ，其中 n 是数组大小。\n\n\n# 思路分析\n\n首先，题目要求出现频率，那么，我们自然会想到建立哈希表，来统计每个整数出现的次数，在这儿，至少会有个遍历，那么这儿的时间复杂度是 o(n)，空间复杂度 o(n);\n\n接下来就是比较关键的问题了，频率求出来了，我们要求 top k，有个问题就是最快的排序算法至少是o(n*log n)，所以通过排序求肯定是无法满足性能要求的。那么，在这种想有序，但是又不能排序的场景下，我们自然而然会想到堆，但是是采用最大堆还是最小堆呢，我们要取的是前面 k 个，堆的大小是比数组小的，那必须是最小堆，因为这样你才能知道当前元素是否应该入堆。\n\n假设当前堆的内容还没有达到 k，随便加入内容，如果达到了，要判断一下当前堆顶的元素是比当前元素大还是小，如果比当前元素小，说明当前元素才应该进去，堆顶的元素应该丢弃，否则保持堆不动。\n\n因为堆内的元素在最终输出的时候是能保证有序性的，所以说，我们就遍历这个记录次数的对象(最坏情况是每个元素都只出现一次)，因此外层循环是 o(n)，堆在插入的时候，建堆的操作是基于二分查找的，所以其时间复杂度是 o(logk)，因为最多 k 个元素，因此空间复杂度是o(k)，因为两个套在一起使用的，所以时间复杂度是 o(n*logk)。\n\n最后再将堆里面的内容全部输出，这儿需要牵涉到堆的调整，已知数组能够在线性的时间复杂度内调整成堆，那么这儿的时间复杂度是o(k);\n\n总的时间复杂度就是o(k) + o(n*logk)，去掉小的o(k)，时间复杂度是o(n*logk); 空间复杂度是: o(k)+o(n)，去掉小的o(k)，空间复杂度是o(n)。\n\n\n# 算法实现\n\n/*\n * 抽象堆\n */\nclass heap {\n  /**\n   * 定义一个存储数据的内存空间\n   */\n  _data = [];\n\n  /**\n   * 比较函数\n   */\n  _compare = null;\n\n  get size() {\n    return this._data.length;\n  }\n\n  constructor(...nums) {\n    // 初始化数组元素\n    nums.foreach((v) => {\n      this._data.push(v);\n    });\n    this.buildheap();\n  }\n\n  _selfcompare = (compareval, currentval) => {\n    if(typeof this._compare !== \'function\') {\n      throw `cannot compare without a compare function`;\n    }\n    return this._compare(compareval, currentval);\n  };\n\n  /**\n   * 设置比较函数\n   * @param {(compareval, currentval) => boolean} comparefunc\n   */\n  setcompare(comparefunc) {\n    this._compare = comparefunc;\n  }\n\n  /**\n   * 获取堆顶的元素\n   */\n  gettop() {\n    return this._data[0];\n  }\n\n  /**\n   * 按断堆是否是空\n   */\n  isempty() {\n    return this._data.length === 0;\n  }\n\n  /**\n   * 向堆中插入一个合法值\n   * @param {number} val\n   */\n  insert(val) {\n    // 如果当前数组没有元素，直接插入即可\n    if (this._data.length === 0) {\n      this._data[0] = val;\n    } else {\n      // 让i指向当前新位置，因为没有哨兵的关系，最后一个元素是length - 1，所以新位置就是length\n      let i = this.size;\n      while (this._selfcompare(val, this._data[math.floor(i / 2)]) && i > 0) {\n        this._data[i] = this._data[math.floor(i / 2)];\n        i = math.floor(i / 2);\n      }\n      // 在合适的位置插入新的值\n      this._data[i] = val;\n    }\n  }\n\n  /**\n   * 获取堆中的最小元素\n   * @returns\n   */\n  deletemin() {\n    if (this.isempty()) {\n      console.warn("can not delete max from empty heap");\n      return;\n    }\n    // 取出堆顶的元素\n    let minval = this._data[0];\n    let temp = this._data[this.size - 1];\n    this._data[0] = temp;\n    // javascript语言需要进行这一步，让数组的规模缩小，释放空间\n    this._data.length--;\n    // 如果当前堆里面还存在元素的话，将\n    this.percdown(0);\n    return minval;\n  }\n\n  /**\n   * 下滤：将堆中以堆data[p]为根的子堆调整为最小堆\n   * @param {number} p 根节点索引\n   */\n  percdown(p) {\n    // 如果当前堆元素小于1个，就不执行调整操作\n    if (this.size <= 1) {\n      return;\n    }\n    let parent, child;\n    /* 取出根结点存放的值 */\n    let temp = this._data[p];\n    for (parent = p; parent * 2 < this.size; parent = child) {\n      child = parent * 2;\n      if (\n        child + 1 < this.size &&\n        this._selfcompare(this._data[child + 1], this._data[child])\n      ) {\n        child++; /* child指向左右子结点的较大者 最大堆 较小者 最小堆 */\n      }\n      /* 找到了合适位置 */\n      // 注意这儿一定要取得等号 temp <= this.#data[child] 最小堆 temp >= this.#data[child] 最大堆\n      if (this._selfcompare(temp, this._data[child])) {\n        break;\n      } else {\n        /* 下滤x */\n        this._data[parent] = this._data[child];\n      }\n    }\n    this._data[parent] = temp;\n  }\n\n  /**\n   * 构建最小堆\n   */\n  buildheap() {\n    /* 调整data中的元素，使满足最小堆的有序性  */\n    /* 这里所有size个元素已经存在data[]中 */\n    /* 从最后一个结点的父节点开始，到根结点1 */\n    for (let i = math.floor(this.size / 2); i > 0; i--) {\n      this.percdown(i);\n    }\n  }\n}\n\n\n/**\n * 求top k个高频元素\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar topkfrequent = function (nums, k) {\n  const map = object.create(null);\n  // 建立出现频率的哈希表\n  nums.foreach((num) => {\n    if (typeof map[num] === "undefined") {\n      map[num] = 1;\n    } else {\n      map[num]++;\n    }\n  });\n  // 将哈希表转成出现频率数组\n  let frequentnumbers = [];\n  object.entries(map).foreach(([prop, value]) => {\n    frequentnumbers.push({\n      prop: number.parseint(prop),\n      value,\n    });\n  });\n  let minheap = new heap();\n  minheap.setcompare((compareval, currentval) => {\n    return currentval.frequent - compareval.frequent >=0;\n  });\n  // 遍历频率建立哈希\n  frequentnumbers.foreach(({ prop, value: frequent }) => {\n    if (minheap.size < k) {\n      minheap.insert({\n        prop,\n        frequent,\n      });\n    } else {\n      // 获取堆顶的最小值\n      let { frequent: minfrequent } = minheap.gettop();\n      // 如果堆顶的小，说明当前元素才应该进堆，堆顶元素应该丢弃\n      if (minfrequent < frequent) {\n        minheap.deletemin();\n        minheap.insert({\n          prop,\n          frequent,\n        });\n      }\n    }\n  });\n  // 依次输出堆顶元素\n  let results = [];\n  while (!minheap.isempty()) {\n    let { prop } = minheap.deletemin();\n    results.push(prop);\n  }\n  return results;\n};\n\n\n# 算法复杂度\n\n时间复杂度：o(n*logk);\n\n空间复杂度：o(n)',charsets:{cjk:!0}},{title:"概念",frontmatter:{},regularPath:"/data-structure/list/array.html",relativePath:"data-structure/list/array.md",key:"v-7f8a6bd5",path:"/data-structure/list/array.html",headers:[{level:2,title:"概念",slug:"概念",normalizedTitle:"概念",charIndex:2},{level:2,title:"数组的遍历",slug:"数组的遍历",normalizedTitle:"数组的遍历",charIndex:352},{level:2,title:"数组的插入",slug:"数组的插入",normalizedTitle:"数组的插入",charIndex:516},{level:2,title:"数组的删除",slug:"数组的删除",normalizedTitle:"数组的删除",charIndex:1393},{level:2,title:"数组的扩容",slug:"数组的扩容",normalizedTitle:"数组的扩容",charIndex:2091},{level:2,title:"数组的应用",slug:"数组的应用",normalizedTitle:"数组的应用",charIndex:2509}],headersStr:"概念 数组的遍历 数组的插入 数组的删除 数组的扩容 数组的应用",content:'# 概念\n\n数组（Array）是有序的元素序列。 若将有限个类型相同的变量的集合命名，那么这个名称为数组名。组成数组的各个变量称为数组的分量，也称为数组的元素，有时也称为下标变量。用于区分数组的各个元素的数字编号称为下标。\n\n数组是在程序设计中，为了处理方便， 把具有相同类型的若干元素按有序的形式组织起来的一种形式。 这些有序排列的同类数据元素的集合称为数组。（以上内容 copy 自百度百科）\n\nJS 数组和其它强类型（如Java，C#等）语言的数组有非常大的区别。\n\n注意事项\n\nJS 的数组是可以自动增长的，而Java和C#的数组在初始化的时候就必须要申明其长度。\n\n因为这个差异，有些时候我们在讨论时间复杂度的时候就存在一定的差异，不过，我们通常还是以通用的数据结构定义为准进行讨论。\n\n\n# 数组的遍历\n\n时间复杂度为O(n)\n\n/**\n * 遍历数组\n * @param {number[]} arr\n */\nfunction visitArray(arr) {\n  for (let i = 0; i < arr.length; i++) {\n    console.log(arr[i]);\n  }\n}\n\n\n\n# 数组的插入\n\n首先，我们需要将插入的位置从数组中找到，这个操作的平均时间复杂度为O(n)，然后我们将数组的长度增加 1，并且把目标位置到数组最后一个位置的元素都依次向后错一位（给新插入的数据腾出空间呀），我们需要把后面的元素依次往前面挪动一位，这个操作的平均复杂度为O(n)，总的时间复杂度为2*O(n),但是我们在讨论复杂度时，其描述的是算法的规模，因此我们需要省略这个系数，所以，数组删除的平均时间复杂度为O(n)。 平均时间复杂度O(n)\n\n/**\n * 像数组中插入一个值\n * @param {number[]} arr\n * @param {number} insertBefore 指定插入的位置在这个元素之后，如果找不到，则插在末尾\n * @param {number} val 待插入的值\n */\nfunction insert(arr, insertBefore, val) {\n  let targetIdx = -1;\n  let length = arr.length;\n  arr.length++;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[targetIdx] === insertBefore) {\n      targetIdx = i;\n      break;\n    }\n  }\n  if (targetIdx === -1) {\n    // 直接插在末尾\n    arr[length] = val;\n    // 这个地方不需要操作js的length，数组length自己会增加\n    return;\n  }\n  // 必须是从后往前错一位\n  for (let i = arr.length; i > targetIdx; i--) {\n    // 将前面的元素拷贝给后面的元素\n    arr[i] = arr[i - 1];\n  }\n  // 在留出的空位上插入新元素\n  arr[targetIdx] = val;\n}\n\n\n\n# 数组的删除\n\n首先，我们需要将待删除的元素从数组中找到，这个操作的平均时间复杂度为O(n)，然后我们将这个位置的元素从数组中拿掉，当前这个位置便空出来了，我们需要把后面的元素依次往前面挪动一位，这个操作的平均复杂度为O(n)，总的时间复杂度为2*O(n),但是我们在讨论复杂度时，其描述的是算法的规模，因此我们需要省略这个系数，所以，数组删除的平均时间复杂度为O(n)。\n\n/**\n * 从数组中删除指定的元素\n * @param {number[] } arr 数据源\n * @param {number} target 待删除的值\n */\nfunction remove(arr, target) {\n  let targetIdx = -1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[targetIdx] === target) {\n      targetIdx = i;\n      break;\n    }\n  }\n  if (targetIdx === -1) {\n    console.warn("the target element can not exist in arr");\n    return;\n  }\n  // 依次将后面的元素向前拷贝\n  for (let i = targetIdx; i < arr.length; i++) {\n    arr[targetIdx] = arr[targetIdx + 1];\n  }\n  // 数组的长度-1\n  arr.length--;\n}\n\n\n\n# 数组的扩容\n\n本节只为阐述原理，实际开发中并不需要这个步骤，这个操作的时间复杂度为O(N)\n\n/**\n * 将数组扩容\n * @param {number[]} arr\n */\nfunction expandArray(arr) {\n  const len = arr.length\n  // 糟粕语法，实际开发中不要使用, 假设扩容两倍\n  const newArr = new Array(2 * len);\n  for(let i = 0;i<newArr.length;i++) {\n    // 将旧的数组的元素拷贝置新的数组上去，同时给新申请的空间初始化0，直接使用length初始化，数组在使用forEach等方法遍历时会跳过空元素\n    const ele = i < arr.length ? arr[i] : 0;\n    newArr[i] = ele;\n  }\n  return newArr;\n}\n\n\n\n# 数组的应用\n\n略',normalizedContent:'# 概念\n\n数组（array）是有序的元素序列。 若将有限个类型相同的变量的集合命名，那么这个名称为数组名。组成数组的各个变量称为数组的分量，也称为数组的元素，有时也称为下标变量。用于区分数组的各个元素的数字编号称为下标。\n\n数组是在程序设计中，为了处理方便， 把具有相同类型的若干元素按有序的形式组织起来的一种形式。 这些有序排列的同类数据元素的集合称为数组。（以上内容 copy 自百度百科）\n\njs 数组和其它强类型（如java，c#等）语言的数组有非常大的区别。\n\n注意事项\n\njs 的数组是可以自动增长的，而java和c#的数组在初始化的时候就必须要申明其长度。\n\n因为这个差异，有些时候我们在讨论时间复杂度的时候就存在一定的差异，不过，我们通常还是以通用的数据结构定义为准进行讨论。\n\n\n# 数组的遍历\n\n时间复杂度为o(n)\n\n/**\n * 遍历数组\n * @param {number[]} arr\n */\nfunction visitarray(arr) {\n  for (let i = 0; i < arr.length; i++) {\n    console.log(arr[i]);\n  }\n}\n\n\n\n# 数组的插入\n\n首先，我们需要将插入的位置从数组中找到，这个操作的平均时间复杂度为o(n)，然后我们将数组的长度增加 1，并且把目标位置到数组最后一个位置的元素都依次向后错一位（给新插入的数据腾出空间呀），我们需要把后面的元素依次往前面挪动一位，这个操作的平均复杂度为o(n)，总的时间复杂度为2*o(n),但是我们在讨论复杂度时，其描述的是算法的规模，因此我们需要省略这个系数，所以，数组删除的平均时间复杂度为o(n)。 平均时间复杂度o(n)\n\n/**\n * 像数组中插入一个值\n * @param {number[]} arr\n * @param {number} insertbefore 指定插入的位置在这个元素之后，如果找不到，则插在末尾\n * @param {number} val 待插入的值\n */\nfunction insert(arr, insertbefore, val) {\n  let targetidx = -1;\n  let length = arr.length;\n  arr.length++;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[targetidx] === insertbefore) {\n      targetidx = i;\n      break;\n    }\n  }\n  if (targetidx === -1) {\n    // 直接插在末尾\n    arr[length] = val;\n    // 这个地方不需要操作js的length，数组length自己会增加\n    return;\n  }\n  // 必须是从后往前错一位\n  for (let i = arr.length; i > targetidx; i--) {\n    // 将前面的元素拷贝给后面的元素\n    arr[i] = arr[i - 1];\n  }\n  // 在留出的空位上插入新元素\n  arr[targetidx] = val;\n}\n\n\n\n# 数组的删除\n\n首先，我们需要将待删除的元素从数组中找到，这个操作的平均时间复杂度为o(n)，然后我们将这个位置的元素从数组中拿掉，当前这个位置便空出来了，我们需要把后面的元素依次往前面挪动一位，这个操作的平均复杂度为o(n)，总的时间复杂度为2*o(n),但是我们在讨论复杂度时，其描述的是算法的规模，因此我们需要省略这个系数，所以，数组删除的平均时间复杂度为o(n)。\n\n/**\n * 从数组中删除指定的元素\n * @param {number[] } arr 数据源\n * @param {number} target 待删除的值\n */\nfunction remove(arr, target) {\n  let targetidx = -1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[targetidx] === target) {\n      targetidx = i;\n      break;\n    }\n  }\n  if (targetidx === -1) {\n    console.warn("the target element can not exist in arr");\n    return;\n  }\n  // 依次将后面的元素向前拷贝\n  for (let i = targetidx; i < arr.length; i++) {\n    arr[targetidx] = arr[targetidx + 1];\n  }\n  // 数组的长度-1\n  arr.length--;\n}\n\n\n\n# 数组的扩容\n\n本节只为阐述原理，实际开发中并不需要这个步骤，这个操作的时间复杂度为o(n)\n\n/**\n * 将数组扩容\n * @param {number[]} arr\n */\nfunction expandarray(arr) {\n  const len = arr.length\n  // 糟粕语法，实际开发中不要使用, 假设扩容两倍\n  const newarr = new array(2 * len);\n  for(let i = 0;i<newarr.length;i++) {\n    // 将旧的数组的元素拷贝置新的数组上去，同时给新申请的空间初始化0，直接使用length初始化，数组在使用foreach等方法遍历时会跳过空元素\n    const ele = i < arr.length ? arr[i] : 0;\n    newarr[i] = ele;\n  }\n  return newarr;\n}\n\n\n\n# 数组的应用\n\n略',charsets:{cjk:!0}},{title:"双向链表",frontmatter:{},regularPath:"/data-structure/list/doubleLinkedList.html",relativePath:"data-structure/list/doubleLinkedList.md",key:"v-57159cad",path:"/data-structure/list/doubleLinkedList.html",headers:[{level:2,title:"双向链表",slug:"双向链表",normalizedTitle:"双向链表",charIndex:2},{level:2,title:"双向链表的一般数据结构定义",slug:"双向链表的一般数据结构定义",normalizedTitle:"双向链表的一般数据结构定义",charIndex:127},{level:2,title:"应用场景",slug:"应用场景",normalizedTitle:"应用场景",charIndex:352}],headersStr:"双向链表 双向链表的一般数据结构定义 应用场景",content:"# 双向链表\n\n由于单向链表只知道后继节点，当我们需要向前查找的时候，是及其不便的，而双向链表相对于链表来说，多了一个前驱域，我们在操作的过程中就可以快速的找到当前节点的前驱节点。因为多了一个指针域的关系，所以双向链表的内存占用会稍稍的多一些。\n\n\n# 双向链表的一般数据结构定义\n\ninterface DoubleLinkedListNode<T> {\n  /**\n   * 链表的数据域\n   */\n  data: T;\n  /**\n   * 链表的后继节点域\n   */\n  next: DoubleLinkedListNode<T> | null;\n  /**\n   * 链表的前驱节点域\n   */\n  prev: DoubleLinkedListNode<T> | null;\n}\n\n\n\n# 应用场景\n\n实现自动扩容队列；\n\n实现自动扩容的栈；\n\nLRU-Cache等；\n\n编程技巧\n\n在任何想频繁的操作前驱节点时，都应该考虑使用双向链表；",normalizedContent:"# 双向链表\n\n由于单向链表只知道后继节点，当我们需要向前查找的时候，是及其不便的，而双向链表相对于链表来说，多了一个前驱域，我们在操作的过程中就可以快速的找到当前节点的前驱节点。因为多了一个指针域的关系，所以双向链表的内存占用会稍稍的多一些。\n\n\n# 双向链表的一般数据结构定义\n\ninterface doublelinkedlistnode<t> {\n  /**\n   * 链表的数据域\n   */\n  data: t;\n  /**\n   * 链表的后继节点域\n   */\n  next: doublelinkedlistnode<t> | null;\n  /**\n   * 链表的前驱节点域\n   */\n  prev: doublelinkedlistnode<t> | null;\n}\n\n\n\n# 应用场景\n\n实现自动扩容队列；\n\n实现自动扩容的栈；\n\nlru-cache等；\n\n编程技巧\n\n在任何想频繁的操作前驱节点时，都应该考虑使用双向链表；",charsets:{cjk:!0}},{title:"算法和数据结构专题",frontmatter:{title:"算法和数据结构专题"},regularPath:"/data-structure/",relativePath:"data-structure/index.md",key:"v-65084bb4",path:"/data-structure/",headers:[{level:2,title:"1.算法好坏的衡量依据——复杂度",slug:"_1-算法好坏的衡量依据-复杂度",normalizedTitle:"1.算法好坏的衡量依据——复杂度",charIndex:2},{level:3,title:"时间复杂度",slug:"时间复杂度",normalizedTitle:"时间复杂度",charIndex:23},{level:3,title:"空间复杂度",slug:"空间复杂度",normalizedTitle:"空间复杂度",charIndex:1789},{level:2,title:"2.实际开发中常见的数据结构和算法",slug:"_2-实际开发中常见的数据结构和算法",normalizedTitle:"2.实际开发中常见的数据结构和算法",charIndex:2057}],headersStr:"1.算法好坏的衡量依据——复杂度 时间复杂度 空间复杂度 2.实际开发中常见的数据结构和算法",content:"# 1.算法好坏的衡量依据——复杂度\n\n\n# 时间复杂度\n\n算法的时间复杂度T(n)，是一个用于度量一个算法的运算时间的一个描述，本质是一个函数，根据这个函数能在不用具体的测试数据来测试的情况下，粗略地估计算法的执行效率，换句话讲时间复杂度表示的只是代码执行时间随数据规模增长的变化趋势。\n\n举个大家非常熟悉的冒泡排序的一个例子：\n\n/**\n * 对数组进行冒泡排序\n * @param {Array<number>} arr 需要进行排序的数组\n */\nfunction bubbleSort(arr) {\n  let temp = null;\n  // 外层循环变量i 用于控制参与排序数据的规模\n  for (let i = arr.length - 1; i >= 0; i--) {\n    // 定义标记，用于判断本轮是否参与交换\n    let flag = true;\n    // 内层循环用于把最“重”的元素下沉至非有序片段的最后一位\n    for (let j = 0; j < i; j++) {\n      // 注意冒泡排序是两两相邻的比较\n      if (arr[j] > arr[j + 1]) {\n        temp = arr[j];\n        arr[j] = arr[j + 1];\n        arr[j + 1] = temp;\n        // 如果交换了元素，还需要设置标记，若数组已经有序，可以提前终止排序，提升性能\n        flag = false;\n      }\n    }\n    // 如果说没有参与交换，则认为数组已经有序，则可以完成排序\n    if (flag) {\n      break;\n    }\n  }\n}\n\n\n举一个极端的例子，假设现在输入的数据是从大到小的，大家现在可以看到，上面的算法是对数据进行升序排序。\n\n对于程序里面的赋值，算术运算，位运算，数组寻址等操作，这是编程语言提供给我们的能力，我们已经无法提升它的速度了，所以这些操作都是常数级的操作。\n\n第一步: 把 0 这个位置上的数据挪动到最后一个位置上，需要进行 2*N 次交换\n\n第二步: 把 0 这个位置上的数据挪动到倒数第二个位置上，需要进行 2*N-1 次交换\n\n重复以上操作，\n\n第 N-1 步：把 0 这个位置交换到 1 这个位置上，需要执行 2 次操作\n\n根据高中学过的等差数列前 N 项和公式，我们可以得到一个粗略的结果为 a*N²+b*N+c，当 N 在特别大的时候，b*N + c 其实对结果的影响不大。\n\n而我们并不需要一个精确的次数，只是想得到一个描述其复杂度规模的指标，因此，系数 a 也可以省略。\n\n所以，最终我们推导出来，冒泡排序的算法时间复杂度是O(N²);\n\n下面是我在网上随便找的一个常见的时间复杂度的对比图，大家看一下，对不同的时间复杂度的规模有一个认识。\n\n\n\n所有常数级的操作都是O(1)，正常的一轮循环是O(n)，像二分查找，平衡二叉树，跳跃链表的查找，堆的插入，每次运算之后都会使得数据的规模减半，这类操作的复杂度是O(log n)，(至于这个O(log n)是怎么算出来的，举个例子：比如 2 的 10 次方是 1024，那么我们对 1024 进行减半得到一个新的值，然后再对这个新值减半，重复这个操作，到得到的数不能再继续减半为止，最多只能操作 10 次，因此求得二分查找的时间复杂度是O(log n))，像冒泡排序，选择排序,插入排序这类简单排序算法，都是简单的两个循环相叠加，这类操作的时间复杂度是O(n²)，比如像堆排序，归并排序，快速排序这类复杂的排序算法，由于里面有运用分治或折半查找思想的优化，这类排序算法的时间复杂度为 O(n*log n)。\n\n正常我们的实际开发中很少遇到O(n³)及以上复杂度的操作，如果出现了此类情况，请一定要检查一下自己的思维方式是否错误。因为我曾经刚毕业的时候，在有一次算股票的成交均线的时候，就把一个O(n)级别的复杂度计算写成了O(n的n次方)级别的计算，这种错误一旦在数据量比较大的时候，会严重影响用户使用的体验，如果用户无法忍受，怒删程序，会造成公司的活跃用户损失，那有可能会影响到你的绩效了哟。\n\n\n# 空间复杂度\n\n算法的空间复杂度 S(n)定义为该算法所耗费的存储空间，它也是问题规模 n 的函数，也是描述代码占用空间随数据规模增长的变化趋势。\n\n比如我们定义一个变量，这时计算机就会为我们开辟一个内存空间用于存储它。跟时间复杂度的计算类似，因为我们不同语言特定的数据类型占用的内存大小是明确的，我们是无法优化的。\n\n就比如，我们做一次哈希映射，我们需要建立起一个对这个数据的关系，这种操作就是O(1)，比如你需要将一个数组的数据都做一份映射，归并排序时需要额外开辟一个数组用于归并数据，那么此时我们的空间复杂度就是O(N)。\n\n\n# 2.实际开发中常见的数据结构和算法\n\n * 数组\n * 链表\n * 字符串\n * 队列\n * 栈\n * 堆（优先队列）\n * 树\n * 图\n * 哈希表\n * 排序\n * 查找",normalizedContent:"# 1.算法好坏的衡量依据——复杂度\n\n\n# 时间复杂度\n\n算法的时间复杂度t(n)，是一个用于度量一个算法的运算时间的一个描述，本质是一个函数，根据这个函数能在不用具体的测试数据来测试的情况下，粗略地估计算法的执行效率，换句话讲时间复杂度表示的只是代码执行时间随数据规模增长的变化趋势。\n\n举个大家非常熟悉的冒泡排序的一个例子：\n\n/**\n * 对数组进行冒泡排序\n * @param {array<number>} arr 需要进行排序的数组\n */\nfunction bubblesort(arr) {\n  let temp = null;\n  // 外层循环变量i 用于控制参与排序数据的规模\n  for (let i = arr.length - 1; i >= 0; i--) {\n    // 定义标记，用于判断本轮是否参与交换\n    let flag = true;\n    // 内层循环用于把最“重”的元素下沉至非有序片段的最后一位\n    for (let j = 0; j < i; j++) {\n      // 注意冒泡排序是两两相邻的比较\n      if (arr[j] > arr[j + 1]) {\n        temp = arr[j];\n        arr[j] = arr[j + 1];\n        arr[j + 1] = temp;\n        // 如果交换了元素，还需要设置标记，若数组已经有序，可以提前终止排序，提升性能\n        flag = false;\n      }\n    }\n    // 如果说没有参与交换，则认为数组已经有序，则可以完成排序\n    if (flag) {\n      break;\n    }\n  }\n}\n\n\n举一个极端的例子，假设现在输入的数据是从大到小的，大家现在可以看到，上面的算法是对数据进行升序排序。\n\n对于程序里面的赋值，算术运算，位运算，数组寻址等操作，这是编程语言提供给我们的能力，我们已经无法提升它的速度了，所以这些操作都是常数级的操作。\n\n第一步: 把 0 这个位置上的数据挪动到最后一个位置上，需要进行 2*n 次交换\n\n第二步: 把 0 这个位置上的数据挪动到倒数第二个位置上，需要进行 2*n-1 次交换\n\n重复以上操作，\n\n第 n-1 步：把 0 这个位置交换到 1 这个位置上，需要执行 2 次操作\n\n根据高中学过的等差数列前 n 项和公式，我们可以得到一个粗略的结果为 a*n²+b*n+c，当 n 在特别大的时候，b*n + c 其实对结果的影响不大。\n\n而我们并不需要一个精确的次数，只是想得到一个描述其复杂度规模的指标，因此，系数 a 也可以省略。\n\n所以，最终我们推导出来，冒泡排序的算法时间复杂度是o(n²);\n\n下面是我在网上随便找的一个常见的时间复杂度的对比图，大家看一下，对不同的时间复杂度的规模有一个认识。\n\n\n\n所有常数级的操作都是o(1)，正常的一轮循环是o(n)，像二分查找，平衡二叉树，跳跃链表的查找，堆的插入，每次运算之后都会使得数据的规模减半，这类操作的复杂度是o(log n)，(至于这个o(log n)是怎么算出来的，举个例子：比如 2 的 10 次方是 1024，那么我们对 1024 进行减半得到一个新的值，然后再对这个新值减半，重复这个操作，到得到的数不能再继续减半为止，最多只能操作 10 次，因此求得二分查找的时间复杂度是o(log n))，像冒泡排序，选择排序,插入排序这类简单排序算法，都是简单的两个循环相叠加，这类操作的时间复杂度是o(n²)，比如像堆排序，归并排序，快速排序这类复杂的排序算法，由于里面有运用分治或折半查找思想的优化，这类排序算法的时间复杂度为 o(n*log n)。\n\n正常我们的实际开发中很少遇到o(n³)及以上复杂度的操作，如果出现了此类情况，请一定要检查一下自己的思维方式是否错误。因为我曾经刚毕业的时候，在有一次算股票的成交均线的时候，就把一个o(n)级别的复杂度计算写成了o(n的n次方)级别的计算，这种错误一旦在数据量比较大的时候，会严重影响用户使用的体验，如果用户无法忍受，怒删程序，会造成公司的活跃用户损失，那有可能会影响到你的绩效了哟。\n\n\n# 空间复杂度\n\n算法的空间复杂度 s(n)定义为该算法所耗费的存储空间，它也是问题规模 n 的函数，也是描述代码占用空间随数据规模增长的变化趋势。\n\n比如我们定义一个变量，这时计算机就会为我们开辟一个内存空间用于存储它。跟时间复杂度的计算类似，因为我们不同语言特定的数据类型占用的内存大小是明确的，我们是无法优化的。\n\n就比如，我们做一次哈希映射，我们需要建立起一个对这个数据的关系，这种操作就是o(1)，比如你需要将一个数组的数据都做一份映射，归并排序时需要额外开辟一个数组用于归并数据，那么此时我们的空间复杂度就是o(n)。\n\n\n# 2.实际开发中常见的数据结构和算法\n\n * 数组\n * 链表\n * 字符串\n * 队列\n * 栈\n * 堆（优先队列）\n * 树\n * 图\n * 哈希表\n * 排序\n * 查找",charsets:{cjk:!0}},{frontmatter:{},regularPath:"/data-structure/list/lfu-cache.html",relativePath:"data-structure/list/lfu-cache.md",key:"v-c99dd316",path:"/data-structure/list/lfu-cache.html",headers:[{level:2,title:"算法介绍",slug:"算法介绍",normalizedTitle:"算法介绍",charIndex:2},{level:2,title:"思路分析",slug:"思路分析",normalizedTitle:"思路分析",charIndex:90},{level:2,title:"算法实现",slug:"算法实现",normalizedTitle:"算法实现",charIndex:282}],headersStr:"算法介绍 思路分析 算法实现",content:'# 算法介绍\n\n在阅读本文之前，请确保你已经掌握LRU，本文不会赘述前文所阐述过的的内容。\n\nLFU缓存算法是在LRU算法上的一个改进，对于缓存增加了一个权重的概念。\n\n\n\n\n# 思路分析\n\n在LRU算法的实现中，我们使用了双向链表，很明显，LFU也是需要使用双向链表的。\n\n但是有个问题，如何来管理权重呢？\n\n由于题目已经要求了算法复杂度，因此，这儿要不就是哈希表，要不就得是链表，如果使用哈希表的话，怎么知道各个权重缓存的关系呢，光用哈希表肯定搞不定，如果加上链表呢？\n\n把权重节点用链表串起来，然后链表的节点内存存储缓存内容，联想到曾经提到过的广义表的内容，算法实现的基本框架就已经成型了，如下图：\n\n\n\n如果能知道到权重的头结点和尾节点，并且能找到任意权重的子链表；如果能获取到对应权重的链表，并且能获取到任意缓存节点，那不就大功告成了吗？\n\n有了这个设计思路，一切都是手到擒来了，接下来，我们将所需要的数据结构定义出来：\n\n/**\n * 索引节点\n */\ninterface IndexedNode {\n  /**\n   * 索引节点的数据头节点\n   */\n  head: CacheNode | null;\n  /**\n   * 索引节点的数据尾节点\n   */\n  tail: CacheNode | null;\n  /**\n   * 索引节点的权重，为的是在删除和扩展的时候知道怎么移除怎么新增新的节点\n   */\n  weight: number;\n  /**\n   * 索引节点的前置节点\n   */\n  prev: IndexedNode | null;\n  /**\n   * 索引节点的后继节点\n   */\n  next: IndexedNode | null;\n}\n\n\n索引节点，即上图中橙色的节点。\n\n/**\n * 缓存节点\n */\ninterface CacheNode {\n  /**\n   * 缓存节点的Key\n   */\n  key: string;\n  /**\n   * 缓存节点的值\n   */\n  data: string;\n  /**\n   * 缓存节点的权重，为了知道它所在的权重节点\n   */\n  weight: number;\n  /**\n   * 缓存节点的前置节点\n   */\n  prev: CacheNode | null;\n  /**\n   * 缓存节点的后继节点\n   */\n  next: CacheNode | null;\n}\n\n\n数据节点，即上图中蓝色的节点。\n\n\n# 算法实现\n\n这个算法实现较为复杂，必须充分的理解面向对象编程的思想，合理的封装，以及职责的划分才能更好的理解这题。（在没有意识到这个问题之前，我不知道被绕晕了多少次）\n\n首先，构造函数的内容，需要定义缓存容量以及当前已缓存的数量，需要定义两个哈希表，用于以O(1)的复杂度在缓存节点中查找，一个用于查找权重，一个用于查找缓存节点。\n\n/**\n * @param {number} capacity\n */\nvar LFUCache = function (capacity) {\n  /**\n   * 缓存的容量\n   * @type {number}\n   */\n  this.capacity = capacity;\n  /**\n   * 缓存的节点数\n   * @type {number}\n   */\n  this.size = 0;\n  /**\n   * @type {Map<number, IndexedNode>}\n   */\n  this.indexedMap = new Map();\n  /**\n   * @type {Map<number, CacheNode>}\n   */\n  this.dataMap = new Map();\n  /**\n   * @type {IndexedNode | null}\n   */\n  this.startIndexedNode;\n  /**\n   * @type {IndexedNode | null}\n   */\n  this.endIndexedNode;\n};\n\n/**\n * 获取缓存\n * @param {number} key\n * @return {number}\n */\nLFUCache.prototype.get = function (key) {\n  // 如果数据不存在\n  if (this.capacity <= 0 || !this.dataMap.has(key)) {\n    return -1;\n  }\n  let dataNode = this.dataMap.get(key);\n  // 刷新数据的权重\n  this.refreshDataNodeWeight(dataNode);\n  return dataNode.data;\n};\n\n/**\n * 设置缓存\n * @param {number} key\n * @param {number} value\n * @return {void}\n */\nLFUCache.prototype.put = function (key, value) {\n  if (this.capacity === 0) {\n    console.warn("exceed the lfu cache capacity");\n    return;\n  }\n  // 尝试获取数据节点\n  let dataNode = this.dataMap.get(key);\n  // 如果数据节点不存在\n  if (!dataNode) {\n    // 创建数据节点\n    dataNode = {\n      key,\n      weight: 1,\n      data: value,\n      prev: null,\n      next: null,\n    };\n    // 如果已经超出了最大的容量的话，删除最久没有使用过的节点\n    if (this.size === this.capacity) {\n      this.eject();\n    } else {\n      // 否则直接将数量增加\n      this.size++;\n    }\n    // 获取权重为1的索引节点\n    let indexedNode = this.getOrCreateIndexedNodeIfNotExist(1);\n    // 确定索引节点已存在，向索引节点插入数据节点\n    this.insertIndexedNodeData(indexedNode, dataNode);\n  } else {\n    dataNode.data = value;\n    // 直接更新节点的权重\n    this.refreshDataNodeWeight(dataNode);\n  }\n};\n\n\n对于put操作来说，新来的节点有两种可能，一种是已经存在，那么它需要执行的操作就非常简单，只需要简单的刷新一下它的权重和更新值即可。\n\n对于一个不存在的节点来说，操作就有点儿复杂了。\n\n首先，肯定得初始化这个缓存节点，这个缓存节点的权重一定是 1(因为是新来的嘛)，那么，对于权重为 1 的权重节点是不一定存在的，我们要将这个缓存节点插入的话，首先得确保这个权重节点存在，所以，不存在的话就需要先创建，封装一个操作，避免每次都要去判断，如下：\n\n/**\n * 获取指定权重的节点，若不存在，则创建\n * @param {number} weight\n */\nLFUCache.prototype.getOrCreateIndexedNodeIfNotExist = function (weight) {\n  let indexedNode = this.indexedMap.get(weight);\n  // 如果现在的索引节点不存在\n  if (!indexedNode) {\n    indexedNode = {\n      weight,\n      head: null,\n      tail: null,\n      prev: null,\n      next: null,\n    };\n    this.insertIndexedNode(indexedNode);\n  }\n  return indexedNode;\n};\n\n\n创建成功了，我们就可以直接将缓存节点插入到权重节点中了吗？\n\n不，还不能，因为有容量的限制，假设当前缓存已经超限了的话，那么，得剔除一下权重最小，最远没有使用过的缓存节点。\n\n特别注意\n\n一定是要先剔除才能插入，因为新插入的缓存节点权重一定是 1，那么如果先插入，再剔除的话，那么一定总是剔除的刚才插入的节点。\n\n接着，来看我们之前所用到的，还没有实现的方法。\n\n首先是剔除，思路非常简单，因为持有权重链表的首尾节点，可以很容易的拿到最小权重的节点，它对应的这个链表，其尾节点一定是最久没有使用过的节点，那么其实现就如下所示了：\n\n/**\n * 删除缓存中权重最小并且最久没有使用过的节点\n */\nLFUCache.prototype.eject = function () {\n  // 获取到权重最小的尾节点\n  let tailNode = this.startIndexedNode.tail;\n  // 删除权重最小的尾节点\n  this.removeIndexedNodeData(this.startIndexedNode, tailNode);\n};\n\n\n接着，来看从权重链表中移除节点和从缓存链表中移除节点方法。\n\n对于权重链表的节点移除需要注意的是，它的删除可能会导致之前持有的权重链表的首尾节点改变，大概能够分为 3 种情况的删除。\n\n * 删除头结点\n * 删除尾节点\n * 删除中间节点\n\n/**\n * 删除indexedNode\n * @param {IndexedNode} indexedNode\n */\nLFUCache.prototype.removeIndexedNode = function (indexedNode) {\n  const isStart = this.startIndexedNode === indexedNode;\n  const isEnd = this.endIndexedNode === indexedNode;\n  // 只有一个节点\n  if (isStart && isEnd) {\n    this.endIndexedNode = this.startIndexedNode = null;\n  } else if (isStart) {\n    // 2个节点以上。删除头节点\n    const afterNode = this.startIndexedNode.next;\n    this.startIndexedNode.next = null;\n    afterNode.prev = null;\n    this.startIndexedNode = afterNode;\n  } else if (isEnd) {\n    // 2个节点以上，删除尾节点\n    const beforeNode = this.endIndexedNode.prev;\n    this.endIndexedNode.prev = null;\n    beforeNode.next = null;\n    this.endIndexedNode = beforeNode;\n  } else {\n    // 如果即不删除头节点，也不删除尾节点，至少是3个节点以上\n    const beforeNode = indexedNode.prev;\n    const afterNode = indexedNode.next;\n    indexedNode.prev = null;\n    indexedNode.next = null;\n    beforeNode.next = afterNode;\n    afterNode.prev = beforeNode;\n  }\n  const weight = indexedNode.weight;\n  this.indexedMap.delete(weight);\n};\n\n\n需要注意点的是，如果头尾节点都是同一个的话，删除之后将头尾节点都必须要指向空。\n\n接着是，删除权重节点关联的缓存链表的节点：\n\n/**\n * 删除indexedNode上的dataNode\n * @param {IndexedNode} indexedNode\n * @param {CacheNode} dataNode\n */\nLFUCache.prototype.removeIndexedNodeData = function (indexedNode, dataNode) {\n  if (!indexedNode || !dataNode) {\n    console.warn("indexed node or data node is null");\n    return;\n  }\n  const isStart = indexedNode.head === dataNode;\n  const isEnd = indexedNode.tail === dataNode;\n  if (isStart && isEnd) {\n    this.removeIndexedNode(indexedNode);\n  } else if (isStart) {\n    const afterNode = indexedNode.head.next;\n    indexedNode.head.next = null;\n    afterNode.prev = null;\n    indexedNode.head = afterNode;\n  } else if (isEnd) {\n    const beforeNode = indexedNode.tail.prev;\n    indexedNode.tail.prev = null;\n    beforeNode.next = null;\n    indexedNode.tail = beforeNode;\n  } else {\n    const beforeDataNode = dataNode.prev;\n    const afterDataNode = dataNode.next;\n    dataNode.prev = null;\n    dataNode.next = null;\n    beforeDataNode.next = afterDataNode;\n    afterDataNode.prev = beforeDataNode;\n  }\n  // 删除key上面的内容\n  const key = dataNode.key;\n  this.dataMap.delete(key);\n};\n\n\n需要考虑的情况和删除权重链表的节点操作类似。\n\n有删除，就有插入，分别是插入权重节点和插入权重节点上的缓存节点的操作。\n\n这两个操作是非常容易出错的，需要尤其小心，考虑的边界条件也多的多。\n\n/**\n * 将indexedNode插入在refNode之后\n * @param {IndexedNode} indexedNode\n * @param {IndexedNode | null} refNode\n */\nLFUCache.prototype.insertIndexedNode = function (indexedNode, refNode = null) {\n  const weight = indexedNode.weight;\n  this.indexedMap.set(weight, indexedNode);\n  // 如果当前表为空\n  if (!this.startIndexedNode && !this.endIndexedNode) {\n    this.startIndexedNode = this.endIndexedNode = indexedNode;\n    return;\n  }\n  // 如果参考节点不存在或者只有一个参考节点，说明当前其实只有一个节点，则直接插入在最后面\n  if (!refNode || (!refNode.next && !refNode.prev)) {\n    // 如果当前节点的索引比较大\n    if (indexedNode.weight < this.startIndexedNode.weight) {\n      indexedNode.next = this.startIndexedNode;\n      this.startIndexedNode.prev = indexedNode;\n      this.startIndexedNode = indexedNode;\n    } else {\n      this.endIndexedNode.next = indexedNode;\n      indexedNode.prev = this.endIndexedNode;\n      this.endIndexedNode = indexedNode;\n    }\n  } else {\n    const refNextNode = refNode.next;\n    // 说明不是最后一个节点\n    if (refNextNode) {\n      // 建立前驱节点的关系\n      refNode.next = indexedNode;\n      indexedNode.prev = refNode;\n      // 建立后继节点的关系\n      indexedNode.next = refNextNode;\n      refNextNode.prev = indexedNode;\n    } else {\n      // 建立前驱节点的关系\n      refNode.next = indexedNode;\n      indexedNode.prev = refNode;\n      this.endIndexedNode = indexedNode;\n    }\n  }\n};\n\n\n如果插入权重节点，之前一个都没有的话，那么直接插入就好。\n\n但问题就是如果之前有的话，你就要指定新来的权重节点插入的位置了，因此，我们引入一个参数叫做refNode。我们规定如果存在refNode的话，都将节点插入在这个节点之后。\n\n这儿有一个极其边界的条件，本来，只有一个权重节点，那么，新插入的节点就不能简单的只考虑直接插入在refNode的后面了，此时需要比较一下新插入的权重节点的权重，决定插入在其前还是后。\n\n在已知权重节点上插入新的缓存节点这个操作非常简单，因为我们之前已经学过了LRU，只需要将新来的节点都插在表头即可。\n\n/**\n * 向indexedNode上插入dataNode\n * @param {IndexedNode} indexedNode\n * @param {CacheNode} dataNode\n */\nLFUCache.prototype.insertIndexedNodeData = function (indexedNode, dataNode) {\n  if (!indexedNode || !dataNode) {\n    console.warn("num node or data node is null");\n    return;\n  }\n  if (indexedNode.head === null && indexedNode.tail === null) {\n    indexedNode.head = dataNode;\n    indexedNode.tail = dataNode;\n  } else {\n    // 将缓存节点插入在当前索引的最前端\n    dataNode.next = indexedNode.head;\n    indexedNode.head.prev = dataNode;\n    indexedNode.head = dataNode;\n  }\n  const key = dataNode.key;\n  this.dataMap.set(key, dataNode);\n};\n\n\n需要注意的就是，如果当前权重节点没有缓存节点都话，那么，头尾节点都必须指向新插入的缓存节点才行。\n\n到这儿，我们已经完成了万里长征的绝大部分了，最后来看一下更新操作。\n\n每次访问了缓存，都需要更新这个缓存的权重，这个操作非常容易理解，将当前缓存节点从原来的权重节点上拿掉，权重增加 1，在新的权重节点上加入。\n\n同样需要注意的问题就是新插入的权重节点是不一定存在的，因此需要确保存在才行，这就是为什么我们之前要封装获取指定权重节点的方法的理由。\n\n/**\n * 更新节点的权重\n * @param {CacheNode} dataNode\n */\nLFUCache.prototype.refreshDataNodeWeight = function (dataNode) {\n  const preKeyOfIndexed = dataNode.weight;\n  // 获取到之前的索引节点\n  let preIndexedNode = this.indexedMap.get(preKeyOfIndexed);\n  // 删除之前索引节点上的数据节点\n  this.removeIndexedNodeData(preIndexedNode, dataNode);\n  const nowKeyOfIndexed = ++dataNode.weight;\n  // 获取现在的索引节点\n  const nowIndexedNode = this.getOrCreateIndexedNodeIfNotExist(nowKeyOfIndexed);\n  // 确定索引节点存在，插入数据节点\n  this.insertIndexedNodeData(nowIndexedNode, dataNode);\n};\n\n\n以上就是LFU缓存的实现全过程，请各位朋友注意区别LRU。\n\n完整代码如下：\n\n/**\n * @param {number} capacity\n */\nvar LFUCache = function (capacity) {\n  /**\n   * 缓存的容量\n   * @type {number}\n   */\n  this.capacity = capacity;\n  /**\n   * 缓存的节点数\n   * @type {number}\n   */\n  this.size = 0;\n  /**\n   * @type {Map<number, IndexedNode>}\n   */\n  this.indexedMap = new Map();\n  /**\n   * @type {Map<number, CacheNode>}\n   */\n  this.dataMap = new Map();\n  /**\n   * @type {IndexedNode | null}\n   */\n  this.startIndexedNode;\n  /**\n   * @type {IndexedNode | null}\n   */\n  this.endIndexedNode;\n};\n\n/**\n * 获取缓存\n * @param {number} key\n * @return {number}\n */\nLFUCache.prototype.get = function (key) {\n  // 如果数据不存在\n  if (this.capacity <= 0 || !this.dataMap.has(key)) {\n    return -1;\n  }\n  let dataNode = this.dataMap.get(key);\n  // 刷新数据的权重\n  this.refreshDataNodeWeight(dataNode);\n  return dataNode.data;\n};\n\n/**\n * 设置缓存\n * @param {number} key\n * @param {number} value\n * @return {void}\n */\nLFUCache.prototype.put = function (key, value) {\n  if (this.capacity === 0) {\n    console.warn("exceed the lfu cache capacity");\n    return;\n  }\n  // 尝试获取数据节点\n  let dataNode = this.dataMap.get(key);\n  // 如果数据节点不存在\n  if (!dataNode) {\n    // 创建数据节点\n    dataNode = {\n      key,\n      weight: 1,\n      data: value,\n      prev: null,\n      next: null,\n    };\n    // 如果已经超出了最大的容量的话，删除最久没有使用过的节点\n    if (this.size === this.capacity) {\n      this.eject();\n    } else {\n      // 否则直接将数量增加\n      this.size++;\n    }\n    // 获取权重为1的索引节点\n    let indexedNode = this.getOrCreateIndexedNodeIfNotExist(1);\n    // 确定索引节点已存在，向索引节点插入数据节点\n    this.insertIndexedNodeData(indexedNode, dataNode);\n  } else {\n    dataNode.data = value;\n    // 直接更新节点的权重\n    this.refreshDataNodeWeight(dataNode);\n  }\n};\n\n/**\n * 删除缓存中权重最小并且最久没有使用过的节点\n */\nLFUCache.prototype.eject = function () {\n  // 获取到权重最小的尾节点\n  let tailNode = this.startIndexedNode.tail;\n  // 删除权重最小的尾节点\n  this.removeIndexedNodeData(this.startIndexedNode, tailNode);\n};\n\n/**\n * 更新节点的权重\n * @param {CacheNode} dataNode\n */\nLFUCache.prototype.refreshDataNodeWeight = function (dataNode) {\n  const preKeyOfIndexed = dataNode.weight;\n  // 获取到之前的索引节点\n  let preIndexedNode = this.indexedMap.get(preKeyOfIndexed);\n  // 删除之前索引节点上的数据节点\n  this.removeIndexedNodeData(preIndexedNode, dataNode);\n  const nowKeyOfIndexed = ++dataNode.weight;\n  // 获取现在的索引节点\n  const nowIndexedNode = this.getOrCreateIndexedNodeIfNotExist(nowKeyOfIndexed);\n  // 确定索引节点存在，插入数据节点\n  this.insertIndexedNodeData(nowIndexedNode, dataNode);\n};\n\n/**\n * 获取指定权重的节点，若不存在，则创建\n * @param {number} weight\n */\nLFUCache.prototype.getOrCreateIndexedNodeIfNotExist = function (weight) {\n  let indexedNode = this.indexedMap.get(weight);\n  // 如果现在的索引节点不存在\n  if (!indexedNode) {\n    indexedNode = {\n      weight,\n      head: null,\n      tail: null,\n      prev: null,\n      next: null,\n    };\n    this.insertIndexedNode(indexedNode);\n  }\n  return indexedNode;\n};\n\n/**\n * 删除indexedNode\n * @param {IndexedNode} indexedNode\n */\nLFUCache.prototype.removeIndexedNode = function (indexedNode) {\n  const isStart = this.startIndexedNode === indexedNode;\n  const isEnd = this.endIndexedNode === indexedNode;\n  // 只有一个节点\n  if (isStart && isEnd) {\n    this.endIndexedNode = this.startIndexedNode = null;\n  } else if (isStart) {\n    // 2个节点以上。删除头节点\n    const afterNode = this.startIndexedNode.next;\n    this.startIndexedNode.next = null;\n    afterNode.prev = null;\n    this.startIndexedNode = afterNode;\n  } else if (isEnd) {\n    // 2个节点以上，删除尾节点\n    const beforeNode = this.endIndexedNode.prev;\n    this.endIndexedNode.prev = null;\n    beforeNode.next = null;\n    this.endIndexedNode = beforeNode;\n  } else {\n    // 如果即不删除头节点，也不删除尾节点，至少是3个节点以上\n    const beforeNode = indexedNode.prev;\n    const afterNode = indexedNode.next;\n    indexedNode.prev = null;\n    indexedNode.next = null;\n    beforeNode.next = afterNode;\n    afterNode.prev = beforeNode;\n  }\n  const weight = indexedNode.weight;\n  this.indexedMap.delete(weight);\n};\n\n/**\n * 将indexedNode插入在refNode之后\n * @param {IndexedNode} indexedNode\n * @param {IndexedNode | null} refNode\n */\nLFUCache.prototype.insertIndexedNode = function (indexedNode, refNode = null) {\n  const weight = indexedNode.weight;\n  this.indexedMap.set(weight, indexedNode);\n  // 如果当前表为空\n  if (!this.startIndexedNode && !this.endIndexedNode) {\n    this.startIndexedNode = this.endIndexedNode = indexedNode;\n    return;\n  }\n  // 如果参考节点不存在或者只有一个参考节点，说明当前其实只有一个节点，则直接插入在最后面\n  if (!refNode || (!refNode.next && !refNode.prev)) {\n    // 如果当前节点的索引比较大\n    if (indexedNode.weight < this.startIndexedNode.weight) {\n      indexedNode.next = this.startIndexedNode;\n      this.startIndexedNode.prev = indexedNode;\n      this.startIndexedNode = indexedNode;\n    } else {\n      this.endIndexedNode.next = indexedNode;\n      indexedNode.prev = this.endIndexedNode;\n      this.endIndexedNode = indexedNode;\n    }\n  } else {\n    const refNextNode = refNode.next;\n    // 说明不是最后一个节点\n    if (refNextNode) {\n      // 建立前驱节点的关系\n      refNode.next = indexedNode;\n      indexedNode.prev = refNode;\n      // 建立后继节点的关系\n      indexedNode.next = refNextNode;\n      refNextNode.prev = indexedNode;\n    } else {\n      // 建立前驱节点的关系\n      refNode.next = indexedNode;\n      indexedNode.prev = refNode;\n      this.endIndexedNode = indexedNode;\n    }\n  }\n};\n\n/**\n * 删除indexedNode上的dataNode\n * @param {IndexedNode} indexedNode\n * @param {CacheNode} dataNode\n */\nLFUCache.prototype.removeIndexedNodeData = function (indexedNode, dataNode) {\n  if (!indexedNode || !dataNode) {\n    console.warn("indexed node or data node is null");\n    return;\n  }\n  const isStart = indexedNode.head === dataNode;\n  const isEnd = indexedNode.tail === dataNode;\n  if (isStart && isEnd) {\n    this.removeIndexedNode(indexedNode);\n  } else if (isStart) {\n    const afterNode = indexedNode.head.next;\n    indexedNode.head.next = null;\n    afterNode.prev = null;\n    indexedNode.head = afterNode;\n  } else if (isEnd) {\n    const beforeNode = indexedNode.tail.prev;\n    indexedNode.tail.prev = null;\n    beforeNode.next = null;\n    indexedNode.tail = beforeNode;\n  } else {\n    const beforeDataNode = dataNode.prev;\n    const afterDataNode = dataNode.next;\n    dataNode.prev = null;\n    dataNode.next = null;\n    beforeDataNode.next = afterDataNode;\n    afterDataNode.prev = beforeDataNode;\n  }\n  // 删除key上面的内容\n  const key = dataNode.key;\n  this.dataMap.delete(key);\n};\n\n/**\n * 向indexedNode上插入dataNode\n * @param {IndexedNode} indexedNode\n * @param {CacheNode} dataNode\n */\nLFUCache.prototype.insertIndexedNodeData = function (indexedNode, dataNode) {\n  if (!indexedNode || !dataNode) {\n    console.warn("num node or data node is null");\n    return;\n  }\n  if (indexedNode.head === null && indexedNode.tail === null) {\n    indexedNode.head = dataNode;\n    indexedNode.tail = dataNode;\n  } else {\n    // 将缓存节点插入在当前索引的最前端\n    dataNode.next = indexedNode.head;\n    indexedNode.head.prev = dataNode;\n    indexedNode.head = dataNode;\n  }\n  const key = dataNode.key;\n  this.dataMap.set(key, dataNode);\n};\n',normalizedContent:'# 算法介绍\n\n在阅读本文之前，请确保你已经掌握lru，本文不会赘述前文所阐述过的的内容。\n\nlfu缓存算法是在lru算法上的一个改进，对于缓存增加了一个权重的概念。\n\n\n\n\n# 思路分析\n\n在lru算法的实现中，我们使用了双向链表，很明显，lfu也是需要使用双向链表的。\n\n但是有个问题，如何来管理权重呢？\n\n由于题目已经要求了算法复杂度，因此，这儿要不就是哈希表，要不就得是链表，如果使用哈希表的话，怎么知道各个权重缓存的关系呢，光用哈希表肯定搞不定，如果加上链表呢？\n\n把权重节点用链表串起来，然后链表的节点内存存储缓存内容，联想到曾经提到过的广义表的内容，算法实现的基本框架就已经成型了，如下图：\n\n\n\n如果能知道到权重的头结点和尾节点，并且能找到任意权重的子链表；如果能获取到对应权重的链表，并且能获取到任意缓存节点，那不就大功告成了吗？\n\n有了这个设计思路，一切都是手到擒来了，接下来，我们将所需要的数据结构定义出来：\n\n/**\n * 索引节点\n */\ninterface indexednode {\n  /**\n   * 索引节点的数据头节点\n   */\n  head: cachenode | null;\n  /**\n   * 索引节点的数据尾节点\n   */\n  tail: cachenode | null;\n  /**\n   * 索引节点的权重，为的是在删除和扩展的时候知道怎么移除怎么新增新的节点\n   */\n  weight: number;\n  /**\n   * 索引节点的前置节点\n   */\n  prev: indexednode | null;\n  /**\n   * 索引节点的后继节点\n   */\n  next: indexednode | null;\n}\n\n\n索引节点，即上图中橙色的节点。\n\n/**\n * 缓存节点\n */\ninterface cachenode {\n  /**\n   * 缓存节点的key\n   */\n  key: string;\n  /**\n   * 缓存节点的值\n   */\n  data: string;\n  /**\n   * 缓存节点的权重，为了知道它所在的权重节点\n   */\n  weight: number;\n  /**\n   * 缓存节点的前置节点\n   */\n  prev: cachenode | null;\n  /**\n   * 缓存节点的后继节点\n   */\n  next: cachenode | null;\n}\n\n\n数据节点，即上图中蓝色的节点。\n\n\n# 算法实现\n\n这个算法实现较为复杂，必须充分的理解面向对象编程的思想，合理的封装，以及职责的划分才能更好的理解这题。（在没有意识到这个问题之前，我不知道被绕晕了多少次）\n\n首先，构造函数的内容，需要定义缓存容量以及当前已缓存的数量，需要定义两个哈希表，用于以o(1)的复杂度在缓存节点中查找，一个用于查找权重，一个用于查找缓存节点。\n\n/**\n * @param {number} capacity\n */\nvar lfucache = function (capacity) {\n  /**\n   * 缓存的容量\n   * @type {number}\n   */\n  this.capacity = capacity;\n  /**\n   * 缓存的节点数\n   * @type {number}\n   */\n  this.size = 0;\n  /**\n   * @type {map<number, indexednode>}\n   */\n  this.indexedmap = new map();\n  /**\n   * @type {map<number, cachenode>}\n   */\n  this.datamap = new map();\n  /**\n   * @type {indexednode | null}\n   */\n  this.startindexednode;\n  /**\n   * @type {indexednode | null}\n   */\n  this.endindexednode;\n};\n\n/**\n * 获取缓存\n * @param {number} key\n * @return {number}\n */\nlfucache.prototype.get = function (key) {\n  // 如果数据不存在\n  if (this.capacity <= 0 || !this.datamap.has(key)) {\n    return -1;\n  }\n  let datanode = this.datamap.get(key);\n  // 刷新数据的权重\n  this.refreshdatanodeweight(datanode);\n  return datanode.data;\n};\n\n/**\n * 设置缓存\n * @param {number} key\n * @param {number} value\n * @return {void}\n */\nlfucache.prototype.put = function (key, value) {\n  if (this.capacity === 0) {\n    console.warn("exceed the lfu cache capacity");\n    return;\n  }\n  // 尝试获取数据节点\n  let datanode = this.datamap.get(key);\n  // 如果数据节点不存在\n  if (!datanode) {\n    // 创建数据节点\n    datanode = {\n      key,\n      weight: 1,\n      data: value,\n      prev: null,\n      next: null,\n    };\n    // 如果已经超出了最大的容量的话，删除最久没有使用过的节点\n    if (this.size === this.capacity) {\n      this.eject();\n    } else {\n      // 否则直接将数量增加\n      this.size++;\n    }\n    // 获取权重为1的索引节点\n    let indexednode = this.getorcreateindexednodeifnotexist(1);\n    // 确定索引节点已存在，向索引节点插入数据节点\n    this.insertindexednodedata(indexednode, datanode);\n  } else {\n    datanode.data = value;\n    // 直接更新节点的权重\n    this.refreshdatanodeweight(datanode);\n  }\n};\n\n\n对于put操作来说，新来的节点有两种可能，一种是已经存在，那么它需要执行的操作就非常简单，只需要简单的刷新一下它的权重和更新值即可。\n\n对于一个不存在的节点来说，操作就有点儿复杂了。\n\n首先，肯定得初始化这个缓存节点，这个缓存节点的权重一定是 1(因为是新来的嘛)，那么，对于权重为 1 的权重节点是不一定存在的，我们要将这个缓存节点插入的话，首先得确保这个权重节点存在，所以，不存在的话就需要先创建，封装一个操作，避免每次都要去判断，如下：\n\n/**\n * 获取指定权重的节点，若不存在，则创建\n * @param {number} weight\n */\nlfucache.prototype.getorcreateindexednodeifnotexist = function (weight) {\n  let indexednode = this.indexedmap.get(weight);\n  // 如果现在的索引节点不存在\n  if (!indexednode) {\n    indexednode = {\n      weight,\n      head: null,\n      tail: null,\n      prev: null,\n      next: null,\n    };\n    this.insertindexednode(indexednode);\n  }\n  return indexednode;\n};\n\n\n创建成功了，我们就可以直接将缓存节点插入到权重节点中了吗？\n\n不，还不能，因为有容量的限制，假设当前缓存已经超限了的话，那么，得剔除一下权重最小，最远没有使用过的缓存节点。\n\n特别注意\n\n一定是要先剔除才能插入，因为新插入的缓存节点权重一定是 1，那么如果先插入，再剔除的话，那么一定总是剔除的刚才插入的节点。\n\n接着，来看我们之前所用到的，还没有实现的方法。\n\n首先是剔除，思路非常简单，因为持有权重链表的首尾节点，可以很容易的拿到最小权重的节点，它对应的这个链表，其尾节点一定是最久没有使用过的节点，那么其实现就如下所示了：\n\n/**\n * 删除缓存中权重最小并且最久没有使用过的节点\n */\nlfucache.prototype.eject = function () {\n  // 获取到权重最小的尾节点\n  let tailnode = this.startindexednode.tail;\n  // 删除权重最小的尾节点\n  this.removeindexednodedata(this.startindexednode, tailnode);\n};\n\n\n接着，来看从权重链表中移除节点和从缓存链表中移除节点方法。\n\n对于权重链表的节点移除需要注意的是，它的删除可能会导致之前持有的权重链表的首尾节点改变，大概能够分为 3 种情况的删除。\n\n * 删除头结点\n * 删除尾节点\n * 删除中间节点\n\n/**\n * 删除indexednode\n * @param {indexednode} indexednode\n */\nlfucache.prototype.removeindexednode = function (indexednode) {\n  const isstart = this.startindexednode === indexednode;\n  const isend = this.endindexednode === indexednode;\n  // 只有一个节点\n  if (isstart && isend) {\n    this.endindexednode = this.startindexednode = null;\n  } else if (isstart) {\n    // 2个节点以上。删除头节点\n    const afternode = this.startindexednode.next;\n    this.startindexednode.next = null;\n    afternode.prev = null;\n    this.startindexednode = afternode;\n  } else if (isend) {\n    // 2个节点以上，删除尾节点\n    const beforenode = this.endindexednode.prev;\n    this.endindexednode.prev = null;\n    beforenode.next = null;\n    this.endindexednode = beforenode;\n  } else {\n    // 如果即不删除头节点，也不删除尾节点，至少是3个节点以上\n    const beforenode = indexednode.prev;\n    const afternode = indexednode.next;\n    indexednode.prev = null;\n    indexednode.next = null;\n    beforenode.next = afternode;\n    afternode.prev = beforenode;\n  }\n  const weight = indexednode.weight;\n  this.indexedmap.delete(weight);\n};\n\n\n需要注意点的是，如果头尾节点都是同一个的话，删除之后将头尾节点都必须要指向空。\n\n接着是，删除权重节点关联的缓存链表的节点：\n\n/**\n * 删除indexednode上的datanode\n * @param {indexednode} indexednode\n * @param {cachenode} datanode\n */\nlfucache.prototype.removeindexednodedata = function (indexednode, datanode) {\n  if (!indexednode || !datanode) {\n    console.warn("indexed node or data node is null");\n    return;\n  }\n  const isstart = indexednode.head === datanode;\n  const isend = indexednode.tail === datanode;\n  if (isstart && isend) {\n    this.removeindexednode(indexednode);\n  } else if (isstart) {\n    const afternode = indexednode.head.next;\n    indexednode.head.next = null;\n    afternode.prev = null;\n    indexednode.head = afternode;\n  } else if (isend) {\n    const beforenode = indexednode.tail.prev;\n    indexednode.tail.prev = null;\n    beforenode.next = null;\n    indexednode.tail = beforenode;\n  } else {\n    const beforedatanode = datanode.prev;\n    const afterdatanode = datanode.next;\n    datanode.prev = null;\n    datanode.next = null;\n    beforedatanode.next = afterdatanode;\n    afterdatanode.prev = beforedatanode;\n  }\n  // 删除key上面的内容\n  const key = datanode.key;\n  this.datamap.delete(key);\n};\n\n\n需要考虑的情况和删除权重链表的节点操作类似。\n\n有删除，就有插入，分别是插入权重节点和插入权重节点上的缓存节点的操作。\n\n这两个操作是非常容易出错的，需要尤其小心，考虑的边界条件也多的多。\n\n/**\n * 将indexednode插入在refnode之后\n * @param {indexednode} indexednode\n * @param {indexednode | null} refnode\n */\nlfucache.prototype.insertindexednode = function (indexednode, refnode = null) {\n  const weight = indexednode.weight;\n  this.indexedmap.set(weight, indexednode);\n  // 如果当前表为空\n  if (!this.startindexednode && !this.endindexednode) {\n    this.startindexednode = this.endindexednode = indexednode;\n    return;\n  }\n  // 如果参考节点不存在或者只有一个参考节点，说明当前其实只有一个节点，则直接插入在最后面\n  if (!refnode || (!refnode.next && !refnode.prev)) {\n    // 如果当前节点的索引比较大\n    if (indexednode.weight < this.startindexednode.weight) {\n      indexednode.next = this.startindexednode;\n      this.startindexednode.prev = indexednode;\n      this.startindexednode = indexednode;\n    } else {\n      this.endindexednode.next = indexednode;\n      indexednode.prev = this.endindexednode;\n      this.endindexednode = indexednode;\n    }\n  } else {\n    const refnextnode = refnode.next;\n    // 说明不是最后一个节点\n    if (refnextnode) {\n      // 建立前驱节点的关系\n      refnode.next = indexednode;\n      indexednode.prev = refnode;\n      // 建立后继节点的关系\n      indexednode.next = refnextnode;\n      refnextnode.prev = indexednode;\n    } else {\n      // 建立前驱节点的关系\n      refnode.next = indexednode;\n      indexednode.prev = refnode;\n      this.endindexednode = indexednode;\n    }\n  }\n};\n\n\n如果插入权重节点，之前一个都没有的话，那么直接插入就好。\n\n但问题就是如果之前有的话，你就要指定新来的权重节点插入的位置了，因此，我们引入一个参数叫做refnode。我们规定如果存在refnode的话，都将节点插入在这个节点之后。\n\n这儿有一个极其边界的条件，本来，只有一个权重节点，那么，新插入的节点就不能简单的只考虑直接插入在refnode的后面了，此时需要比较一下新插入的权重节点的权重，决定插入在其前还是后。\n\n在已知权重节点上插入新的缓存节点这个操作非常简单，因为我们之前已经学过了lru，只需要将新来的节点都插在表头即可。\n\n/**\n * 向indexednode上插入datanode\n * @param {indexednode} indexednode\n * @param {cachenode} datanode\n */\nlfucache.prototype.insertindexednodedata = function (indexednode, datanode) {\n  if (!indexednode || !datanode) {\n    console.warn("num node or data node is null");\n    return;\n  }\n  if (indexednode.head === null && indexednode.tail === null) {\n    indexednode.head = datanode;\n    indexednode.tail = datanode;\n  } else {\n    // 将缓存节点插入在当前索引的最前端\n    datanode.next = indexednode.head;\n    indexednode.head.prev = datanode;\n    indexednode.head = datanode;\n  }\n  const key = datanode.key;\n  this.datamap.set(key, datanode);\n};\n\n\n需要注意的就是，如果当前权重节点没有缓存节点都话，那么，头尾节点都必须指向新插入的缓存节点才行。\n\n到这儿，我们已经完成了万里长征的绝大部分了，最后来看一下更新操作。\n\n每次访问了缓存，都需要更新这个缓存的权重，这个操作非常容易理解，将当前缓存节点从原来的权重节点上拿掉，权重增加 1，在新的权重节点上加入。\n\n同样需要注意的问题就是新插入的权重节点是不一定存在的，因此需要确保存在才行，这就是为什么我们之前要封装获取指定权重节点的方法的理由。\n\n/**\n * 更新节点的权重\n * @param {cachenode} datanode\n */\nlfucache.prototype.refreshdatanodeweight = function (datanode) {\n  const prekeyofindexed = datanode.weight;\n  // 获取到之前的索引节点\n  let preindexednode = this.indexedmap.get(prekeyofindexed);\n  // 删除之前索引节点上的数据节点\n  this.removeindexednodedata(preindexednode, datanode);\n  const nowkeyofindexed = ++datanode.weight;\n  // 获取现在的索引节点\n  const nowindexednode = this.getorcreateindexednodeifnotexist(nowkeyofindexed);\n  // 确定索引节点存在，插入数据节点\n  this.insertindexednodedata(nowindexednode, datanode);\n};\n\n\n以上就是lfu缓存的实现全过程，请各位朋友注意区别lru。\n\n完整代码如下：\n\n/**\n * @param {number} capacity\n */\nvar lfucache = function (capacity) {\n  /**\n   * 缓存的容量\n   * @type {number}\n   */\n  this.capacity = capacity;\n  /**\n   * 缓存的节点数\n   * @type {number}\n   */\n  this.size = 0;\n  /**\n   * @type {map<number, indexednode>}\n   */\n  this.indexedmap = new map();\n  /**\n   * @type {map<number, cachenode>}\n   */\n  this.datamap = new map();\n  /**\n   * @type {indexednode | null}\n   */\n  this.startindexednode;\n  /**\n   * @type {indexednode | null}\n   */\n  this.endindexednode;\n};\n\n/**\n * 获取缓存\n * @param {number} key\n * @return {number}\n */\nlfucache.prototype.get = function (key) {\n  // 如果数据不存在\n  if (this.capacity <= 0 || !this.datamap.has(key)) {\n    return -1;\n  }\n  let datanode = this.datamap.get(key);\n  // 刷新数据的权重\n  this.refreshdatanodeweight(datanode);\n  return datanode.data;\n};\n\n/**\n * 设置缓存\n * @param {number} key\n * @param {number} value\n * @return {void}\n */\nlfucache.prototype.put = function (key, value) {\n  if (this.capacity === 0) {\n    console.warn("exceed the lfu cache capacity");\n    return;\n  }\n  // 尝试获取数据节点\n  let datanode = this.datamap.get(key);\n  // 如果数据节点不存在\n  if (!datanode) {\n    // 创建数据节点\n    datanode = {\n      key,\n      weight: 1,\n      data: value,\n      prev: null,\n      next: null,\n    };\n    // 如果已经超出了最大的容量的话，删除最久没有使用过的节点\n    if (this.size === this.capacity) {\n      this.eject();\n    } else {\n      // 否则直接将数量增加\n      this.size++;\n    }\n    // 获取权重为1的索引节点\n    let indexednode = this.getorcreateindexednodeifnotexist(1);\n    // 确定索引节点已存在，向索引节点插入数据节点\n    this.insertindexednodedata(indexednode, datanode);\n  } else {\n    datanode.data = value;\n    // 直接更新节点的权重\n    this.refreshdatanodeweight(datanode);\n  }\n};\n\n/**\n * 删除缓存中权重最小并且最久没有使用过的节点\n */\nlfucache.prototype.eject = function () {\n  // 获取到权重最小的尾节点\n  let tailnode = this.startindexednode.tail;\n  // 删除权重最小的尾节点\n  this.removeindexednodedata(this.startindexednode, tailnode);\n};\n\n/**\n * 更新节点的权重\n * @param {cachenode} datanode\n */\nlfucache.prototype.refreshdatanodeweight = function (datanode) {\n  const prekeyofindexed = datanode.weight;\n  // 获取到之前的索引节点\n  let preindexednode = this.indexedmap.get(prekeyofindexed);\n  // 删除之前索引节点上的数据节点\n  this.removeindexednodedata(preindexednode, datanode);\n  const nowkeyofindexed = ++datanode.weight;\n  // 获取现在的索引节点\n  const nowindexednode = this.getorcreateindexednodeifnotexist(nowkeyofindexed);\n  // 确定索引节点存在，插入数据节点\n  this.insertindexednodedata(nowindexednode, datanode);\n};\n\n/**\n * 获取指定权重的节点，若不存在，则创建\n * @param {number} weight\n */\nlfucache.prototype.getorcreateindexednodeifnotexist = function (weight) {\n  let indexednode = this.indexedmap.get(weight);\n  // 如果现在的索引节点不存在\n  if (!indexednode) {\n    indexednode = {\n      weight,\n      head: null,\n      tail: null,\n      prev: null,\n      next: null,\n    };\n    this.insertindexednode(indexednode);\n  }\n  return indexednode;\n};\n\n/**\n * 删除indexednode\n * @param {indexednode} indexednode\n */\nlfucache.prototype.removeindexednode = function (indexednode) {\n  const isstart = this.startindexednode === indexednode;\n  const isend = this.endindexednode === indexednode;\n  // 只有一个节点\n  if (isstart && isend) {\n    this.endindexednode = this.startindexednode = null;\n  } else if (isstart) {\n    // 2个节点以上。删除头节点\n    const afternode = this.startindexednode.next;\n    this.startindexednode.next = null;\n    afternode.prev = null;\n    this.startindexednode = afternode;\n  } else if (isend) {\n    // 2个节点以上，删除尾节点\n    const beforenode = this.endindexednode.prev;\n    this.endindexednode.prev = null;\n    beforenode.next = null;\n    this.endindexednode = beforenode;\n  } else {\n    // 如果即不删除头节点，也不删除尾节点，至少是3个节点以上\n    const beforenode = indexednode.prev;\n    const afternode = indexednode.next;\n    indexednode.prev = null;\n    indexednode.next = null;\n    beforenode.next = afternode;\n    afternode.prev = beforenode;\n  }\n  const weight = indexednode.weight;\n  this.indexedmap.delete(weight);\n};\n\n/**\n * 将indexednode插入在refnode之后\n * @param {indexednode} indexednode\n * @param {indexednode | null} refnode\n */\nlfucache.prototype.insertindexednode = function (indexednode, refnode = null) {\n  const weight = indexednode.weight;\n  this.indexedmap.set(weight, indexednode);\n  // 如果当前表为空\n  if (!this.startindexednode && !this.endindexednode) {\n    this.startindexednode = this.endindexednode = indexednode;\n    return;\n  }\n  // 如果参考节点不存在或者只有一个参考节点，说明当前其实只有一个节点，则直接插入在最后面\n  if (!refnode || (!refnode.next && !refnode.prev)) {\n    // 如果当前节点的索引比较大\n    if (indexednode.weight < this.startindexednode.weight) {\n      indexednode.next = this.startindexednode;\n      this.startindexednode.prev = indexednode;\n      this.startindexednode = indexednode;\n    } else {\n      this.endindexednode.next = indexednode;\n      indexednode.prev = this.endindexednode;\n      this.endindexednode = indexednode;\n    }\n  } else {\n    const refnextnode = refnode.next;\n    // 说明不是最后一个节点\n    if (refnextnode) {\n      // 建立前驱节点的关系\n      refnode.next = indexednode;\n      indexednode.prev = refnode;\n      // 建立后继节点的关系\n      indexednode.next = refnextnode;\n      refnextnode.prev = indexednode;\n    } else {\n      // 建立前驱节点的关系\n      refnode.next = indexednode;\n      indexednode.prev = refnode;\n      this.endindexednode = indexednode;\n    }\n  }\n};\n\n/**\n * 删除indexednode上的datanode\n * @param {indexednode} indexednode\n * @param {cachenode} datanode\n */\nlfucache.prototype.removeindexednodedata = function (indexednode, datanode) {\n  if (!indexednode || !datanode) {\n    console.warn("indexed node or data node is null");\n    return;\n  }\n  const isstart = indexednode.head === datanode;\n  const isend = indexednode.tail === datanode;\n  if (isstart && isend) {\n    this.removeindexednode(indexednode);\n  } else if (isstart) {\n    const afternode = indexednode.head.next;\n    indexednode.head.next = null;\n    afternode.prev = null;\n    indexednode.head = afternode;\n  } else if (isend) {\n    const beforenode = indexednode.tail.prev;\n    indexednode.tail.prev = null;\n    beforenode.next = null;\n    indexednode.tail = beforenode;\n  } else {\n    const beforedatanode = datanode.prev;\n    const afterdatanode = datanode.next;\n    datanode.prev = null;\n    datanode.next = null;\n    beforedatanode.next = afterdatanode;\n    afterdatanode.prev = beforedatanode;\n  }\n  // 删除key上面的内容\n  const key = datanode.key;\n  this.datamap.delete(key);\n};\n\n/**\n * 向indexednode上插入datanode\n * @param {indexednode} indexednode\n * @param {cachenode} datanode\n */\nlfucache.prototype.insertindexednodedata = function (indexednode, datanode) {\n  if (!indexednode || !datanode) {\n    console.warn("num node or data node is null");\n    return;\n  }\n  if (indexednode.head === null && indexednode.tail === null) {\n    indexednode.head = datanode;\n    indexednode.tail = datanode;\n  } else {\n    // 将缓存节点插入在当前索引的最前端\n    datanode.next = indexednode.head;\n    indexednode.head.prev = datanode;\n    indexednode.head = datanode;\n  }\n  const key = datanode.key;\n  this.datamap.set(key, datanode);\n};\n',charsets:{cjk:!0}},{title:"链表",frontmatter:{},regularPath:"/data-structure/list/linkedList.html",relativePath:"data-structure/list/linkedList.md",key:"v-f3c1e4e2",path:"/data-structure/list/linkedList.html",headers:[{level:2,title:"链表",slug:"链表",normalizedTitle:"链表",charIndex:2},{level:2,title:"链表的一般数据结构定义",slug:"链表的一般数据结构定义",normalizedTitle:"链表的一般数据结构定义",charIndex:165},{level:2,title:"链表的操作",slug:"链表的操作",normalizedTitle:"链表的操作",charIndex:310},{level:3,title:"初始化",slug:"初始化",normalizedTitle:"初始化",charIndex:340},{level:3,title:"遍历",slug:"遍历",normalizedTitle:"遍历",charIndex:344},{level:3,title:"插入",slug:"插入",normalizedTitle:"插入",charIndex:541},{level:3,title:"查找",slug:"查找",normalizedTitle:"查找",charIndex:3605},{level:3,title:"删除",slug:"删除",normalizedTitle:"删除",charIndex:4208},{level:2,title:"结语",slug:"结语",normalizedTitle:"结语",charIndex:5064}],headersStr:"链表 链表的一般数据结构定义 链表的操作 初始化 遍历 插入 查找 删除 结语",content:'# 链表\n\n链表，是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。\n\n链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。\n\n一般我们说链表都是指的是单向链表。\n\n\n# 链表的一般数据结构定义\n\ninterface LinkedListNode<T> {\n  /**\n   * 链表的数据域\n   */\n  data: T;\n  /**\n   * 链表的后继节点域\n   */\n  next: LinkedListNode<T> | null;\n}\n\n\n\n# 链表的操作\n\n对于链表的操作，我个人感觉最重要的两个操作就是初始化和遍历。对于链表的操作有些同学喜欢在头放一个空节点，这是属于个人的编程习惯，而我一般不喜欢（可不是出于节约内存的想法哦，哈哈哈），因此，选择一个适合你的习惯即可。以下的所有代码实现均不包含空的头结点。\n\n\n# 初始化\n\n初始化，即把一堆数据构造成链表。对于链表的初始化一般有两种操作：即头插法和尾插法。 头插法：用一个变量指向已有链表的头结点，每次新来的节点都插在头结点的前面，再让这个变量指向新插入的节点，因此头插法构建出的链表数据的顺序和输入的顺序是相反的。\n\n头插法插入节点的过程：\n\n/**\n * 以头插法初始化链表\n * @param {Array<number>} arr 用于初始化链表的数据\n */\nfunction initialize(arr) {\n  // 如果图中第一步\n  let head = null;\n  // 此例中无用，仅用于阐述问题\n  let tail = null;\n  arr.forEach((val) => {\n    const node = createNode(val);\n    // 如果是空链表的话，直接让头结点指针指向第一个节点\n    if (head == null) {\n      // 如图第二步\n      head = node;\n      // 此例中无用，仅用于阐述问题\n      tail = node;\n    } else {\n      //先让新来的节点指向head节点，如图第三步\n      node.next = head;\n      // 再让head指针指向最新的节点，如图第四步\n      head = node;\n    }\n  });\n  return head;\n}\n\n\n尾插法：用一个变量指向已有链表的尾结点，每次新来的节点都插在尾结点的后面，再让这个变量指向新插入的尾结点，因此尾插法构建出的链表数据的顺序和输入的顺序是相同的。\n\n尾插法插入节点的过程：\n\n/**\n * 以尾插法初始化链表\n * @param {Array<number>} arr 用于初始化链表的数据\n */\nfunction initialize(arr) {\n  // 如图第一步\n  let head = null;\n  let tail = null;\n  arr.forEach((val) => {\n    const node = createNode(val);\n    if (head == null) {\n      // 如果是空链表的话，直接让头结点指针和尾结点指针指向第一个节点，对应图中第一步\n      head = node;\n      tail = node;\n    } else {\n      // 让尾结点的后继指针指向新来的节点, 如图第三步\n      tail.next = node;\n      // 让尾节点指针指向最后一个节点，如图第四步\n      tail = node;\n    }\n  });\n  return head;\n}\n\n\n我个人编程习惯喜欢用第二种，但是即使是使用头插法，你也可以多用一个变量来记住链表的尾结点，这样的好处就是如果某个时刻你需要在尾部插入的话，可以直接用尾节点指针而不用再去遍历了。\n\n\n# 遍历\n\n链表的遍历几乎可以说是一种标准范式了，这是对于链表一定得掌握的知识。对于单向链表，只要给头指针就可以完成遍历。\n\n编程技巧\n\n在遍历链表时，我们有时候会申明一个前驱节点，这样可以使得在遍历的过程中，既能找到当前节点，又可以找到当前节点的前驱节点，在某些时候非常好用，这也是一个必须掌握的编程技巧。\n\n需要注意的是在遍历链表的过程中不要修改头指针，因为一旦修改了头指针就找不回来了，万一需要用到头指针，那代码又得重新设计。\n\n链表遍历的复杂度为O(n);\n\n/**\n * 遍历链表\n * @param {Node<number>} head 链表头指针\n */\nfunction traverse(head) {\n  let node = head;\n  // pre在本例中无用，仅用于说明这是一种编程技巧\n  let pre = null;\n  // 如果当前节点指向空 （对于空链表，开始就直接指向空）\n  while (node) {\n    console.log(node);\n    // 让pre滞后，这样可以永远保证pre指向node的前一个节点（如果node是null,pre指向最后一个节点，如果node是第一个节点或者链表是空表，pre指向null）\n    pre = node;\n    node = node.next;\n  }\n}\n\n\n\n# 插入\n\n对于链表的操作操作一定要谨慎，否则容易丢失后继节点或者使得链表的节点指向表现非预期。\n\n我们演示一下在表中部插入节点的场景，其流程如下：\n\n伪代码描述即：newNode.next = node; pre.next = newNode; 这两行代码一定不能交换。\n\n链表插入的平均时间复杂度为：O(n);\n\n/**\n * 在链表中指定的K位置插入节点, 如果K小于1，则插在头部，如果K大于链表的长度，则直接插在尾部\n * @param {Node<number>} head 链表头\n * @param {number} val 节点值\n * @param {number} K 插入的位置,K为节点数,不是索引\n */\nfunction insert(head, val, K) {\n  const newNode = createNode(val);\n  // 如果需要插在头部的话\n  if (K < 1) {\n    newNode.next = head;\n    head = newNode;\n    return head;\n  }\n  let node = head;\n  // 申明一个空指针，因为其滞后node一个表结点，主要是用来记录上一个节点\n  let pre = null;\n  // 申明一个计数器，用于标记已经遍历的节点的个数\n  let counter = 0;\n  let inserted = false;\n  while (node) {\n    counter++;\n    // 如果找到了合适的插入位置，插入完成以后就没有继续循环的必要了\n    if (counter === K) {\n      // 必须先用一个临时变量将其记住，否则会丢失后继节点\n      let nextNode = node.next;\n      // 插入新的节点\n      node.next = newNode;\n      newNode.next = nextNode;\n      // 标记插入完成\n      inserted = true;\n      break;\n    }\n    // 先把当前这个节点记住，然后向后迭代\n    pre = node;\n    node = node.next;\n  }\n  // 如果已经插入了的哈，就不用再管什么事儿了\n  if (inserted) {\n    return head;\n  }\n  // 如果K大于等于链表的长度的话，就直接插在链表尾部即可\n  if (counter < K && pre) {\n    // 此刻的node已经是null了，而pre指针指向链表的最后一个节点\n    pre.next = newNode;\n  } else {\n    // 如果链表是空表，之前的循环一次都没有执行的，那么直接让head指向新来的节点即可\n    head = newNode;\n  }\n  return head;\n}\n\n\n\n# 查找\n\n查找主要分为按值查找或者按位置查找。 查找的思路和遍历类似。\n\n查找的平均算法复杂度为O(N)。\n\n/**\n * 根据索引查找链表节点\n * @param {Node<number>} head 链表头结点\n * @param {number} idx 目标索引\n */\nfunction findIndex(head, idx) {\n  let node = head;\n  let counter = 0;\n  // 找到表尾没有找到目标索引 或者 找到了目标索引 结束循环\n  while (node && counter < idx) {\n    counter++;\n    node = node.next;\n  }\n  return counter === idx ? node : null;\n}\n\n/**\n * 根据节点值查找节点\n * @param {Node<number>} head 链表头结点\n * @param {number} val 目标节点值\n */\nfunction find(head, val) {\n  let node = head;\n  // 找到节点值或遍历到链表结束，终止循环\n  while (node && node.val !== val) {\n    node = node.next;\n  }\n  return node;\n}\n\n\n\n# 删除\n\n链表的删除相对来说比较简单，直接拿掉特定节点即可，这一点，相对于数组来说有优势的，因为在数组删除元素后，需要把元素统统往前挪动一位，然后才能把 size 减少。\n\nWARNING\n\n当数据的每个单元是一个复杂结构的时候，这个拷贝时间的开销可是不能忽略的。\n\n链表节点的删除过程：\n\n/**\n * 从链表中删除值为val的节点\n * @param {Node<number>} head 链表的头结点\n * @param {number} val 待删除的值\n */\nfunction remove(head, val) {\n  if (!head) {\n    console.warn("can not remove element from empty linked list");\n    return;\n  }\n  let node = head;\n  let pre = null;\n  while (node) {\n    // 找到了目标节点，需要结束循环\n    if (node.value != val) {\n      break;\n    }\n    pre = node;\n    node = node.next;\n  }\n  // 如果pre存在的话，说明用户删除的不是头结点\n  if (pre) {\n    // 如图第二步\n    pre.next = node.next;\n    // 如图第三步\n    node.next = null;\n    node = null;\n  } else {\n    // 删除头结点时，首先得用临时变量把第二个节点先记下来（哪怕它不存在）\n    let nextHead = head.next;\n    // 解除头结点对第二个节点的引用\n    head.next = null;\n    // 让头结点指针指向下一个节点\n    head = nextHead;\n  }\n  return head;\n}\n\n\n\n# 结语\n\n链表相对于数组还有一个优势是在内存足够的前提下，其长度是可以无限增长的。链表在初始化的的时候无需知道表长，而数组必须确定表长（此性质不考虑 JavaScript 语言），对于其它语言来说（C#，Java 等）数组的扩容代价相对较大，首先需要向系统申请更长的连续空间（在某些情况下是可能申请不到的），然后需要把旧数据拷贝到新数组里面去，然后再将原来的数组释放，而在每个数据项比较大的情况下，这个拷贝时间是不能被忽略的。\n\n链表平均算法复杂度与数组的比较如下：\n\n操作            数组     链表\n随机访问          O(1)   O(N)\n插入(不考虑前置查找)   O(N)   O(1)\n查找            O(N)   O(N)\n删除(不考虑前置查找)   O(N)   O(1)\n\n但是如果需要对其数据进行排序的话，有些排序算法是不能直接用的，在实际开发中我们需要根据需求选择链表还是数组。\n\n常见的应用链表的场景，如流程引擎中编辑过程，如果使用数组的话，当用户频繁的更改关系，其操作变得相当笨重，而使用链表仅修改节点的前驱和 后继指针而已。\n\n还有在查找节，多层链表结合二分查找，可以实现高效的跳(跃)(链)表',normalizedContent:'# 链表\n\n链表，是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。\n\n链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。\n\n一般我们说链表都是指的是单向链表。\n\n\n# 链表的一般数据结构定义\n\ninterface linkedlistnode<t> {\n  /**\n   * 链表的数据域\n   */\n  data: t;\n  /**\n   * 链表的后继节点域\n   */\n  next: linkedlistnode<t> | null;\n}\n\n\n\n# 链表的操作\n\n对于链表的操作，我个人感觉最重要的两个操作就是初始化和遍历。对于链表的操作有些同学喜欢在头放一个空节点，这是属于个人的编程习惯，而我一般不喜欢（可不是出于节约内存的想法哦，哈哈哈），因此，选择一个适合你的习惯即可。以下的所有代码实现均不包含空的头结点。\n\n\n# 初始化\n\n初始化，即把一堆数据构造成链表。对于链表的初始化一般有两种操作：即头插法和尾插法。 头插法：用一个变量指向已有链表的头结点，每次新来的节点都插在头结点的前面，再让这个变量指向新插入的节点，因此头插法构建出的链表数据的顺序和输入的顺序是相反的。\n\n头插法插入节点的过程：\n\n/**\n * 以头插法初始化链表\n * @param {array<number>} arr 用于初始化链表的数据\n */\nfunction initialize(arr) {\n  // 如果图中第一步\n  let head = null;\n  // 此例中无用，仅用于阐述问题\n  let tail = null;\n  arr.foreach((val) => {\n    const node = createnode(val);\n    // 如果是空链表的话，直接让头结点指针指向第一个节点\n    if (head == null) {\n      // 如图第二步\n      head = node;\n      // 此例中无用，仅用于阐述问题\n      tail = node;\n    } else {\n      //先让新来的节点指向head节点，如图第三步\n      node.next = head;\n      // 再让head指针指向最新的节点，如图第四步\n      head = node;\n    }\n  });\n  return head;\n}\n\n\n尾插法：用一个变量指向已有链表的尾结点，每次新来的节点都插在尾结点的后面，再让这个变量指向新插入的尾结点，因此尾插法构建出的链表数据的顺序和输入的顺序是相同的。\n\n尾插法插入节点的过程：\n\n/**\n * 以尾插法初始化链表\n * @param {array<number>} arr 用于初始化链表的数据\n */\nfunction initialize(arr) {\n  // 如图第一步\n  let head = null;\n  let tail = null;\n  arr.foreach((val) => {\n    const node = createnode(val);\n    if (head == null) {\n      // 如果是空链表的话，直接让头结点指针和尾结点指针指向第一个节点，对应图中第一步\n      head = node;\n      tail = node;\n    } else {\n      // 让尾结点的后继指针指向新来的节点, 如图第三步\n      tail.next = node;\n      // 让尾节点指针指向最后一个节点，如图第四步\n      tail = node;\n    }\n  });\n  return head;\n}\n\n\n我个人编程习惯喜欢用第二种，但是即使是使用头插法，你也可以多用一个变量来记住链表的尾结点，这样的好处就是如果某个时刻你需要在尾部插入的话，可以直接用尾节点指针而不用再去遍历了。\n\n\n# 遍历\n\n链表的遍历几乎可以说是一种标准范式了，这是对于链表一定得掌握的知识。对于单向链表，只要给头指针就可以完成遍历。\n\n编程技巧\n\n在遍历链表时，我们有时候会申明一个前驱节点，这样可以使得在遍历的过程中，既能找到当前节点，又可以找到当前节点的前驱节点，在某些时候非常好用，这也是一个必须掌握的编程技巧。\n\n需要注意的是在遍历链表的过程中不要修改头指针，因为一旦修改了头指针就找不回来了，万一需要用到头指针，那代码又得重新设计。\n\n链表遍历的复杂度为o(n);\n\n/**\n * 遍历链表\n * @param {node<number>} head 链表头指针\n */\nfunction traverse(head) {\n  let node = head;\n  // pre在本例中无用，仅用于说明这是一种编程技巧\n  let pre = null;\n  // 如果当前节点指向空 （对于空链表，开始就直接指向空）\n  while (node) {\n    console.log(node);\n    // 让pre滞后，这样可以永远保证pre指向node的前一个节点（如果node是null,pre指向最后一个节点，如果node是第一个节点或者链表是空表，pre指向null）\n    pre = node;\n    node = node.next;\n  }\n}\n\n\n\n# 插入\n\n对于链表的操作操作一定要谨慎，否则容易丢失后继节点或者使得链表的节点指向表现非预期。\n\n我们演示一下在表中部插入节点的场景，其流程如下：\n\n伪代码描述即：newnode.next = node; pre.next = newnode; 这两行代码一定不能交换。\n\n链表插入的平均时间复杂度为：o(n);\n\n/**\n * 在链表中指定的k位置插入节点, 如果k小于1，则插在头部，如果k大于链表的长度，则直接插在尾部\n * @param {node<number>} head 链表头\n * @param {number} val 节点值\n * @param {number} k 插入的位置,k为节点数,不是索引\n */\nfunction insert(head, val, k) {\n  const newnode = createnode(val);\n  // 如果需要插在头部的话\n  if (k < 1) {\n    newnode.next = head;\n    head = newnode;\n    return head;\n  }\n  let node = head;\n  // 申明一个空指针，因为其滞后node一个表结点，主要是用来记录上一个节点\n  let pre = null;\n  // 申明一个计数器，用于标记已经遍历的节点的个数\n  let counter = 0;\n  let inserted = false;\n  while (node) {\n    counter++;\n    // 如果找到了合适的插入位置，插入完成以后就没有继续循环的必要了\n    if (counter === k) {\n      // 必须先用一个临时变量将其记住，否则会丢失后继节点\n      let nextnode = node.next;\n      // 插入新的节点\n      node.next = newnode;\n      newnode.next = nextnode;\n      // 标记插入完成\n      inserted = true;\n      break;\n    }\n    // 先把当前这个节点记住，然后向后迭代\n    pre = node;\n    node = node.next;\n  }\n  // 如果已经插入了的哈，就不用再管什么事儿了\n  if (inserted) {\n    return head;\n  }\n  // 如果k大于等于链表的长度的话，就直接插在链表尾部即可\n  if (counter < k && pre) {\n    // 此刻的node已经是null了，而pre指针指向链表的最后一个节点\n    pre.next = newnode;\n  } else {\n    // 如果链表是空表，之前的循环一次都没有执行的，那么直接让head指向新来的节点即可\n    head = newnode;\n  }\n  return head;\n}\n\n\n\n# 查找\n\n查找主要分为按值查找或者按位置查找。 查找的思路和遍历类似。\n\n查找的平均算法复杂度为o(n)。\n\n/**\n * 根据索引查找链表节点\n * @param {node<number>} head 链表头结点\n * @param {number} idx 目标索引\n */\nfunction findindex(head, idx) {\n  let node = head;\n  let counter = 0;\n  // 找到表尾没有找到目标索引 或者 找到了目标索引 结束循环\n  while (node && counter < idx) {\n    counter++;\n    node = node.next;\n  }\n  return counter === idx ? node : null;\n}\n\n/**\n * 根据节点值查找节点\n * @param {node<number>} head 链表头结点\n * @param {number} val 目标节点值\n */\nfunction find(head, val) {\n  let node = head;\n  // 找到节点值或遍历到链表结束，终止循环\n  while (node && node.val !== val) {\n    node = node.next;\n  }\n  return node;\n}\n\n\n\n# 删除\n\n链表的删除相对来说比较简单，直接拿掉特定节点即可，这一点，相对于数组来说有优势的，因为在数组删除元素后，需要把元素统统往前挪动一位，然后才能把 size 减少。\n\nwarning\n\n当数据的每个单元是一个复杂结构的时候，这个拷贝时间的开销可是不能忽略的。\n\n链表节点的删除过程：\n\n/**\n * 从链表中删除值为val的节点\n * @param {node<number>} head 链表的头结点\n * @param {number} val 待删除的值\n */\nfunction remove(head, val) {\n  if (!head) {\n    console.warn("can not remove element from empty linked list");\n    return;\n  }\n  let node = head;\n  let pre = null;\n  while (node) {\n    // 找到了目标节点，需要结束循环\n    if (node.value != val) {\n      break;\n    }\n    pre = node;\n    node = node.next;\n  }\n  // 如果pre存在的话，说明用户删除的不是头结点\n  if (pre) {\n    // 如图第二步\n    pre.next = node.next;\n    // 如图第三步\n    node.next = null;\n    node = null;\n  } else {\n    // 删除头结点时，首先得用临时变量把第二个节点先记下来（哪怕它不存在）\n    let nexthead = head.next;\n    // 解除头结点对第二个节点的引用\n    head.next = null;\n    // 让头结点指针指向下一个节点\n    head = nexthead;\n  }\n  return head;\n}\n\n\n\n# 结语\n\n链表相对于数组还有一个优势是在内存足够的前提下，其长度是可以无限增长的。链表在初始化的的时候无需知道表长，而数组必须确定表长（此性质不考虑 javascript 语言），对于其它语言来说（c#，java 等）数组的扩容代价相对较大，首先需要向系统申请更长的连续空间（在某些情况下是可能申请不到的），然后需要把旧数据拷贝到新数组里面去，然后再将原来的数组释放，而在每个数据项比较大的情况下，这个拷贝时间是不能被忽略的。\n\n链表平均算法复杂度与数组的比较如下：\n\n操作            数组     链表\n随机访问          o(1)   o(n)\n插入(不考虑前置查找)   o(n)   o(1)\n查找            o(n)   o(n)\n删除(不考虑前置查找)   o(n)   o(1)\n\n但是如果需要对其数据进行排序的话，有些排序算法是不能直接用的，在实际开发中我们需要根据需求选择链表还是数组。\n\n常见的应用链表的场景，如流程引擎中编辑过程，如果使用数组的话，当用户频繁的更改关系，其操作变得相当笨重，而使用链表仅修改节点的前驱和 后继指针而已。\n\n还有在查找节，多层链表结合二分查找，可以实现高效的跳(跃)(链)表',charsets:{cjk:!0}},{title:"算法介绍",frontmatter:{},regularPath:"/data-structure/list/lru-cache.html",relativePath:"data-structure/list/lru-cache.md",key:"v-7af007f5",path:"/data-structure/list/lru-cache.html",headers:[{level:2,title:"算法介绍",slug:"算法介绍",normalizedTitle:"算法介绍",charIndex:2},{level:2,title:"思路分析",slug:"思路分析",normalizedTitle:"思路分析",charIndex:258},{level:2,title:"算法实现",slug:"算法实现",normalizedTitle:"算法实现",charIndex:614},{level:2,title:"应用场景",slug:"应用场景",normalizedTitle:"应用场景",charIndex:3106}],headersStr:"算法介绍 思路分析 算法实现 应用场景",content:'# 算法介绍\n\nLRU是 Least Recently Used 的缩写，即最近最少使用，是一种常用的页面置换算法，选择最近最久未使用的页面予以淘汰。该算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 t，当须淘汰一个页面时，选择现有页面中其 t 值最大的，即最近最少使用的页面予以淘汰。（copy 自百度百科）\n\n听君一席话，如听君一席话，上述描述理解起来还挺费劲儿，我觉得简单点儿就是，每次访问缓存，都把当前访问节点的权重更新，如果新增内容且超出了容量，则删除权重最低的即可。\n\n\n# 思路分析\n\n由于缓存都是有频繁的访问（如果不频繁访问，那缓存就没有意义了）的，如何提高效率是一个值得商榷的事情。最好让我们的get和set都是O(1)，那是最好不过的了。\n\n可能做到吗？先思考一下拥有O(1)访问效率的数据结构有哪些：\n\n哈希表或数组在获取内容的时候访问效率为 O(1);链表在插入或删除时，如无前置查找，效率为O(1)。\n\n那我们即可构建一个链表，用一个哈希表记住链表上的每个节点，如果获取到节点，需要将缓存更新，则将其提到链表的最前面，如果新增内容超出了缓存的最大容量，只需要删除最后一个节点即可，并且把新来的节点插入到链表头部。\n\n考虑到在获取到链表中部的节点时，为了方便找前驱节点和后继节点，那么，我们得考虑使用双向链表。通过这样设计的话，我们get和set的效率都为O(1)。\n\n\n# 算法实现\n\n/**\n * @param {number} capacity\n */\nvar LRUCache = function (capacity) {\n  if (capacity <= 0) {\n    console.error("the LRUCache capacity must bigger than zero");\n  }\n  this.capacity = capacity;\n  this.size = 0;\n  /**\n   * @type { Map<any, DoubleLinkedListNode> }\n   */\n  this.mapping = new Map();\n  /**\n   * @type { DoubleLinkedListNode | null }\n   */\n  this.head = null;\n  /**\n   * @type { DoubleLinkedListNode | null }\n   */\n  this.tail = null;\n};\n\n/**\n * 刷新链表节点\n * @param {DoubleLinkedListNode} node\n * @returns\n */\nLRUCache.prototype.refresh = function (node) {\n  if (!node) {\n    console.warn("failed to refresh cache node");\n    return;\n  }\n  let prevNode = node.prev;\n  let nextNode = node.next;\n  // 如果不存在前驱节点，说明当前节点就是最近使用过的节点，无需刷新\n  if (!prevNode) {\n    // this.head = node;\n    return;\n  }\n  // 如果不存在后继节点，说明当前节点就是最后一个节点，直接提到最前面去\n  if (!nextNode) {\n    prevNode.next = null;\n    this.tail = prevNode;\n    node.next = this.head;\n    this.head.prev = node;\n    this.head = node;\n  }\n  // 如果同时存在前驱和后继节点\n  if (prevNode && nextNode) {\n    // 把原来的两个节点接到一起\n    prevNode.next = nextNode;\n    nextNode.prev = prevNode;\n    // 然后把当前这个节点提到最前面去\n    node.next = this.head;\n    this.head.prev = node;\n    node.prev = null;\n    this.head = node;\n  }\n};\n\n/**\n * @param {any} key\n * @return {number}\n */\nLRUCache.prototype.get = function (key) {\n  let node = this.mapping.get(key);\n  if (!node) {\n    return -1;\n  }\n  // 刷新节点\n  this.refresh(node);\n  return node.val;\n};\n\n/**\n * @param {any} key\n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function (key, value) {\n  let oldNode = this.mapping.get(key);\n  // 旧节点不存在\n  if (!oldNode) {\n    const newNode = this.createNode(key, value);\n    // 设置新值\n    this.mapping.set(key, newNode);\n    if (this.size === 0) {\n      this.head = newNode;\n      this.tail = newNode;\n    } else {\n      newNode.next = this.head;\n      this.head.prev = newNode;\n      this.head = newNode;\n    }\n    this.size++;\n    if (this.size > this.capacity) {\n      let oldKey = this.tail.key;\n      this.mapping.delete(oldKey);\n      // 解开最后一个节点\n      let preTail = this.tail.prev;\n      preTail.next = null;\n      this.tail.prev = null;\n      this.tail = preTail;\n      this.size--;\n    }\n  } else {\n    oldNode.val = value;\n    this.refresh(oldNode);\n  }\n};\n\n/**\n * 创建一个链表节点\n * @param {number} val\n * @returns {Node}\n */\nLRUCache.prototype.createNode = function (key, val) {\n  return {\n    prev: null,\n    next: null,\n    val,\n    key,\n  };\n};\n\n\n\n# 应用场景\n\n在 vue 中KeepAlive组件对于缓存实例数的控制就是用的 LRUCache;\n\n在 Vvu 使用SSR时，页面缓存也可以使用 LRUCache 算法；\n\n对于实际开发中，我们可以使用更成熟的第三方库，如lru-cache库，仓库地址。',normalizedContent:'# 算法介绍\n\nlru是 least recently used 的缩写，即最近最少使用，是一种常用的页面置换算法，选择最近最久未使用的页面予以淘汰。该算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 t，当须淘汰一个页面时，选择现有页面中其 t 值最大的，即最近最少使用的页面予以淘汰。（copy 自百度百科）\n\n听君一席话，如听君一席话，上述描述理解起来还挺费劲儿，我觉得简单点儿就是，每次访问缓存，都把当前访问节点的权重更新，如果新增内容且超出了容量，则删除权重最低的即可。\n\n\n# 思路分析\n\n由于缓存都是有频繁的访问（如果不频繁访问，那缓存就没有意义了）的，如何提高效率是一个值得商榷的事情。最好让我们的get和set都是o(1)，那是最好不过的了。\n\n可能做到吗？先思考一下拥有o(1)访问效率的数据结构有哪些：\n\n哈希表或数组在获取内容的时候访问效率为 o(1);链表在插入或删除时，如无前置查找，效率为o(1)。\n\n那我们即可构建一个链表，用一个哈希表记住链表上的每个节点，如果获取到节点，需要将缓存更新，则将其提到链表的最前面，如果新增内容超出了缓存的最大容量，只需要删除最后一个节点即可，并且把新来的节点插入到链表头部。\n\n考虑到在获取到链表中部的节点时，为了方便找前驱节点和后继节点，那么，我们得考虑使用双向链表。通过这样设计的话，我们get和set的效率都为o(1)。\n\n\n# 算法实现\n\n/**\n * @param {number} capacity\n */\nvar lrucache = function (capacity) {\n  if (capacity <= 0) {\n    console.error("the lrucache capacity must bigger than zero");\n  }\n  this.capacity = capacity;\n  this.size = 0;\n  /**\n   * @type { map<any, doublelinkedlistnode> }\n   */\n  this.mapping = new map();\n  /**\n   * @type { doublelinkedlistnode | null }\n   */\n  this.head = null;\n  /**\n   * @type { doublelinkedlistnode | null }\n   */\n  this.tail = null;\n};\n\n/**\n * 刷新链表节点\n * @param {doublelinkedlistnode} node\n * @returns\n */\nlrucache.prototype.refresh = function (node) {\n  if (!node) {\n    console.warn("failed to refresh cache node");\n    return;\n  }\n  let prevnode = node.prev;\n  let nextnode = node.next;\n  // 如果不存在前驱节点，说明当前节点就是最近使用过的节点，无需刷新\n  if (!prevnode) {\n    // this.head = node;\n    return;\n  }\n  // 如果不存在后继节点，说明当前节点就是最后一个节点，直接提到最前面去\n  if (!nextnode) {\n    prevnode.next = null;\n    this.tail = prevnode;\n    node.next = this.head;\n    this.head.prev = node;\n    this.head = node;\n  }\n  // 如果同时存在前驱和后继节点\n  if (prevnode && nextnode) {\n    // 把原来的两个节点接到一起\n    prevnode.next = nextnode;\n    nextnode.prev = prevnode;\n    // 然后把当前这个节点提到最前面去\n    node.next = this.head;\n    this.head.prev = node;\n    node.prev = null;\n    this.head = node;\n  }\n};\n\n/**\n * @param {any} key\n * @return {number}\n */\nlrucache.prototype.get = function (key) {\n  let node = this.mapping.get(key);\n  if (!node) {\n    return -1;\n  }\n  // 刷新节点\n  this.refresh(node);\n  return node.val;\n};\n\n/**\n * @param {any} key\n * @param {number} value\n * @return {void}\n */\nlrucache.prototype.put = function (key, value) {\n  let oldnode = this.mapping.get(key);\n  // 旧节点不存在\n  if (!oldnode) {\n    const newnode = this.createnode(key, value);\n    // 设置新值\n    this.mapping.set(key, newnode);\n    if (this.size === 0) {\n      this.head = newnode;\n      this.tail = newnode;\n    } else {\n      newnode.next = this.head;\n      this.head.prev = newnode;\n      this.head = newnode;\n    }\n    this.size++;\n    if (this.size > this.capacity) {\n      let oldkey = this.tail.key;\n      this.mapping.delete(oldkey);\n      // 解开最后一个节点\n      let pretail = this.tail.prev;\n      pretail.next = null;\n      this.tail.prev = null;\n      this.tail = pretail;\n      this.size--;\n    }\n  } else {\n    oldnode.val = value;\n    this.refresh(oldnode);\n  }\n};\n\n/**\n * 创建一个链表节点\n * @param {number} val\n * @returns {node}\n */\nlrucache.prototype.createnode = function (key, val) {\n  return {\n    prev: null,\n    next: null,\n    val,\n    key,\n  };\n};\n\n\n\n# 应用场景\n\n在 vue 中keepalive组件对于缓存实例数的控制就是用的 lrucache;\n\n在 vvu 使用ssr时，页面缓存也可以使用 lrucache 算法；\n\n对于实际开发中，我们可以使用更成熟的第三方库，如lru-cache库，仓库地址。',charsets:{cjk:!0}},{title:"合并 2 个有序数组",frontmatter:{},regularPath:"/data-structure/list/mergeArray.html",relativePath:"data-structure/list/mergeArray.md",key:"v-03d8873b",path:"/data-structure/list/mergeArray.html",headers:[{level:2,title:"合并 2 个有序数组",slug:"合并-2-个有序数组",normalizedTitle:"合并 2 个有序数组",charIndex:2},{level:3,title:"描述",slug:"描述",normalizedTitle:"描述",charIndex:17},{level:3,title:"思路分析",slug:"思路分析",normalizedTitle:"思路分析",charIndex:58},{level:3,title:"算法实现",slug:"算法实现",normalizedTitle:"算法实现",charIndex:256},{level:2,title:"合并 K 有序个数组",slug:"合并-k-有序个数组",normalizedTitle:"合并 k 有序个数组",charIndex:979},{level:3,title:"描述",slug:"描述-2",normalizedTitle:"描述",charIndex:17},{level:3,title:"思路分析",slug:"思路分析-2",normalizedTitle:"思路分析",charIndex:58},{level:3,title:"算法实现",slug:"算法实现-2",normalizedTitle:"算法实现",charIndex:256}],headersStr:"合并 2 个有序数组 描述 思路分析 算法实现 合并 K 有序个数组 描述 思路分析 算法实现",content:'# 合并 2 个有序数组\n\n\n# 描述\n\n给你 2 个不降序数组，合并之后得到的数组仍然保持不降序的性质。\n\n\n# 思路分析\n\n首先，我们需要需要一个新的数组存储合并之后的结果，因为 JS 的数组是自动扩容的，所以我们不需要考虑数组的容量问题。然后定义两个偏移变量，用于判断合并的进程。当这两个偏移量都在对应数组的范围内时，我们分别读取两个数组当前偏移位置的数据，把小的那个加入到结果中，同时对应的偏移量+1。当一个数组已经合并完成之后，另外一个数组可能还有内容，我只需要直接将其内容追加到结果中即可。\n\n\n# 算法实现\n\n/**\n * 合并2个有序数组\n * @param {number[]} arr1\n * @param {number[]} arr2\n */\nfunction merge(arr1, arr2) {\n  let offset1 = 0;\n  let offset2 = 0;\n  let offset = 0;\n  let newArr = [];\n  // 当两个数组都还没有处理完成的时候\n  while (offset1 < arr1.length && offset2 < arr2.length) {\n    let val1 = arr1[offset1];\n    let val2 = arr2[offset2];\n    if (val1 >= val2) {\n      newArr[offset++] = arr2[offset2++];\n    } else {\n      newArr[offset++] = arr1[offset1++];\n    }\n  }\n  /**\n   * 这两个while不可能同时成立，只有可能成立一个，将数组长度较大的剩余部分拷贝给新数组\n   */\n  while (offset1 < arr1.length) {\n    newArr[offset++] = arr1[offset1++];\n  }\n  while (offset2 < arr2.length) {\n    newArr[offset++] = arr2[offset2++];\n  }\n  return newArr;\n}\n\n\n请记住这个范式，在将来的归并排序中，我们还要用到它。\n\n\n# 合并 K 有序个数组\n\n\n# 描述\n\n给你 K 个不降序数组，合并之后得到的数组仍然保持不降序的性质。\n\n\n# 思路分析\n\n朴素法：每次从这个 K 数组中出一个最小的，如果当前数组为空则跳过，直到所有的数组都为空，即可完成合并。\n\n建堆法：每次从这个 K 个数组的第 i 中出一个数，将其插入到一个最小堆中，当第 i 个数组为空时，继续处理下一个数组，直到所有的数组都处理完成，然后将堆中的数组依次出堆，则可得到最后的结果。\n\n归并法：\n\n每次选两个数组进行归并，将本轮归并的结果添加到一个新数组中，然后对新数组再次归并，重复这个过程，直到得到的新数组为 1 个，则这最后的一个数组则是结果。\n\n\n# 算法实现\n\n# 建堆法的算法实现：\n\n朴素法效率较低，此处就不展示代码了，有兴趣的读者可以自行实现。\n\n# 建堆法的算法实现：\n\n/**\n * 抽象堆\n */\nclass Heap {\n  get count() {\n    return this.size;\n  }\n  /**\n   * 定义哨兵的最值，所有插入堆的元素都必须和这个值比较\n   */\n  SENTRY;\n\n  /**\n   * 定义一个存储数据的内存空间\n   */\n  data = [];\n\n  /**\n   * 当前堆的元素个数\n   */\n  size = 0;\n\n  /**\n   * 比较函数, 通过先前和当前元素的比较，决定是否将当前元素提置先前元素前\n   */\n  compare;\n\n  /**\n   * 自身用于比较的函数\n   * @param preVal 被比较的值\n   * @param curVal 当前值\n   */\n  selfCompare(preVal, curVal) {\n    return this.compare(preVal, curVal);\n  }\n\n  validInitParams() {\n    if (this.SENTRY === void 0) {\n      throw `can not insert queue before the sentry been set `;\n    }\n    if (this.compare === void 0) {\n      throw `can not insert queue before the compare callback been set `;\n    }\n  }\n\n  constructor(...initElements) {\n    // 初始化数组元素\n    initElements.forEach((v, i) => {\n      this.data[i + 1] = v;\n      this.size++;\n    });\n    this.buildHeap();\n  }\n\n  /**\n   * 设置哨兵元素\n   * @param sentryEle\n   */\n  setSentry(sentryEle) {\n    this.SENTRY = sentryEle;\n    this.data[0] = this.SENTRY;\n  }\n\n  /**\n   * 设置比较函数\n   * @param compareFunc 比较函数\n   */\n  setCompare(compareFunc) {\n    this.compare = compareFunc;\n  }\n\n  /**\n   * 获取堆中最小的元素\n   * @returns\n   */\n  getTop() {\n    if (this.size == 0) {\n      throw `can not get element from an empty heap`;\n    }\n    return this.data[1];\n  }\n\n  /**\n   * 判断堆是否为空\n   * @returns\n   */\n  isEmpty() {\n    return this.size === 0;\n  }\n\n  /**\n   * 向堆中插入一个合法值\n   * @param val\n   */\n  insertQueue(val) {\n    this.validInitParams();\n    if (this.selfCompare(this.SENTRY, val)) {\n      throw `can not insert val bigger or smaller than ${this.SENTRY}`;\n    }\n    // 堆的容量扩充1\n    this.size++;\n    // 让i指向当前新位置\n    let i = this.size;\n    // 因为有哨兵的关系，不需要添加约束条件 i > 0\n    // this.#data[Math.floor(i / 2)] > val\n    while (this.selfCompare(this.data[Math.floor(i / 2)], val)) {\n      this.data[i] = this.data[Math.floor(i / 2)];\n      i = Math.floor(i / 2);\n    }\n    this.data[i] = val;\n  }\n\n  /**\n   * 获取堆中的最小元素\n   * @returns {T}\n   */\n  deleteQueue() {\n    if (this.isEmpty()) {\n      throw "can not delete element from empty heap";\n    }\n    // 取出堆顶的元素\n    let firstVal = this.data[1];\n    let temp = this.data[this.size--];\n    this.data[1] = temp;\n    // JavaScript语言需要进行这一步，让数组的规模缩小，释放空间\n    this.data.length--;\n    this.percDown(1);\n    return firstVal;\n  }\n\n  /**\n   * 下滤：将堆中以堆data[p]为根的子堆调整为最小堆\n   * @param p 根节点索引\n   */\n  percDown(p) {\n    let parent, child;\n    let temp = this.data[p]; /* 取出根结点存放的值 */\n    for (parent = p; parent * 2 <= this.size; parent = child) {\n      child = parent * 2;\n      /* child指向左右子结点的较?者 */\n      if (child != this.size && this.selfCompare(this.data[child], this.data[child + 1])) {\n        child++;\n      }\n      /* 找到了合适位置 */\n      if (this.selfCompare(this.data[child], temp)) {\n        break;\n      } else {\n        /* 下滤X */\n        this.data[parent] = this.data[child];\n      }\n    }\n    this.data[parent] = temp;\n  }\n\n  /**\n   * 构建堆\n   */\n  buildHeap() {\n    /* 调整data中的元素，使满足最堆的有序性  */\n    /* 这里所有size个元素已经存在data[]中 */\n    /* 从最后一个结点的父节点开始，到根结点1 */\n    for (let i = Math.floor(this.size / 2); i > 0; i--) {\n      this.percDown(i);\n    }\n  }\n}\n\n/**\n * 堆元素为number的最小堆\n */\nclass SimpleMinHeap extends Heap {\n  constructor(...initElements) {\n    super(...initElements);\n    this.setSentry(-Infinity);\n    this.setCompare((preVal, curVal) => {\n      return preVal >= curVal;\n    });\n  }\n\n  deleteMin() {\n    return this.deleteQueue();\n  }\n\n  getMin() {\n    return this.getTop();\n  }\n}\n\n/**\n * 合并K个有序数组\n * @param {number[][]} arrs\n */\nfunction mergeKArray(arrs) {\n  let minHeap = new SimpleMinHeap();\n  let offset = 0;\n  while(offset < arrs.length) {\n    let currentArr = arrs[offset];\n    // 处理一个数组，直至为空\n    while(currentArr.length) {\n      const ele = currentArr.shift();\n      minHeap.insertQueue(ele);\n    }\n    offset++;\n  }\n  let newArr = [];\n  let idx = 0;\n  // 输出堆，得到最终结果\n  while(!minHeap.isEmpty()) {\n    const ele = minHeap.deleteMin();\n    newArr[idx++] = ele;\n  }\n  return newArr;\n}\n\n\n上述代码看起来比较长，主要是我们实现了一个堆（实际开发中，这是一个可以封装进成熟的代码库的操作，并不需要我们自己实现），但是其实大家只需要看关键的函数mergeKArray\n\n# 归并法的算法实现\n\n归并法我们需要把上面合并 2 个有序数组的代码 copy 过来进行一下简单的修改，因为在归并的过程中，有可能剩下的数组只有可能存在一个了。修改点非常简单，只需要在第二个数组上加上默认值即可。\n\n/**\n * 合并2个有序数组\n * @param {number[]} arr1\n * @param {number[]} arr2 可选参数，若不传递该参数，则相当于将原数组copy一份\n */\nfunction merge(arr1, arr2 = []) {\n  let offset1 = 0;\n  let offset2 = 0;\n  let offset = 0;\n  let newArr = [];\n  // 当两个数组都还没有处理完成的时候\n  while (offset1 < arr1.length && offset2 < arr2.length) {\n    let val1 = arr1[offset1];\n    let val2 = arr2[offset2];\n    if (val1 >= val2) {\n      newArr[offset++] = arr2[offset2++];\n    } else {\n      newArr[offset++] = arr1[offset1++];\n    }\n  }\n  /**\n   * 这两个while不可能同时成立，只有可能成立一个，将数组长度较大的剩余部分拷贝给新数组\n   */\n  while (offset1 < arr1.length) {\n    newArr[offset++] = arr1[offset1++];\n  }\n  while (offset2 < arr2.length) {\n    newArr[offset++] = arr2[offset2++];\n  }\n  return newArr;\n}\n\n/**\n * 合并K个有序数组\n * @param {number[][]} arrs\n */\nfunction mergeKArray(arrs) {\n  let mergedArr = arrs;\n  // 如果归并结果大于1，则需要继续进行归并\n  while (mergedArr.length > 1) {\n    // 本轮的归并结果\n    const mergePassArr = [];\n    for (let i = 0; i < mergedArr.length; i += 2) {\n      // 得到二路归并的结果\n      const newArr = merge(mergedArr[i], mergedArr[i + 1]);\n      mergePassArr.push(newArr);\n    }\n    // 将本轮的归并结果给最终的合并结果，使之可以继续下一轮归并\n    mergedArr = mergePassArr;\n  }\n  // 如果归并0个数组，则返回空，否则返回正常的归并结果\n  return mergedArr.length ? mergedArr[0] : [];\n}\n',normalizedContent:'# 合并 2 个有序数组\n\n\n# 描述\n\n给你 2 个不降序数组，合并之后得到的数组仍然保持不降序的性质。\n\n\n# 思路分析\n\n首先，我们需要需要一个新的数组存储合并之后的结果，因为 js 的数组是自动扩容的，所以我们不需要考虑数组的容量问题。然后定义两个偏移变量，用于判断合并的进程。当这两个偏移量都在对应数组的范围内时，我们分别读取两个数组当前偏移位置的数据，把小的那个加入到结果中，同时对应的偏移量+1。当一个数组已经合并完成之后，另外一个数组可能还有内容，我只需要直接将其内容追加到结果中即可。\n\n\n# 算法实现\n\n/**\n * 合并2个有序数组\n * @param {number[]} arr1\n * @param {number[]} arr2\n */\nfunction merge(arr1, arr2) {\n  let offset1 = 0;\n  let offset2 = 0;\n  let offset = 0;\n  let newarr = [];\n  // 当两个数组都还没有处理完成的时候\n  while (offset1 < arr1.length && offset2 < arr2.length) {\n    let val1 = arr1[offset1];\n    let val2 = arr2[offset2];\n    if (val1 >= val2) {\n      newarr[offset++] = arr2[offset2++];\n    } else {\n      newarr[offset++] = arr1[offset1++];\n    }\n  }\n  /**\n   * 这两个while不可能同时成立，只有可能成立一个，将数组长度较大的剩余部分拷贝给新数组\n   */\n  while (offset1 < arr1.length) {\n    newarr[offset++] = arr1[offset1++];\n  }\n  while (offset2 < arr2.length) {\n    newarr[offset++] = arr2[offset2++];\n  }\n  return newarr;\n}\n\n\n请记住这个范式，在将来的归并排序中，我们还要用到它。\n\n\n# 合并 k 有序个数组\n\n\n# 描述\n\n给你 k 个不降序数组，合并之后得到的数组仍然保持不降序的性质。\n\n\n# 思路分析\n\n朴素法：每次从这个 k 数组中出一个最小的，如果当前数组为空则跳过，直到所有的数组都为空，即可完成合并。\n\n建堆法：每次从这个 k 个数组的第 i 中出一个数，将其插入到一个最小堆中，当第 i 个数组为空时，继续处理下一个数组，直到所有的数组都处理完成，然后将堆中的数组依次出堆，则可得到最后的结果。\n\n归并法：\n\n每次选两个数组进行归并，将本轮归并的结果添加到一个新数组中，然后对新数组再次归并，重复这个过程，直到得到的新数组为 1 个，则这最后的一个数组则是结果。\n\n\n# 算法实现\n\n# 建堆法的算法实现：\n\n朴素法效率较低，此处就不展示代码了，有兴趣的读者可以自行实现。\n\n# 建堆法的算法实现：\n\n/**\n * 抽象堆\n */\nclass heap {\n  get count() {\n    return this.size;\n  }\n  /**\n   * 定义哨兵的最值，所有插入堆的元素都必须和这个值比较\n   */\n  sentry;\n\n  /**\n   * 定义一个存储数据的内存空间\n   */\n  data = [];\n\n  /**\n   * 当前堆的元素个数\n   */\n  size = 0;\n\n  /**\n   * 比较函数, 通过先前和当前元素的比较，决定是否将当前元素提置先前元素前\n   */\n  compare;\n\n  /**\n   * 自身用于比较的函数\n   * @param preval 被比较的值\n   * @param curval 当前值\n   */\n  selfcompare(preval, curval) {\n    return this.compare(preval, curval);\n  }\n\n  validinitparams() {\n    if (this.sentry === void 0) {\n      throw `can not insert queue before the sentry been set `;\n    }\n    if (this.compare === void 0) {\n      throw `can not insert queue before the compare callback been set `;\n    }\n  }\n\n  constructor(...initelements) {\n    // 初始化数组元素\n    initelements.foreach((v, i) => {\n      this.data[i + 1] = v;\n      this.size++;\n    });\n    this.buildheap();\n  }\n\n  /**\n   * 设置哨兵元素\n   * @param sentryele\n   */\n  setsentry(sentryele) {\n    this.sentry = sentryele;\n    this.data[0] = this.sentry;\n  }\n\n  /**\n   * 设置比较函数\n   * @param comparefunc 比较函数\n   */\n  setcompare(comparefunc) {\n    this.compare = comparefunc;\n  }\n\n  /**\n   * 获取堆中最小的元素\n   * @returns\n   */\n  gettop() {\n    if (this.size == 0) {\n      throw `can not get element from an empty heap`;\n    }\n    return this.data[1];\n  }\n\n  /**\n   * 判断堆是否为空\n   * @returns\n   */\n  isempty() {\n    return this.size === 0;\n  }\n\n  /**\n   * 向堆中插入一个合法值\n   * @param val\n   */\n  insertqueue(val) {\n    this.validinitparams();\n    if (this.selfcompare(this.sentry, val)) {\n      throw `can not insert val bigger or smaller than ${this.sentry}`;\n    }\n    // 堆的容量扩充1\n    this.size++;\n    // 让i指向当前新位置\n    let i = this.size;\n    // 因为有哨兵的关系，不需要添加约束条件 i > 0\n    // this.#data[math.floor(i / 2)] > val\n    while (this.selfcompare(this.data[math.floor(i / 2)], val)) {\n      this.data[i] = this.data[math.floor(i / 2)];\n      i = math.floor(i / 2);\n    }\n    this.data[i] = val;\n  }\n\n  /**\n   * 获取堆中的最小元素\n   * @returns {t}\n   */\n  deletequeue() {\n    if (this.isempty()) {\n      throw "can not delete element from empty heap";\n    }\n    // 取出堆顶的元素\n    let firstval = this.data[1];\n    let temp = this.data[this.size--];\n    this.data[1] = temp;\n    // javascript语言需要进行这一步，让数组的规模缩小，释放空间\n    this.data.length--;\n    this.percdown(1);\n    return firstval;\n  }\n\n  /**\n   * 下滤：将堆中以堆data[p]为根的子堆调整为最小堆\n   * @param p 根节点索引\n   */\n  percdown(p) {\n    let parent, child;\n    let temp = this.data[p]; /* 取出根结点存放的值 */\n    for (parent = p; parent * 2 <= this.size; parent = child) {\n      child = parent * 2;\n      /* child指向左右子结点的较?者 */\n      if (child != this.size && this.selfcompare(this.data[child], this.data[child + 1])) {\n        child++;\n      }\n      /* 找到了合适位置 */\n      if (this.selfcompare(this.data[child], temp)) {\n        break;\n      } else {\n        /* 下滤x */\n        this.data[parent] = this.data[child];\n      }\n    }\n    this.data[parent] = temp;\n  }\n\n  /**\n   * 构建堆\n   */\n  buildheap() {\n    /* 调整data中的元素，使满足最堆的有序性  */\n    /* 这里所有size个元素已经存在data[]中 */\n    /* 从最后一个结点的父节点开始，到根结点1 */\n    for (let i = math.floor(this.size / 2); i > 0; i--) {\n      this.percdown(i);\n    }\n  }\n}\n\n/**\n * 堆元素为number的最小堆\n */\nclass simpleminheap extends heap {\n  constructor(...initelements) {\n    super(...initelements);\n    this.setsentry(-infinity);\n    this.setcompare((preval, curval) => {\n      return preval >= curval;\n    });\n  }\n\n  deletemin() {\n    return this.deletequeue();\n  }\n\n  getmin() {\n    return this.gettop();\n  }\n}\n\n/**\n * 合并k个有序数组\n * @param {number[][]} arrs\n */\nfunction mergekarray(arrs) {\n  let minheap = new simpleminheap();\n  let offset = 0;\n  while(offset < arrs.length) {\n    let currentarr = arrs[offset];\n    // 处理一个数组，直至为空\n    while(currentarr.length) {\n      const ele = currentarr.shift();\n      minheap.insertqueue(ele);\n    }\n    offset++;\n  }\n  let newarr = [];\n  let idx = 0;\n  // 输出堆，得到最终结果\n  while(!minheap.isempty()) {\n    const ele = minheap.deletemin();\n    newarr[idx++] = ele;\n  }\n  return newarr;\n}\n\n\n上述代码看起来比较长，主要是我们实现了一个堆（实际开发中，这是一个可以封装进成熟的代码库的操作，并不需要我们自己实现），但是其实大家只需要看关键的函数mergekarray\n\n# 归并法的算法实现\n\n归并法我们需要把上面合并 2 个有序数组的代码 copy 过来进行一下简单的修改，因为在归并的过程中，有可能剩下的数组只有可能存在一个了。修改点非常简单，只需要在第二个数组上加上默认值即可。\n\n/**\n * 合并2个有序数组\n * @param {number[]} arr1\n * @param {number[]} arr2 可选参数，若不传递该参数，则相当于将原数组copy一份\n */\nfunction merge(arr1, arr2 = []) {\n  let offset1 = 0;\n  let offset2 = 0;\n  let offset = 0;\n  let newarr = [];\n  // 当两个数组都还没有处理完成的时候\n  while (offset1 < arr1.length && offset2 < arr2.length) {\n    let val1 = arr1[offset1];\n    let val2 = arr2[offset2];\n    if (val1 >= val2) {\n      newarr[offset++] = arr2[offset2++];\n    } else {\n      newarr[offset++] = arr1[offset1++];\n    }\n  }\n  /**\n   * 这两个while不可能同时成立，只有可能成立一个，将数组长度较大的剩余部分拷贝给新数组\n   */\n  while (offset1 < arr1.length) {\n    newarr[offset++] = arr1[offset1++];\n  }\n  while (offset2 < arr2.length) {\n    newarr[offset++] = arr2[offset2++];\n  }\n  return newarr;\n}\n\n/**\n * 合并k个有序数组\n * @param {number[][]} arrs\n */\nfunction mergekarray(arrs) {\n  let mergedarr = arrs;\n  // 如果归并结果大于1，则需要继续进行归并\n  while (mergedarr.length > 1) {\n    // 本轮的归并结果\n    const mergepassarr = [];\n    for (let i = 0; i < mergedarr.length; i += 2) {\n      // 得到二路归并的结果\n      const newarr = merge(mergedarr[i], mergedarr[i + 1]);\n      mergepassarr.push(newarr);\n    }\n    // 将本轮的归并结果给最终的合并结果，使之可以继续下一轮归并\n    mergedarr = mergepassarr;\n  }\n  // 如果归并0个数组，则返回空，否则返回正常的归并结果\n  return mergedarr.length ? mergedarr[0] : [];\n}\n',charsets:{cjk:!0}},{title:"洗牌算法",frontmatter:{},regularPath:"/data-structure/list/shuffle.html",relativePath:"data-structure/list/shuffle.md",key:"v-23be0695",path:"/data-structure/list/shuffle.html",headers:[{level:2,title:"洗牌算法",slug:"洗牌算法",normalizedTitle:"洗牌算法",charIndex:2}],headersStr:"洗牌算法",content:"# 洗牌算法\n\n洗牌算法，是D.E.Knuth教授改进之后的算法，是不是觉得这个名字有点儿熟悉？对，你记性真好呢，KMP算法的K就是来源于唐纳德教授的名字。\n\n这个算法的思路理解起来也比较简单，接下来我们就描述一下这个算法的执行过程，并分析它是如何保证数据能够被等概率打乱的。\n\n假设有N个数据（下标则是[0,N-1]），第一步随机从0-N-1的范围里面随便取一个索引（我们从后向前面处理），并将这个索引的值交换到N-1这个下标上。这个操作中，每个数被取到的概率都是均等的。经过这个操作之后，将待处理的数据的规模减 1。\n\n\n\n第一步：元素5被选中的概率是1/5\n\n\n\n第二步：元素3被选中的概率是4/5 * 1/4 = 1/5（第一轮没有被选中概率是4/5，第二轮被选中，概率是1/4，看不懂的请查看概率论的知识点）\n\n\n\n第五步: 元素5被选中的概率是4/5* 3/4 * 2/3 * 1/2 * 1 = 1/5(前面 4 个代表没有被选中的概率，最后一个代表一定会被选中)\n\n不断的重复上述过程，直到处理到数组的第一个元素，则完成了数组的随机化处理，并且保证了数组每个元素被等概率的随机化。\n\n/**\n * 随机化数组\n * @param {number[]} arr 待随机化数组\n */\nfunction shuffle(arr) {\n  for (let i = arr.length - 1; i >= 0; i--) {\n    // 因为JS的随机数范围是[0, 1)，对其取floor之后，随机数范围则变成了[0, i - 1]， 所以为了保证，每个数都有机会被选取到，生成随机索引时，要传入i+1，\n    // 使得生成的随机数索引范围在[0, i]之间\n    const rndIdx = Math.floor(Math.random() * (i + 1));\n    // 将随机选中的数交换到当前处理的位置上\n    let tmp = arr[i];\n    arr[i] = arr[rndIdx];\n    arr[rndIdx] = tmp;\n    // 完成交换之后，数据规模递减，直到完成所有的处理\n  }\n}\n\n\nDANGER\n\n需要注意的就是JS的随机数的范围是[0, 1)的半闭半开区间，在经过Math.floor处理之后，注意需要保证能够把当前正在处理的位置上的元素有概率选进去，否则就不是真正的随机化了。",normalizedContent:"# 洗牌算法\n\n洗牌算法，是d.e.knuth教授改进之后的算法，是不是觉得这个名字有点儿熟悉？对，你记性真好呢，kmp算法的k就是来源于唐纳德教授的名字。\n\n这个算法的思路理解起来也比较简单，接下来我们就描述一下这个算法的执行过程，并分析它是如何保证数据能够被等概率打乱的。\n\n假设有n个数据（下标则是[0,n-1]），第一步随机从0-n-1的范围里面随便取一个索引（我们从后向前面处理），并将这个索引的值交换到n-1这个下标上。这个操作中，每个数被取到的概率都是均等的。经过这个操作之后，将待处理的数据的规模减 1。\n\n\n\n第一步：元素5被选中的概率是1/5\n\n\n\n第二步：元素3被选中的概率是4/5 * 1/4 = 1/5（第一轮没有被选中概率是4/5，第二轮被选中，概率是1/4，看不懂的请查看概率论的知识点）\n\n\n\n第五步: 元素5被选中的概率是4/5* 3/4 * 2/3 * 1/2 * 1 = 1/5(前面 4 个代表没有被选中的概率，最后一个代表一定会被选中)\n\n不断的重复上述过程，直到处理到数组的第一个元素，则完成了数组的随机化处理，并且保证了数组每个元素被等概率的随机化。\n\n/**\n * 随机化数组\n * @param {number[]} arr 待随机化数组\n */\nfunction shuffle(arr) {\n  for (let i = arr.length - 1; i >= 0; i--) {\n    // 因为js的随机数范围是[0, 1)，对其取floor之后，随机数范围则变成了[0, i - 1]， 所以为了保证，每个数都有机会被选取到，生成随机索引时，要传入i+1，\n    // 使得生成的随机数索引范围在[0, i]之间\n    const rndidx = math.floor(math.random() * (i + 1));\n    // 将随机选中的数交换到当前处理的位置上\n    let tmp = arr[i];\n    arr[i] = arr[rndidx];\n    arr[rndidx] = tmp;\n    // 完成交换之后，数据规模递减，直到完成所有的处理\n  }\n}\n\n\ndanger\n\n需要注意的就是js的随机数的范围是[0, 1)的半闭半开区间，在经过math.floor处理之后，注意需要保证能够把当前正在处理的位置上的元素有概率选进去，否则就不是真正的随机化了。",charsets:{cjk:!0}},{title:"队列",frontmatter:{},regularPath:"/data-structure/queue/desc.html",relativePath:"data-structure/queue/desc.md",key:"v-ea677b16",path:"/data-structure/queue/desc.html",headers:[{level:2,title:"队列",slug:"队列",normalizedTitle:"队列",charIndex:2},{level:2,title:"队列的通用数组实现",slug:"队列的通用数组实现",normalizedTitle:"队列的通用数组实现",charIndex:179},{level:2,title:"队列的通用链表实现",slug:"队列的通用链表实现",normalizedTitle:"队列的通用链表实现",charIndex:936},{level:2,title:"在 JavaScript 中使用队列",slug:"在-javascript-中使用队列",normalizedTitle:"在 javascript 中使用队列",charIndex:2493},{level:2,title:"队列的复杂度问题",slug:"队列的复杂度问题",normalizedTitle:"队列的复杂度问题",charIndex:2790},{level:2,title:"队列的应用",slug:"队列的应用",normalizedTitle:"队列的应用",charIndex:3115}],headersStr:"队列 队列的通用数组实现 队列的通用链表实现 在 JavaScript 中使用队列 队列的复杂度问题 队列的应用",content:'# 队列\n\n队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。（copy 自百度百科）\n\n由于每次我们要么从队尾插入元素，要么从队首删除元素，因此，队列具备一个重要的性质：\n\n先入先出。\n\n\n# 队列的通用数组实现\n\n/**\n * 队列类\n */\nclass Queue<T> {\n  private data: T[] = [];\n\n  get size(): number {\n    return this.data.length;\n  }\n\n  /**\n   * 入队一个元素\n   * @param ele\n   */\n  public enqueue(ele: T) {\n    // 我们把数组的尾作为队首，数组的头作为队尾\n    this.data.length++;\n    for (let i = this.data.length - 1; i >= 1; i--) {\n      this.data[i] = this.data[i - 1];\n    }\n    this.data[0] = ele;\n  }\n\n  /**\n   * 出队一个元素\n   */\n  public dequeue() {\n    if (this.isEmpty()) {\n      throw new Error("can not dequeue from an empty queue");\n    }\n    let len = this.size;\n    // 获取数组中最后一个元素\n    let ele = this.data[len - 1];\n    // 将数组的长度递减\n    this.data.length--;\n    return ele;\n  }\n\n  /**\n   * 队列是否为空\n   * @returns\n   */\n  public isEmpty() {\n    return this.data.length === 0;\n  }\n}\n\n\n\n# 队列的通用链表实现\n\n/**\n * 队列元素的节点元素定义，必须使用双向链表，便于我们查找前驱和后继元素\n */\ninterface LinkedListNode<T> {\n  next: LinkedListNode<T> | null;\n  prev: LinkedListNode<T> | null;\n  data: T;\n}\n\nclass Queue<T> {\n  /**\n   * 链表的头结点\n   */\n  private head: LinkedListNode<T> | null = null;\n\n  /**\n   * 链表的尾节点\n   */\n  private tail: LinkedListNode<T> | null = null;\n\n  private length = 0;\n\n  public get size() {\n    return this.length;\n  }\n\n  /**\n   * 入队一个元素\n   * @param ele\n   */\n  public enqueue(ele: T) {\n    const newNode: LinkedListNode<T> = {\n      next: null,\n      prev: null,\n      data: ele,\n    };\n    // 队列长度增加\n    this.length++;\n    // 如果一个元素都没有，直接让head和tail都指向这个节点\n    if (this.head === null) {\n      this.head = this.tail = newNode;\n    } else {\n      // 如果存在多个元素，让尾指针指向新来的节点\n      this.tail!.next = newNode;\n      // 新来的节点指向队尾指针\n      newNode.prev = this.tail;\n      // 让队尾指针指向新来的节点\n      this.tail = newNode;\n    }\n  }\n\n  /**\n   * 出队一个元素\n   */\n  public dequeue() {\n    if (this.isEmpty()) {\n      throw new Error("can not dequeue from an empty queue");\n    }\n    // 获取到头节点的后继节点\n    let head = this.head!.next;\n    // 队列中的元素\n    let ele = this.head!.data;\n    // 解开第一个节点的后继节点\n    this.head!.next = null;\n    if(head) {\n      // 解开第一个节点的后继节点的前驱节点\n      head.prev = null;\n    }\n    // 让队首元素指向新的队首元素\n    this.head = head;\n    // 队列长度递减\n    this.length--;\n    // 将链表指针置空，若队列空\n    if(this.length == 0) {\n      this.head = null;\n      this.tail = null;\n    }\n    return ele;\n  }\n\n  /**\n   * 队列是否为空\n   * @returns\n   */\n  public isEmpty() {\n    return this.length === 0;\n  }\n}\n\n\n\n# 在 JavaScript 中使用队列\n\nJS 的数组同时具备栈和队列的特性，假设我们每次仅使用数组的unshift和push方法，数组即队列。\n\nconst queue = [];\nqueue.push(1); //[1]\nqueue.push(12); //[1, 12]\nqueue.push(123); //[1, 12, 123]\n\nlet front = queue.unshift() // front 为1\nfront = queue.unshift() // front为12\nfront = queue.unshift() // front为123, 此时队列已空\n\n\n\n# 队列的复杂度问题\n\n对于 JavaScript 来说，如果使用数组实现队列，我们的入队操作看起来是O(1)，为什么要说“看起来”呢，因为对于 JS 来说数组长度是可变的，我们只是执行了一个数组的基本操作，并没有什么遍历之类的操作。但是对于如C#，Java这类语言，数组在初始化的时候，必须首先确定数组的长度，假如你一直不停的入队，但是此刻数组已经没有空间容纳新来的内容了，此刻，我们便需要进行扩容，即申请一个更大的连续内存空间，然后把旧数组的内容拷贝到这块内容上来，此刻便会有一个O(n)的时间复杂度。\n\n如果使用链表实现，由于我们每次的操作总是队首或队尾元素，链表的增删操作的时间复杂度为O(1)，因此，这个实现在实际开发中有重要的意义。\n\n\n# 队列的应用\n\n在前端面试中，我们被问的最多的便是 JavaScript 的事件队列，这便是队列的实际应用场景之一，同类应用还有消息队列。\n\n另外，在广度优先搜索中，我们也需要使用队列。',normalizedContent:'# 队列\n\n队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。（copy 自百度百科）\n\n由于每次我们要么从队尾插入元素，要么从队首删除元素，因此，队列具备一个重要的性质：\n\n先入先出。\n\n\n# 队列的通用数组实现\n\n/**\n * 队列类\n */\nclass queue<t> {\n  private data: t[] = [];\n\n  get size(): number {\n    return this.data.length;\n  }\n\n  /**\n   * 入队一个元素\n   * @param ele\n   */\n  public enqueue(ele: t) {\n    // 我们把数组的尾作为队首，数组的头作为队尾\n    this.data.length++;\n    for (let i = this.data.length - 1; i >= 1; i--) {\n      this.data[i] = this.data[i - 1];\n    }\n    this.data[0] = ele;\n  }\n\n  /**\n   * 出队一个元素\n   */\n  public dequeue() {\n    if (this.isempty()) {\n      throw new error("can not dequeue from an empty queue");\n    }\n    let len = this.size;\n    // 获取数组中最后一个元素\n    let ele = this.data[len - 1];\n    // 将数组的长度递减\n    this.data.length--;\n    return ele;\n  }\n\n  /**\n   * 队列是否为空\n   * @returns\n   */\n  public isempty() {\n    return this.data.length === 0;\n  }\n}\n\n\n\n# 队列的通用链表实现\n\n/**\n * 队列元素的节点元素定义，必须使用双向链表，便于我们查找前驱和后继元素\n */\ninterface linkedlistnode<t> {\n  next: linkedlistnode<t> | null;\n  prev: linkedlistnode<t> | null;\n  data: t;\n}\n\nclass queue<t> {\n  /**\n   * 链表的头结点\n   */\n  private head: linkedlistnode<t> | null = null;\n\n  /**\n   * 链表的尾节点\n   */\n  private tail: linkedlistnode<t> | null = null;\n\n  private length = 0;\n\n  public get size() {\n    return this.length;\n  }\n\n  /**\n   * 入队一个元素\n   * @param ele\n   */\n  public enqueue(ele: t) {\n    const newnode: linkedlistnode<t> = {\n      next: null,\n      prev: null,\n      data: ele,\n    };\n    // 队列长度增加\n    this.length++;\n    // 如果一个元素都没有，直接让head和tail都指向这个节点\n    if (this.head === null) {\n      this.head = this.tail = newnode;\n    } else {\n      // 如果存在多个元素，让尾指针指向新来的节点\n      this.tail!.next = newnode;\n      // 新来的节点指向队尾指针\n      newnode.prev = this.tail;\n      // 让队尾指针指向新来的节点\n      this.tail = newnode;\n    }\n  }\n\n  /**\n   * 出队一个元素\n   */\n  public dequeue() {\n    if (this.isempty()) {\n      throw new error("can not dequeue from an empty queue");\n    }\n    // 获取到头节点的后继节点\n    let head = this.head!.next;\n    // 队列中的元素\n    let ele = this.head!.data;\n    // 解开第一个节点的后继节点\n    this.head!.next = null;\n    if(head) {\n      // 解开第一个节点的后继节点的前驱节点\n      head.prev = null;\n    }\n    // 让队首元素指向新的队首元素\n    this.head = head;\n    // 队列长度递减\n    this.length--;\n    // 将链表指针置空，若队列空\n    if(this.length == 0) {\n      this.head = null;\n      this.tail = null;\n    }\n    return ele;\n  }\n\n  /**\n   * 队列是否为空\n   * @returns\n   */\n  public isempty() {\n    return this.length === 0;\n  }\n}\n\n\n\n# 在 javascript 中使用队列\n\njs 的数组同时具备栈和队列的特性，假设我们每次仅使用数组的unshift和push方法，数组即队列。\n\nconst queue = [];\nqueue.push(1); //[1]\nqueue.push(12); //[1, 12]\nqueue.push(123); //[1, 12, 123]\n\nlet front = queue.unshift() // front 为1\nfront = queue.unshift() // front为12\nfront = queue.unshift() // front为123, 此时队列已空\n\n\n\n# 队列的复杂度问题\n\n对于 javascript 来说，如果使用数组实现队列，我们的入队操作看起来是o(1)，为什么要说“看起来”呢，因为对于 js 来说数组长度是可变的，我们只是执行了一个数组的基本操作，并没有什么遍历之类的操作。但是对于如c#，java这类语言，数组在初始化的时候，必须首先确定数组的长度，假如你一直不停的入队，但是此刻数组已经没有空间容纳新来的内容了，此刻，我们便需要进行扩容，即申请一个更大的连续内存空间，然后把旧数组的内容拷贝到这块内容上来，此刻便会有一个o(n)的时间复杂度。\n\n如果使用链表实现，由于我们每次的操作总是队首或队尾元素，链表的增删操作的时间复杂度为o(1)，因此，这个实现在实际开发中有重要的意义。\n\n\n# 队列的应用\n\n在前端面试中，我们被问的最多的便是 javascript 的事件队列，这便是队列的实际应用场景之一，同类应用还有消息队列。\n\n另外，在广度优先搜索中，我们也需要使用队列。',charsets:{cjk:!0}},{title:"AVL 树",frontmatter:{},regularPath:"/data-structure/search/avlTree.html",relativePath:"data-structure/search/avlTree.md",key:"v-42bdb895",path:"/data-structure/search/avlTree.html",headers:[{level:2,title:"AVL 树",slug:"avl-树",normalizedTitle:"avl 树",charIndex:2},{level:3,title:"AVL 树的节点定义",slug:"avl-树的节点定义",normalizedTitle:"avl 树的节点定义",charIndex:165},{level:3,title:"AVL 树的旋转",slug:"avl-树的旋转",normalizedTitle:"avl 树的旋转",charIndex:450},{level:3,title:"AVL 树旋转代码的实现",slug:"avl-树旋转代码的实现",normalizedTitle:"avl 树旋转代码的实现",charIndex:2194},{level:3,title:"AVL 树的插入",slug:"avl-树的插入",normalizedTitle:"avl 树的插入",charIndex:4171},{level:3,title:"AVL 树的删除",slug:"avl-树的删除",normalizedTitle:"avl 树的删除",charIndex:6074},{level:3,title:"复杂度分析",slug:"复杂度分析",normalizedTitle:"复杂度分析",charIndex:9587}],headersStr:"AVL 树 AVL 树的节点定义 AVL 树的旋转 AVL 树旋转代码的实现 AVL 树的插入 AVL 树的删除 复杂度分析",content:"# AVL 树\n\nAVL树是一颗自平衡二叉搜索树。在AVL树中任何节点的两个子树的高度最大差为 1，所以它也被称为高度平衡树。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。AVL树得名于它的发明者G. M. Adelson-Velsky和E. M. Landis。\n\n在阅读本文之前，请确保你已熟知二叉搜索树。\n\n\n# AVL 树的节点定义\n\n因为AVL树需要根据树高对树进行平衡性的调整，所以在树的节点上需要增加一个height域。\n\n/**\n * AVL树节点\n */\ninterface AVLTreeNode<T> {\n  /**\n   * 左子树\n   */\n  left: AVLTreeNode<T> | null;\n  /**\n   * 右子树\n   */\n  right: AVLTreeNode<T> | null;\n  /**\n   * 节点值\n   */\n  val: T;\n  /**\n   * 树高\n   */\n  height: number;\n}\n\n\n\n# AVL 树的旋转\n\n\n\n在上文我们提到在AVL树中，任何节点的两个子树的高度最大差为 1，那么，其实除开左子树或右子树上多出来的那个节点（后文我们就把它称之为孤儿节点，上图中值为 1 的节点，或值为 5 的节点），别的部分也是平衡的；\n\n如红框里圈出来的：\n\n\n\n对于节点 3，左子树高度 1，右子树高度 2，平衡因子 -1；\n\n对于节点 2，左子树高度 0，右子树高度 0，平衡因子 0；\n\n对于节点 4，左子树高度 0，右子树高度 1，平衡因子 1；\n\n对于节点 5，左右子树高度 0，平衡因子 0；\n\n因此，为了便于理解后面的几个旋转，我们就可以把问题抽象成这样：\n\n孤儿节点为左子结点：\n\n\n\n孤儿节点为右子结点：\n\n\n\n# LL 旋转\n\n若孤儿节点为左子节点（L），在其左子结点(L)上插入 C子树（还是因为任何节点的两个子树的高度最大差为 1的特征，C是可以有子节点的，后续不再赘述）：\n\n\n\n对于节点A，左子树的高度为 2，右子树高度为 0，平衡因子为-2，节点B的左子树高度 1，右子树 0，平衡因子-1；节点C的左右子树都是 0，平衡因子 0。\n\n那么，我们只需要把它调整为CBA的顺序即可。即：\n\n\n\n这就是LL旋转，即右旋。因为节点A也可能有右子树，B节点也可能有右子树。那么，B节点的右子树是要比A节点的右子树小的，所以A节点的右子树保持不动，将B的右子树挂在A节点的左子树上，若 C有左右子节点，则保持不动即可。\n\n即：\n\n\n\n# RR 旋转：\n\n若孤儿节点为右子节点（R），在其右子结点(R)上插入 C子树：\n\n\n\n对于节点A，左子树的高度为 0，右子树高度为 2，平衡因子为 2，节点B的左子树高度 0，右子树 1，平衡因子 1；节点C的左右子树都是 0，平衡因子 0。\n\n那么，我们只需要把它调整为ABC的顺序即可。即：\n\n\n\n这就是RR旋转，即左旋。因为节点A也可能有左子树，B节点也可能有左子树。那么，B节点的左子树是要比A节点的左子树大的，所以A节点的左子树保持不动，将B的左子树挂在A节点的右子树上，若C有左右子树，则保持不动即可。\n\n即：\n\n\n\n# LR 旋转\n\n若孤儿节点为左子节点（L），在其右子结点(R)上插入 C子树：\n\n\n\n对于节点A，左子树的高度为 2，右子树高度为 0，平衡因子为-2，节点B的左子树高度 0，右子树 1，平衡因子 1；节点C的左右子树都是 0，平衡因子 0。\n\n我们需要把它调整为CBA的顺序。\n\n那么，首先得把C提节点上去，即：\n\n\n\n接着，我们把C再次向上提，把A往右下压，即：\n\n\n\n同理，上述情况节点A可能有右子树，节点B可能有左子树，其实是保持不变的，但若C有左右子树，可以确定的是C的左右子树都是小于A的，C 的左右子树都是大于B的，那么C的左子树可以放在B的右子树上，C的右子树可以放在A的左子树上，即：\n\n\n\n可以看到，LR旋转，是先对节点 B进行了一次RR旋转（先左旋），再对 A 进行一次LL旋转（再右旋）。\n\n# RL 旋转\n\n若孤儿节点为右子节点（R），在其左子结点(L)上插入 C子树：\n\n\n\n对于节点A，右子树的高度为 2，左子树高度为 0，平衡因子为 2，节点B的左子树高度 1，右子树 0，平衡因子 -1；节点C的左右子树都是 0，平衡因子 0。\n\n我们需要把它调整为ACB的顺序。\n\n那么，首先得把C提上去，即：\n\n\n\n接着，我们把C再次向上提，把A往左下压，即：\n\n\n\n同理，上述情况节点A可能有左子树，节点B可能有右子树，其实是保持不变的，但若C有左右子树，可以确定的是C的左右子树都是大于A的，但C的左子树一定是小于B的，那么C的左子树可以放在B的左子树上，C的右子树可以放在A的右子树上，即：\n\n\n\n可以看到，RL旋转，是先对节点 B进行了一次LL旋转（先右旋），再对 A 进行一次RR旋转（再左旋）。\n\n这儿有个易混淆的点大家需要关注一下，LL旋转是右旋，RR旋转是左旋，对于LR旋转和RL旋转的旋转过程取决于你怎么解读L和R了，比如你将LR旋转解读为LL旋转+RR旋转，先进行的是RR旋转，再进行LL旋转，如果你将LR旋转解读为左旋和右旋，则先左旋，再右旋。\n\n\n# AVL 树旋转代码的实现\n\n首先定义一个获取树高的辅助函数\n\n/**\n * 获取以treeNode为根节点的树的高度\n * @param {AVLTreeNode<number>} treeNode\n */\nfunction getHeight(treeNode) {\n  return treeNode ? treeNode.height : 0;\n}\n\n\n# LL 旋转\n\n上面的旋转流程，我们已经阐述的很清楚了，因为是LL旋转，那么A是必须有一个左节点B的（因为我们现在插入的是C子树），把B往右上拽，把A往右下压，然后B成为了新树的根节点，重新更新一下左右子树的高度即可，现在B的左子树是B本来的左子树（即上述流程中的C），B的右子树则是调整之后以A节点为根节点的子树。A节点的左右子树没有变化，重新处理一下它的左右子树即可。\n\n/**\n * LL单旋\n * @param {AVLTreeNode<number>} A\n * @returns {AVLTreeNode<number>}\n */\nfunction singleLeftRotation(A) {\n  /* 注意：A必须有一个左子结点B */\n  let B = A.left;\n  // 注意： 一定要先把B的右子树挂在A的左边\n  A.left = B.right;\n  B.right = A;\n  /* 将A与B做左单旋，更新A与B的高度，返回新的根结点B */\n  A.height = Math.max(this.getHeight(A.left), this.getHeight(A.right)) + 1;\n  B.height = Math.max(this.getHeight(B.left), this.getHeight(A)) + 1;\n  return B;\n}\n\n\n# LR 旋转\n\n在上述流程中，我们是先对B和C进行了一次RR旋转，B即A.left，把A-(左)>B-(右)>C变成了A-(左)>C-(左)>B，然后再对A执行一次LL旋转即完成了LR旋转。\n\n/**\n * LR旋转\n * @param {AVLTreeNode<number>} A\n * @returns {AVLTreeNode<number>}\n */\nfunction doubleLeftRightRotation(A) {\n  /* 注意：A必须有一个左子结点B，且B必须有一个右子结点C */\n  /* 将A、B与C做两次单旋，返回新的根结点C */\n  /* 将B与C做右单旋，C被返回 */\n  A.left = this.singleRightRotation(A.left);\n  /* 将A与C做左单旋，C被返回 */\n  return this.singleLeftRotation(A);\n}\n\n\n# RR 旋转\n\n流程和LL旋转类似，此处不再赘述。\n\n/**\n * RR单旋\n * @param {AVLTreeNode<number>} A\n */\nfunction singleRightRotation(A) {\n  /* 注意：A必须有一个左子结点B */\n  /* 将A与B做左单旋，更新A与B的高度，返回新的根结点B */\n  let B = A.right;\n  // 注意： 一定要先把B的左子树挂在A的右边\n  A.right = B.left;\n  // A的右子树的左子树\n  B.left = A;\n  A.height = Math.max(this.getHeight(A.left), this.getHeight(A.right)) + 1;\n  B.height = Math.max(this.getHeight(B.right), this.getHeight(A)) + 1;\n  return B;\n}\n\n\n# RL 旋转\n\n流程和LR旋转类似，此处不再赘述。\n\n/**\n * 右左旋转\n * @param {AVLTreeNode<number>} A\n * @returns {AVLTreeNode<number>}\n */\nfunction doubleRightLeftRotation(A) {\n  /* 注意：A必须有一个右子结点B，且B必须有一个左子结点C */\n  /* 将A、B与C做两次单旋，返回新的根结点C */\n  /* 将B与C做左单旋，C被返回 */\n  A.right = this.singleLeftRotation(A.right);\n  /* 将A与C做右单旋，C被返回 */\n  return this.singleRightRotation(A);\n}\n\n\n\n# AVL 树的插入\n\nAVL树的插入原理和二叉搜索树的原理类似，只不过每次再插入完成之后，需要进行旋转的调整。\n\n基本流程如下：\n\n首先，如果树空，则插入新结点，更新树高，并且返回；\n\n若树不为空，判断插入值和当前根节点的值的大小，若比当前根节点的值大，则沿着左子树递归，否则，沿着右子树递归（本文不考虑二叉树中存在重复值）。\n\n在已经确定好了是在左还是右子树上插入之后，插入完成，此时，因为我们的插入操作影响到了树高，可能需要进行旋转调整，若左右子树高度绝对值等于 2（我才懒得去记谁减去谁呢），说明当前树已经不再是AVL树了，需要调整。\n\n如果我们是插在当前根节点的左子树上的，那么，肯定是左旋，至于是LL旋转还是LR旋转呢，这就要取决于我们是插入在左子树的左边还是右边的，因此，我们可以通过val < treeNode.left.val知道是插入在左边还是右边。如果这个条件成立，说明是插入在左子树的左边，则执行LL旋转，否则执行LR旋转。\n\n掌握左子树的插入之后，在右子树上的操作就变得简单了，此处不再赘述。\n\n/**\n * 插入子节点\n * @param {number} val\n */\nfunction insert(val) {\n  this.root = this._insert(this.root, val);\n}\n\n/**\n * 插入子节点\n * @param {AVLTreeNode<number>} treeNode\n * @param {number} val\n * @returns {AVLTreeNode<number>}\n */\nfunction _insert(treeNode, val) {\n  /* 将X插入AVL树treeNode中，并且返回调整后的AVL树 */\n  if (!treeNode) {\n    /* 若插入空树，则新建包含一个结点的树 */\n    treeNode = {\n      val: val,\n      height: 0,\n      left: null,\n      right: null,\n    };\n  } else if (val < treeNode.val) {\n    /* 插入treeNode的左子树 */\n    treeNode.left = this._insert(treeNode.left, val);\n    /* 如果需要旋旋 */\n    if (this.getHeight(treeNode.left) - this.getHeight(treeNode.right) === 2) {\n      if (val < treeNode.left.val) {\n        /* 左单旋 */\n        treeNode = this.singleLeftRotation(treeNode);\n      } else {\n        /* 左-右双旋 */\n        treeNode = this.doubleLeftRightRotation(treeNode);\n      }\n    }\n  } else if (val > treeNode.val) {\n    /* 插入treeNode的右子树 */\n    treeNode.right = this._insert(treeNode.right, val);\n    /* 如果需要右旋 */\n    if (this.getHeight(treeNode.left) - this.getHeight(treeNode.right) === -2) {\n      if (val > treeNode.right.val) {\n        /* 右单旋 */\n        treeNode = this.singleRightRotation(treeNode);\n      } else {\n        /* 右-左双旋 */\n        treeNode = this.doubleRightLeftRotation(treeNode);\n      }\n    }\n  }\n  /* 更新树高 */\n  treeNode.height =\n    Math.max(this.getHeight(treeNode.left), this.getHeight(treeNode.right)) + 1;\n  return treeNode;\n}\n\n\n\n# AVL 树的删除\n\nAVL树的删除操作，是插入操作的逆过程，我们以递归实现为思路，首先删除操作必须是基于一个二叉搜索树的删除， 如果当前是空树，则无法删除，如果当前根节点的值比待删除值大，则沿着左子树递归删除，反之则沿着右子树递归删除；如果当前根节点的值待删除值相同，则说明这个节点就是要删除的值，此时，就要看当前节点是一个什么样的情况了，如果它同时具有左右儿子，那么，我们可以从它的右子树里面找一个最小值（左子树里面找一个最大值也可以），然后把找到的最值节点拷贝到当前这个位置上，并且从当前节点的子树开始，递归的去删除它的最值（如果你之前是用的是右子树的最小值，就从右子树出发删除最小值，使用左子树的最大值同理），最后我们的问题始终转换为删除不同时具有左右子节点的问题。如果当前节点没有左右儿子，直接把treeNode指针标记为空即可，如果当前节点只有左儿子，那么直接用当前节点的左儿子指针覆盖treeNode指针即可，如果当前节点只有右儿子，那么直接用当前节点的右儿子指针覆盖treeNode指针即可，\n\n因为我们删除了树的节点，影响到了高度，所以现在需要根据树高进行旋转调整。\n\n比如现在你删除了右子树上面的节点，若是影响了树的高度的话（左右子树高度差大于等于 2），我们即需要进行左旋转，至于是LL旋转还是LR旋转，得取决于当前左子树的左右子树的高度，如果左子树的左子树树高大于等于左子树的右子树树高，说明左边高，则进行LL旋转，否则LR旋转。（分不清这儿的同学可以看一下上文旋转操作的图示）。\n\n下图表示的是删除A的右子节点之后，其中B的左子树树高大于等于B的左子树的树高（取得等于的时候是B的右子树存在时），这种情况下进行的是LL旋转。\n\n\n\n下图表示的是删除A的右子节点之后，其中B的右子树树高，大于B的左子树的树高，这种情况下进行的是LR旋转。\n\n\n\n当删除节点是某个节点的左叶子节点的情况时上面两种情况差不多，就不再赘述。\n\n当这些操作都进行完毕之后，千万别忘了更新树高。\n\n一次删除，可能需要多次回溯才可能最终使树变得平衡，因为我们使用的是递归算法，当递归调用退栈的时候，将会根据左右子树的高度决定是否进行旋转调整。\n\n/**\n * 在AVL树中查找最小值\n * @param {AVLTreeNode<number>} treeNode\n * @returns\n */\nfunction findMin(treeNode) {\n  let minTreeNode = null;\n  while (treeNode) {\n    minTreeNode = treeNode;\n    treeNode = treeNode.left;\n  }\n  return minTreeNode;\n}\n\n/**\n * 删除子节点\n * @param {number} val\n */\nfunction delete(val) {\n  this.root = this._delete(this.root, val);\n}\n\n/**\n * 辅助函数：删除子节点\n * @param {AVLTreeNode<number>} treeNode\n * @param {number} delVal\n * @returns\n */\nfunction _delete(treeNode, delVal) {\n  if (treeNode === null) {\n    // 空树，无法删除\n    return null;\n  } else if (delVal < treeNode.val) {\n    // val 位于左子树，其实就是相当于右子树的插入，所以在调整的时候，执行右旋\n    treeNode.left = this._delete(treeNode.left, delVal);\n    // 更新树高\n    treeNode.height =\n      Math.max(\n        this.getHeight(treeNode.left),\n        this.getHeight(treeNode.right)\n      ) + 1;\n    if (\n      Math.abs(\n        this.getHeight(treeNode.right) - this.getHeight(treeNode.left)\n      ) === 2\n    ) {\n      // 在回溯时，仍然有可能有调整子树的需求\n      if (\n        this.getHeight(treeNode.right.right) >=\n        this.getHeight(treeNode.right.left)\n      ) {\n        treeNode = this.singleRightRotation(treeNode);\n      } else {\n        treeNode = this.doubleLeftRightRotation(treeNode);\n      }\n    }\n  } else if (delVal > treeNode.val) {\n    // val 位于右子树删除，其实就是相当于是左子树插入\n    treeNode.right = this._delete(treeNode.right, delVal);\n    // 更新树高\n    treeNode.height =\n      Math.max(\n        this.getHeight(treeNode.left),\n        this.getHeight(treeNode.right)\n      ) + 1;\n    if (\n      Math.abs(\n        this.getHeight(treeNode.left) - this.getHeight(treeNode.right)\n      ) === 2\n    ) {\n      // 在回溯时，仍然有可能有调整子树的需求\n      if (\n        this.getHeight(treeNode.left.left) >=\n        this.getHeight(treeNode.left.right)\n      ) {\n        treeNode = this.singleLeftRotation(treeNode);\n      } else {\n        treeNode = this.doubleLeftRightRotation(treeNode);\n      }\n    }\n  } else if (treeNode.left && treeNode.right) {\n    /* 如果待删除节点同时存在左右儿子节点 */\n    // 找到右子树的最小节点\n    let rightSubTreeMinNode = this.findMin(treeNode.right);\n    // 用右子树上的最小节点替换当前值，然后再从当前右子树触发，递归的删除右子树上的最小值。\n    treeNode.val = rightSubTreeMinNode.val;\n    treeNode.right = this._delete(treeNode.right, treeNode.val);\n  } else {\n    /* 如果待删除节点只有左儿子节点，那么把它的左儿子直接赋值给它自己，相当于移除了待删除节点 */\n    if (treeNode.right === null) {\n      treeNode = treeNode.left;\n    } else if (treeNode.left === null) {\n      /* 如果待删除节点只有右儿子节点，那么把它的右儿子直接赋值给它自己，相当于移除了待删除节点 */\n      treeNode = treeNode.right;\n    } else {\n      /* 如果待删除节点没有左右儿子节点，直接赋值为空，相当于移除了待删除节点 */\n      treeNode = null;\n    }\n  }\n  return treeNode;\n}\n\n\n\n# 复杂度分析\n\nAVL树的完整代码如下：\n\n/**\n * 平衡二叉树的实现\n */\nclass AVLTree {\n  /**\n   * 根节点\n   * @type {AVLTreeNode<number> | null}\n   */\n  root = null;\n\n  /**\n   * 获取以treeNode为根节点的树高\n   * @param {AVLTreeNode<number>} treeNode\n   */\n  getHeight(treeNode) {\n    return treeNode ? treeNode.height : 0;\n  }\n\n  /**\n   * 左单旋\n   * @param {AVLTreeNode<number>} A\n   * @returns {AVLTreeNode<number>}\n   */\n  singleLeftRotation(A) {\n    /* 注意：A必须有一个左子结点B */\n    /* 将A与B做左单旋，更新A与B的高度，返回新的根结点B */\n    // 当前树节点的左子树\n    let B = A.left;\n    // 注意： 一定要先把B的右子树挂在A的左边\n    A.left = B.right;\n    B.right = A;\n    A.height = Math.max(this.getHeight(A.left), this.getHeight(A.right)) + 1;\n    B.height = Math.max(this.getHeight(B.left), this.getHeight(A)) + 1;\n    return B;\n  }\n\n  /**\n   * 右单旋\n   * @param {AVLTreeNode<number>} A\n   */\n  singleRightRotation(A) {\n    /* 注意：A必须有一个左子结点B */\n    /* 将A与B做左单旋，更新A与B的高度，返回新的根结点B */\n    let B = A.right;\n    // 注意： 一定要先把B的左子树挂在A的右边\n    A.right = B.left;\n    // A的右子树的左子树\n    B.left = A;\n    A.height = Math.max(this.getHeight(A.left), this.getHeight(A.right)) + 1;\n    B.height = Math.max(this.getHeight(B.right), this.getHeight(A)) + 1;\n    return B;\n  }\n\n  /**\n   * 左右旋转\n   * @param {AVLTreeNode<number>} A\n   * @returns {AVLTreeNode<number>}\n   */\n  doubleLeftRightRotation(A) {\n    /* 注意：A必须有一个左子结点B，且B必须有一个右子结点C */\n    /* 将A、B与C做两次单旋，返回新的根结点C */\n    /* 将B与C做右单旋，C被返回 */\n    A.left = this.singleRightRotation(A.left);\n    /* 将A与C做左单旋，C被返回 */\n    return this.singleLeftRotation(A);\n  }\n\n  /**\n   * 右左旋转\n   * @param {AVLTreeNode<number>} A\n   * @returns {AVLTreeNode<number>}\n   */\n  doubleRightLeftRotation(A) {\n    /* 注意：A必须有一个右子结点B，且B必须有一个左子结点C */\n    /* 将A、B与C做两次单旋，返回新的根结点C */\n    /* 将B与C做左单旋，C被返回 */\n    A.right = this.singleLeftRotation(A.right);\n    /* 将A与C做右单旋，C被返回 */\n    return this.singleRightRotation(A);\n  }\n\n  /**\n   * 查找指定值是否在二叉搜索树中存在\n   * @param {number} val\n   * @returns {AVLTreeNode<number>}\n   */\n  find(val) {\n    return this._find(val, this.root);\n  }\n\n  /**\n   * 查找辅助函数\n   * @param {number} val\n   * @param {AVLTreeNode<number>} treeNode\n   */\n  _find(val, treeNode) {\n    let node = treeNode;\n    while (node) {\n      if (node.val == val) {\n        break;\n      } else if (node.val > val) {\n        // 沿着左子树查找\n        node = node.left;\n      } else if (node.val < val) {\n        // 沿着右子树查找\n        node = node.right;\n      }\n    }\n    return node;\n  }\n\n  /**\n   * 在AVL树中查找最小值\n   * @param {AVLTreeNode<number>} treeNode\n   * @returns\n   */\n  findMin(treeNode) {\n    let minTreeNode = null;\n    while (treeNode) {\n      minTreeNode = treeNode;\n      treeNode = treeNode.left;\n    }\n    return minTreeNode;\n  }\n\n  /**\n   * 插入子节点\n   * @param {number} val\n   */\n  insert(val) {\n    this.root = this._insert(this.root, val);\n  }\n\n  /**\n   * 删除子节点\n   * @param {number} val\n   */\n  delete(val) {\n    this.root = this._delete(this.root, val);\n  }\n\n  /**\n   * 辅助函数：删除子节点\n   * @param {AVLTreeNode<number>} treeNode\n   * @param {number} delVal\n   * @returns\n   */\n  _delete(treeNode, delVal) {\n    if (treeNode === null) {\n      // 空树，无法删除\n      return null;\n    } else if (delVal < treeNode.val) {\n      // val 位于左子树，其实就是相当于右子树的插入，所以在调整的时候，执行右旋\n      treeNode.left = this._delete(treeNode.left, delVal);\n      // 更新树高\n      treeNode.height =\n        Math.max(\n          this.getHeight(treeNode.left),\n          this.getHeight(treeNode.right)\n        ) + 1;\n      if (\n        Math.abs(\n          this.getHeight(treeNode.right) - this.getHeight(treeNode.left)\n        ) === 2\n      ) {\n        if (\n          this.getHeight(treeNode.right.right) >=\n          this.getHeight(treeNode.right.left)\n        ) {\n          treeNode = this.singleRightRotation(treeNode);\n        } else {\n          treeNode = this.doubleLeftRightRotation(treeNode);\n        }\n      }\n    } else if (delVal > treeNode.val) {\n      // val 位于右子树删除，其实就是相当于是左子树插入\n      treeNode.right = this._delete(treeNode.right, delVal);\n      // 更新树高\n      treeNode.height =\n        Math.max(\n          this.getHeight(treeNode.left),\n          this.getHeight(treeNode.right)\n        ) + 1;\n      if (\n        Math.abs(\n          this.getHeight(treeNode.left) - this.getHeight(treeNode.right)\n        ) === 2\n      ) {\n        if (\n          this.getHeight(treeNode.left.left) >=\n          this.getHeight(treeNode.left.right)\n        ) {\n          treeNode = this.singleLeftRotation(treeNode);\n        } else {\n          treeNode = this.doubleLeftRightRotation(treeNode);\n        }\n      }\n    } else if (treeNode.left && treeNode.right) {\n      /* 如果待删除节点同时存在左右儿子节点 */\n      // 找到右子树的最小节点\n      let rightSubTreeMinNode = this.findMin(treeNode.right);\n      // 用右子树上的最小节点替换当前值，然后再从当前右子树触发，递归的删除右子树上的最小值。\n      treeNode.val = rightSubTreeMinNode.val;\n      treeNode.right = this._delete(treeNode.right, treeNode.val);\n    } else {\n      /* 如果待删除节点只有左儿子节点，那么把它的左儿子直接赋值给它自己，相当于移除了待删除节点 */\n      if (treeNode.right === null) {\n        treeNode = treeNode.left;\n      } else if (treeNode.left === null) {\n        /* 如果待删除节点只有右儿子节点，那么把它的右儿子直接赋值给它自己，相当于移除了待删除节点 */\n        treeNode = treeNode.right;\n      } else {\n        /* 如果待删除节点没有左右儿子节点，直接赋值为空，相当于移除了待删除节点 */\n        treeNode = null;\n      }\n    }\n    return treeNode;\n  }\n\n  /**\n   * 辅助函数：插入子节点\n   * @param {AVLTreeNode<number>} treeNode\n   * @param {number} val\n   * @returns {AVLTreeNode<number>}\n   */\n  _insert(treeNode, val) {\n    /* 将X插入AVL树treeNode中，并且返回调整后的AVL树 */\n    if (!treeNode) {\n      /* 若插入空树，则新建包含一个结点的树 */\n      treeNode = {\n        val: val,\n        height: 0,\n        left: null,\n        right: null,\n      };\n    } else if (val < treeNode.val) {\n      /* 插入treeNode的左子树 */\n      treeNode.left = this._insert(treeNode.left, val);\n      /* 如果需要左旋 */\n      if (\n        Math.abs(\n          this.getHeight(treeNode.left) - this.getHeight(treeNode.right)\n        ) === 2\n      ) {\n        if (val < treeNode.left.val) {\n          /* 左单旋 */\n          treeNode = this.singleLeftRotation(treeNode);\n        } else {\n          /* 左-右双旋 */\n          treeNode = this.doubleLeftRightRotation(treeNode);\n        }\n      }\n    } else if (val > treeNode.val) {\n      /* 插入treeNode的右子树 */\n      treeNode.right = this._insert(treeNode.right, val);\n      /* 如果需要右旋 */\n      if (\n        Math.abs(\n          this.getHeight(treeNode.left) - this.getHeight(treeNode.right)\n        ) === 2\n      ) {\n        if (val > treeNode.right.val) {\n          /* 右单旋 */\n          treeNode = this.singleRightRotation(treeNode);\n        } else {\n          /* 右-左双旋 */\n          treeNode = this.doubleRightLeftRotation(treeNode);\n        }\n      }\n    }\n    /* 更新树高 */\n    treeNode.height =\n      Math.max(this.getHeight(treeNode.left), this.getHeight(treeNode.right)) +\n      1;\n    return treeNode;\n  }\n}\n\n\nAVL树的插入和删除时间复杂度都是O(log n)，具体的分析过程，有兴趣的同学请参考相应的论文资料。",normalizedContent:"# avl 树\n\navl树是一颗自平衡二叉搜索树。在avl树中任何节点的两个子树的高度最大差为 1，所以它也被称为高度平衡树。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。avl树得名于它的发明者g. m. adelson-velsky和e. m. landis。\n\n在阅读本文之前，请确保你已熟知二叉搜索树。\n\n\n# avl 树的节点定义\n\n因为avl树需要根据树高对树进行平衡性的调整，所以在树的节点上需要增加一个height域。\n\n/**\n * avl树节点\n */\ninterface avltreenode<t> {\n  /**\n   * 左子树\n   */\n  left: avltreenode<t> | null;\n  /**\n   * 右子树\n   */\n  right: avltreenode<t> | null;\n  /**\n   * 节点值\n   */\n  val: t;\n  /**\n   * 树高\n   */\n  height: number;\n}\n\n\n\n# avl 树的旋转\n\n\n\n在上文我们提到在avl树中，任何节点的两个子树的高度最大差为 1，那么，其实除开左子树或右子树上多出来的那个节点（后文我们就把它称之为孤儿节点，上图中值为 1 的节点，或值为 5 的节点），别的部分也是平衡的；\n\n如红框里圈出来的：\n\n\n\n对于节点 3，左子树高度 1，右子树高度 2，平衡因子 -1；\n\n对于节点 2，左子树高度 0，右子树高度 0，平衡因子 0；\n\n对于节点 4，左子树高度 0，右子树高度 1，平衡因子 1；\n\n对于节点 5，左右子树高度 0，平衡因子 0；\n\n因此，为了便于理解后面的几个旋转，我们就可以把问题抽象成这样：\n\n孤儿节点为左子结点：\n\n\n\n孤儿节点为右子结点：\n\n\n\n# ll 旋转\n\n若孤儿节点为左子节点（l），在其左子结点(l)上插入 c子树（还是因为任何节点的两个子树的高度最大差为 1的特征，c是可以有子节点的，后续不再赘述）：\n\n\n\n对于节点a，左子树的高度为 2，右子树高度为 0，平衡因子为-2，节点b的左子树高度 1，右子树 0，平衡因子-1；节点c的左右子树都是 0，平衡因子 0。\n\n那么，我们只需要把它调整为cba的顺序即可。即：\n\n\n\n这就是ll旋转，即右旋。因为节点a也可能有右子树，b节点也可能有右子树。那么，b节点的右子树是要比a节点的右子树小的，所以a节点的右子树保持不动，将b的右子树挂在a节点的左子树上，若 c有左右子节点，则保持不动即可。\n\n即：\n\n\n\n# rr 旋转：\n\n若孤儿节点为右子节点（r），在其右子结点(r)上插入 c子树：\n\n\n\n对于节点a，左子树的高度为 0，右子树高度为 2，平衡因子为 2，节点b的左子树高度 0，右子树 1，平衡因子 1；节点c的左右子树都是 0，平衡因子 0。\n\n那么，我们只需要把它调整为abc的顺序即可。即：\n\n\n\n这就是rr旋转，即左旋。因为节点a也可能有左子树，b节点也可能有左子树。那么，b节点的左子树是要比a节点的左子树大的，所以a节点的左子树保持不动，将b的左子树挂在a节点的右子树上，若c有左右子树，则保持不动即可。\n\n即：\n\n\n\n# lr 旋转\n\n若孤儿节点为左子节点（l），在其右子结点(r)上插入 c子树：\n\n\n\n对于节点a，左子树的高度为 2，右子树高度为 0，平衡因子为-2，节点b的左子树高度 0，右子树 1，平衡因子 1；节点c的左右子树都是 0，平衡因子 0。\n\n我们需要把它调整为cba的顺序。\n\n那么，首先得把c提节点上去，即：\n\n\n\n接着，我们把c再次向上提，把a往右下压，即：\n\n\n\n同理，上述情况节点a可能有右子树，节点b可能有左子树，其实是保持不变的，但若c有左右子树，可以确定的是c的左右子树都是小于a的，c 的左右子树都是大于b的，那么c的左子树可以放在b的右子树上，c的右子树可以放在a的左子树上，即：\n\n\n\n可以看到，lr旋转，是先对节点 b进行了一次rr旋转（先左旋），再对 a 进行一次ll旋转（再右旋）。\n\n# rl 旋转\n\n若孤儿节点为右子节点（r），在其左子结点(l)上插入 c子树：\n\n\n\n对于节点a，右子树的高度为 2，左子树高度为 0，平衡因子为 2，节点b的左子树高度 1，右子树 0，平衡因子 -1；节点c的左右子树都是 0，平衡因子 0。\n\n我们需要把它调整为acb的顺序。\n\n那么，首先得把c提上去，即：\n\n\n\n接着，我们把c再次向上提，把a往左下压，即：\n\n\n\n同理，上述情况节点a可能有左子树，节点b可能有右子树，其实是保持不变的，但若c有左右子树，可以确定的是c的左右子树都是大于a的，但c的左子树一定是小于b的，那么c的左子树可以放在b的左子树上，c的右子树可以放在a的右子树上，即：\n\n\n\n可以看到，rl旋转，是先对节点 b进行了一次ll旋转（先右旋），再对 a 进行一次rr旋转（再左旋）。\n\n这儿有个易混淆的点大家需要关注一下，ll旋转是右旋，rr旋转是左旋，对于lr旋转和rl旋转的旋转过程取决于你怎么解读l和r了，比如你将lr旋转解读为ll旋转+rr旋转，先进行的是rr旋转，再进行ll旋转，如果你将lr旋转解读为左旋和右旋，则先左旋，再右旋。\n\n\n# avl 树旋转代码的实现\n\n首先定义一个获取树高的辅助函数\n\n/**\n * 获取以treenode为根节点的树的高度\n * @param {avltreenode<number>} treenode\n */\nfunction getheight(treenode) {\n  return treenode ? treenode.height : 0;\n}\n\n\n# ll 旋转\n\n上面的旋转流程，我们已经阐述的很清楚了，因为是ll旋转，那么a是必须有一个左节点b的（因为我们现在插入的是c子树），把b往右上拽，把a往右下压，然后b成为了新树的根节点，重新更新一下左右子树的高度即可，现在b的左子树是b本来的左子树（即上述流程中的c），b的右子树则是调整之后以a节点为根节点的子树。a节点的左右子树没有变化，重新处理一下它的左右子树即可。\n\n/**\n * ll单旋\n * @param {avltreenode<number>} a\n * @returns {avltreenode<number>}\n */\nfunction singleleftrotation(a) {\n  /* 注意：a必须有一个左子结点b */\n  let b = a.left;\n  // 注意： 一定要先把b的右子树挂在a的左边\n  a.left = b.right;\n  b.right = a;\n  /* 将a与b做左单旋，更新a与b的高度，返回新的根结点b */\n  a.height = math.max(this.getheight(a.left), this.getheight(a.right)) + 1;\n  b.height = math.max(this.getheight(b.left), this.getheight(a)) + 1;\n  return b;\n}\n\n\n# lr 旋转\n\n在上述流程中，我们是先对b和c进行了一次rr旋转，b即a.left，把a-(左)>b-(右)>c变成了a-(左)>c-(左)>b，然后再对a执行一次ll旋转即完成了lr旋转。\n\n/**\n * lr旋转\n * @param {avltreenode<number>} a\n * @returns {avltreenode<number>}\n */\nfunction doubleleftrightrotation(a) {\n  /* 注意：a必须有一个左子结点b，且b必须有一个右子结点c */\n  /* 将a、b与c做两次单旋，返回新的根结点c */\n  /* 将b与c做右单旋，c被返回 */\n  a.left = this.singlerightrotation(a.left);\n  /* 将a与c做左单旋，c被返回 */\n  return this.singleleftrotation(a);\n}\n\n\n# rr 旋转\n\n流程和ll旋转类似，此处不再赘述。\n\n/**\n * rr单旋\n * @param {avltreenode<number>} a\n */\nfunction singlerightrotation(a) {\n  /* 注意：a必须有一个左子结点b */\n  /* 将a与b做左单旋，更新a与b的高度，返回新的根结点b */\n  let b = a.right;\n  // 注意： 一定要先把b的左子树挂在a的右边\n  a.right = b.left;\n  // a的右子树的左子树\n  b.left = a;\n  a.height = math.max(this.getheight(a.left), this.getheight(a.right)) + 1;\n  b.height = math.max(this.getheight(b.right), this.getheight(a)) + 1;\n  return b;\n}\n\n\n# rl 旋转\n\n流程和lr旋转类似，此处不再赘述。\n\n/**\n * 右左旋转\n * @param {avltreenode<number>} a\n * @returns {avltreenode<number>}\n */\nfunction doublerightleftrotation(a) {\n  /* 注意：a必须有一个右子结点b，且b必须有一个左子结点c */\n  /* 将a、b与c做两次单旋，返回新的根结点c */\n  /* 将b与c做左单旋，c被返回 */\n  a.right = this.singleleftrotation(a.right);\n  /* 将a与c做右单旋，c被返回 */\n  return this.singlerightrotation(a);\n}\n\n\n\n# avl 树的插入\n\navl树的插入原理和二叉搜索树的原理类似，只不过每次再插入完成之后，需要进行旋转的调整。\n\n基本流程如下：\n\n首先，如果树空，则插入新结点，更新树高，并且返回；\n\n若树不为空，判断插入值和当前根节点的值的大小，若比当前根节点的值大，则沿着左子树递归，否则，沿着右子树递归（本文不考虑二叉树中存在重复值）。\n\n在已经确定好了是在左还是右子树上插入之后，插入完成，此时，因为我们的插入操作影响到了树高，可能需要进行旋转调整，若左右子树高度绝对值等于 2（我才懒得去记谁减去谁呢），说明当前树已经不再是avl树了，需要调整。\n\n如果我们是插在当前根节点的左子树上的，那么，肯定是左旋，至于是ll旋转还是lr旋转呢，这就要取决于我们是插入在左子树的左边还是右边的，因此，我们可以通过val < treenode.left.val知道是插入在左边还是右边。如果这个条件成立，说明是插入在左子树的左边，则执行ll旋转，否则执行lr旋转。\n\n掌握左子树的插入之后，在右子树上的操作就变得简单了，此处不再赘述。\n\n/**\n * 插入子节点\n * @param {number} val\n */\nfunction insert(val) {\n  this.root = this._insert(this.root, val);\n}\n\n/**\n * 插入子节点\n * @param {avltreenode<number>} treenode\n * @param {number} val\n * @returns {avltreenode<number>}\n */\nfunction _insert(treenode, val) {\n  /* 将x插入avl树treenode中，并且返回调整后的avl树 */\n  if (!treenode) {\n    /* 若插入空树，则新建包含一个结点的树 */\n    treenode = {\n      val: val,\n      height: 0,\n      left: null,\n      right: null,\n    };\n  } else if (val < treenode.val) {\n    /* 插入treenode的左子树 */\n    treenode.left = this._insert(treenode.left, val);\n    /* 如果需要旋旋 */\n    if (this.getheight(treenode.left) - this.getheight(treenode.right) === 2) {\n      if (val < treenode.left.val) {\n        /* 左单旋 */\n        treenode = this.singleleftrotation(treenode);\n      } else {\n        /* 左-右双旋 */\n        treenode = this.doubleleftrightrotation(treenode);\n      }\n    }\n  } else if (val > treenode.val) {\n    /* 插入treenode的右子树 */\n    treenode.right = this._insert(treenode.right, val);\n    /* 如果需要右旋 */\n    if (this.getheight(treenode.left) - this.getheight(treenode.right) === -2) {\n      if (val > treenode.right.val) {\n        /* 右单旋 */\n        treenode = this.singlerightrotation(treenode);\n      } else {\n        /* 右-左双旋 */\n        treenode = this.doublerightleftrotation(treenode);\n      }\n    }\n  }\n  /* 更新树高 */\n  treenode.height =\n    math.max(this.getheight(treenode.left), this.getheight(treenode.right)) + 1;\n  return treenode;\n}\n\n\n\n# avl 树的删除\n\navl树的删除操作，是插入操作的逆过程，我们以递归实现为思路，首先删除操作必须是基于一个二叉搜索树的删除， 如果当前是空树，则无法删除，如果当前根节点的值比待删除值大，则沿着左子树递归删除，反之则沿着右子树递归删除；如果当前根节点的值待删除值相同，则说明这个节点就是要删除的值，此时，就要看当前节点是一个什么样的情况了，如果它同时具有左右儿子，那么，我们可以从它的右子树里面找一个最小值（左子树里面找一个最大值也可以），然后把找到的最值节点拷贝到当前这个位置上，并且从当前节点的子树开始，递归的去删除它的最值（如果你之前是用的是右子树的最小值，就从右子树出发删除最小值，使用左子树的最大值同理），最后我们的问题始终转换为删除不同时具有左右子节点的问题。如果当前节点没有左右儿子，直接把treenode指针标记为空即可，如果当前节点只有左儿子，那么直接用当前节点的左儿子指针覆盖treenode指针即可，如果当前节点只有右儿子，那么直接用当前节点的右儿子指针覆盖treenode指针即可，\n\n因为我们删除了树的节点，影响到了高度，所以现在需要根据树高进行旋转调整。\n\n比如现在你删除了右子树上面的节点，若是影响了树的高度的话（左右子树高度差大于等于 2），我们即需要进行左旋转，至于是ll旋转还是lr旋转，得取决于当前左子树的左右子树的高度，如果左子树的左子树树高大于等于左子树的右子树树高，说明左边高，则进行ll旋转，否则lr旋转。（分不清这儿的同学可以看一下上文旋转操作的图示）。\n\n下图表示的是删除a的右子节点之后，其中b的左子树树高大于等于b的左子树的树高（取得等于的时候是b的右子树存在时），这种情况下进行的是ll旋转。\n\n\n\n下图表示的是删除a的右子节点之后，其中b的右子树树高，大于b的左子树的树高，这种情况下进行的是lr旋转。\n\n\n\n当删除节点是某个节点的左叶子节点的情况时上面两种情况差不多，就不再赘述。\n\n当这些操作都进行完毕之后，千万别忘了更新树高。\n\n一次删除，可能需要多次回溯才可能最终使树变得平衡，因为我们使用的是递归算法，当递归调用退栈的时候，将会根据左右子树的高度决定是否进行旋转调整。\n\n/**\n * 在avl树中查找最小值\n * @param {avltreenode<number>} treenode\n * @returns\n */\nfunction findmin(treenode) {\n  let mintreenode = null;\n  while (treenode) {\n    mintreenode = treenode;\n    treenode = treenode.left;\n  }\n  return mintreenode;\n}\n\n/**\n * 删除子节点\n * @param {number} val\n */\nfunction delete(val) {\n  this.root = this._delete(this.root, val);\n}\n\n/**\n * 辅助函数：删除子节点\n * @param {avltreenode<number>} treenode\n * @param {number} delval\n * @returns\n */\nfunction _delete(treenode, delval) {\n  if (treenode === null) {\n    // 空树，无法删除\n    return null;\n  } else if (delval < treenode.val) {\n    // val 位于左子树，其实就是相当于右子树的插入，所以在调整的时候，执行右旋\n    treenode.left = this._delete(treenode.left, delval);\n    // 更新树高\n    treenode.height =\n      math.max(\n        this.getheight(treenode.left),\n        this.getheight(treenode.right)\n      ) + 1;\n    if (\n      math.abs(\n        this.getheight(treenode.right) - this.getheight(treenode.left)\n      ) === 2\n    ) {\n      // 在回溯时，仍然有可能有调整子树的需求\n      if (\n        this.getheight(treenode.right.right) >=\n        this.getheight(treenode.right.left)\n      ) {\n        treenode = this.singlerightrotation(treenode);\n      } else {\n        treenode = this.doubleleftrightrotation(treenode);\n      }\n    }\n  } else if (delval > treenode.val) {\n    // val 位于右子树删除，其实就是相当于是左子树插入\n    treenode.right = this._delete(treenode.right, delval);\n    // 更新树高\n    treenode.height =\n      math.max(\n        this.getheight(treenode.left),\n        this.getheight(treenode.right)\n      ) + 1;\n    if (\n      math.abs(\n        this.getheight(treenode.left) - this.getheight(treenode.right)\n      ) === 2\n    ) {\n      // 在回溯时，仍然有可能有调整子树的需求\n      if (\n        this.getheight(treenode.left.left) >=\n        this.getheight(treenode.left.right)\n      ) {\n        treenode = this.singleleftrotation(treenode);\n      } else {\n        treenode = this.doubleleftrightrotation(treenode);\n      }\n    }\n  } else if (treenode.left && treenode.right) {\n    /* 如果待删除节点同时存在左右儿子节点 */\n    // 找到右子树的最小节点\n    let rightsubtreeminnode = this.findmin(treenode.right);\n    // 用右子树上的最小节点替换当前值，然后再从当前右子树触发，递归的删除右子树上的最小值。\n    treenode.val = rightsubtreeminnode.val;\n    treenode.right = this._delete(treenode.right, treenode.val);\n  } else {\n    /* 如果待删除节点只有左儿子节点，那么把它的左儿子直接赋值给它自己，相当于移除了待删除节点 */\n    if (treenode.right === null) {\n      treenode = treenode.left;\n    } else if (treenode.left === null) {\n      /* 如果待删除节点只有右儿子节点，那么把它的右儿子直接赋值给它自己，相当于移除了待删除节点 */\n      treenode = treenode.right;\n    } else {\n      /* 如果待删除节点没有左右儿子节点，直接赋值为空，相当于移除了待删除节点 */\n      treenode = null;\n    }\n  }\n  return treenode;\n}\n\n\n\n# 复杂度分析\n\navl树的完整代码如下：\n\n/**\n * 平衡二叉树的实现\n */\nclass avltree {\n  /**\n   * 根节点\n   * @type {avltreenode<number> | null}\n   */\n  root = null;\n\n  /**\n   * 获取以treenode为根节点的树高\n   * @param {avltreenode<number>} treenode\n   */\n  getheight(treenode) {\n    return treenode ? treenode.height : 0;\n  }\n\n  /**\n   * 左单旋\n   * @param {avltreenode<number>} a\n   * @returns {avltreenode<number>}\n   */\n  singleleftrotation(a) {\n    /* 注意：a必须有一个左子结点b */\n    /* 将a与b做左单旋，更新a与b的高度，返回新的根结点b */\n    // 当前树节点的左子树\n    let b = a.left;\n    // 注意： 一定要先把b的右子树挂在a的左边\n    a.left = b.right;\n    b.right = a;\n    a.height = math.max(this.getheight(a.left), this.getheight(a.right)) + 1;\n    b.height = math.max(this.getheight(b.left), this.getheight(a)) + 1;\n    return b;\n  }\n\n  /**\n   * 右单旋\n   * @param {avltreenode<number>} a\n   */\n  singlerightrotation(a) {\n    /* 注意：a必须有一个左子结点b */\n    /* 将a与b做左单旋，更新a与b的高度，返回新的根结点b */\n    let b = a.right;\n    // 注意： 一定要先把b的左子树挂在a的右边\n    a.right = b.left;\n    // a的右子树的左子树\n    b.left = a;\n    a.height = math.max(this.getheight(a.left), this.getheight(a.right)) + 1;\n    b.height = math.max(this.getheight(b.right), this.getheight(a)) + 1;\n    return b;\n  }\n\n  /**\n   * 左右旋转\n   * @param {avltreenode<number>} a\n   * @returns {avltreenode<number>}\n   */\n  doubleleftrightrotation(a) {\n    /* 注意：a必须有一个左子结点b，且b必须有一个右子结点c */\n    /* 将a、b与c做两次单旋，返回新的根结点c */\n    /* 将b与c做右单旋，c被返回 */\n    a.left = this.singlerightrotation(a.left);\n    /* 将a与c做左单旋，c被返回 */\n    return this.singleleftrotation(a);\n  }\n\n  /**\n   * 右左旋转\n   * @param {avltreenode<number>} a\n   * @returns {avltreenode<number>}\n   */\n  doublerightleftrotation(a) {\n    /* 注意：a必须有一个右子结点b，且b必须有一个左子结点c */\n    /* 将a、b与c做两次单旋，返回新的根结点c */\n    /* 将b与c做左单旋，c被返回 */\n    a.right = this.singleleftrotation(a.right);\n    /* 将a与c做右单旋，c被返回 */\n    return this.singlerightrotation(a);\n  }\n\n  /**\n   * 查找指定值是否在二叉搜索树中存在\n   * @param {number} val\n   * @returns {avltreenode<number>}\n   */\n  find(val) {\n    return this._find(val, this.root);\n  }\n\n  /**\n   * 查找辅助函数\n   * @param {number} val\n   * @param {avltreenode<number>} treenode\n   */\n  _find(val, treenode) {\n    let node = treenode;\n    while (node) {\n      if (node.val == val) {\n        break;\n      } else if (node.val > val) {\n        // 沿着左子树查找\n        node = node.left;\n      } else if (node.val < val) {\n        // 沿着右子树查找\n        node = node.right;\n      }\n    }\n    return node;\n  }\n\n  /**\n   * 在avl树中查找最小值\n   * @param {avltreenode<number>} treenode\n   * @returns\n   */\n  findmin(treenode) {\n    let mintreenode = null;\n    while (treenode) {\n      mintreenode = treenode;\n      treenode = treenode.left;\n    }\n    return mintreenode;\n  }\n\n  /**\n   * 插入子节点\n   * @param {number} val\n   */\n  insert(val) {\n    this.root = this._insert(this.root, val);\n  }\n\n  /**\n   * 删除子节点\n   * @param {number} val\n   */\n  delete(val) {\n    this.root = this._delete(this.root, val);\n  }\n\n  /**\n   * 辅助函数：删除子节点\n   * @param {avltreenode<number>} treenode\n   * @param {number} delval\n   * @returns\n   */\n  _delete(treenode, delval) {\n    if (treenode === null) {\n      // 空树，无法删除\n      return null;\n    } else if (delval < treenode.val) {\n      // val 位于左子树，其实就是相当于右子树的插入，所以在调整的时候，执行右旋\n      treenode.left = this._delete(treenode.left, delval);\n      // 更新树高\n      treenode.height =\n        math.max(\n          this.getheight(treenode.left),\n          this.getheight(treenode.right)\n        ) + 1;\n      if (\n        math.abs(\n          this.getheight(treenode.right) - this.getheight(treenode.left)\n        ) === 2\n      ) {\n        if (\n          this.getheight(treenode.right.right) >=\n          this.getheight(treenode.right.left)\n        ) {\n          treenode = this.singlerightrotation(treenode);\n        } else {\n          treenode = this.doubleleftrightrotation(treenode);\n        }\n      }\n    } else if (delval > treenode.val) {\n      // val 位于右子树删除，其实就是相当于是左子树插入\n      treenode.right = this._delete(treenode.right, delval);\n      // 更新树高\n      treenode.height =\n        math.max(\n          this.getheight(treenode.left),\n          this.getheight(treenode.right)\n        ) + 1;\n      if (\n        math.abs(\n          this.getheight(treenode.left) - this.getheight(treenode.right)\n        ) === 2\n      ) {\n        if (\n          this.getheight(treenode.left.left) >=\n          this.getheight(treenode.left.right)\n        ) {\n          treenode = this.singleleftrotation(treenode);\n        } else {\n          treenode = this.doubleleftrightrotation(treenode);\n        }\n      }\n    } else if (treenode.left && treenode.right) {\n      /* 如果待删除节点同时存在左右儿子节点 */\n      // 找到右子树的最小节点\n      let rightsubtreeminnode = this.findmin(treenode.right);\n      // 用右子树上的最小节点替换当前值，然后再从当前右子树触发，递归的删除右子树上的最小值。\n      treenode.val = rightsubtreeminnode.val;\n      treenode.right = this._delete(treenode.right, treenode.val);\n    } else {\n      /* 如果待删除节点只有左儿子节点，那么把它的左儿子直接赋值给它自己，相当于移除了待删除节点 */\n      if (treenode.right === null) {\n        treenode = treenode.left;\n      } else if (treenode.left === null) {\n        /* 如果待删除节点只有右儿子节点，那么把它的右儿子直接赋值给它自己，相当于移除了待删除节点 */\n        treenode = treenode.right;\n      } else {\n        /* 如果待删除节点没有左右儿子节点，直接赋值为空，相当于移除了待删除节点 */\n        treenode = null;\n      }\n    }\n    return treenode;\n  }\n\n  /**\n   * 辅助函数：插入子节点\n   * @param {avltreenode<number>} treenode\n   * @param {number} val\n   * @returns {avltreenode<number>}\n   */\n  _insert(treenode, val) {\n    /* 将x插入avl树treenode中，并且返回调整后的avl树 */\n    if (!treenode) {\n      /* 若插入空树，则新建包含一个结点的树 */\n      treenode = {\n        val: val,\n        height: 0,\n        left: null,\n        right: null,\n      };\n    } else if (val < treenode.val) {\n      /* 插入treenode的左子树 */\n      treenode.left = this._insert(treenode.left, val);\n      /* 如果需要左旋 */\n      if (\n        math.abs(\n          this.getheight(treenode.left) - this.getheight(treenode.right)\n        ) === 2\n      ) {\n        if (val < treenode.left.val) {\n          /* 左单旋 */\n          treenode = this.singleleftrotation(treenode);\n        } else {\n          /* 左-右双旋 */\n          treenode = this.doubleleftrightrotation(treenode);\n        }\n      }\n    } else if (val > treenode.val) {\n      /* 插入treenode的右子树 */\n      treenode.right = this._insert(treenode.right, val);\n      /* 如果需要右旋 */\n      if (\n        math.abs(\n          this.getheight(treenode.left) - this.getheight(treenode.right)\n        ) === 2\n      ) {\n        if (val > treenode.right.val) {\n          /* 右单旋 */\n          treenode = this.singlerightrotation(treenode);\n        } else {\n          /* 右-左双旋 */\n          treenode = this.doublerightleftrotation(treenode);\n        }\n      }\n    }\n    /* 更新树高 */\n    treenode.height =\n      math.max(this.getheight(treenode.left), this.getheight(treenode.right)) +\n      1;\n    return treenode;\n  }\n}\n\n\navl树的插入和删除时间复杂度都是o(log n)，具体的分析过程，有兴趣的同学请参考相应的论文资料。",charsets:{cjk:!0}},{title:"二分查找",frontmatter:{},regularPath:"/data-structure/search/binarySearch.html",relativePath:"data-structure/search/binarySearch.md",key:"v-bbc4fa82",path:"/data-structure/search/binarySearch.html",headers:[{level:2,title:"二分查找",slug:"二分查找",normalizedTitle:"二分查找",charIndex:2},{level:3,title:"概念",slug:"概念",normalizedTitle:"概念",charIndex:11},{level:3,title:"代码实现",slug:"代码实现",normalizedTitle:"代码实现",charIndex:155},{level:3,title:"复杂度分析",slug:"复杂度分析",normalizedTitle:"复杂度分析",charIndex:1127}],headersStr:"二分查找 概念 代码实现 复杂度分析",content:"# 二分查找\n\n\n# 概念\n\n二分查找：对于有序的线性表，首先找到位于这个线性表中央的元素(即mid)，将查找区域分为左半区([0,mid-1])和右半区[mid+1, length-1]，如果mid元素比待查找元素大，则在左半区查找，否则在右边区查找，重复这个过程，直到待查找区域为空时，结束查找。\n\n\n# 代码实现\n\n/**\n * 二分查找法\n * @param {Array<Number>} arr 需要查找的序列\n * @param {Number} target 需要查找的数据\n * @returns {Number} 查找成功返回数据所在的下标索引，查找失败，返回-1\n */\nfunction binarySearch(arr, target) {\n    if (!Array.isArray(arr) || arr.length == 0) {\n        console.log('empty array')\n        return -1;\n    }\n    // 初始化开始指针\n    let low = 0;\n    // 初始化结束指针\n    let high = arr.length - 1\n    // 初始化中间位置标记\n    let mid = Math.floor((low + high) / 2)\n    // 定义初始的位置\n    let pos = -1;\n    while (low <= high) {\n        // 如果找到了，则不再进行查找，跳出循环\n        if (arr[mid] === target) {\n            pos = mid;\n            break\n        }\n        // 如果当前值在中间值的左侧，说明从中间值往左的元素，都是不大于target的 缩小查找范围，因此从mid的前一位查找\n        if (arr[mid] > target) {\n            high = mid - 1\n        }\n        // 如果当前值在中间值的右侧，说明中间值往右的元素，都是不小于target的 缩小查找范围，因此从mid的后一位查找\n        else if (arr[mid] < target) {\n            low = mid + 1\n        }\n        // 重新划分中间值\n        mid = Math.floor((low + high) / 2)\n    }\n    return pos\n}\n\n\n\n# 复杂度分析\n\n二分查找是高效的查找算法，其时间复杂度为O(logN)。",normalizedContent:"# 二分查找\n\n\n# 概念\n\n二分查找：对于有序的线性表，首先找到位于这个线性表中央的元素(即mid)，将查找区域分为左半区([0,mid-1])和右半区[mid+1, length-1]，如果mid元素比待查找元素大，则在左半区查找，否则在右边区查找，重复这个过程，直到待查找区域为空时，结束查找。\n\n\n# 代码实现\n\n/**\n * 二分查找法\n * @param {array<number>} arr 需要查找的序列\n * @param {number} target 需要查找的数据\n * @returns {number} 查找成功返回数据所在的下标索引，查找失败，返回-1\n */\nfunction binarysearch(arr, target) {\n    if (!array.isarray(arr) || arr.length == 0) {\n        console.log('empty array')\n        return -1;\n    }\n    // 初始化开始指针\n    let low = 0;\n    // 初始化结束指针\n    let high = arr.length - 1\n    // 初始化中间位置标记\n    let mid = math.floor((low + high) / 2)\n    // 定义初始的位置\n    let pos = -1;\n    while (low <= high) {\n        // 如果找到了，则不再进行查找，跳出循环\n        if (arr[mid] === target) {\n            pos = mid;\n            break\n        }\n        // 如果当前值在中间值的左侧，说明从中间值往左的元素，都是不大于target的 缩小查找范围，因此从mid的前一位查找\n        if (arr[mid] > target) {\n            high = mid - 1\n        }\n        // 如果当前值在中间值的右侧，说明中间值往右的元素，都是不小于target的 缩小查找范围，因此从mid的后一位查找\n        else if (arr[mid] < target) {\n            low = mid + 1\n        }\n        // 重新划分中间值\n        mid = math.floor((low + high) / 2)\n    }\n    return pos\n}\n\n\n\n# 复杂度分析\n\n二分查找是高效的查找算法，其时间复杂度为o(logn)。",charsets:{cjk:!0}},{title:"跳表(跳跃链表)",frontmatter:{},regularPath:"/data-structure/search/skipList.html",relativePath:"data-structure/search/skipList.md",key:"v-79b9b1d7",path:"/data-structure/search/skipList.html",headers:[{level:2,title:"跳表(跳跃链表)",slug:"跳表-跳跃链表",normalizedTitle:"跳表(跳跃链表)",charIndex:2},{level:3,title:"查找辅助函数",slug:"查找辅助函数",normalizedTitle:"查找辅助函数",charIndex:877},{level:3,title:"查找",slug:"查找",normalizedTitle:"查找",charIndex:76},{level:3,title:"插入",slug:"插入",normalizedTitle:"插入",charIndex:27},{level:3,title:"删除",slug:"删除",normalizedTitle:"删除",charIndex:30},{level:3,title:"结语",slug:"结语",normalizedTitle:"结语",charIndex:4541}],headersStr:"跳表(跳跃链表) 查找辅助函数 查找 插入 删除 结语",content:'# 跳表(跳跃链表)\n\n在前文，我们有介绍链表，链表的插入和删除是较为高效的，因为只需要修改前驱和后继指针，但是链表无法做到像数组那样的随机化访问，每次查找的平均算法复杂度为O(N)，这是链表的一个比较大的缺点。\n\n跳跃链表，简称跳表，在原有的有序链表上面增加了多级索引，通过索引来实现快速查找，是一个随机化的数据结构，实质就是一种可以进行二分查找的有序链表，是在 O(log*n)时间内完成增加、删除、搜索操作的数据结构。\n\n跳表相比于堆与AVL树(或红黑树)，其功能与性能相当，但跳表的代码长度相较下更短，其设计思想与链表相似。\n\n跳表不仅能提高搜索性能，同时也可以提高插入和删除操作的性能。\n\n最底层是原始的链表，接着根据生成的随机数决定是否继续向上生成当前节点的后继节点，直到把它的最大层都填满(以 4 层举例)，大致如下图：\n\n\n\n第一个节点是哨兵节点，跳表的节点就像鳞次栉比的山峰，不同的山峰之间的相同层上就是建立的引用关系，用来加快查找的速度。\n\n需要注意的是，比如对于图中的节点3，并不是说它的next指针数组的长度为 1，而依然是 4 层，只不过，除了最底层的内容以外，其余都存的是null，我们在查找时，某层就会忽略这个节点，这样就实现了跳跃。\n\n因此，可以采用如下方式来表示跳表中的节点：\n\nclass ListNode {\n  /**\n   * @type {number}\n   */\n  val = -1;\n  /**\n   * @type {ListNode[]}\n   */\n  next = [];\n  /**\n   * @param {number} val\n   * @param {number} level\n   */\n  constructor(val, level) {\n    this.val = val;\n    // 初始化指定高度的数组\n    this.next = Array.from({\n      length: level,\n    }).fill(null);\n  }\n}\n\n\n\n# 查找辅助函数\n\n因为跳表是基于二分查找的，在查找的过程中，我们总是从最上层查找到最下层的，我们需要把每次的位置记下来，这样不管是查找， 插入，删除都可以很方便的使用这个路径。\n\n这节我们先不详细阐述辅助函数，同学们可以看完插入节之后再回头来看这节的内容。\n\n/**\n * 查找辅助函数，记录从上至下查找路径\n * @param {number} target\n */\nfunction find(target) {\n  let path = Array.from({\n    length: this.level,\n  }).fill(null);\n  // 从头节点开始遍历每一层，p最开始就是头结点\n  let p = this.head;\n  for (let i = this.level - 1; i >= 0; i--) {\n    // 从上层往下层找\n    while (p.next[i] && p.next[i].val < target) {\n      // 如果当前层 i 的 next 不为空，且它的值小于 target，则 p 往后走指向这一层 p 的 next，下层的p就从这一层的p开始\n      p = p.next[i];\n    }\n    // 退出 while 时说明找到了第 i 层小于 target 的最大节点就是 p\n    path[i] = p;\n  }\n  return path;\n}\n\n\n\n# 查找\n\n上面的查找辅助函数我们并没有给出运行过程，因为需要结合着一个操作来解释它才更好描述。\n\n比如，现在跳表的存储如上图所示，查找一个存在的情况，假设要查找22。\n\n首先，从head的最顶层开始查找，向后找到节点7，接着找，发现已经到末尾，因此，路径的第一层节点可以确定为节点7。\n\n接着，从head的第二层开始查找，这次，我们要直接从节点7开始向后找，发现下一节点为37，但是37大于22，因此，路径的第 2 层的节点可以确定为节点7。\n\n然后，从head的第三层开始查找，这次，我们要直接从节点7开始向后找，发现下一节点为19，接着往后找，发现下一节点是37，但是37大于22，因此，路径的第 3 层的节点可以确定为节点19。\n\n最后，从head的最后一层开始查找，这次，我们要直接从19开始向后找，发现下一节点为22，但是22等于22，因此，路径的第 4 层的节点可以确定为节点19。\n\n有同学可能会问，为什么19后面就一定是22呢？，因为这个跳表里面的节点太少，不太好理解，假设有很多节点，比如19后面有20，21，循环是要遇到大于等于22的才会停止的。\n\n比如，现在跳表的存储如表示方法节所描述所示，查找一个不存在的情况，假设要查找23。\n\n首先，从head的最顶层开始查找，向后找到7，接着找，发现已经到末尾，因此，路径的第一层节点可以确定为节点7。\n\n接着，从head的第二层开始查找，这次，我们要直接从7开始向后找，发现下一节点为37，但是37大于22，因此，路径的第 2 层的节点可以确定为节点7。\n\n然后，从head的第三层开始查找，这次，我们要直接从7开始向后找，发现下一节点为19，接着往后找，发现下一节点是37，但是37大于22，因此，路径的第 3 层的节点可以确定为节点19。\n\n最后，从head的最后一层开始查找，这次，我们要直接从19开始向后找，发现下一节点为22，但是22小于23，接着向后查找，发现下一节点是37，37大于23，因此，路径的第 4 层的节点可以确定为节点22。\n\n因为节点22的下一节点是33，因此可以得知，23在表中不存在。\n\n上述的查找过程，大致如下图所示：\n\n\n\n/**\n * 查找元素\n * @param {number} target\n * @returns\n */\nfunction search(target) {\n  // 先找到每一层 i 小于目标值 target 的最大节点 path[i]\n  let path = this.find(target);\n  // 因为最下层【0】的节点是全的，所以只需要判断 target 是否在第 0 层即可，而 path[0] 正好就是小于 target 的最大节点，如果 path[0]->next[0] 的值不是 target 说明没有这个元素\n  let p = path[0].next[0];\n  return p != null && p.val == target;\n}\n\n\n在明白查找过程之后，大家再回过头来看我们的find函数就一目了然了。如果你掌握了跳表的查找，那么恭喜你，整个跳表的知识点你已经掌握了 80%了。\n\n\n# 插入\n\n对于插入操作，我们需要根据随机数据来决定当前节点的高度。下文以0.5为分界线，若超过的话，我们就不断的建立后继指针，否则就在某层提前结束。这是一个跟单链表类似的操作。\n\n首先，find辅助函数已经找到了每层的节点，那么对于每层的节点，即path[i]，我们可以直接将新创建的节点加入到链表中。\n\n即：\n\n// 创建一个新的节点\nlet node = new ListNode(num, this.level);\n// 将对应层的next指针指向path的next指针的对应层\nnode.next[i] = path[i].next[i];\n// 将path的next指针指向node\npath[i].next[i] = node;\n/**\n * node.next = path.next\n * path.next = node\n */\n\n\n如果看着比较迷糊的同学，你可以先不考虑i这个变量对插入操作的影响，先将其抽象为普通的链表插入来理解，如代码中的注释所示，抽象流程如下：\n\n\n\n随机数即控制了我们要建立多少层的关联，因此整个插入流程如下图所示：\n\n\n\n/**\n * 插入元素\n * @param {number} num\n */\nfunction add(num) {\n  // 先找到每一层 i 小于目标值 target 的最大节点 path[i]\n  let path = this.find(num);\n  // 创建要插入的新节点\n  let node = new ListNode(num, this.level);\n  for (let i = 0; i < this.level; i++) {\n    // 遍历每一层，从下往上插入新节点\n    // 这两步就是单链表的插入\n    node.next[i] = path[i].next[i];\n    path[i].next[i] = node;\n    // 每一层有 50% 的概率不插入新节点\n    if (Math.random() > 0.5) {\n      break;\n    }\n  }\n}\n\n\n\n# 删除\n\n删除操作也相对比较简单，首先，我们需要确定待删除的值在跳表中是否存在，为什么我们不直接调用查找函数而是要调用辅助函数呢，这是因为我们需要知道待删除节点的前驱节点。\n\n比如，现在要删除节点22，经过前置查找，我们能确定下来节点22的前置指针，接着，就可以直接对每层的指针进行删除。\n\n需要注意的是，待删除节点可能不是每层都有的，我们在删除的时候，必须从底层删至上层，发现当前层为空的话，就可提前结束循环了。\n\n/**\n * 删除元素\n * @param {number} num\n * @returns\n */\nfunction remove(num) {\n  // 先找到每一层 i 小于目标值 target 的最大节点 path[i]\n  let path = this.find(num);\n  // 先判断 num 是否存在，不存在直接返回 false\n  // 第 0 层存储的是全部节点，所以只需要判断 path[0]->next[0]（第 0 层小于 num 的最大节点的在第 0 层的 next） 是不是 num 即可\n  let p = path[0].next[0];\n  if (!p || p.val != num) {\n    console.warn("要删除的值不存在!");\n    return false;\n  }\n  // 否则删除每一层的 num，如果 path[i]->next[i] == p 说明第 i 层存在 p\n  for (let i = 0; i < this.level && path[i].next[i] === p; i++) {\n    // 单链表删除\n    path[i].next[i] = p.next[i];\n  }\n  p = null; // 删除节点 p，防止内存泄漏\n  return true;\n}\n\n\n\n# 结语\n\n跳表也是典型的空间换时间的应用场景，在大名鼎鼎的Redis中，就使用了跳表。\n\n# 时间复杂度\n\n跳表的查询、删除、插入的时间复杂度近似O(log*n)，其证明过程非常复杂，具体的分析过程超出了本文的讨论范畴，有兴趣的同学可以参考原始论文。\n\n# 空间复杂度\n\nO(level*n)，和层数以及节点数相关，每个节点最大的开销就是存储在每一层的next。\n\n跳表的完整实现如下：\n\nclass ListNode {\n  /**\n   * @type {number}\n   */\n  val = -1;\n  /**\n   * @type {ListNode[]}\n   */\n  next = [];\n  /**\n   * @param {number} val\n   * @param {number} level\n   */\n  constructor(val, level) {\n    this.val = val;\n    // 初始化指定高度的数组\n    this.next = Array.from({\n      length: level,\n    }).fill(null);\n  }\n}\n\nclass SkipList {\n  /**\n   * 最大层数\n   * @type {number}\n   */\n  level = 8;\n  /**\n   * 头结点\n   * @type {ListNode | null}\n   */\n  head = null;\n\n  constructor() {\n    this.head = new ListNode(-1, this.level);\n  }\n  /**\n   * 查找辅助函数，记录从上至下查找路径\n   * @param {number} target\n   */\n  find(target) {\n    let path = Array.from({\n      length: this.level,\n    }).fill(null);\n    // 从头节点开始遍历每一层\n    let p = this.head;\n    for (let i = this.level - 1; i >= 0; i--) {\n      // 从上层往下层找\n      while (p.next[i] && p.next[i].val < target) {\n        // 如果当前层 i 的 next 不为空，且它的值小于 target，则 p 往后走指向这一层 p 的 next\n        p = p.next[i];\n      }\n      // 退出 while 时说明找到了第 i 层小于 target 的最大节点就是 p\n      path[i] = p;\n    }\n    return path;\n  }\n  /**\n   * 查找元素\n   * @param {number} target\n   * @returns\n   */\n  search(target) {\n    // 先找到每一层 i 小于目标值 target 的最大节点 path[i]\n    let path = this.find(target);\n    // 因为最下层【0】的节点是全的，所以只需要判断 target 是否在第 0 层即可，而 path[0] 正好就是小于 target 的最大节点，如果 path[0]->next[0] 的值不是 target 说明没有这个元素\n    let p = path[0].next[0];\n    return p != null && p.val == target;\n  }\n\n  /**\n   * 插入元素\n   * @param {number} num\n   */\n  add(num) {\n    // 先找到每一层 i 小于目标值 target 的最大节点 path[i]\n    let path = this.find(num);\n    // 创建要插入的新节点\n    let node = new ListNode(num, this.level);\n    for (let i = 0; i < this.level; i++) {\n      // 遍历每一层，从下往上插入新节点\n      // 这两步就是单链表的插入\n      node.next[i] = path[i].next[i];\n      path[i].next[i] = node;\n      // 每一层有 50% 的概率不插入新节点\n      if (Math.random() > 0.5) {\n        break;\n      }\n    }\n  }\n  /**\n   * 删除元素\n   * @param {number} num\n   * @returns\n   */\n  remove(num) {\n    // 先找到每一层 i 小于目标值 target 的最大节点 path[i]\n    let path = this.find(num);\n    // 先判断 num 是否存在，不存在直接返回 false\n    // 第 0 层存储的是全部节点，所以只需要判断 path[0]->next[0]（第 0 层小于 num 的最大节点的在第 0 层的 next） 是不是 num 即可\n    let p = path[0].next[0];\n    if (!p || p.val != num) {\n      console.warn("要删除的值不存在!");\n      return false;\n    }\n    // 否则删除每一层的 num，如果 path[i]->next[i] == p 说明第 i 层存在 p\n    for (let i = 0; i < this.level && path[i].next[i] == p; i++) {\n      // 单链表删除\n      path[i].next[i] = p.next[i];\n    }\n    // 删除节点 p，防止内存泄漏\n    p = null;\n    return true;\n  }\n}\n',normalizedContent:'# 跳表(跳跃链表)\n\n在前文，我们有介绍链表，链表的插入和删除是较为高效的，因为只需要修改前驱和后继指针，但是链表无法做到像数组那样的随机化访问，每次查找的平均算法复杂度为o(n)，这是链表的一个比较大的缺点。\n\n跳跃链表，简称跳表，在原有的有序链表上面增加了多级索引，通过索引来实现快速查找，是一个随机化的数据结构，实质就是一种可以进行二分查找的有序链表，是在 o(log*n)时间内完成增加、删除、搜索操作的数据结构。\n\n跳表相比于堆与avl树(或红黑树)，其功能与性能相当，但跳表的代码长度相较下更短，其设计思想与链表相似。\n\n跳表不仅能提高搜索性能，同时也可以提高插入和删除操作的性能。\n\n最底层是原始的链表，接着根据生成的随机数决定是否继续向上生成当前节点的后继节点，直到把它的最大层都填满(以 4 层举例)，大致如下图：\n\n\n\n第一个节点是哨兵节点，跳表的节点就像鳞次栉比的山峰，不同的山峰之间的相同层上就是建立的引用关系，用来加快查找的速度。\n\n需要注意的是，比如对于图中的节点3，并不是说它的next指针数组的长度为 1，而依然是 4 层，只不过，除了最底层的内容以外，其余都存的是null，我们在查找时，某层就会忽略这个节点，这样就实现了跳跃。\n\n因此，可以采用如下方式来表示跳表中的节点：\n\nclass listnode {\n  /**\n   * @type {number}\n   */\n  val = -1;\n  /**\n   * @type {listnode[]}\n   */\n  next = [];\n  /**\n   * @param {number} val\n   * @param {number} level\n   */\n  constructor(val, level) {\n    this.val = val;\n    // 初始化指定高度的数组\n    this.next = array.from({\n      length: level,\n    }).fill(null);\n  }\n}\n\n\n\n# 查找辅助函数\n\n因为跳表是基于二分查找的，在查找的过程中，我们总是从最上层查找到最下层的，我们需要把每次的位置记下来，这样不管是查找， 插入，删除都可以很方便的使用这个路径。\n\n这节我们先不详细阐述辅助函数，同学们可以看完插入节之后再回头来看这节的内容。\n\n/**\n * 查找辅助函数，记录从上至下查找路径\n * @param {number} target\n */\nfunction find(target) {\n  let path = array.from({\n    length: this.level,\n  }).fill(null);\n  // 从头节点开始遍历每一层，p最开始就是头结点\n  let p = this.head;\n  for (let i = this.level - 1; i >= 0; i--) {\n    // 从上层往下层找\n    while (p.next[i] && p.next[i].val < target) {\n      // 如果当前层 i 的 next 不为空，且它的值小于 target，则 p 往后走指向这一层 p 的 next，下层的p就从这一层的p开始\n      p = p.next[i];\n    }\n    // 退出 while 时说明找到了第 i 层小于 target 的最大节点就是 p\n    path[i] = p;\n  }\n  return path;\n}\n\n\n\n# 查找\n\n上面的查找辅助函数我们并没有给出运行过程，因为需要结合着一个操作来解释它才更好描述。\n\n比如，现在跳表的存储如上图所示，查找一个存在的情况，假设要查找22。\n\n首先，从head的最顶层开始查找，向后找到节点7，接着找，发现已经到末尾，因此，路径的第一层节点可以确定为节点7。\n\n接着，从head的第二层开始查找，这次，我们要直接从节点7开始向后找，发现下一节点为37，但是37大于22，因此，路径的第 2 层的节点可以确定为节点7。\n\n然后，从head的第三层开始查找，这次，我们要直接从节点7开始向后找，发现下一节点为19，接着往后找，发现下一节点是37，但是37大于22，因此，路径的第 3 层的节点可以确定为节点19。\n\n最后，从head的最后一层开始查找，这次，我们要直接从19开始向后找，发现下一节点为22，但是22等于22，因此，路径的第 4 层的节点可以确定为节点19。\n\n有同学可能会问，为什么19后面就一定是22呢？，因为这个跳表里面的节点太少，不太好理解，假设有很多节点，比如19后面有20，21，循环是要遇到大于等于22的才会停止的。\n\n比如，现在跳表的存储如表示方法节所描述所示，查找一个不存在的情况，假设要查找23。\n\n首先，从head的最顶层开始查找，向后找到7，接着找，发现已经到末尾，因此，路径的第一层节点可以确定为节点7。\n\n接着，从head的第二层开始查找，这次，我们要直接从7开始向后找，发现下一节点为37，但是37大于22，因此，路径的第 2 层的节点可以确定为节点7。\n\n然后，从head的第三层开始查找，这次，我们要直接从7开始向后找，发现下一节点为19，接着往后找，发现下一节点是37，但是37大于22，因此，路径的第 3 层的节点可以确定为节点19。\n\n最后，从head的最后一层开始查找，这次，我们要直接从19开始向后找，发现下一节点为22，但是22小于23，接着向后查找，发现下一节点是37，37大于23，因此，路径的第 4 层的节点可以确定为节点22。\n\n因为节点22的下一节点是33，因此可以得知，23在表中不存在。\n\n上述的查找过程，大致如下图所示：\n\n\n\n/**\n * 查找元素\n * @param {number} target\n * @returns\n */\nfunction search(target) {\n  // 先找到每一层 i 小于目标值 target 的最大节点 path[i]\n  let path = this.find(target);\n  // 因为最下层【0】的节点是全的，所以只需要判断 target 是否在第 0 层即可，而 path[0] 正好就是小于 target 的最大节点，如果 path[0]->next[0] 的值不是 target 说明没有这个元素\n  let p = path[0].next[0];\n  return p != null && p.val == target;\n}\n\n\n在明白查找过程之后，大家再回过头来看我们的find函数就一目了然了。如果你掌握了跳表的查找，那么恭喜你，整个跳表的知识点你已经掌握了 80%了。\n\n\n# 插入\n\n对于插入操作，我们需要根据随机数据来决定当前节点的高度。下文以0.5为分界线，若超过的话，我们就不断的建立后继指针，否则就在某层提前结束。这是一个跟单链表类似的操作。\n\n首先，find辅助函数已经找到了每层的节点，那么对于每层的节点，即path[i]，我们可以直接将新创建的节点加入到链表中。\n\n即：\n\n// 创建一个新的节点\nlet node = new listnode(num, this.level);\n// 将对应层的next指针指向path的next指针的对应层\nnode.next[i] = path[i].next[i];\n// 将path的next指针指向node\npath[i].next[i] = node;\n/**\n * node.next = path.next\n * path.next = node\n */\n\n\n如果看着比较迷糊的同学，你可以先不考虑i这个变量对插入操作的影响，先将其抽象为普通的链表插入来理解，如代码中的注释所示，抽象流程如下：\n\n\n\n随机数即控制了我们要建立多少层的关联，因此整个插入流程如下图所示：\n\n\n\n/**\n * 插入元素\n * @param {number} num\n */\nfunction add(num) {\n  // 先找到每一层 i 小于目标值 target 的最大节点 path[i]\n  let path = this.find(num);\n  // 创建要插入的新节点\n  let node = new listnode(num, this.level);\n  for (let i = 0; i < this.level; i++) {\n    // 遍历每一层，从下往上插入新节点\n    // 这两步就是单链表的插入\n    node.next[i] = path[i].next[i];\n    path[i].next[i] = node;\n    // 每一层有 50% 的概率不插入新节点\n    if (math.random() > 0.5) {\n      break;\n    }\n  }\n}\n\n\n\n# 删除\n\n删除操作也相对比较简单，首先，我们需要确定待删除的值在跳表中是否存在，为什么我们不直接调用查找函数而是要调用辅助函数呢，这是因为我们需要知道待删除节点的前驱节点。\n\n比如，现在要删除节点22，经过前置查找，我们能确定下来节点22的前置指针，接着，就可以直接对每层的指针进行删除。\n\n需要注意的是，待删除节点可能不是每层都有的，我们在删除的时候，必须从底层删至上层，发现当前层为空的话，就可提前结束循环了。\n\n/**\n * 删除元素\n * @param {number} num\n * @returns\n */\nfunction remove(num) {\n  // 先找到每一层 i 小于目标值 target 的最大节点 path[i]\n  let path = this.find(num);\n  // 先判断 num 是否存在，不存在直接返回 false\n  // 第 0 层存储的是全部节点，所以只需要判断 path[0]->next[0]（第 0 层小于 num 的最大节点的在第 0 层的 next） 是不是 num 即可\n  let p = path[0].next[0];\n  if (!p || p.val != num) {\n    console.warn("要删除的值不存在!");\n    return false;\n  }\n  // 否则删除每一层的 num，如果 path[i]->next[i] == p 说明第 i 层存在 p\n  for (let i = 0; i < this.level && path[i].next[i] === p; i++) {\n    // 单链表删除\n    path[i].next[i] = p.next[i];\n  }\n  p = null; // 删除节点 p，防止内存泄漏\n  return true;\n}\n\n\n\n# 结语\n\n跳表也是典型的空间换时间的应用场景，在大名鼎鼎的redis中，就使用了跳表。\n\n# 时间复杂度\n\n跳表的查询、删除、插入的时间复杂度近似o(log*n)，其证明过程非常复杂，具体的分析过程超出了本文的讨论范畴，有兴趣的同学可以参考原始论文。\n\n# 空间复杂度\n\no(level*n)，和层数以及节点数相关，每个节点最大的开销就是存储在每一层的next。\n\n跳表的完整实现如下：\n\nclass listnode {\n  /**\n   * @type {number}\n   */\n  val = -1;\n  /**\n   * @type {listnode[]}\n   */\n  next = [];\n  /**\n   * @param {number} val\n   * @param {number} level\n   */\n  constructor(val, level) {\n    this.val = val;\n    // 初始化指定高度的数组\n    this.next = array.from({\n      length: level,\n    }).fill(null);\n  }\n}\n\nclass skiplist {\n  /**\n   * 最大层数\n   * @type {number}\n   */\n  level = 8;\n  /**\n   * 头结点\n   * @type {listnode | null}\n   */\n  head = null;\n\n  constructor() {\n    this.head = new listnode(-1, this.level);\n  }\n  /**\n   * 查找辅助函数，记录从上至下查找路径\n   * @param {number} target\n   */\n  find(target) {\n    let path = array.from({\n      length: this.level,\n    }).fill(null);\n    // 从头节点开始遍历每一层\n    let p = this.head;\n    for (let i = this.level - 1; i >= 0; i--) {\n      // 从上层往下层找\n      while (p.next[i] && p.next[i].val < target) {\n        // 如果当前层 i 的 next 不为空，且它的值小于 target，则 p 往后走指向这一层 p 的 next\n        p = p.next[i];\n      }\n      // 退出 while 时说明找到了第 i 层小于 target 的最大节点就是 p\n      path[i] = p;\n    }\n    return path;\n  }\n  /**\n   * 查找元素\n   * @param {number} target\n   * @returns\n   */\n  search(target) {\n    // 先找到每一层 i 小于目标值 target 的最大节点 path[i]\n    let path = this.find(target);\n    // 因为最下层【0】的节点是全的，所以只需要判断 target 是否在第 0 层即可，而 path[0] 正好就是小于 target 的最大节点，如果 path[0]->next[0] 的值不是 target 说明没有这个元素\n    let p = path[0].next[0];\n    return p != null && p.val == target;\n  }\n\n  /**\n   * 插入元素\n   * @param {number} num\n   */\n  add(num) {\n    // 先找到每一层 i 小于目标值 target 的最大节点 path[i]\n    let path = this.find(num);\n    // 创建要插入的新节点\n    let node = new listnode(num, this.level);\n    for (let i = 0; i < this.level; i++) {\n      // 遍历每一层，从下往上插入新节点\n      // 这两步就是单链表的插入\n      node.next[i] = path[i].next[i];\n      path[i].next[i] = node;\n      // 每一层有 50% 的概率不插入新节点\n      if (math.random() > 0.5) {\n        break;\n      }\n    }\n  }\n  /**\n   * 删除元素\n   * @param {number} num\n   * @returns\n   */\n  remove(num) {\n    // 先找到每一层 i 小于目标值 target 的最大节点 path[i]\n    let path = this.find(num);\n    // 先判断 num 是否存在，不存在直接返回 false\n    // 第 0 层存储的是全部节点，所以只需要判断 path[0]->next[0]（第 0 层小于 num 的最大节点的在第 0 层的 next） 是不是 num 即可\n    let p = path[0].next[0];\n    if (!p || p.val != num) {\n      console.warn("要删除的值不存在!");\n      return false;\n    }\n    // 否则删除每一层的 num，如果 path[i]->next[i] == p 说明第 i 层存在 p\n    for (let i = 0; i < this.level && path[i].next[i] == p; i++) {\n      // 单链表删除\n      path[i].next[i] = p.next[i];\n    }\n    // 删除节点 p，防止内存泄漏\n    p = null;\n    return true;\n  }\n}\n',charsets:{cjk:!0}},{title:"冒泡排序",frontmatter:{},regularPath:"/data-structure/sort/bubbleSort.html",relativePath:"data-structure/sort/bubbleSort.md",key:"v-45875829",path:"/data-structure/sort/bubbleSort.html",headers:[{level:2,title:"冒泡排序",slug:"冒泡排序",normalizedTitle:"冒泡排序",charIndex:2},{level:3,title:"排序过程",slug:"排序过程",normalizedTitle:"排序过程",charIndex:92},{level:3,title:"算法实现",slug:"算法实现",normalizedTitle:"算法实现",charIndex:101},{level:3,title:"复杂度与稳定性",slug:"复杂度与稳定性",normalizedTitle:"复杂度与稳定性",charIndex:769}],headersStr:"冒泡排序 排序过程 算法实现 复杂度与稳定性",content:"# 冒泡排序\n\n冒泡排序每轮循环把最重（取决于你对重的定义）的元素下沉到有序片段的前一位，无序数据片段规模递减 1，有序数据片段规模递增 1，直到所有的元素都有序则完成排序。\n\n\n# 排序过程\n\n\n# 算法实现\n\n/**\n * 对数组进行冒泡排序\n * @param {Array<number>} arr 需要进行排序的数组\n */\nfunction bubbleSort(arr) {\n  let temp = null;\n  // 外层循环变量i 用于控制参与排序数据的规模\n  for (let i = arr.length - 1; i >= 0; i--) {\n    // 定义标记，用于判断本轮是否参与交换\n    let flag = true;\n    // 内层循环用于把最“重”的元素下沉至非有序片段的最后一位\n    for (let j = 0; j < i; j++) {\n      // 注意冒泡排序是两两相邻的比较\n      if (arr[j] > arr[j + 1]) {\n        temp = arr[j];\n        arr[j] = arr[j + 1];\n        arr[j + 1] = temp;\n        // 如果交换了元素，还需要设置标记，若数组已经有序，可以提前终止排序，提升性能\n        flag = false;\n      }\n    }\n    // 如果说没有参与交换，则认为数组已经有序，则可以完成排序\n    if (flag) {\n      break;\n    }\n  }\n}\n\n\n需要注意的是冒泡排序在排序过程中，下沉元素时，是和相邻的元素进行比较，请注意区分选择排序，如果数据已经有序，需要提前终止排序。\n\n\n# 复杂度与稳定性\n\n冒泡排序的时间复杂度是O(n²)，是稳定的排序算法。",normalizedContent:"# 冒泡排序\n\n冒泡排序每轮循环把最重（取决于你对重的定义）的元素下沉到有序片段的前一位，无序数据片段规模递减 1，有序数据片段规模递增 1，直到所有的元素都有序则完成排序。\n\n\n# 排序过程\n\n\n# 算法实现\n\n/**\n * 对数组进行冒泡排序\n * @param {array<number>} arr 需要进行排序的数组\n */\nfunction bubblesort(arr) {\n  let temp = null;\n  // 外层循环变量i 用于控制参与排序数据的规模\n  for (let i = arr.length - 1; i >= 0; i--) {\n    // 定义标记，用于判断本轮是否参与交换\n    let flag = true;\n    // 内层循环用于把最“重”的元素下沉至非有序片段的最后一位\n    for (let j = 0; j < i; j++) {\n      // 注意冒泡排序是两两相邻的比较\n      if (arr[j] > arr[j + 1]) {\n        temp = arr[j];\n        arr[j] = arr[j + 1];\n        arr[j + 1] = temp;\n        // 如果交换了元素，还需要设置标记，若数组已经有序，可以提前终止排序，提升性能\n        flag = false;\n      }\n    }\n    // 如果说没有参与交换，则认为数组已经有序，则可以完成排序\n    if (flag) {\n      break;\n    }\n  }\n}\n\n\n需要注意的是冒泡排序在排序过程中，下沉元素时，是和相邻的元素进行比较，请注意区分选择排序，如果数据已经有序，需要提前终止排序。\n\n\n# 复杂度与稳定性\n\n冒泡排序的时间复杂度是o(n²)，是稳定的排序算法。",charsets:{cjk:!0}},{title:"桶排序",frontmatter:{},regularPath:"/data-structure/sort/bucketSort.html",relativePath:"data-structure/sort/bucketSort.md",key:"v-390e2f26",path:"/data-structure/sort/bucketSort.html",headers:[{level:2,title:"桶排序",slug:"桶排序",normalizedTitle:"桶排序",charIndex:2},{level:3,title:"排序过程",slug:"排序过程",normalizedTitle:"排序过程",charIndex:163},{level:3,title:"算法实现",slug:"算法实现",normalizedTitle:"算法实现",charIndex:583},{level:3,title:"复杂度与稳定性",slug:"复杂度与稳定性",normalizedTitle:"复杂度与稳定性",charIndex:1084}],headersStr:"桶排序 排序过程 算法实现 复杂度与稳定性",content:"# 桶排序\n\n桶排序的思路与之前提到过的排序算法的思路都不同，之前提到的排序算法都是基于数值的大小比较进行排序的，而桶排序是基于基准进行排序，因此每个基准就可以看做一个桶。\n\n桶排序的基准的计算，其作用就相当于快排中划分，已经把大量数据分割成了基本有序的数据块(桶)。然后只需要对桶中的少量数据做先进的比较排序即可。\n\n\n# 排序过程\n\n举个大家都经历过的例子，某些大学会限制大一参加英语四级考试的名额，假设现在需要对大一新生的英语成绩进行排序，选取英语成绩位于前50%的学生允许参加大一上学期的英语四级考试。\n\n一般来说一个大学的新生一般都是一万人左右，如果直接用基于比较的排序算法也不会特别的耗时间，但是通过观察可以知道的是，这些学生的成绩有个显著的特点，它们都是在[0-150]之间，也就是说，我们可以申明151个数组，每个数组（即桶）保存对应分数学生的英语成绩。最后，我们再将排序之后的数据导回至原来的数据中则完成排序。可以看到的是，由于我们的桶是远远小于数组的量级的，在排序的时候我们会使用一轮循环遍历数据，最后将排序之后的数据导回去需要一轮循环。其时间复杂度是线性的，约为O(N)（需要注意的是此处把成绩插入到对应的桶中是不需要再进行排序的，所以时间复杂度可以表示为O(N)），可以看到这个例子的算法时间复杂度是已经超过了基于比较的排序算法的。\n\n\n# 算法实现\n\n/**\n * 桶排序\n * @param {number[]} arr\n */\nfunction bucketSort(arr) {\n  /* 申明桶 */\n  const buckets = Array.from({\n    length: 151,\n  }).map(() => {\n    return [];\n  });\n  /* 按分值划分桶 */\n  for (let i = 0; i < arr.length; i++) {\n    const score = arr[i];\n    buckets[score].push(score);\n  }\n  /* 将桶中的数据导回至原数组 */\n  let offset = 0;\n  while (buckets.length) {\n    const bucket = buckets.shift();\n    while (bucket.length) {\n      const score = bucket.shift();\n      arr[offset++] = score;\n    }\n  }\n}\n\n\n\n# 复杂度与稳定性\n\n假设数据有N项，排序过程中分配M个桶，桶排序的平均时间复杂度为线性的 O(N+C)，其中 C=N*(logN-logM)。如果相对于同样的N，桶数量M越大，其效率越高，最好的时间复杂度达到O(N)。空间复杂度为O(N+M)。",normalizedContent:"# 桶排序\n\n桶排序的思路与之前提到过的排序算法的思路都不同，之前提到的排序算法都是基于数值的大小比较进行排序的，而桶排序是基于基准进行排序，因此每个基准就可以看做一个桶。\n\n桶排序的基准的计算，其作用就相当于快排中划分，已经把大量数据分割成了基本有序的数据块(桶)。然后只需要对桶中的少量数据做先进的比较排序即可。\n\n\n# 排序过程\n\n举个大家都经历过的例子，某些大学会限制大一参加英语四级考试的名额，假设现在需要对大一新生的英语成绩进行排序，选取英语成绩位于前50%的学生允许参加大一上学期的英语四级考试。\n\n一般来说一个大学的新生一般都是一万人左右，如果直接用基于比较的排序算法也不会特别的耗时间，但是通过观察可以知道的是，这些学生的成绩有个显著的特点，它们都是在[0-150]之间，也就是说，我们可以申明151个数组，每个数组（即桶）保存对应分数学生的英语成绩。最后，我们再将排序之后的数据导回至原来的数据中则完成排序。可以看到的是，由于我们的桶是远远小于数组的量级的，在排序的时候我们会使用一轮循环遍历数据，最后将排序之后的数据导回去需要一轮循环。其时间复杂度是线性的，约为o(n)（需要注意的是此处把成绩插入到对应的桶中是不需要再进行排序的，所以时间复杂度可以表示为o(n)），可以看到这个例子的算法时间复杂度是已经超过了基于比较的排序算法的。\n\n\n# 算法实现\n\n/**\n * 桶排序\n * @param {number[]} arr\n */\nfunction bucketsort(arr) {\n  /* 申明桶 */\n  const buckets = array.from({\n    length: 151,\n  }).map(() => {\n    return [];\n  });\n  /* 按分值划分桶 */\n  for (let i = 0; i < arr.length; i++) {\n    const score = arr[i];\n    buckets[score].push(score);\n  }\n  /* 将桶中的数据导回至原数组 */\n  let offset = 0;\n  while (buckets.length) {\n    const bucket = buckets.shift();\n    while (bucket.length) {\n      const score = bucket.shift();\n      arr[offset++] = score;\n    }\n  }\n}\n\n\n\n# 复杂度与稳定性\n\n假设数据有n项，排序过程中分配m个桶，桶排序的平均时间复杂度为线性的 o(n+c)，其中 c=n*(logn-logm)。如果相对于同样的n，桶数量m越大，其效率越高，最好的时间复杂度达到o(n)。空间复杂度为o(n+m)。",charsets:{cjk:!0}},{frontmatter:{},regularPath:"/data-structure/sort/",relativePath:"data-structure/sort/index.md",key:"v-bb0e9124",path:"/data-structure/sort/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{title:"排序算法的比较与总结",frontmatter:{},regularPath:"/data-structure/sort/compare.html",relativePath:"data-structure/sort/compare.md",key:"v-162bf415",path:"/data-structure/sort/compare.html",headers:[{level:2,title:"排序算法的比较与总结",slug:"排序算法的比较与总结",normalizedTitle:"排序算法的比较与总结",charIndex:2},{level:3,title:"规范",slug:"规范",normalizedTitle:"规范",charIndex:17},{level:3,title:"排序算法的稳定性",slug:"排序算法的稳定性",normalizedTitle:"排序算法的稳定性",charIndex:94},{level:3,title:"复杂度、稳定性与额外占用空间比较",slug:"复杂度、稳定性与额外占用空间比较",normalizedTitle:"复杂度、稳定性与额外占用空间比较",charIndex:1175},{level:3,title:"时间比较",slug:"时间比较",normalizedTitle:"时间比较",charIndex:1741}],headersStr:"排序算法的比较与总结 规范 排序算法的稳定性 复杂度、稳定性与额外占用空间比较 时间比较",content:"# 排序算法的比较与总结\n\n\n# 规范\n\n排序算法必须原地排序，不能修改数组的引用，只能修改数组内容\n\n排序算法必须向外界提供统一的接口，仅接收一个数组作为参数，不返回任何内容；\n\n\n# 排序算法的稳定性\n\n这是一个我们经常提到，但是却又没有怎么留意的问题。什么是排序算法的稳定性呢，就比如现在我们有一堆手牌， 假设，我现在手里面按顺序有梅花6，红桃A，方块6，红桃2，黑桃5。我们按点数大小（Ace视为 1 点）从小到大进行排序，此时，有两个数值相同的 6，如果说，当我们的排序算法完成之后，梅花6还是排在方块6之前的话，那么我们就可以说这个排序算法是稳定的。什么时候我们才会考虑稳定性呢？就拿刚才的例子举例，我们希望当数值相同时，扑克的花色按最初的相对顺序排列，这时候就需要用一个稳定的排序算法。\n\n比如，现在我们要选出优秀的学生参与奥赛班，我们对学生进行一次摸底考试，根据学生的的成绩排序，然后再根据学生的年纪进行排序，我们就可以选出相同成绩下年级较小的同学参赛，若排序算法不稳定的话，则会导致我们用年龄再次排序时就达不到预期的效果了。如果只是单纯的对成绩排序，那么就不会再有什么想通数组的初始顺序的问题了，所以，系统为我们实现的排序方法，当你在对数字进行排序的时候，一般会采用不稳定的，对对象进行排序的时候，会采用稳定的算法。\n\n但是排序算法的稳定性并不是绝对的，这取决于你写的排序算法的判别条件，众所周知，插入排序是稳定的排序算法，但是假设我们把代码写成这样：\n\n\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n/**\n * 对数组进行插入排序\n * @param {Array<number>} arr 需要进行排序的数组\n */\nfunction insertionSort(arr) {\n  // 默认认为第一个元素已经有序\n  for (let i = 1; i < arr.length; i++) {\n    let j = i;\n    let cur = arr[i];\n    //向前找合适的插入位置，退出条件有两种可能，1、找到了合适的插入位置；2、找到了头了\n    while (j > 0 && arr[j - 1] >= cur) {\n      // 在每次查找插入位置的时候，都将当前元素向后挪一位。\n      arr[j] = arr[j - 1];\n      j--;\n    }\n    arr[j] = cur;\n  }\n}\n\n\n如果我们把向前插入的条件写成arr[j - 1] >= cur，那么很明显当方块6进行插入的时候，它一定会跑到梅花6的前面去，变成了不稳定的排序算法了。\n\n因此，排序算法的稳定性其实还是一个相对的概念，如果你只要举得出例子证明它，那么它就是稳定或者不稳定的。\n\n\n# 复杂度、稳定性与额外占用空间比较\n\n排序算法名称   平均算法复杂度                     是否稳定   是否额外空间复杂度\n冒泡排序     O(N²)                       是      否\n选择排序     O(N²)                       是      否\n插入排序     O(N²)                       是      否\n希尔排序     O(N*logN)                   否      否\n快速排序     O(N*logN)                   否      是，平均 O(logN)，最坏 O(N)\n归并排序     O(N*logN)                   是      是，O(N)\n堆排序      O(N*logN)                   否      否\n桶排序      O(N+C)，其中 C=N*(logN-logM)   是      是，O(N+M)，N 为数据的数量级，M 为桶的数量级\n基数排序     O(P(N+B))                   是      是，O(N+M)，N 为数据的数量级，M 为桶的数量级\n\n\n# 时间比较\n\n我们各类的语言底层（如 JS 的Array.prototype.sort）提供的排序算法就是根据不同排序算法的稳定性、时间复杂度、空间复杂度差异，根据待排数据的性质，在三者之间进行取舍，从而实现更加高效的排序算法。\n\n为了让大家直观的体验不同排序算法的差异，我对这些排序算法在 LeetCode 上都依次进行了提交（同一个排序算法 3 次提交，对结果取最接近平均值的那组数据），然后将结果进行了统计，结果如下：\n\n排序算法名称                       执行用时      执行用时击败所有提交区间   内存消耗      内存消耗击败所有提交区间   是否稳定\n冒泡排序                         6036ms    10.62%         50.7MB    89.30%         是\n选择排序                         7100 ms   6.86%          50.7 MB   86.00%         是\n插入排序                         1508 ms   39.15%         50.8 MB   85.80%         是\n希尔排序                         108 ms    95.09%         50.8 MB   85.80%         是\n朴素快速排序                       1512 ms   39.06%         57.5 MB   37.14%         否\n三元取中快速排序                     112 ms    91.57%         50.8 MB   83.76%         否\n归并排序（递归版）                    620 ms    48.71%         54.2 MB   49.68%         是\n归并排序（非递归版）                   120 ms    83.46%         51.6 MB   63.65%         是\n堆排序                          108 ms    95.09%         50.5 MB   93.77%         否\n桶排序（采用了 10 个桶，每个桶采用直接插入排序）   4140 ms   17.98%         61.4MB    11.93%         是\n基数排序                         108ms     23.01%         57.6MB    8.21%          是\n程序内置排序函数（以 JS 为例）            108 ms    95.09%         50.6 MB   92.65%         不讨论\n\n最后通过这个表格验证了我们的结论，因为语言底层的排序算法通过对不同对数据环境下的数据采用了符合场景的排序算法，速度是最快的。（在 LeetCode 上提交各种排序算法的我，那个小丑竟然是我自己）。有的同学可能会说我学排序算法学了个寂寞，不如直接就用语言提供的排序算法就好啊，其实我们学习是为了掌握理论，为的知道其底层原理，便于解决各种生产中的 bug，是对能力的一种培养。再者，面试官再问你各种排序算法，你心里面也有个谱了吧。",normalizedContent:"# 排序算法的比较与总结\n\n\n# 规范\n\n排序算法必须原地排序，不能修改数组的引用，只能修改数组内容\n\n排序算法必须向外界提供统一的接口，仅接收一个数组作为参数，不返回任何内容；\n\n\n# 排序算法的稳定性\n\n这是一个我们经常提到，但是却又没有怎么留意的问题。什么是排序算法的稳定性呢，就比如现在我们有一堆手牌， 假设，我现在手里面按顺序有梅花6，红桃a，方块6，红桃2，黑桃5。我们按点数大小（ace视为 1 点）从小到大进行排序，此时，有两个数值相同的 6，如果说，当我们的排序算法完成之后，梅花6还是排在方块6之前的话，那么我们就可以说这个排序算法是稳定的。什么时候我们才会考虑稳定性呢？就拿刚才的例子举例，我们希望当数值相同时，扑克的花色按最初的相对顺序排列，这时候就需要用一个稳定的排序算法。\n\n比如，现在我们要选出优秀的学生参与奥赛班，我们对学生进行一次摸底考试，根据学生的的成绩排序，然后再根据学生的年纪进行排序，我们就可以选出相同成绩下年级较小的同学参赛，若排序算法不稳定的话，则会导致我们用年龄再次排序时就达不到预期的效果了。如果只是单纯的对成绩排序，那么就不会再有什么想通数组的初始顺序的问题了，所以，系统为我们实现的排序方法，当你在对数字进行排序的时候，一般会采用不稳定的，对对象进行排序的时候，会采用稳定的算法。\n\n但是排序算法的稳定性并不是绝对的，这取决于你写的排序算法的判别条件，众所周知，插入排序是稳定的排序算法，但是假设我们把代码写成这样：\n\n\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n/**\n * 对数组进行插入排序\n * @param {array<number>} arr 需要进行排序的数组\n */\nfunction insertionsort(arr) {\n  // 默认认为第一个元素已经有序\n  for (let i = 1; i < arr.length; i++) {\n    let j = i;\n    let cur = arr[i];\n    //向前找合适的插入位置，退出条件有两种可能，1、找到了合适的插入位置；2、找到了头了\n    while (j > 0 && arr[j - 1] >= cur) {\n      // 在每次查找插入位置的时候，都将当前元素向后挪一位。\n      arr[j] = arr[j - 1];\n      j--;\n    }\n    arr[j] = cur;\n  }\n}\n\n\n如果我们把向前插入的条件写成arr[j - 1] >= cur，那么很明显当方块6进行插入的时候，它一定会跑到梅花6的前面去，变成了不稳定的排序算法了。\n\n因此，排序算法的稳定性其实还是一个相对的概念，如果你只要举得出例子证明它，那么它就是稳定或者不稳定的。\n\n\n# 复杂度、稳定性与额外占用空间比较\n\n排序算法名称   平均算法复杂度                     是否稳定   是否额外空间复杂度\n冒泡排序     o(n²)                       是      否\n选择排序     o(n²)                       是      否\n插入排序     o(n²)                       是      否\n希尔排序     o(n*logn)                   否      否\n快速排序     o(n*logn)                   否      是，平均 o(logn)，最坏 o(n)\n归并排序     o(n*logn)                   是      是，o(n)\n堆排序      o(n*logn)                   否      否\n桶排序      o(n+c)，其中 c=n*(logn-logm)   是      是，o(n+m)，n 为数据的数量级，m 为桶的数量级\n基数排序     o(p(n+b))                   是      是，o(n+m)，n 为数据的数量级，m 为桶的数量级\n\n\n# 时间比较\n\n我们各类的语言底层（如 js 的array.prototype.sort）提供的排序算法就是根据不同排序算法的稳定性、时间复杂度、空间复杂度差异，根据待排数据的性质，在三者之间进行取舍，从而实现更加高效的排序算法。\n\n为了让大家直观的体验不同排序算法的差异，我对这些排序算法在 leetcode 上都依次进行了提交（同一个排序算法 3 次提交，对结果取最接近平均值的那组数据），然后将结果进行了统计，结果如下：\n\n排序算法名称                       执行用时      执行用时击败所有提交区间   内存消耗      内存消耗击败所有提交区间   是否稳定\n冒泡排序                         6036ms    10.62%         50.7mb    89.30%         是\n选择排序                         7100 ms   6.86%          50.7 mb   86.00%         是\n插入排序                         1508 ms   39.15%         50.8 mb   85.80%         是\n希尔排序                         108 ms    95.09%         50.8 mb   85.80%         是\n朴素快速排序                       1512 ms   39.06%         57.5 mb   37.14%         否\n三元取中快速排序                     112 ms    91.57%         50.8 mb   83.76%         否\n归并排序（递归版）                    620 ms    48.71%         54.2 mb   49.68%         是\n归并排序（非递归版）                   120 ms    83.46%         51.6 mb   63.65%         是\n堆排序                          108 ms    95.09%         50.5 mb   93.77%         否\n桶排序（采用了 10 个桶，每个桶采用直接插入排序）   4140 ms   17.98%         61.4mb    11.93%         是\n基数排序                         108ms     23.01%         57.6mb    8.21%          是\n程序内置排序函数（以 js 为例）            108 ms    95.09%         50.6 mb   92.65%         不讨论\n\n最后通过这个表格验证了我们的结论，因为语言底层的排序算法通过对不同对数据环境下的数据采用了符合场景的排序算法，速度是最快的。（在 leetcode 上提交各种排序算法的我，那个小丑竟然是我自己）。有的同学可能会说我学排序算法学了个寂寞，不如直接就用语言提供的排序算法就好啊，其实我们学习是为了掌握理论，为的知道其底层原理，便于解决各种生产中的 bug，是对能力的一种培养。再者，面试官再问你各种排序算法，你心里面也有个谱了吧。",charsets:{cjk:!0}},{title:"插入排序",frontmatter:{},regularPath:"/data-structure/sort/insertionSort.html",relativePath:"data-structure/sort/insertionSort.md",key:"v-6e866b56",path:"/data-structure/sort/insertionSort.html",headers:[{level:2,title:"插入排序",slug:"插入排序",normalizedTitle:"插入排序",charIndex:2},{level:3,title:"排序过程",slug:"排序过程",normalizedTitle:"排序过程",charIndex:117},{level:3,title:"算法实现",slug:"算法实现",normalizedTitle:"算法实现",charIndex:126},{level:3,title:"复杂度与稳定性",slug:"复杂度与稳定性",normalizedTitle:"复杂度与稳定性",charIndex:516}],headersStr:"插入排序 排序过程 算法实现 复杂度与稳定性",content:"# 插入排序\n\n取出从无序序列中的第一个元素，有序片段的规模加 1，在有序片段中找到该元素合适的插入位置进行插入，无序片段的规模减 1，下次又从无序片段的第一个元素开始排序，重复这个操作直到无序片段长度为 0， 则完成排序。\n\n\n# 排序过程\n\n\n# 算法实现\n\n/**\n * 对数组进行插入排序\n * @param {Array<number>} arr 需要进行排序的数组\n */\nfunction insertionSort(arr) {\n  // 默认认为第一个元素已经有序\n  for (let i = 1; i < arr.length; i++) {\n    let j = i;\n    let cur = arr[i];\n    //向前找合适的插入位置，退出条件有两种可能，1、找到了合适的插入位置；2、找到了头了\n    while (j > 0 && arr[j - 1] > cur) {\n      // 在每次查找插入位置的时候，都将当前元素向后挪一位。\n      arr[j] = arr[j - 1];\n      j--;\n    }\n    arr[j] = cur;\n  }\n}\n\n\n\n# 复杂度与稳定性\n\n插入排序的时间复杂度是O(n²)，是稳定的排序算法。",normalizedContent:"# 插入排序\n\n取出从无序序列中的第一个元素，有序片段的规模加 1，在有序片段中找到该元素合适的插入位置进行插入，无序片段的规模减 1，下次又从无序片段的第一个元素开始排序，重复这个操作直到无序片段长度为 0， 则完成排序。\n\n\n# 排序过程\n\n\n# 算法实现\n\n/**\n * 对数组进行插入排序\n * @param {array<number>} arr 需要进行排序的数组\n */\nfunction insertionsort(arr) {\n  // 默认认为第一个元素已经有序\n  for (let i = 1; i < arr.length; i++) {\n    let j = i;\n    let cur = arr[i];\n    //向前找合适的插入位置，退出条件有两种可能，1、找到了合适的插入位置；2、找到了头了\n    while (j > 0 && arr[j - 1] > cur) {\n      // 在每次查找插入位置的时候，都将当前元素向后挪一位。\n      arr[j] = arr[j - 1];\n      j--;\n    }\n    arr[j] = cur;\n  }\n}\n\n\n\n# 复杂度与稳定性\n\n插入排序的时间复杂度是o(n²)，是稳定的排序算法。",charsets:{cjk:!0}},{title:"归并排序",frontmatter:{},regularPath:"/data-structure/sort/mergeSort.html",relativePath:"data-structure/sort/mergeSort.md",key:"v-1696c5b5",path:"/data-structure/sort/mergeSort.html",headers:[{level:2,title:"归并排序",slug:"归并排序",normalizedTitle:"归并排序",charIndex:2},{level:3,title:"排序过程",slug:"排序过程",normalizedTitle:"排序过程",charIndex:75},{level:3,title:"算法实现",slug:"算法实现",normalizedTitle:"算法实现",charIndex:84},{level:3,title:"复杂度与稳定性",slug:"复杂度与稳定性",normalizedTitle:"复杂度与稳定性",charIndex:3680}],headersStr:"归并排序 排序过程 算法实现 复杂度与稳定性",content:"# 归并排序\n\n将数组划分为若干个片段，然后不断的合并两个有序片段，得到新的结果，再在这个结果上重复此操作，直到这些片段最终合并成整个数组。\n\n\n# 排序过程\n\n\n# 算法实现\n\n在使用递归实现归并排序时，注意我们最后一次性的传递临时数组到排序函数里面去，不要在排序函数内部申请数组进行结果的保存，因为外界传入只会处理一次，而内部申请，每个片段你都需要申请和释放空间，在数据量比较大的时候，性能不佳。\n\n# 递归实现\n\n/**\n * 对数组片段进行合并\n * @param {Array<number>} arr 需要进行合并的数组片段\n * @param {number} leftStart 待合并数组片段1的开始索引\n * @param {number} rightStart 待合并数组片段2的开始索引\n * @param {number} rightEnd 待合并数组片段2的结束索引\n * @param {Array<number>} tempArr 临时数组，用于记录合并有序序列\n */\nfunction _merge(arr, leftStart, rightStart, rightEnd, tempArr) {\n  // 计算出序列的总长度，用于日后将临时数组中的数据导入到数组中\n  let length = rightEnd - leftStart + 1;\n  // 计算出序列1结束的位置\n  let leftEnd = rightStart - 1;\n  // 记录序列的开始位置\n  let pos = leftStart;\n  while (leftStart <= leftEnd && rightStart <= rightEnd) {\n    // 将数组中的元素按特定的规则复制到临时数组里面去\n    if (arr[leftStart] >= arr[rightStart]) {\n      tempArr[pos++] = arr[rightStart++];\n    } else {\n      tempArr[pos++] = arr[leftStart++];\n    }\n  }\n\n  // 两个while不可能同时成立，只拷贝较长的部分\n  while (leftStart <= leftEnd) {\n    tempArr[pos++] = arr[leftStart++];\n  }\n\n  while (rightStart <= rightEnd) {\n    tempArr[pos++] = arr[rightStart++];\n  }\n\n  // 因为最后合并完成之后pos指向的是最后一个元素的下一位，因此，需要将其减1\n  for (let i = pos - 1, k = 0; k < length; k++, i--) {\n    // 将临时数组的数据导入到真实数组里面去\n    arr[i] = tempArr[i];\n  }\n}\n\n/**\n * 对数组片段进行归并排序\n * @param {Array<number>} arr 需要进行排序的数组\n * @param {number} left 待排序数组片段的开始索引\n * @param {number} right 待排序数组片段的结束索引\n */\nfunction _mergeSort(arr, left, right) {\n  if (left >= right) {\n    return;\n  }\n  let center = Math.floor((left + right) / 2);\n  let tempArr = [];\n  // 递归的对左半部分进行归并排序\n  _mergeSort(arr, left, center);\n  // 递归的对右半部分进行归并排序\n  _mergeSort(arr, center + 1, right);\n  // 合并两个有序数组\n  _merge(arr, left, center + 1, right, tempArr);\n}\n\n/**\n * 对数组进行归并排序\n * @param {Array<number>} arr 需要进行排序的数组\n */\nfunction mergeSort(arr) {\n  _mergeSort(arr, 0, arr.length - 1);\n}\n\n\n# 非递归实现\n\n本例中，在_merge函数中并没有进行把临时数组导回至原数组的操作，在while循环中，巧妙地利用了临时数据已经被排序过的特点，下次排序直接利用它，并且再把排序的数据导回至原数组，减少了数组元素的拷贝次数。\n\n/**\n * 合并两个有序片段，存到tmpArr中\n * @param {Array<number>} arr\n * @param {number} leftStart\n * @param {number} rightStart\n * @param {number} rightEnd\n * @param {Array<number>} tmpArr\n */\nfunction _merge(arr, leftStart, rightStart, rightEnd, tmpArr) {\n  let pos = leftStart;\n  let leftEnd = rightStart - 1;\n  while (leftStart <= leftEnd && rightStart <= rightEnd) {\n    if (arr[leftStart] >= arr[rightStart]) {\n      tmpArr[pos++] = arr[rightStart++];\n    } else {\n      tmpArr[pos++] = arr[leftStart++];\n    }\n  }\n  while (leftStart <= leftEnd) {\n    tmpArr[pos++] = arr[leftStart++];\n  }\n  while (rightStart <= rightEnd) {\n    tmpArr[pos++] = arr[rightStart++];\n  }\n}\n\n/**\n * 一次归并两个有序片段\n * @param {Array<number>} arr 待排序数组\n * @param {number} sliceSize 每个块的长度\n * @param {Array<number>} tmpArr 临时数组\n */\nfunction _mergePass(arr, sliceSize, tmpArr) {\n  let i = 0;\n  // 只合并到倒数第二或者倒数第一个块之前的块\n  while (i <= arr.length - 2 * sliceSize) {\n    /* 两两归并相邻有序子列 */\n    _merge(arr, i, i + sliceSize, i + 2 * sliceSize - 1, tmpArr);\n    // 每次跨2个序列块\n    i += 2 * sliceSize;\n  }\n  if (i + sliceSize < arr.length) {\n    /* 说明刚好，当前chunk数是 2倍块数的整数倍 归并最后2个子列*/\n    _merge(arr, i, i + sliceSize, arr.length - 1, tmpArr);\n  } else {\n    /* 还差点儿，直接把最后只剩1个子序列导到临时数组即可 */\n    for (let j = i; j < arr.length; j++) {\n      tmpArr[j] = arr[j];\n    }\n  }\n}\n\n/**\n * 归并排序 非递归实现\n * @param {Array<number>} arr\n */\nfunction mergeSort(arr) {\n  /* 初始化子序列长度*/\n  let slice = 1;\n  let tmpArr = [];\n  /**\n   * 块的size从1增长到length\n   */\n  while (slice < arr.length) {\n    // 一轮归并\n    _mergePass(arr, slice, tmpArr);\n    slice *= 2;\n    /* 翻滚两次，这个地方不仅在排序，还完成了把tmpArr的内容导回至arr的事儿, 如果原数据已经有序，仅完成导回操作。*/\n    _mergePass(tmpArr, slice, arr);\n    slice *= 2;\n  }\n}\n\n\n\n# 复杂度与稳定性\n\n归并排序是稳定的排序算法；\n\n平均算法时间复杂度: O(N*logN)，空间复杂度: O(N)\n\n归并排序的缺点就是因为有额外的空间复杂度。\n\n我们各类的语言底层（如 JS 的Array.prototype.sort）提供的排序算法就是根据不同排序算法的稳定性、时间复杂度、空间复杂度差异，根据待排数据的性质，在三者之间进行取舍，从而实现更加高效的排序算法。",normalizedContent:"# 归并排序\n\n将数组划分为若干个片段，然后不断的合并两个有序片段，得到新的结果，再在这个结果上重复此操作，直到这些片段最终合并成整个数组。\n\n\n# 排序过程\n\n\n# 算法实现\n\n在使用递归实现归并排序时，注意我们最后一次性的传递临时数组到排序函数里面去，不要在排序函数内部申请数组进行结果的保存，因为外界传入只会处理一次，而内部申请，每个片段你都需要申请和释放空间，在数据量比较大的时候，性能不佳。\n\n# 递归实现\n\n/**\n * 对数组片段进行合并\n * @param {array<number>} arr 需要进行合并的数组片段\n * @param {number} leftstart 待合并数组片段1的开始索引\n * @param {number} rightstart 待合并数组片段2的开始索引\n * @param {number} rightend 待合并数组片段2的结束索引\n * @param {array<number>} temparr 临时数组，用于记录合并有序序列\n */\nfunction _merge(arr, leftstart, rightstart, rightend, temparr) {\n  // 计算出序列的总长度，用于日后将临时数组中的数据导入到数组中\n  let length = rightend - leftstart + 1;\n  // 计算出序列1结束的位置\n  let leftend = rightstart - 1;\n  // 记录序列的开始位置\n  let pos = leftstart;\n  while (leftstart <= leftend && rightstart <= rightend) {\n    // 将数组中的元素按特定的规则复制到临时数组里面去\n    if (arr[leftstart] >= arr[rightstart]) {\n      temparr[pos++] = arr[rightstart++];\n    } else {\n      temparr[pos++] = arr[leftstart++];\n    }\n  }\n\n  // 两个while不可能同时成立，只拷贝较长的部分\n  while (leftstart <= leftend) {\n    temparr[pos++] = arr[leftstart++];\n  }\n\n  while (rightstart <= rightend) {\n    temparr[pos++] = arr[rightstart++];\n  }\n\n  // 因为最后合并完成之后pos指向的是最后一个元素的下一位，因此，需要将其减1\n  for (let i = pos - 1, k = 0; k < length; k++, i--) {\n    // 将临时数组的数据导入到真实数组里面去\n    arr[i] = temparr[i];\n  }\n}\n\n/**\n * 对数组片段进行归并排序\n * @param {array<number>} arr 需要进行排序的数组\n * @param {number} left 待排序数组片段的开始索引\n * @param {number} right 待排序数组片段的结束索引\n */\nfunction _mergesort(arr, left, right) {\n  if (left >= right) {\n    return;\n  }\n  let center = math.floor((left + right) / 2);\n  let temparr = [];\n  // 递归的对左半部分进行归并排序\n  _mergesort(arr, left, center);\n  // 递归的对右半部分进行归并排序\n  _mergesort(arr, center + 1, right);\n  // 合并两个有序数组\n  _merge(arr, left, center + 1, right, temparr);\n}\n\n/**\n * 对数组进行归并排序\n * @param {array<number>} arr 需要进行排序的数组\n */\nfunction mergesort(arr) {\n  _mergesort(arr, 0, arr.length - 1);\n}\n\n\n# 非递归实现\n\n本例中，在_merge函数中并没有进行把临时数组导回至原数组的操作，在while循环中，巧妙地利用了临时数据已经被排序过的特点，下次排序直接利用它，并且再把排序的数据导回至原数组，减少了数组元素的拷贝次数。\n\n/**\n * 合并两个有序片段，存到tmparr中\n * @param {array<number>} arr\n * @param {number} leftstart\n * @param {number} rightstart\n * @param {number} rightend\n * @param {array<number>} tmparr\n */\nfunction _merge(arr, leftstart, rightstart, rightend, tmparr) {\n  let pos = leftstart;\n  let leftend = rightstart - 1;\n  while (leftstart <= leftend && rightstart <= rightend) {\n    if (arr[leftstart] >= arr[rightstart]) {\n      tmparr[pos++] = arr[rightstart++];\n    } else {\n      tmparr[pos++] = arr[leftstart++];\n    }\n  }\n  while (leftstart <= leftend) {\n    tmparr[pos++] = arr[leftstart++];\n  }\n  while (rightstart <= rightend) {\n    tmparr[pos++] = arr[rightstart++];\n  }\n}\n\n/**\n * 一次归并两个有序片段\n * @param {array<number>} arr 待排序数组\n * @param {number} slicesize 每个块的长度\n * @param {array<number>} tmparr 临时数组\n */\nfunction _mergepass(arr, slicesize, tmparr) {\n  let i = 0;\n  // 只合并到倒数第二或者倒数第一个块之前的块\n  while (i <= arr.length - 2 * slicesize) {\n    /* 两两归并相邻有序子列 */\n    _merge(arr, i, i + slicesize, i + 2 * slicesize - 1, tmparr);\n    // 每次跨2个序列块\n    i += 2 * slicesize;\n  }\n  if (i + slicesize < arr.length) {\n    /* 说明刚好，当前chunk数是 2倍块数的整数倍 归并最后2个子列*/\n    _merge(arr, i, i + slicesize, arr.length - 1, tmparr);\n  } else {\n    /* 还差点儿，直接把最后只剩1个子序列导到临时数组即可 */\n    for (let j = i; j < arr.length; j++) {\n      tmparr[j] = arr[j];\n    }\n  }\n}\n\n/**\n * 归并排序 非递归实现\n * @param {array<number>} arr\n */\nfunction mergesort(arr) {\n  /* 初始化子序列长度*/\n  let slice = 1;\n  let tmparr = [];\n  /**\n   * 块的size从1增长到length\n   */\n  while (slice < arr.length) {\n    // 一轮归并\n    _mergepass(arr, slice, tmparr);\n    slice *= 2;\n    /* 翻滚两次，这个地方不仅在排序，还完成了把tmparr的内容导回至arr的事儿, 如果原数据已经有序，仅完成导回操作。*/\n    _mergepass(tmparr, slice, arr);\n    slice *= 2;\n  }\n}\n\n\n\n# 复杂度与稳定性\n\n归并排序是稳定的排序算法；\n\n平均算法时间复杂度: o(n*logn)，空间复杂度: o(n)\n\n归并排序的缺点就是因为有额外的空间复杂度。\n\n我们各类的语言底层（如 js 的array.prototype.sort）提供的排序算法就是根据不同排序算法的稳定性、时间复杂度、空间复杂度差异，根据待排数据的性质，在三者之间进行取舍，从而实现更加高效的排序算法。",charsets:{cjk:!0}},{title:"堆排序",frontmatter:{},regularPath:"/data-structure/sort/heapSort.html",relativePath:"data-structure/sort/heapSort.md",key:"v-ce31282e",path:"/data-structure/sort/heapSort.html",headers:[{level:2,title:"堆排序",slug:"堆排序",normalizedTitle:"堆排序",charIndex:2},{level:3,title:"排序过程",slug:"排序过程",normalizedTitle:"排序过程",charIndex:124},{level:3,title:"算法实现",slug:"算法实现",normalizedTitle:"算法实现",charIndex:133},{level:3,title:"复杂度与稳定性",slug:"复杂度与稳定性",normalizedTitle:"复杂度与稳定性",charIndex:1402}],headersStr:"堆排序 排序过程 算法实现 复杂度与稳定性",content:"# 堆排序\n\n将数组片段在线性的时间内调整成最大（小）堆，取出堆顶的元素和数组无序片段的最后一个元素进行交换，有序片段规模增加 1，无序片段规模减少 1，再将剩余的无序片段元素调整成最大（小）堆，重复这个操作，直到无序片段为空则完成排序。\n\n\n# 排序过程\n\n\n# 算法实现\n\n/**\n * 将长度为length的数组片段以p为根节点构建最大堆\n * @param {Array<number>} arr 需要进行排序的数组\n * @param {number} p 根节点\n * @param {number} length 数组片段的长度\n */\nfunction percDown(arr, p, length) {\n  let temp = arr[p];\n  let child, parent;\n  // 从p节点开始，如果parent*2等于length的话，说明堆已经越界，无需进行循环\n  for (parent = p; parent * 2 < length; parent = child) {\n    // 找到左儿子节点所在的索引\n    child = parent * 2;\n    // 右儿子存在,并且右儿子比左儿子大，则取右儿子\n    if (child + 1 < length && arr[child] < arr[child + 1]) {\n      child++;\n    }\n    // 如果待插入的值比当前这个位置大或者相等，则说明这个位置就是可以插入的位置,不能再继续下滤了，因此退出循环\n    if (temp >= arr[child]) {\n      break;\n    } else {\n      // 把大的值向上提\n      arr[parent] = arr[child];\n    }\n    // 节点下滤\n  }\n  // 把元素放在合适的位置\n  arr[parent] = temp;\n}\n\n/**\n * 对数组进行堆排序\n * @param {Array<number>} arr 需要进行排序的数组\n */\nfunction heapSort(arr) {\n  // 因为在没有哨兵时，对于父节点为i的节点，其左右儿子分别是 2i+1, 2i+2，那我们可以根据最后一个元素算出，最后一个元素的父节点是 Math.floor(arr.length / 2)\n  // 从最后一个元素的父元素开始，在线性的时间内将数组调整成最大堆,\n  for (let i = Math.floor(arr.length / 2); i >= 0; i--) {\n    percDown(arr, i, arr.length);\n  }\n  for (let i = arr.length - 1; i >= 0; i--) {\n    // 取出堆顶的第一个元素\n    let temp = arr[0];\n    // 将无序片段最后一个元素交换到堆顶\n    arr[0] = arr[i];\n    arr[i] = temp;\n    // 继续将长度为i的元素片段，以0为根节点，调整成最大堆\n    percDown(arr, 0, i);\n    // 最后无序片段的规模递减\n  }\n}\n\n\n\n# 复杂度与稳定性\n\n堆排序是不稳定的排序算法；\n\n定理: 堆排序处理 N 个不同元素的随机排列的平均比较次数是 2N*logN-O(N*log(logN))\n\n堆排序的复杂度可以写成 O(N*logN)，而且比这个复杂度要比 O(N*logN)略好一些。\n\n平均算法复杂度：O(N*logN)，无额外的空间复杂度",normalizedContent:"# 堆排序\n\n将数组片段在线性的时间内调整成最大（小）堆，取出堆顶的元素和数组无序片段的最后一个元素进行交换，有序片段规模增加 1，无序片段规模减少 1，再将剩余的无序片段元素调整成最大（小）堆，重复这个操作，直到无序片段为空则完成排序。\n\n\n# 排序过程\n\n\n# 算法实现\n\n/**\n * 将长度为length的数组片段以p为根节点构建最大堆\n * @param {array<number>} arr 需要进行排序的数组\n * @param {number} p 根节点\n * @param {number} length 数组片段的长度\n */\nfunction percdown(arr, p, length) {\n  let temp = arr[p];\n  let child, parent;\n  // 从p节点开始，如果parent*2等于length的话，说明堆已经越界，无需进行循环\n  for (parent = p; parent * 2 < length; parent = child) {\n    // 找到左儿子节点所在的索引\n    child = parent * 2;\n    // 右儿子存在,并且右儿子比左儿子大，则取右儿子\n    if (child + 1 < length && arr[child] < arr[child + 1]) {\n      child++;\n    }\n    // 如果待插入的值比当前这个位置大或者相等，则说明这个位置就是可以插入的位置,不能再继续下滤了，因此退出循环\n    if (temp >= arr[child]) {\n      break;\n    } else {\n      // 把大的值向上提\n      arr[parent] = arr[child];\n    }\n    // 节点下滤\n  }\n  // 把元素放在合适的位置\n  arr[parent] = temp;\n}\n\n/**\n * 对数组进行堆排序\n * @param {array<number>} arr 需要进行排序的数组\n */\nfunction heapsort(arr) {\n  // 因为在没有哨兵时，对于父节点为i的节点，其左右儿子分别是 2i+1, 2i+2，那我们可以根据最后一个元素算出，最后一个元素的父节点是 math.floor(arr.length / 2)\n  // 从最后一个元素的父元素开始，在线性的时间内将数组调整成最大堆,\n  for (let i = math.floor(arr.length / 2); i >= 0; i--) {\n    percdown(arr, i, arr.length);\n  }\n  for (let i = arr.length - 1; i >= 0; i--) {\n    // 取出堆顶的第一个元素\n    let temp = arr[0];\n    // 将无序片段最后一个元素交换到堆顶\n    arr[0] = arr[i];\n    arr[i] = temp;\n    // 继续将长度为i的元素片段，以0为根节点，调整成最大堆\n    percdown(arr, 0, i);\n    // 最后无序片段的规模递减\n  }\n}\n\n\n\n# 复杂度与稳定性\n\n堆排序是不稳定的排序算法；\n\n定理: 堆排序处理 n 个不同元素的随机排列的平均比较次数是 2n*logn-o(n*log(logn))\n\n堆排序的复杂度可以写成 o(n*logn)，而且比这个复杂度要比 o(n*logn)略好一些。\n\n平均算法复杂度：o(n*logn)，无额外的空间复杂度",charsets:{cjk:!0}},{title:"快速排序",frontmatter:{},regularPath:"/data-structure/sort/quickSort.html",relativePath:"data-structure/sort/quickSort.md",key:"v-0e9221d6",path:"/data-structure/sort/quickSort.html",headers:[{level:2,title:"快速排序",slug:"快速排序",normalizedTitle:"快速排序",charIndex:2},{level:3,title:"排序过程",slug:"排序过程",normalizedTitle:"排序过程",charIndex:210},{level:3,title:"算法实现",slug:"算法实现",normalizedTitle:"算法实现",charIndex:219},{level:3,title:"复杂度与稳定性",slug:"复杂度与稳定性",normalizedTitle:"复杂度与稳定性",charIndex:2970}],headersStr:"快速排序 排序过程 算法实现 复杂度与稳定性",content:"# 快速排序\n\n若数组片段的长度大于 1，则随机从数组片段中取出一个元素作为主元(pivot)，将数组分为两份 A,B，这个位置之前的为一份(A)，这个位置之后的为一份(B)，将 A 中所有比 pivot 大的元素全部放到 B 中，将 B 中比 pivot 小的元素全部放大 A 中，然后分别递归的对数组片段 A 和 B 分别重复这个过程，直到所有的元素都有序即完成排序。\n\n快速排序是基于分治思想的排序算法。\n\n\n# 排序过程\n\n\n# 算法实现\n\n# 朴素法\n\n朴素法虽然比较好理解，也比较好记忆，但是实际上并不快，因为每次都简单的按特定的规则选取主元，如果主元的选择情况并不好的话，那我们的快速排序算法就跟冒泡排序差不多了。\n\n/**\n * 对数组片段进行快速排序\n * @param {Array<number>} arr 需要进行排序的数组\n * @param {number} left 待排序数组片段的开始索引\n * @param {number} right 待排序数组片段的结束索引\n */\nfunction _quickSort(arr, left, right) {\n  // 如果数组片段的长度小于或者等于1，无需进行排序\n  if (left >= right) {\n    return;\n  }\n  // 随机取一个元素作为主元\n  let pivot = arr[left];\n  let i = left;\n  let j = right;\n  while (i < j) {\n    // 从数组片段右侧找比主元小的元素\n    while (i < j && arr[j] > pivot) {\n      j--;\n    }\n    // 说明此刻已经找到了比主元小的元素\n    if (i < j) {\n      arr[i] = arr[j];\n      // 缩小规模\n      i++;\n    }\n    // 从数组片段左侧找比主元大的元素\n    while (i < j && arr[i] < pivot) {\n      i++;\n    }\n    // 说明找到了比主元大的元素\n    if (i < j) {\n      arr[j] = arr[i];\n      j--;\n    }\n  }\n  // 当退出循环的时候，i == j, 此刻这个位置之前所有的元素都比主元小，这个位置之后的所有元素都比主元大，这个位置就是我们存放主元的位置\n  arr[i] = pivot;\n  // 递归的对左半部分元素进行快速排序\n  _quickSort(arr, left, i - 1);\n  // 递归的对右半部分元素进行快速排序\n  _quickSort(arr, i + 1, right);\n}\n\n/**\n * 对数组进行快速排序\n * @param {Array<number>} arr 需要进行排序的数组\n */\nfunction quickSort(arr) {\n  _quickSort(arr, 0, arr.length - 1);\n}\n\n\n# 三元取中法\n\n/**\n * 定义数据的规模，如果少于这个量，则用简单排序，否则使用快速排序\n */\nconst N = 50;\n/**\n * 定义直接插入排序的方法，此直接插入排序方法和普通的插入排序有区别，因为是针对数组的某一个片段进行排序，因此需要引入一个offset偏移量参数\n * @param {Array} arr 待排序数组\n * @param {Number} offset 初始偏移量\n * @param {Number} length 待排序片段的总长度\n */\nfunction _insertionSort(arr, offset, length) {\n  let temp, i;\n  for (let p = offset + 1; p < offset + length; p++) {\n    temp = arr[p];\n    for (i = p; i > offset && temp < arr[i - 1]; i--) {\n      arr[i] = arr[i - 1];\n    }\n    arr[i] = temp;\n  }\n}\n\n/**\n * 三元取中法获取主元\n */\nfunction _mediant3(arr, left, right) {\n  let center = Math.floor((left + right) / 2);\n  if (arr[left] > arr[right]) {\n    _swap(arr, left, right);\n  }\n\n  if (arr[left] > arr[center]) {\n    _swap(arr, left, center);\n  }\n\n  if (arr[center] > arr[right]) {\n    _swap(arr, right, center);\n  }\n  // 并且把主元藏在数组片段的倒数第二位\n  _swap(arr, right - 1, center);\n  return arr[right - 1];\n}\n\n/**\n * 交换数组中的2个元素\n */\nfunction _swap(arr, i, j) {\n  let temp = arr[j];\n  arr[j] = arr[i];\n  arr[i] = temp;\n}\n\n/**\n * 对数组片段进行快速排序\n */\nfunction _quickSort(arr, left, right) {\n  // 数据片段的长度\n  let len = right - left + 1;\n  // 如果数据规模少于它，则使用简单排序\n  if (len <= N) {\n    _insertionSort(arr, left, len);\n  } else {\n    // 使用三元法获取主元\n    let pivot = _mediant3(arr, left, right);\n    let i = left;\n    let j = right - 1;\n    while (true) {\n      while (arr[--j] > pivot);\n      while (arr[++i] < pivot);\n      if (i >= j) {\n        break;\n      }\n      _swap(arr, i, j);\n    }\n    _swap(arr, i, right - 1);\n    _quickSort(arr, left, i - 1);\n    _quickSort(arr, i + 1, right);\n  }\n}\n\n/**\n * 对数组进行快速排序\n */\nfunction quickSort(arr) {\n  _quickSort(arr, 0, arr.length - 1);\n}\n\n\n\n# 复杂度与稳定性\n\n快速排序是不稳定的排序算法\n\n平均算法时间复杂度：O(n*logn),最坏：O(N²)",normalizedContent:"# 快速排序\n\n若数组片段的长度大于 1，则随机从数组片段中取出一个元素作为主元(pivot)，将数组分为两份 a,b，这个位置之前的为一份(a)，这个位置之后的为一份(b)，将 a 中所有比 pivot 大的元素全部放到 b 中，将 b 中比 pivot 小的元素全部放大 a 中，然后分别递归的对数组片段 a 和 b 分别重复这个过程，直到所有的元素都有序即完成排序。\n\n快速排序是基于分治思想的排序算法。\n\n\n# 排序过程\n\n\n# 算法实现\n\n# 朴素法\n\n朴素法虽然比较好理解，也比较好记忆，但是实际上并不快，因为每次都简单的按特定的规则选取主元，如果主元的选择情况并不好的话，那我们的快速排序算法就跟冒泡排序差不多了。\n\n/**\n * 对数组片段进行快速排序\n * @param {array<number>} arr 需要进行排序的数组\n * @param {number} left 待排序数组片段的开始索引\n * @param {number} right 待排序数组片段的结束索引\n */\nfunction _quicksort(arr, left, right) {\n  // 如果数组片段的长度小于或者等于1，无需进行排序\n  if (left >= right) {\n    return;\n  }\n  // 随机取一个元素作为主元\n  let pivot = arr[left];\n  let i = left;\n  let j = right;\n  while (i < j) {\n    // 从数组片段右侧找比主元小的元素\n    while (i < j && arr[j] > pivot) {\n      j--;\n    }\n    // 说明此刻已经找到了比主元小的元素\n    if (i < j) {\n      arr[i] = arr[j];\n      // 缩小规模\n      i++;\n    }\n    // 从数组片段左侧找比主元大的元素\n    while (i < j && arr[i] < pivot) {\n      i++;\n    }\n    // 说明找到了比主元大的元素\n    if (i < j) {\n      arr[j] = arr[i];\n      j--;\n    }\n  }\n  // 当退出循环的时候，i == j, 此刻这个位置之前所有的元素都比主元小，这个位置之后的所有元素都比主元大，这个位置就是我们存放主元的位置\n  arr[i] = pivot;\n  // 递归的对左半部分元素进行快速排序\n  _quicksort(arr, left, i - 1);\n  // 递归的对右半部分元素进行快速排序\n  _quicksort(arr, i + 1, right);\n}\n\n/**\n * 对数组进行快速排序\n * @param {array<number>} arr 需要进行排序的数组\n */\nfunction quicksort(arr) {\n  _quicksort(arr, 0, arr.length - 1);\n}\n\n\n# 三元取中法\n\n/**\n * 定义数据的规模，如果少于这个量，则用简单排序，否则使用快速排序\n */\nconst n = 50;\n/**\n * 定义直接插入排序的方法，此直接插入排序方法和普通的插入排序有区别，因为是针对数组的某一个片段进行排序，因此需要引入一个offset偏移量参数\n * @param {array} arr 待排序数组\n * @param {number} offset 初始偏移量\n * @param {number} length 待排序片段的总长度\n */\nfunction _insertionsort(arr, offset, length) {\n  let temp, i;\n  for (let p = offset + 1; p < offset + length; p++) {\n    temp = arr[p];\n    for (i = p; i > offset && temp < arr[i - 1]; i--) {\n      arr[i] = arr[i - 1];\n    }\n    arr[i] = temp;\n  }\n}\n\n/**\n * 三元取中法获取主元\n */\nfunction _mediant3(arr, left, right) {\n  let center = math.floor((left + right) / 2);\n  if (arr[left] > arr[right]) {\n    _swap(arr, left, right);\n  }\n\n  if (arr[left] > arr[center]) {\n    _swap(arr, left, center);\n  }\n\n  if (arr[center] > arr[right]) {\n    _swap(arr, right, center);\n  }\n  // 并且把主元藏在数组片段的倒数第二位\n  _swap(arr, right - 1, center);\n  return arr[right - 1];\n}\n\n/**\n * 交换数组中的2个元素\n */\nfunction _swap(arr, i, j) {\n  let temp = arr[j];\n  arr[j] = arr[i];\n  arr[i] = temp;\n}\n\n/**\n * 对数组片段进行快速排序\n */\nfunction _quicksort(arr, left, right) {\n  // 数据片段的长度\n  let len = right - left + 1;\n  // 如果数据规模少于它，则使用简单排序\n  if (len <= n) {\n    _insertionsort(arr, left, len);\n  } else {\n    // 使用三元法获取主元\n    let pivot = _mediant3(arr, left, right);\n    let i = left;\n    let j = right - 1;\n    while (true) {\n      while (arr[--j] > pivot);\n      while (arr[++i] < pivot);\n      if (i >= j) {\n        break;\n      }\n      _swap(arr, i, j);\n    }\n    _swap(arr, i, right - 1);\n    _quicksort(arr, left, i - 1);\n    _quicksort(arr, i + 1, right);\n  }\n}\n\n/**\n * 对数组进行快速排序\n */\nfunction quicksort(arr) {\n  _quicksort(arr, 0, arr.length - 1);\n}\n\n\n\n# 复杂度与稳定性\n\n快速排序是不稳定的排序算法\n\n平均算法时间复杂度：o(n*logn),最坏：o(n²)",charsets:{cjk:!0}},{title:"选择排序",frontmatter:{},regularPath:"/data-structure/sort/selectionSort.html",relativePath:"data-structure/sort/selectionSort.md",key:"v-1a0d3835",path:"/data-structure/sort/selectionSort.html",headers:[{level:2,title:"选择排序",slug:"选择排序",normalizedTitle:"选择排序",charIndex:2},{level:3,title:"排序过程",slug:"排序过程",normalizedTitle:"排序过程",charIndex:86},{level:3,title:"算法实现",slug:"算法实现",normalizedTitle:"算法实现",charIndex:95},{level:3,title:"复杂度与稳定性",slug:"复杂度与稳定性",normalizedTitle:"复杂度与稳定性",charIndex:506}],headersStr:"选择排序 排序过程 算法实现 复杂度与稳定性",content:"# 选择排序\n\n从无序片段中找到最值所在的位置，将无序片段的第一个元素与最值元素进行交换，有序片段规模递增 1，无序片段规模递减 1，直到所有元素有序则完成排序。\n\n\n# 排序过程\n\n\n# 算法实现\n\n/**\n * 对数组进行选择排序\n * @param {Array<number>} arr 需要进行排序的数组\n */\nfunction selectionSort(arr) {\n  let temp = null;\n  for (let i = 0; i < arr.length; i++) {\n    // 假设无序片段的第一个元素是最值，从后面的序列中找一个最值与其交换\n    for (let j = i + 1; j < arr.length; j++) {\n      if (arr[j] < arr[i]) {\n        temp = arr[j];\n        arr[j] = arr[i];\n        arr[i] = temp;\n      }\n    }\n  }\n}\n\n\n需要注意的是，选择排序排在排序时，不是和相邻元素进行交换的，注意和冒泡排序的区别\n\n\n# 复杂度与稳定性\n\n选择排序的时间复杂度是O(n²)，是稳定的排序算法。",normalizedContent:"# 选择排序\n\n从无序片段中找到最值所在的位置，将无序片段的第一个元素与最值元素进行交换，有序片段规模递增 1，无序片段规模递减 1，直到所有元素有序则完成排序。\n\n\n# 排序过程\n\n\n# 算法实现\n\n/**\n * 对数组进行选择排序\n * @param {array<number>} arr 需要进行排序的数组\n */\nfunction selectionsort(arr) {\n  let temp = null;\n  for (let i = 0; i < arr.length; i++) {\n    // 假设无序片段的第一个元素是最值，从后面的序列中找一个最值与其交换\n    for (let j = i + 1; j < arr.length; j++) {\n      if (arr[j] < arr[i]) {\n        temp = arr[j];\n        arr[j] = arr[i];\n        arr[i] = temp;\n      }\n    }\n  }\n}\n\n\n需要注意的是，选择排序排在排序时，不是和相邻元素进行交换的，注意和冒泡排序的区别\n\n\n# 复杂度与稳定性\n\n选择排序的时间复杂度是o(n²)，是稳定的排序算法。",charsets:{cjk:!0}},{title:"基数排序",frontmatter:{},regularPath:"/data-structure/sort/radixSort.html",relativePath:"data-structure/sort/radixSort.md",key:"v-1fd34c35",path:"/data-structure/sort/radixSort.html",headers:[{level:2,title:"基数排序",slug:"基数排序",normalizedTitle:"基数排序",charIndex:2},{level:3,title:"排序过程(以LSD为例)",slug:"排序过程-以lsd为例",normalizedTitle:"排序过程(以lsd为例)",charIndex:201},{level:3,title:"算法实现",slug:"算法实现",normalizedTitle:"算法实现",charIndex:404},{level:3,title:"复杂度与稳定性",slug:"复杂度与稳定性",normalizedTitle:"复杂度与稳定性",charIndex:4609}],headersStr:"基数排序 排序过程(以LSD为例) 算法实现 复杂度与稳定性",content:"# 基数排序\n\n桶排序有一定的使用局限，假设有N=10个整数，每个数值在0到999之间（M有1000个不同的值），如果还是按照桶排序的做法的话，将需要1000个桶，这是非常浪费性能的。通过观察可以发现，这些数的位数都是0-9，可以建立10个桶，然后用每位数字做关键字利用桶排序的思路对其进行排序。\n\n基数排序可以算的上是在桶排序上的一种扩展，以待排数据的各位上的数据作为索引，以减少桶的数量。\n\n\n# 排序过程(以LSD为例)\n\n第一步：将待排序数据构建成链表\n\n第二步：依次摘取出链表的节点，从这个节点的数据的右边取出的第一位数字作为key，根据key的值将数据插入到对应key的桶中\n\n第三步：将桶中非空的链表重新构建成新的链表\n\n第四步：重复第二步的过程，取节点的数据的倒数第二位的数字作为key，若数据长度不够，则视为0。\n\n...\n\n第N步：将桶中的非空链表导依次回至原数组中，完成排序。\n\n\n# 算法实现\n\n最高位优先(Most Significant Digit first)法，简称 MSD 法：先按 k[1]（从左到右第一位） 排序分组，同一组中记录，关键码 k[1] 相等，再对各组按 k[2] 排序分成子组，之后，对后面的关键码继续这样的排序分组，直到按最次位关键码 k[d] 对各子组排序后。再将各组连接起来，便得到一个有序序列。\n\n最低位优先(Least Significant Digit first)法，简称 LSD 法：先从 k[d]（从右到左第一位） 开始排序，再对 k[d-1] 进行排序，依次重复，直到对 k[1] 排序后便得到一个有序序列。\n\n# LSD 算法实现\n\n/**\n * 次位优先基数排序\n * @param {number[]} arr\n */\nfunction LSDRadixSort(arr) {\n  /* 假设元素最多有MaxDigit个关键字，基数全是同样的Radix */\n  const MaxDigit = 3;\n  const Radix = 10;\n\n  /**\n   * 获取第offset位数的数数字\n   * @param {number} num\n   * @param {number} offset\n   * @returns\n   */\n  function getDigit(num, offset) {\n    let d, i;\n    for (i = 1; i <= offset; i++) {\n      d = num % Radix;\n      num = Number.parseInt(num / Radix);\n    }\n    return d;\n  }\n\n  /* 初始化每个桶为空链表 */\n  let buckets = Array.from({\n    length: Radix,\n  }).map(() => {\n    return {\n      head: null,\n      tail: null,\n    };\n  });\n  let list = null;\n\n  /* 将原始序列逆序存入初始链表List */\n  for (let i = 0; i < arr.length; i++) {\n    const node = {\n      value: arr[i],\n      next: list,\n    };\n    if (list === null) {\n      list = node;\n    } else {\n      node.next = list;\n      list = node;\n    }\n  }\n\n  /* 下面开始排序 */\n  /* 对数据的每一位循环处理 */\n  for (let pass = 1; pass <= MaxDigit; pass++) {\n    /* 下面是分配的过程 */\n    let node = list;\n    while (node) {\n      /* 获得当前元素的当前位数字 */\n      let Di = getDigit(node.value, pass);\n      /* 将node从list中摘除 */\n      let nextNode = node.next;\n      node.next = null;\n      /* 将node插入buckets[Di]号桶尾 */\n      if (buckets[Di].head == null) {\n        buckets[Di].head = buckets[Di].tail = node;\n      } else {\n        buckets[Di].tail.next = node;\n        buckets[Di].tail = node;\n      }\n      node = nextNode;\n    }\n    /* 下面是收集的过程 */\n    list = null;\n    /* 将每个桶的元素顺序收集入list */\n    for (let digit = Radix - 1; digit >= 0; digit--) {\n      /* 如果桶不为空 */\n      if (buckets[digit].head) {\n        /* 整桶插入list表头 */\n        buckets[digit].tail.next = list;\n        list = buckets[digit].head;\n        /* 清空桶 */\n        buckets[digit].head = buckets[digit].tail = null;\n      }\n    }\n  }\n  /* 将list导回arr */\n  let node = list;\n  let offset = 0;\n  while (node) {\n    arr[offset++] = node.value;\n    node = node.next;\n  }\n}\n\n\n# MSD 算法实现\n\nMSD算法实现采用的是递归方式进行实现的，可以看出，当处理到最后一位数的时候，待排序数据则一定是完成排序的，因此，只需要把它导回至原数组即可。\n\n/**\n * 主位优先基数排序\n * @param {number[]} arr\n */\nfunction MSDRadixSort(arr) {\n  /* 假设元素最多有MaxDigit个关键字，基数全是同样的Radix */\n  const MaxDigit = 3;\n  const Radix = 10;\n\n  function getDigit(num, offset) {\n    /* 默认次位D=1, 主位D<=MaxDigit */\n    let d, i;\n    for (i = 1; i <= offset; i++) {\n      d = num % Radix;\n      num = Number.parseInt(num / Radix);\n    }\n    return d;\n  }\n\n  function MSD(arr, left, right, D) {\n    /* 核心递归函数: 对arr[left]...arr[right]的第D位数进行排序 */\n    /* 初始化每个桶为空链表 */\n    let buckets = Array.from({\n      length: Radix,\n    }).map(() => {\n      return {\n        head: null,\n        tail: null,\n      };\n    });\n    let list = null;\n    /* 递归终止条件 */\n    if (D == 0) {\n      return;\n    }\n    /* 将原始序列逆序存入初始链表List */\n    for (let i = left; i <= right; i++) {\n      const node = {\n        val: arr[i],\n        next: list,\n      };\n      if (list === null) {\n        list = node;\n      } else {\n        node.next = list;\n        list = node;\n      }\n    }\n    /* 下面是分配的过程，以头插法分配 */\n    let node = list;\n    while (node) {\n      /* 获得当前元素的当前位数字 */\n      let Di = getDigit(node.val, D);\n      /* 从list中摘除 */\n      let nextNode = node.next;\n      node.next = null;\n      /* 插入buckets[Di]号桶 */\n      if (buckets[Di].head == null) {\n        buckets[Di].head = buckets[Di].tail = node;\n      } else {\n        node.next = buckets[Di].head;\n        buckets[Di].head = node;\n      }\n      node = nextNode;\n    }\n\n    /* 下面是收集的过程 */\n    /* i, j记录当前要处理的arr[]的左右端下标 */\n    let i = left,\n      j = i;\n    for (let digit = 0; digit < Radix; digit++) {\n      /* 对于每个桶 */\n      if (buckets[digit].head) {\n        /* 将非空的桶整桶倒入arr[], 递归排序 */\n        let node = buckets[digit].head;\n        while (node) {\n          arr[j++] = node.val;\n          node = node.next;\n        }\n        /* 递归对该桶数据排序, 位数减1 */\n        MSD(arr, i, j - 1, D - 1);\n        /* 为下一个桶对应的arr[]左端 */\n        i = j;\n      }\n    }\n  }\n\n  MSD(arr, 0, arr.length - 1, MaxDigit);\n}\n\n\n\n# 复杂度与稳定性\n\n基数排序是稳定的排序算法。\n\n基数排序的时间复杂度为 O(P(N+B))，其中P是最大数据关键字的位数，B是桶的量级，可以看出，当最大关键字的位数和桶的个数在比较小的时候，基数排序的时间复杂度是线性的。空间复杂度为O(N+B)，其中B是桶的量级。",normalizedContent:"# 基数排序\n\n桶排序有一定的使用局限，假设有n=10个整数，每个数值在0到999之间（m有1000个不同的值），如果还是按照桶排序的做法的话，将需要1000个桶，这是非常浪费性能的。通过观察可以发现，这些数的位数都是0-9，可以建立10个桶，然后用每位数字做关键字利用桶排序的思路对其进行排序。\n\n基数排序可以算的上是在桶排序上的一种扩展，以待排数据的各位上的数据作为索引，以减少桶的数量。\n\n\n# 排序过程(以lsd为例)\n\n第一步：将待排序数据构建成链表\n\n第二步：依次摘取出链表的节点，从这个节点的数据的右边取出的第一位数字作为key，根据key的值将数据插入到对应key的桶中\n\n第三步：将桶中非空的链表重新构建成新的链表\n\n第四步：重复第二步的过程，取节点的数据的倒数第二位的数字作为key，若数据长度不够，则视为0。\n\n...\n\n第n步：将桶中的非空链表导依次回至原数组中，完成排序。\n\n\n# 算法实现\n\n最高位优先(most significant digit first)法，简称 msd 法：先按 k[1]（从左到右第一位） 排序分组，同一组中记录，关键码 k[1] 相等，再对各组按 k[2] 排序分成子组，之后，对后面的关键码继续这样的排序分组，直到按最次位关键码 k[d] 对各子组排序后。再将各组连接起来，便得到一个有序序列。\n\n最低位优先(least significant digit first)法，简称 lsd 法：先从 k[d]（从右到左第一位） 开始排序，再对 k[d-1] 进行排序，依次重复，直到对 k[1] 排序后便得到一个有序序列。\n\n# lsd 算法实现\n\n/**\n * 次位优先基数排序\n * @param {number[]} arr\n */\nfunction lsdradixsort(arr) {\n  /* 假设元素最多有maxdigit个关键字，基数全是同样的radix */\n  const maxdigit = 3;\n  const radix = 10;\n\n  /**\n   * 获取第offset位数的数数字\n   * @param {number} num\n   * @param {number} offset\n   * @returns\n   */\n  function getdigit(num, offset) {\n    let d, i;\n    for (i = 1; i <= offset; i++) {\n      d = num % radix;\n      num = number.parseint(num / radix);\n    }\n    return d;\n  }\n\n  /* 初始化每个桶为空链表 */\n  let buckets = array.from({\n    length: radix,\n  }).map(() => {\n    return {\n      head: null,\n      tail: null,\n    };\n  });\n  let list = null;\n\n  /* 将原始序列逆序存入初始链表list */\n  for (let i = 0; i < arr.length; i++) {\n    const node = {\n      value: arr[i],\n      next: list,\n    };\n    if (list === null) {\n      list = node;\n    } else {\n      node.next = list;\n      list = node;\n    }\n  }\n\n  /* 下面开始排序 */\n  /* 对数据的每一位循环处理 */\n  for (let pass = 1; pass <= maxdigit; pass++) {\n    /* 下面是分配的过程 */\n    let node = list;\n    while (node) {\n      /* 获得当前元素的当前位数字 */\n      let di = getdigit(node.value, pass);\n      /* 将node从list中摘除 */\n      let nextnode = node.next;\n      node.next = null;\n      /* 将node插入buckets[di]号桶尾 */\n      if (buckets[di].head == null) {\n        buckets[di].head = buckets[di].tail = node;\n      } else {\n        buckets[di].tail.next = node;\n        buckets[di].tail = node;\n      }\n      node = nextnode;\n    }\n    /* 下面是收集的过程 */\n    list = null;\n    /* 将每个桶的元素顺序收集入list */\n    for (let digit = radix - 1; digit >= 0; digit--) {\n      /* 如果桶不为空 */\n      if (buckets[digit].head) {\n        /* 整桶插入list表头 */\n        buckets[digit].tail.next = list;\n        list = buckets[digit].head;\n        /* 清空桶 */\n        buckets[digit].head = buckets[digit].tail = null;\n      }\n    }\n  }\n  /* 将list导回arr */\n  let node = list;\n  let offset = 0;\n  while (node) {\n    arr[offset++] = node.value;\n    node = node.next;\n  }\n}\n\n\n# msd 算法实现\n\nmsd算法实现采用的是递归方式进行实现的，可以看出，当处理到最后一位数的时候，待排序数据则一定是完成排序的，因此，只需要把它导回至原数组即可。\n\n/**\n * 主位优先基数排序\n * @param {number[]} arr\n */\nfunction msdradixsort(arr) {\n  /* 假设元素最多有maxdigit个关键字，基数全是同样的radix */\n  const maxdigit = 3;\n  const radix = 10;\n\n  function getdigit(num, offset) {\n    /* 默认次位d=1, 主位d<=maxdigit */\n    let d, i;\n    for (i = 1; i <= offset; i++) {\n      d = num % radix;\n      num = number.parseint(num / radix);\n    }\n    return d;\n  }\n\n  function msd(arr, left, right, d) {\n    /* 核心递归函数: 对arr[left]...arr[right]的第d位数进行排序 */\n    /* 初始化每个桶为空链表 */\n    let buckets = array.from({\n      length: radix,\n    }).map(() => {\n      return {\n        head: null,\n        tail: null,\n      };\n    });\n    let list = null;\n    /* 递归终止条件 */\n    if (d == 0) {\n      return;\n    }\n    /* 将原始序列逆序存入初始链表list */\n    for (let i = left; i <= right; i++) {\n      const node = {\n        val: arr[i],\n        next: list,\n      };\n      if (list === null) {\n        list = node;\n      } else {\n        node.next = list;\n        list = node;\n      }\n    }\n    /* 下面是分配的过程，以头插法分配 */\n    let node = list;\n    while (node) {\n      /* 获得当前元素的当前位数字 */\n      let di = getdigit(node.val, d);\n      /* 从list中摘除 */\n      let nextnode = node.next;\n      node.next = null;\n      /* 插入buckets[di]号桶 */\n      if (buckets[di].head == null) {\n        buckets[di].head = buckets[di].tail = node;\n      } else {\n        node.next = buckets[di].head;\n        buckets[di].head = node;\n      }\n      node = nextnode;\n    }\n\n    /* 下面是收集的过程 */\n    /* i, j记录当前要处理的arr[]的左右端下标 */\n    let i = left,\n      j = i;\n    for (let digit = 0; digit < radix; digit++) {\n      /* 对于每个桶 */\n      if (buckets[digit].head) {\n        /* 将非空的桶整桶倒入arr[], 递归排序 */\n        let node = buckets[digit].head;\n        while (node) {\n          arr[j++] = node.val;\n          node = node.next;\n        }\n        /* 递归对该桶数据排序, 位数减1 */\n        msd(arr, i, j - 1, d - 1);\n        /* 为下一个桶对应的arr[]左端 */\n        i = j;\n      }\n    }\n  }\n\n  msd(arr, 0, arr.length - 1, maxdigit);\n}\n\n\n\n# 复杂度与稳定性\n\n基数排序是稳定的排序算法。\n\n基数排序的时间复杂度为 o(p(n+b))，其中p是最大数据关键字的位数，b是桶的量级，可以看出，当最大关键字的位数和桶的个数在比较小的时候，基数排序的时间复杂度是线性的。空间复杂度为o(n+b)，其中b是桶的量级。",charsets:{cjk:!0}},{title:"希尔排序",frontmatter:{},regularPath:"/data-structure/sort/shellSort.html",relativePath:"data-structure/sort/shellSort.md",key:"v-f36ef296",path:"/data-structure/sort/shellSort.html",headers:[{level:2,title:"希尔排序",slug:"希尔排序",normalizedTitle:"希尔排序",charIndex:2},{level:3,title:"排序过程",slug:"排序过程",normalizedTitle:"排序过程",charIndex:391},{level:3,title:"算法实现",slug:"算法实现",normalizedTitle:"算法实现",charIndex:400},{level:3,title:"复杂度与稳定性",slug:"复杂度与稳定性",normalizedTitle:"复杂度与稳定性",charIndex:862}],headersStr:"希尔排序 排序过程 算法实现 复杂度与稳定性",content:"# 希尔排序\n\n希尔排序的思路是消除数组中的逆序对，是在插入排序算法上的改良，其根据一定的规则选取增量序列 D(k)·D(k-1)·D(k-2)···1，增量序列的最后一项必须是 1,分别以对 D(k)至 1 为间距对数组进行插入排序(因为采取了对 D(k-1)为间距的插入排序之后并不会使得 D(k)为间距进行插入排序之后的结果变坏这是希尔排序的理论基础)，此刻数组会变得大致有序，最后再进行一次（间距 D 为 1）插入排序，从而使得数组有序。\n\n用通俗易懂的语言描述就是，举个例子，我先对数组使用一次 4 （D(k)）为间距的插入排序，得到一个结果，在这个结果上以 2(即 D(k-1), 这个间距完成之后，并不会让之前 4 为间距的插入排序的结果变坏) 为间距再进行一次插入排序，又的到一个结果，最后，我对数组使用一次纯粹(因为间隔是 1，所以说它纯粹)的插入排序。\n\n\n# 排序过程\n\n\n# 算法实现\n\n/**\n * 对数组进行希尔排序\n * @param {Array<number>} arr 需要进行排序的数组\n */\nfunction shellSort(arr) {\n  // 选取 N/2->N/4->N/8->···->1的增量序列\n  for (let D = Math.floor(arr.length / 2); D >= 1; D = Math.floor(D / 2)) {\n    // 以间距D对数组进行插入排序\n    for (let i = D; i < arr.length; i++) {\n      let cur = arr[i];\n      let j = i;\n      // 注意这儿需要取到等于\n      while (j >= D && arr[j - D] > cur) {\n        arr[j] = arr[j - D];\n        j -= D;\n      }\n      arr[j] = cur;\n    }\n  }\n}\n\n\n\n# 复杂度与稳定性\n\n希尔排序的时间复杂度是O(n*logn)，是不稳定的排序算法。\n\n希尔排序的算法复杂度的分析是个世纪难题，其算法的时间复杂度跟你选择的增量序列有关系，有兴趣的朋友可以自行了解这部分的内容。",normalizedContent:"# 希尔排序\n\n希尔排序的思路是消除数组中的逆序对，是在插入排序算法上的改良，其根据一定的规则选取增量序列 d(k)·d(k-1)·d(k-2)···1，增量序列的最后一项必须是 1,分别以对 d(k)至 1 为间距对数组进行插入排序(因为采取了对 d(k-1)为间距的插入排序之后并不会使得 d(k)为间距进行插入排序之后的结果变坏这是希尔排序的理论基础)，此刻数组会变得大致有序，最后再进行一次（间距 d 为 1）插入排序，从而使得数组有序。\n\n用通俗易懂的语言描述就是，举个例子，我先对数组使用一次 4 （d(k)）为间距的插入排序，得到一个结果，在这个结果上以 2(即 d(k-1), 这个间距完成之后，并不会让之前 4 为间距的插入排序的结果变坏) 为间距再进行一次插入排序，又的到一个结果，最后，我对数组使用一次纯粹(因为间隔是 1，所以说它纯粹)的插入排序。\n\n\n# 排序过程\n\n\n# 算法实现\n\n/**\n * 对数组进行希尔排序\n * @param {array<number>} arr 需要进行排序的数组\n */\nfunction shellsort(arr) {\n  // 选取 n/2->n/4->n/8->···->1的增量序列\n  for (let d = math.floor(arr.length / 2); d >= 1; d = math.floor(d / 2)) {\n    // 以间距d对数组进行插入排序\n    for (let i = d; i < arr.length; i++) {\n      let cur = arr[i];\n      let j = i;\n      // 注意这儿需要取到等于\n      while (j >= d && arr[j - d] > cur) {\n        arr[j] = arr[j - d];\n        j -= d;\n      }\n      arr[j] = cur;\n    }\n  }\n}\n\n\n\n# 复杂度与稳定性\n\n希尔排序的时间复杂度是o(n*logn)，是不稳定的排序算法。\n\n希尔排序的算法复杂度的分析是个世纪难题，其算法的时间复杂度跟你选择的增量序列有关系，有兴趣的朋友可以自行了解这部分的内容。",charsets:{cjk:!0}},{title:"栈",frontmatter:{},regularPath:"/data-structure/stack/desc.html",relativePath:"data-structure/stack/desc.md",key:"v-3feaf1d5",path:"/data-structure/stack/desc.html",headers:[{level:2,title:"栈",slug:"栈",normalizedTitle:"栈",charIndex:2},{level:2,title:"栈的通用数组实现",slug:"栈的通用数组实现",normalizedTitle:"栈的通用数组实现",charIndex:205},{level:2,title:"栈的通用链表实现（使用 TypeScript ）",slug:"栈的通用链表实现-使用-typescript",normalizedTitle:"栈的通用链表实现（使用 typescript ）",charIndex:978},{level:2,title:"栈的复杂度问题",slug:"栈的复杂度问题",normalizedTitle:"栈的复杂度问题",charIndex:2431},{level:2,title:"在 JavaScript 中使用栈",slug:"在-javascript-中使用栈",normalizedTitle:"在 javascript 中使用栈",charIndex:2752},{level:2,title:"栈的应用",slug:"栈的应用",normalizedTitle:"栈的应用",charIndex:3024}],headersStr:"栈 栈的通用数组实现 栈的通用链表实现（使用 TypeScript ） 栈的复杂度问题 在 JavaScript 中使用栈 栈的应用",content:'# 栈\n\n栈（stack）又名堆栈，它是一种运算受限的线性表。限定仅在表尾进行插入和删除操作的线性表。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。(copy 自百度百科)\n\n因此，栈具备一个重要的性质：后入先出。\n\n\n\n\n# 栈的通用数组实现\n\nclass Stack<T> {\n  private data: T[] = [];\n\n  get size(): number {\n    return this.data.length;\n  }\n\n  /* 获取栈顶元素 */\n  get top(): T | null {\n    return this.isEmpty() ? null : this.data[this.size-1];\n  }\n\n  /**\n   * 压栈\n   * @param ele\n   */\n  push(ele: T) {\n    let length = this.data.length;\n    // 让数组长度增加\n    this.data.length++;\n    // 将新加入的元素放在最后面\n    this.data[length] = ele;\n  }\n\n  /**\n   * 退栈\n   * @returns\n   */\n  pop() {\n    if (this.isEmpty()) {\n      throw new Error("can\'t pop from an empty stack");\n    }\n    let length = this.data.length;\n    // 取出最后一个元素\n    let ele = this.data[length - 1];\n    // 数组长度-1\n    this.data.length--;\n    return ele;\n  }\n\n  /**\n   * 判断栈是否为空\n   * @returns\n   */\n  isEmpty() {\n    return this.data.length === 0;\n  }\n}\n\n\n\n# 栈的通用链表实现（使用 TypeScript ）\n\n/**\n * 栈的节点元素定义，必须使用双向链表，便于我们查找前驱和后继元素\n */\ninterface LinkedListNode<T> {\n  next: LinkedListNode<T> | null;\n  prev: LinkedListNode<T> | null;\n  data: T;\n}\n\nclass Stack<T> {\n  /**\n   * 链表的头结点\n   */\n  private head: LinkedListNode<T> | null = null;\n\n  private length = 0;\n\n  public get size() {\n    return this.length;\n  }\n  /* 获取栈顶元素 */\n  public get top(): T | null {\n    return this.isEmpty() ? null : this.head!.data;\n  }\n\n  /**\n   * 压栈\n   * @param ele\n   */\n  public push(ele: T) {\n    const newNode: LinkedListNode<T> = {\n      next: null,\n      prev: null,\n      data: ele,\n    };\n    // 栈长度增加\n    this.length++;\n    // 如果一个元素都没有，直接让head指向这个节点\n    if (this.head === null) {\n      this.head = newNode;\n    } else {\n      newNode.next = this.head;\n      this.head.prev = newNode;\n      // 让原本的头指针指向新来的节点\n      this.head = newNode;\n    }\n  }\n\n  /**\n   * 退栈\n   */\n  public pop() {\n    if (this.isEmpty()) {\n      throw new Error("can not pop from an empty stack");\n    }\n    // 获取到头节点的后继节点\n    let head = this.head!.next;\n    // 栈中的元素\n    let ele = this.head!.data;\n    if (head) {\n      // 解开第一个节点的后继节点\n      this.head!.next = null;\n      // 解开第一个节点的后继节点的前驱节点\n      head.prev = null;\n      // 让栈首元素指向新的栈首元素\n      this.head = head;\n    } else {\n      this.head = null;\n    }\n    // 栈长度递减\n    this.length--;\n    return ele;\n  }\n\n  /**\n   * 栈是否为空\n   * @returns\n   */\n  public isEmpty() {\n    return this.length === 0;\n  }\n}\n\n\n\n\n\n# 栈的复杂度问题\n\n对于 JavaScript 来说，如果使用数组实现栈，我们的入栈操作看起来是O(1)，为什么要说“看起来”呢，因为对于 JS 来说数组长度是可变的，我们只是执行了一个数组的基本操作，并没有什么遍历之类的操作。但是对于如C#，Java这类语言，数组在初始化的时候，必须首先确定数组的长度，假如你一直不停的入栈，但是此刻数组已经没有空间容纳新来的内容了，此刻，我们便需要进行扩容，即申请一个更大的连续内存空间，然后把旧数组的内容拷贝到这块内容上来，此刻便会有一个O(n)的时间复杂度。\n\n如果使用链表实现，由于我们每次的操作总是顶端的元素，链表的增删操作的时间复杂度为O(1)，因此，这个实现在实际开发中有重要的意义。\n\n\n# 在 JavaScript 中使用栈\n\nJS 的数组同时具备栈和队列的特性，假设我们每次仅使用数组的push和pop方法，数组即栈。\n\nconst queue = [];\nqueue.push(1); //[1]\nqueue.push(12); //[1, 12]\nqueue.push(123); //[1, 12, 123]\n\nlet tail = queue.pop() // tail 为123\ntail = queue.pop() // tail为12\ntail = queue.pop() // tail为1, 此时栈已空\n\n\n\n# 栈的应用\n\n系统的堆栈就是栈的应用场景之一；\n\n在深度优先搜索中，我们也需要使用栈用来记住返回的路径；\n\n在我们需要逆序的场景时，我们也需要使用栈，如无权图的单源最短路问题。\n\n在词法分析时，我们也需要栈，如babel将我们写在 vue 组件中 template 的内容解析为AST；',normalizedContent:'# 栈\n\n栈（stack）又名堆栈，它是一种运算受限的线性表。限定仅在表尾进行插入和删除操作的线性表。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。(copy 自百度百科)\n\n因此，栈具备一个重要的性质：后入先出。\n\n\n\n\n# 栈的通用数组实现\n\nclass stack<t> {\n  private data: t[] = [];\n\n  get size(): number {\n    return this.data.length;\n  }\n\n  /* 获取栈顶元素 */\n  get top(): t | null {\n    return this.isempty() ? null : this.data[this.size-1];\n  }\n\n  /**\n   * 压栈\n   * @param ele\n   */\n  push(ele: t) {\n    let length = this.data.length;\n    // 让数组长度增加\n    this.data.length++;\n    // 将新加入的元素放在最后面\n    this.data[length] = ele;\n  }\n\n  /**\n   * 退栈\n   * @returns\n   */\n  pop() {\n    if (this.isempty()) {\n      throw new error("can\'t pop from an empty stack");\n    }\n    let length = this.data.length;\n    // 取出最后一个元素\n    let ele = this.data[length - 1];\n    // 数组长度-1\n    this.data.length--;\n    return ele;\n  }\n\n  /**\n   * 判断栈是否为空\n   * @returns\n   */\n  isempty() {\n    return this.data.length === 0;\n  }\n}\n\n\n\n# 栈的通用链表实现（使用 typescript ）\n\n/**\n * 栈的节点元素定义，必须使用双向链表，便于我们查找前驱和后继元素\n */\ninterface linkedlistnode<t> {\n  next: linkedlistnode<t> | null;\n  prev: linkedlistnode<t> | null;\n  data: t;\n}\n\nclass stack<t> {\n  /**\n   * 链表的头结点\n   */\n  private head: linkedlistnode<t> | null = null;\n\n  private length = 0;\n\n  public get size() {\n    return this.length;\n  }\n  /* 获取栈顶元素 */\n  public get top(): t | null {\n    return this.isempty() ? null : this.head!.data;\n  }\n\n  /**\n   * 压栈\n   * @param ele\n   */\n  public push(ele: t) {\n    const newnode: linkedlistnode<t> = {\n      next: null,\n      prev: null,\n      data: ele,\n    };\n    // 栈长度增加\n    this.length++;\n    // 如果一个元素都没有，直接让head指向这个节点\n    if (this.head === null) {\n      this.head = newnode;\n    } else {\n      newnode.next = this.head;\n      this.head.prev = newnode;\n      // 让原本的头指针指向新来的节点\n      this.head = newnode;\n    }\n  }\n\n  /**\n   * 退栈\n   */\n  public pop() {\n    if (this.isempty()) {\n      throw new error("can not pop from an empty stack");\n    }\n    // 获取到头节点的后继节点\n    let head = this.head!.next;\n    // 栈中的元素\n    let ele = this.head!.data;\n    if (head) {\n      // 解开第一个节点的后继节点\n      this.head!.next = null;\n      // 解开第一个节点的后继节点的前驱节点\n      head.prev = null;\n      // 让栈首元素指向新的栈首元素\n      this.head = head;\n    } else {\n      this.head = null;\n    }\n    // 栈长度递减\n    this.length--;\n    return ele;\n  }\n\n  /**\n   * 栈是否为空\n   * @returns\n   */\n  public isempty() {\n    return this.length === 0;\n  }\n}\n\n\n\n\n\n# 栈的复杂度问题\n\n对于 javascript 来说，如果使用数组实现栈，我们的入栈操作看起来是o(1)，为什么要说“看起来”呢，因为对于 js 来说数组长度是可变的，我们只是执行了一个数组的基本操作，并没有什么遍历之类的操作。但是对于如c#，java这类语言，数组在初始化的时候，必须首先确定数组的长度，假如你一直不停的入栈，但是此刻数组已经没有空间容纳新来的内容了，此刻，我们便需要进行扩容，即申请一个更大的连续内存空间，然后把旧数组的内容拷贝到这块内容上来，此刻便会有一个o(n)的时间复杂度。\n\n如果使用链表实现，由于我们每次的操作总是顶端的元素，链表的增删操作的时间复杂度为o(1)，因此，这个实现在实际开发中有重要的意义。\n\n\n# 在 javascript 中使用栈\n\njs 的数组同时具备栈和队列的特性，假设我们每次仅使用数组的push和pop方法，数组即栈。\n\nconst queue = [];\nqueue.push(1); //[1]\nqueue.push(12); //[1, 12]\nqueue.push(123); //[1, 12, 123]\n\nlet tail = queue.pop() // tail 为123\ntail = queue.pop() // tail为12\ntail = queue.pop() // tail为1, 此时栈已空\n\n\n\n# 栈的应用\n\n系统的堆栈就是栈的应用场景之一；\n\n在深度优先搜索中，我们也需要使用栈用来记住返回的路径；\n\n在我们需要逆序的场景时，我们也需要使用栈，如无权图的单源最短路问题。\n\n在词法分析时，我们也需要栈，如babel将我们写在 vue 组件中 template 的内容解析为ast；',charsets:{cjk:!0}},{title:"栈的应用之 DFS",frontmatter:{},regularPath:"/data-structure/stack/dfs.html",relativePath:"data-structure/stack/dfs.md",key:"v-5428026a",path:"/data-structure/stack/dfs.html",headers:[{level:2,title:"栈的应用之 DFS",slug:"栈的应用之-dfs",normalizedTitle:"栈的应用之 dfs",charIndex:2},{level:3,title:"先序遍历二叉树",slug:"先序遍历二叉树",normalizedTitle:"先序遍历二叉树",charIndex:52},{level:3,title:"DFS 遍历 N-叉树",slug:"dfs-遍历-n-叉树",normalizedTitle:"dfs 遍历 n-叉树",charIndex:643}],headersStr:"栈的应用之 DFS 先序遍历二叉树 DFS 遍历 N-叉树",content:'# 栈的应用之 DFS\n\n在 DFS 中，如果我们不用递归，需要自己用一个栈来模拟系统的堆栈。\n\n\n# 先序遍历二叉树\n\n/**\n * 先序非递归遍历二叉树\n * @param {TreeNode<number>} tree\n */\nfunction treePreOrder(tree) {\n  if (!tree) {\n    console.log("empty tree!");\n    return;\n  }\n  // 定义一个栈用于模拟系统提供的堆栈\n  let stack = [];\n  // 让node指向树的跟节点，准备开始遍历\n  let node = tree;\n  // 如果树不空，或者栈中还有内容，则应该继续进行遍历\n  while (stack.length > 0 || node) {\n    // 如果node节点不为空的话，不断的向左压栈，直到为空\n    while (node) {\n      stack.push(node);\n      console.log(node.data);\n      node = node.left;\n    }\n    // 向左走到头了，若当前栈中还有内容，则从栈中取出一个内容，从当前内容的右子树继续遍历\n    if (stack.length > 0) {\n      node = stack.pop();\n      node = node.right;\n    }\n  }\n}\n\n\n\n# DFS 遍历 N-叉树\n\n/**\n * N叉树非递归深度优先遍历\n * @param { NTreeNode<number>[] } treeNodes\n */\nfunction dfsVisit(treeNodes) {\n  if (!Array.isArray(treeNodes) || treeNodes.length === 0) {\n    console.warn("treeNodes empty");\n    return;\n  }\n  let stack = [];\n  // 用来记住每个节点的下一个兄弟节点\n  let nextSiblingMap = new Map();\n  // 建立下一个兄弟节点的关系\n  for (let i = 0; i < treeNodes.length; i++) {\n    const curNode = treeNodes[i];\n    const nextNode = treeNodes[i + 1] || null;\n    nextSiblingMap.set(curNode, nextNode);\n  }\n  let treeNode = treeNodes[0];\n  while (stack.length || treeNode) {\n    // 当节点为空时，说明已经迭代到最叶节点了，退出循环\n    while (treeNode) {\n      console.log(treeNode.data);\n      stack.push(treeNode);\n      let subNodes = Array.isArray(treeNode.children) ? treeNode.children : [];\n      // 每一层都建立下一个兄弟节点的关系\n      for (let k = 0; k < subNodes.length; k++) {\n        const curNode = subNodes[k];\n        const nextNode = subNodes[k + 1] || null;\n        nextSiblingMap.set(curNode, nextNode);\n      }\n      // 下滤节点\n      treeNode = subNodes[0] || null;\n    }\n    if (stack.length) {\n      treeNode = stack.pop();\n      // 根据当前节点到map里面找当前节点的下一个兄弟节点\n      let nextSiblingNode = nextSiblingMap.get(treeNode);\n      if (nextSiblingNode) {\n        treeNode = nextSiblingNode;\n      } else {\n        // 如果没有下一个兄弟节点了，说明需要回退到父亲节点，父亲节点处理完成之后，准备处理父亲节点的下一个兄弟节点\n        if (stack.length) {\n          treeNode = stack.pop();\n          // 继续切换到父节点的兄弟节点\n          treeNode = nextSiblingMap.get(treeNode);\n        } else {\n          // 已经将所有的节点处理完成，可以功成身退\n          treeNode = null;\n        }\n      }\n    }\n  }\n}\n',normalizedContent:'# 栈的应用之 dfs\n\n在 dfs 中，如果我们不用递归，需要自己用一个栈来模拟系统的堆栈。\n\n\n# 先序遍历二叉树\n\n/**\n * 先序非递归遍历二叉树\n * @param {treenode<number>} tree\n */\nfunction treepreorder(tree) {\n  if (!tree) {\n    console.log("empty tree!");\n    return;\n  }\n  // 定义一个栈用于模拟系统提供的堆栈\n  let stack = [];\n  // 让node指向树的跟节点，准备开始遍历\n  let node = tree;\n  // 如果树不空，或者栈中还有内容，则应该继续进行遍历\n  while (stack.length > 0 || node) {\n    // 如果node节点不为空的话，不断的向左压栈，直到为空\n    while (node) {\n      stack.push(node);\n      console.log(node.data);\n      node = node.left;\n    }\n    // 向左走到头了，若当前栈中还有内容，则从栈中取出一个内容，从当前内容的右子树继续遍历\n    if (stack.length > 0) {\n      node = stack.pop();\n      node = node.right;\n    }\n  }\n}\n\n\n\n# dfs 遍历 n-叉树\n\n/**\n * n叉树非递归深度优先遍历\n * @param { ntreenode<number>[] } treenodes\n */\nfunction dfsvisit(treenodes) {\n  if (!array.isarray(treenodes) || treenodes.length === 0) {\n    console.warn("treenodes empty");\n    return;\n  }\n  let stack = [];\n  // 用来记住每个节点的下一个兄弟节点\n  let nextsiblingmap = new map();\n  // 建立下一个兄弟节点的关系\n  for (let i = 0; i < treenodes.length; i++) {\n    const curnode = treenodes[i];\n    const nextnode = treenodes[i + 1] || null;\n    nextsiblingmap.set(curnode, nextnode);\n  }\n  let treenode = treenodes[0];\n  while (stack.length || treenode) {\n    // 当节点为空时，说明已经迭代到最叶节点了，退出循环\n    while (treenode) {\n      console.log(treenode.data);\n      stack.push(treenode);\n      let subnodes = array.isarray(treenode.children) ? treenode.children : [];\n      // 每一层都建立下一个兄弟节点的关系\n      for (let k = 0; k < subnodes.length; k++) {\n        const curnode = subnodes[k];\n        const nextnode = subnodes[k + 1] || null;\n        nextsiblingmap.set(curnode, nextnode);\n      }\n      // 下滤节点\n      treenode = subnodes[0] || null;\n    }\n    if (stack.length) {\n      treenode = stack.pop();\n      // 根据当前节点到map里面找当前节点的下一个兄弟节点\n      let nextsiblingnode = nextsiblingmap.get(treenode);\n      if (nextsiblingnode) {\n        treenode = nextsiblingnode;\n      } else {\n        // 如果没有下一个兄弟节点了，说明需要回退到父亲节点，父亲节点处理完成之后，准备处理父亲节点的下一个兄弟节点\n        if (stack.length) {\n          treenode = stack.pop();\n          // 继续切换到父节点的兄弟节点\n          treenode = nextsiblingmap.get(treenode);\n        } else {\n          // 已经将所有的节点处理完成，可以功成身退\n          treenode = null;\n        }\n      }\n    }\n  }\n}\n',charsets:{cjk:!0}},{title:"单调栈",frontmatter:{},regularPath:"/data-structure/stack/monotonous-stack.html",relativePath:"data-structure/stack/monotonous-stack.md",key:"v-21516316",path:"/data-structure/stack/monotonous-stack.html",headers:[{level:2,title:"单调栈",slug:"单调栈",normalizedTitle:"单调栈",charIndex:2}],headersStr:"单调栈",content:"# 单调栈\n\n建设中，敬请期待...",normalizedContent:"# 单调栈\n\n建设中，敬请期待...",charsets:{cjk:!0}},{title:"栈的应用之逆序",frontmatter:{},regularPath:"/data-structure/stack/reverse.html",relativePath:"data-structure/stack/reverse.md",key:"v-495d0d29",path:"/data-structure/stack/reverse.html",headers:[{level:2,title:"栈的应用之逆序",slug:"栈的应用之逆序",normalizedTitle:"栈的应用之逆序",charIndex:2},{level:3,title:"两数相加",slug:"两数相加",normalizedTitle:"两数相加",charIndex:57},{level:3,title:"无权图的单源最短路径",slug:"无权图的单源最短路径",normalizedTitle:"无权图的单源最短路径",charIndex:2273}],headersStr:"栈的应用之逆序 两数相加 无权图的单源最短路径",content:'# 栈的应用之逆序\n\n在实际开发中，我们一旦遇到逆序的问题，可以想当然的先思考一下是否可以用栈进行处理。\n\n\n# 两数相加\n\n# 描述\n\n给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。\n\n你可以假设除了数字 0 之外，这两个数字都不会以零开头。\n\n# 思路分析\n\n因为是逆序，所以我们会想到用栈，分别遍历两个链表，用两个栈存储对应的节点，则问题转化为类似合并 2 个有序数组的问题。\n\n# 算法实现\n\n链表节点定义如下：\n\ninterface ListNode<T> {\n  next: ListNode<T> | null;\n  val: T;\n}\n\n\n/**\n * @param {ListNode} l1\n * @param {ListNode} l2\n * @return {ListNode}\n */\nvar addTwoNumbers = function (l1, l2) {\n  const stack1 = [];\n  const stack2 = [];\n  let node1 = l1;\n  let node2 = l2;\n  while (node1 && node2) {\n    stack1.push(node1);\n    stack2.push(node2);\n    node1 = node1.next;\n    node2 = node2.next;\n  }\n\n  while (node1) {\n    stack1.push(node1);\n    node1 = node1.next;\n  }\n\n  while (node2) {\n    stack2.push(node2);\n    node2 = node2.next;\n  }\n\n  let needIncrease = false;\n  let newHead = null;\n  while (stack1.length && stack2.length) {\n    const num1Node = stack1.pop();\n    const num2Node = stack2.pop();\n    let val = num1Node.val + num2Node.val + (needIncrease ? 1 : 0);\n    needIncrease = false;\n    if (val >= 10) {\n      val = val - 10;\n      needIncrease = true;\n    }\n    const tempNode = {\n      val,\n      next: null,\n    };\n    if (!newHead) {\n      newHead = tempNode;\n    } else {\n      tempNode.next = newHead;\n      newHead = tempNode;\n    }\n  }\n  while (stack1.length) {\n    const num1Node = stack1.pop();\n    let val = num1Node.val + (needIncrease ? 1 : 0);\n    needIncrease = false;\n    if (val >= 10) {\n      val = val - 10;\n      needIncrease = true;\n    }\n    const tempNode = {\n      val,\n      next: null,\n    };\n    if (!newHead) {\n      newHead = tempNode;\n    } else {\n      tempNode.next = newHead;\n      newHead = tempNode;\n    }\n  }\n  while (stack2.length) {\n    const num2Node = stack2.pop();\n    let val = num2Node.val + (needIncrease ? 1 : 0);\n    needIncrease = false;\n    if (val >= 10) {\n      val = val - 10;\n      needIncrease = true;\n    }\n    const tempNode = {\n      val,\n      next: null,\n    };\n    if (!newHead) {\n      newHead = tempNode;\n    } else {\n      tempNode.next = newHead;\n      newHead = tempNode;\n    }\n  }\n  if (needIncrease) {\n    const tempNode = {\n      val: 1,\n      next: null,\n    };\n    tempNode.next = newHead;\n    newHead = tempNode;\n  }\n  return newHead;\n};\n\n\n\n# 无权图的单源最短路径\n\n对于有这样的图：\n\n\n\n假设我们用如下方式表示图：\n\nclass Edge {\n  constructor(name) {\n    this.name = name;\n  }\n  /**\n   * 边的编号\n   */\n  name;\n  /**\n   * 起始点\n   * @type {Vertex}\n   */\n  from;\n  /**\n   * 终止点\n   * @type {Vertex}\n   */\n  to;\n}\n\nclass Vertex {\n  /**\n   * 城市名称\n   */\n  cityName;\n  /**\n   * 邻接点\n   */\n  siblings = [];\n  constructor(cityName) {\n    this.cityName = cityName;\n  }\n}\n\nclass Graph {\n  vertexList = [];\n  edgeList = [];\n  addVertex(v) {\n    this.vertexList.push(v);\n  }\n\n  /**\n   * 增加边\n   * @param {Vertex} from\n   * @param {Vertex} to\n   */\n  addEdge(from, to) {\n    const name = `${from.cityName}至${to.cityName}`;\n    const edge = new Edge(name);\n    this.edgeList.push(edge);\n    from.siblings.push(to);\n    to.siblings.push(from);\n  }\n}\n\nconst g = new Graph();\nconst beijing = new Vertex("北京");\nconst nanjing = new Vertex("南京");\nconst guangzhou = new Vertex("广州");\nconst shenzhen = new Vertex("深圳");\nconst hongkong = new Vertex("香港");\nconst chengdu = new Vertex("成都");\nconst xian = new Vertex("西安");\nconst urumchi = new Vertex("乌鲁木齐");\n\n/**\n * 将城市加入到图中\n */\ng.addVertex(beijing);\ng.addVertex(nanjing);\ng.addVertex(guangzhou);\ng.addVertex(shenzhen);\ng.addVertex(hongkong);\ng.addVertex(chengdu);\ng.addVertex(xian);\ng.addVertex(urumchi);\n/**\n * 建立连接关系\n */\ng.addEdge(beijing, nanjing);\ng.addEdge(beijing, xian);\ng.addEdge(nanjing, guangzhou);\ng.addEdge(guangzhou, shenzhen);\ng.addEdge(guangzhou, hongkong);\ng.addEdge(hongkong, shenzhen);\ng.addEdge(chengdu, guangzhou);\ng.addEdge(chengdu, xian);\ng.addEdge(urumchi, xian);\ng.addEdge(urumchi, beijing);\n/**\n * 单源无权图的最短路算法\n * @param {Vertex} start\n * @param {Vertex} end\n */\nfunction unweightedShortestPath(start, end) {\n  const queue = [];\n  const dist = new Map();\n  const path = new Map();\n  dist.set(start, 0);\n  queue.push(start);\n  while (queue.length > 0) {\n    let vertex = queue.shift();\n    for (let i = 0; i < vertex.siblings.length; i++) {\n      let adjoinVertex = vertex.siblings[i];\n      /* 若adjoinVertex未被访问过 */\n      if (typeof dist.get(adjoinVertex) === "undefined") {\n        /* 将这个点到start的距离更新 */\n        dist.set(adjoinVertex, dist.get(vertex) + 1);\n        /* 将这个点记录在S到adjoinVertex的路径上 */\n        path.set(adjoinVertex, vertex);\n        queue.push(adjoinVertex);\n      }\n    }\n  }\n  // 获取终点的最短路径长度\n  const distance = dist.get(end);\n  // 使用栈记住终点\n  const stack = [end];\n  let preVertex = path.get(end);\n  // 沿途处理从终点到起点所经过的路径\n  while (preVertex) {\n    stack.push(preVertex);\n    preVertex = path.get(preVertex);\n  }\n  // 经过逆序，得到了正确的路径\n  let via = "";\n  while (stack.length) {\n    const city = stack.pop();\n    via += "->" + city.cityName;\n  }\n  return { distance, path: via.replace(/(^->)|(->$)/g, "") };\n}\n',normalizedContent:'# 栈的应用之逆序\n\n在实际开发中，我们一旦遇到逆序的问题，可以想当然的先思考一下是否可以用栈进行处理。\n\n\n# 两数相加\n\n# 描述\n\n给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。\n\n你可以假设除了数字 0 之外，这两个数字都不会以零开头。\n\n# 思路分析\n\n因为是逆序，所以我们会想到用栈，分别遍历两个链表，用两个栈存储对应的节点，则问题转化为类似合并 2 个有序数组的问题。\n\n# 算法实现\n\n链表节点定义如下：\n\ninterface listnode<t> {\n  next: listnode<t> | null;\n  val: t;\n}\n\n\n/**\n * @param {listnode} l1\n * @param {listnode} l2\n * @return {listnode}\n */\nvar addtwonumbers = function (l1, l2) {\n  const stack1 = [];\n  const stack2 = [];\n  let node1 = l1;\n  let node2 = l2;\n  while (node1 && node2) {\n    stack1.push(node1);\n    stack2.push(node2);\n    node1 = node1.next;\n    node2 = node2.next;\n  }\n\n  while (node1) {\n    stack1.push(node1);\n    node1 = node1.next;\n  }\n\n  while (node2) {\n    stack2.push(node2);\n    node2 = node2.next;\n  }\n\n  let needincrease = false;\n  let newhead = null;\n  while (stack1.length && stack2.length) {\n    const num1node = stack1.pop();\n    const num2node = stack2.pop();\n    let val = num1node.val + num2node.val + (needincrease ? 1 : 0);\n    needincrease = false;\n    if (val >= 10) {\n      val = val - 10;\n      needincrease = true;\n    }\n    const tempnode = {\n      val,\n      next: null,\n    };\n    if (!newhead) {\n      newhead = tempnode;\n    } else {\n      tempnode.next = newhead;\n      newhead = tempnode;\n    }\n  }\n  while (stack1.length) {\n    const num1node = stack1.pop();\n    let val = num1node.val + (needincrease ? 1 : 0);\n    needincrease = false;\n    if (val >= 10) {\n      val = val - 10;\n      needincrease = true;\n    }\n    const tempnode = {\n      val,\n      next: null,\n    };\n    if (!newhead) {\n      newhead = tempnode;\n    } else {\n      tempnode.next = newhead;\n      newhead = tempnode;\n    }\n  }\n  while (stack2.length) {\n    const num2node = stack2.pop();\n    let val = num2node.val + (needincrease ? 1 : 0);\n    needincrease = false;\n    if (val >= 10) {\n      val = val - 10;\n      needincrease = true;\n    }\n    const tempnode = {\n      val,\n      next: null,\n    };\n    if (!newhead) {\n      newhead = tempnode;\n    } else {\n      tempnode.next = newhead;\n      newhead = tempnode;\n    }\n  }\n  if (needincrease) {\n    const tempnode = {\n      val: 1,\n      next: null,\n    };\n    tempnode.next = newhead;\n    newhead = tempnode;\n  }\n  return newhead;\n};\n\n\n\n# 无权图的单源最短路径\n\n对于有这样的图：\n\n\n\n假设我们用如下方式表示图：\n\nclass edge {\n  constructor(name) {\n    this.name = name;\n  }\n  /**\n   * 边的编号\n   */\n  name;\n  /**\n   * 起始点\n   * @type {vertex}\n   */\n  from;\n  /**\n   * 终止点\n   * @type {vertex}\n   */\n  to;\n}\n\nclass vertex {\n  /**\n   * 城市名称\n   */\n  cityname;\n  /**\n   * 邻接点\n   */\n  siblings = [];\n  constructor(cityname) {\n    this.cityname = cityname;\n  }\n}\n\nclass graph {\n  vertexlist = [];\n  edgelist = [];\n  addvertex(v) {\n    this.vertexlist.push(v);\n  }\n\n  /**\n   * 增加边\n   * @param {vertex} from\n   * @param {vertex} to\n   */\n  addedge(from, to) {\n    const name = `${from.cityname}至${to.cityname}`;\n    const edge = new edge(name);\n    this.edgelist.push(edge);\n    from.siblings.push(to);\n    to.siblings.push(from);\n  }\n}\n\nconst g = new graph();\nconst beijing = new vertex("北京");\nconst nanjing = new vertex("南京");\nconst guangzhou = new vertex("广州");\nconst shenzhen = new vertex("深圳");\nconst hongkong = new vertex("香港");\nconst chengdu = new vertex("成都");\nconst xian = new vertex("西安");\nconst urumchi = new vertex("乌鲁木齐");\n\n/**\n * 将城市加入到图中\n */\ng.addvertex(beijing);\ng.addvertex(nanjing);\ng.addvertex(guangzhou);\ng.addvertex(shenzhen);\ng.addvertex(hongkong);\ng.addvertex(chengdu);\ng.addvertex(xian);\ng.addvertex(urumchi);\n/**\n * 建立连接关系\n */\ng.addedge(beijing, nanjing);\ng.addedge(beijing, xian);\ng.addedge(nanjing, guangzhou);\ng.addedge(guangzhou, shenzhen);\ng.addedge(guangzhou, hongkong);\ng.addedge(hongkong, shenzhen);\ng.addedge(chengdu, guangzhou);\ng.addedge(chengdu, xian);\ng.addedge(urumchi, xian);\ng.addedge(urumchi, beijing);\n/**\n * 单源无权图的最短路算法\n * @param {vertex} start\n * @param {vertex} end\n */\nfunction unweightedshortestpath(start, end) {\n  const queue = [];\n  const dist = new map();\n  const path = new map();\n  dist.set(start, 0);\n  queue.push(start);\n  while (queue.length > 0) {\n    let vertex = queue.shift();\n    for (let i = 0; i < vertex.siblings.length; i++) {\n      let adjoinvertex = vertex.siblings[i];\n      /* 若adjoinvertex未被访问过 */\n      if (typeof dist.get(adjoinvertex) === "undefined") {\n        /* 将这个点到start的距离更新 */\n        dist.set(adjoinvertex, dist.get(vertex) + 1);\n        /* 将这个点记录在s到adjoinvertex的路径上 */\n        path.set(adjoinvertex, vertex);\n        queue.push(adjoinvertex);\n      }\n    }\n  }\n  // 获取终点的最短路径长度\n  const distance = dist.get(end);\n  // 使用栈记住终点\n  const stack = [end];\n  let prevertex = path.get(end);\n  // 沿途处理从终点到起点所经过的路径\n  while (prevertex) {\n    stack.push(prevertex);\n    prevertex = path.get(prevertex);\n  }\n  // 经过逆序，得到了正确的路径\n  let via = "";\n  while (stack.length) {\n    const city = stack.pop();\n    via += "->" + city.cityname;\n  }\n  return { distance, path: via.replace(/(^->)|(->$)/g, "") };\n}\n',charsets:{cjk:!0}},{title:"栈的应用之词法分析",frontmatter:{},regularPath:"/data-structure/stack/syntaxAnalysis.html",relativePath:"data-structure/stack/syntaxAnalysis.md",key:"v-78408355",path:"/data-structure/stack/syntaxAnalysis.html",headers:[{level:2,title:"栈的应用之词法分析",slug:"栈的应用之词法分析",normalizedTitle:"栈的应用之词法分析",charIndex:2},{level:3,title:"1. 序列化与反序列化二叉树",slug:"_1-序列化与反序列化二叉树",normalizedTitle:"1. 序列化与反序列化二叉树",charIndex:16},{level:3,title:"2. 四则运算求值",slug:"_2-四则运算求值",normalizedTitle:"2. 四则运算求值",charIndex:3344}],headersStr:"栈的应用之词法分析 1. 序列化与反序列化二叉树 2. 四则运算求值",content:'# 栈的应用之词法分析\n\n\n# 1. 序列化与反序列化二叉树\n\n二叉树节点的定义如下：\n\ninterface TreeNode<T> {\n  left: TreeNode | null;\n  right: TreeNode | null;\n  val: T;\n}\n\n\n# 分析\n\n序列化二叉树的代码较为简单，只要对数据结构有一点儿入门的同学一定能够解答出来。但是反序列化就相当不简单了。因为序列化之后的结果是一层一层的{和}的嵌套。首先假设输入一定合法，怎么样确定解析规则呢？每当我们遇到一个}，向前推导，那么一定是可以遇到一个{的。如果一个二叉树有左右子树，那么一定就存在左右子节点。这段字符串里面也一定有相应的字段。（但是也有可能没有，或者是left:null这样的情况），我们把左右儿子节点解析出来以后，先按规则存下来，然后，再解析根节点存下来，重复这样一个过程，最终存结果的容器里面只会有一个节点，那就是根节点，即可得到最终的结果。\n\n# 代码实现：\n\n/**\n * 序列化二叉树\n * @param {TreeNode} root\n * @return {string}\n */\nvar serialize = function (root) {\n  if (typeof root === "undefined") {\n    return "";\n  } else if (root === null) {\n    return "null";\n  } else {\n    const leftStr = serialize(root.left);\n    const rightStr = serialize(root.right);\n    let str = `val:${root.val}`;\n    if (leftStr !== "") {\n      str += `,left:${leftStr}`;\n    }\n    if (rightStr !== "") {\n      str += `,right:${rightStr}`;\n    }\n    return `{${str}}`;\n  }\n};\n\n/**\n * 反序列化二叉树\n * @param {string} data\n * @return {TreeNode}\n */\nvar deserialize = function (data) {\n  try {\n    // 定义一个栈，用于词法分析\n    const stack = [];\n    // 定义一个节点栈，用于存储解析的结果，你也可以不用栈，根据自己的需要即可\n    const nodeStack = [];\n    let offset = 0;\n    while (offset < data.length) {\n      let char = data[offset];\n      // 如果遇到后大括号，需要退栈，退到遇到前花括号为止\n      if (char === "}") {\n        let leftChar = stack.pop();\n        let tempStr = "";\n        while (stack.length && leftChar != "{") {\n          tempStr = leftChar + tempStr;\n          leftChar = stack.pop();\n        }\n        /*\n          经过上述操作之后，我们可以得到一个不含嵌套的树节点字符串\n          主要有这几种case:\n          "val: 1"\n          "val: 1, left: null",\n          "val: 1, left: null, right: null",\n          "val: 1, left: , right: "\n        */\n        // 定义解析val域的正则\n        let valArr = tempStr.match(/val:\\s*(-?\\d+)/);\n        // 定义解析左子树的正则\n        let leftArr = tempStr.match(/left:\\s*(null)?/);\n        // 定义解析右子树的正则\n        let rightArr = tempStr.match(/right:\\s*(null)?/);\n        // 申明一个初始的空节点，一会根据提取的内容覆盖其属性\n        let node = { val: Infinity };\n        // 解析val\n        if (!Array.isArray(valArr)) {\n          throw `the data source is not valid`;\n        } else {\n          node.val = Number.parseInt(valArr[1]);\n        }\n        // 解析左子树，但左子树不一定存在\n        if (Array.isArray(rightArr)) {\n          if (rightArr[1] === "null") {\n            node.right = null;\n          } else {\n            const rightChild = nodeStack.pop();\n            if (typeof rightChild === "undefined") {\n              throw `the data source is not valid`;\n            }\n            node.right = rightChild;\n          }\n        }\n        // 解析右子树，但右子树不一定存在\n        if (Array.isArray(leftArr)) {\n          if (leftArr[1] === "null") {\n            node.left = null;\n          } else {\n            const leftChild = nodeStack.pop();\n            if (typeof leftChild === "undefined") {\n              throw `the data source is not valid`;\n            }\n            node.left = leftChild;\n          }\n        }\n        /* 把解析出来的节点加入节点栈 */\n        nodeStack.push(node);\n      } else {\n        // 否则内容直接入栈\n        stack.push(char);\n      }\n      offset++;\n    }\n    if (nodeStack.length != 1) {\n      throw `the data source is not valid`;\n    }\n    // 在输入合法的前提下，节点栈中的第一个节点就是树的根节点\n    return nodeStack[0];\n  } catch (exp) {\n    console.log(exp);\n    return null;\n  }\n};\n\n\n有了这个基础，相信有能力的同学一定能够手写JSON.parse()。\n\n\n# 2. 四则运算求值\n\n# 描述：\n\n输入一个表达式（用字符串表示），求这个表达式的值。 保证字符串中的有效字符包括[‘0’-‘9’],‘+’,‘-’, ‘*’,‘/’ ,‘(’， ‘)’,‘[’, ‘]’,‘{’ ,‘}’。且表达式一定合法。\n\n例如: 3+2*{1+2*[-4/(8-6)+7]}，最终结果为 25。\n\n# 分析：\n\n题设已经说了输入有效。那我们就不考虑异常 case 了，对于一个正常的不带{},[],()表达式，比较好求。如1+2/-10*4-3,只需要正常的求，首先还是要遍历，第一轮我们主要考虑*和/,一轮之后,得到的结果便是1+-0.8-3，然后第二轮我们可以直接按顺序算便可以得到结果（这儿还有个取巧的方法，用eval，哈哈哈）。如果带上{},[],()这类运算符号的话，我们是否可以像我们之前的思维方式一样还是分轮进行解析。首先把()之间的表达式的值求出来，再填到表达式里面去。接着处理[],再者处理{},最后，问题转化成了我们最开始讨论的不带括号的表达式了。\n\n# 算法实现：\n\n/**\n * 根据不带括号的表达式求值\n * @param {string} str\n */\nvar calc = function (str) {\n  // TODO: 暂时先用eval实现，后期优化为自行处理\n  return eval(str);\n};\n\n/**\n * 四则运算求值\n * @param {string} s\n */\nvar arithmetic = function (s) {\n  let offset = 0;\n  let stack = [];\n  while (offset < s.length) {\n    let char = s[offset];\n    if (char === ")") {\n      // 解析()之间的内容\n      let tmpStr = "";\n      let tmpChar = stack.pop();\n      while (tmpChar != "(") {\n        tmpStr = tmpChar + tmpStr;\n        tmpChar = stack.pop();\n      }\n      stack.push(eval(tmpStr));\n    } else if (char === "]") {\n      // 解析[]之间的内容\n      let tmpStr = "";\n      let tmpChar = stack.pop();\n      while (tmpChar != "[") {\n        tmpStr = tmpChar + tmpStr;\n        tmpChar = stack.pop();\n      }\n      stack.push(calc(tmpStr));\n    } else if (char === "}") {\n      // 解析{}\n      let tmpStr = "";\n      let tmpChar = stack.pop();\n      while (tmpChar != "{") {\n        tmpStr = tmpChar + tmpStr;\n        tmpChar = stack.pop();\n      }\n      stack.push(calc(tmpStr));\n    } else {\n      stack.push(char);\n    }\n    offset++;\n  }\n  // 解析不带括号的表达式的结果\n  let tmpStr = "";\n  while (stack.length) {\n    tmpStr = stack.pop() + tmpStr;\n  }\n  let val = calc(tmpStr);\n  return val;\n};\n',normalizedContent:'# 栈的应用之词法分析\n\n\n# 1. 序列化与反序列化二叉树\n\n二叉树节点的定义如下：\n\ninterface treenode<t> {\n  left: treenode | null;\n  right: treenode | null;\n  val: t;\n}\n\n\n# 分析\n\n序列化二叉树的代码较为简单，只要对数据结构有一点儿入门的同学一定能够解答出来。但是反序列化就相当不简单了。因为序列化之后的结果是一层一层的{和}的嵌套。首先假设输入一定合法，怎么样确定解析规则呢？每当我们遇到一个}，向前推导，那么一定是可以遇到一个{的。如果一个二叉树有左右子树，那么一定就存在左右子节点。这段字符串里面也一定有相应的字段。（但是也有可能没有，或者是left:null这样的情况），我们把左右儿子节点解析出来以后，先按规则存下来，然后，再解析根节点存下来，重复这样一个过程，最终存结果的容器里面只会有一个节点，那就是根节点，即可得到最终的结果。\n\n# 代码实现：\n\n/**\n * 序列化二叉树\n * @param {treenode} root\n * @return {string}\n */\nvar serialize = function (root) {\n  if (typeof root === "undefined") {\n    return "";\n  } else if (root === null) {\n    return "null";\n  } else {\n    const leftstr = serialize(root.left);\n    const rightstr = serialize(root.right);\n    let str = `val:${root.val}`;\n    if (leftstr !== "") {\n      str += `,left:${leftstr}`;\n    }\n    if (rightstr !== "") {\n      str += `,right:${rightstr}`;\n    }\n    return `{${str}}`;\n  }\n};\n\n/**\n * 反序列化二叉树\n * @param {string} data\n * @return {treenode}\n */\nvar deserialize = function (data) {\n  try {\n    // 定义一个栈，用于词法分析\n    const stack = [];\n    // 定义一个节点栈，用于存储解析的结果，你也可以不用栈，根据自己的需要即可\n    const nodestack = [];\n    let offset = 0;\n    while (offset < data.length) {\n      let char = data[offset];\n      // 如果遇到后大括号，需要退栈，退到遇到前花括号为止\n      if (char === "}") {\n        let leftchar = stack.pop();\n        let tempstr = "";\n        while (stack.length && leftchar != "{") {\n          tempstr = leftchar + tempstr;\n          leftchar = stack.pop();\n        }\n        /*\n          经过上述操作之后，我们可以得到一个不含嵌套的树节点字符串\n          主要有这几种case:\n          "val: 1"\n          "val: 1, left: null",\n          "val: 1, left: null, right: null",\n          "val: 1, left: , right: "\n        */\n        // 定义解析val域的正则\n        let valarr = tempstr.match(/val:\\s*(-?\\d+)/);\n        // 定义解析左子树的正则\n        let leftarr = tempstr.match(/left:\\s*(null)?/);\n        // 定义解析右子树的正则\n        let rightarr = tempstr.match(/right:\\s*(null)?/);\n        // 申明一个初始的空节点，一会根据提取的内容覆盖其属性\n        let node = { val: infinity };\n        // 解析val\n        if (!array.isarray(valarr)) {\n          throw `the data source is not valid`;\n        } else {\n          node.val = number.parseint(valarr[1]);\n        }\n        // 解析左子树，但左子树不一定存在\n        if (array.isarray(rightarr)) {\n          if (rightarr[1] === "null") {\n            node.right = null;\n          } else {\n            const rightchild = nodestack.pop();\n            if (typeof rightchild === "undefined") {\n              throw `the data source is not valid`;\n            }\n            node.right = rightchild;\n          }\n        }\n        // 解析右子树，但右子树不一定存在\n        if (array.isarray(leftarr)) {\n          if (leftarr[1] === "null") {\n            node.left = null;\n          } else {\n            const leftchild = nodestack.pop();\n            if (typeof leftchild === "undefined") {\n              throw `the data source is not valid`;\n            }\n            node.left = leftchild;\n          }\n        }\n        /* 把解析出来的节点加入节点栈 */\n        nodestack.push(node);\n      } else {\n        // 否则内容直接入栈\n        stack.push(char);\n      }\n      offset++;\n    }\n    if (nodestack.length != 1) {\n      throw `the data source is not valid`;\n    }\n    // 在输入合法的前提下，节点栈中的第一个节点就是树的根节点\n    return nodestack[0];\n  } catch (exp) {\n    console.log(exp);\n    return null;\n  }\n};\n\n\n有了这个基础，相信有能力的同学一定能够手写json.parse()。\n\n\n# 2. 四则运算求值\n\n# 描述：\n\n输入一个表达式（用字符串表示），求这个表达式的值。 保证字符串中的有效字符包括[‘0’-‘9’],‘+’,‘-’, ‘*’,‘/’ ,‘(’， ‘)’,‘[’, ‘]’,‘{’ ,‘}’。且表达式一定合法。\n\n例如: 3+2*{1+2*[-4/(8-6)+7]}，最终结果为 25。\n\n# 分析：\n\n题设已经说了输入有效。那我们就不考虑异常 case 了，对于一个正常的不带{},[],()表达式，比较好求。如1+2/-10*4-3,只需要正常的求，首先还是要遍历，第一轮我们主要考虑*和/,一轮之后,得到的结果便是1+-0.8-3，然后第二轮我们可以直接按顺序算便可以得到结果（这儿还有个取巧的方法，用eval，哈哈哈）。如果带上{},[],()这类运算符号的话，我们是否可以像我们之前的思维方式一样还是分轮进行解析。首先把()之间的表达式的值求出来，再填到表达式里面去。接着处理[],再者处理{},最后，问题转化成了我们最开始讨论的不带括号的表达式了。\n\n# 算法实现：\n\n/**\n * 根据不带括号的表达式求值\n * @param {string} str\n */\nvar calc = function (str) {\n  // todo: 暂时先用eval实现，后期优化为自行处理\n  return eval(str);\n};\n\n/**\n * 四则运算求值\n * @param {string} s\n */\nvar arithmetic = function (s) {\n  let offset = 0;\n  let stack = [];\n  while (offset < s.length) {\n    let char = s[offset];\n    if (char === ")") {\n      // 解析()之间的内容\n      let tmpstr = "";\n      let tmpchar = stack.pop();\n      while (tmpchar != "(") {\n        tmpstr = tmpchar + tmpstr;\n        tmpchar = stack.pop();\n      }\n      stack.push(eval(tmpstr));\n    } else if (char === "]") {\n      // 解析[]之间的内容\n      let tmpstr = "";\n      let tmpchar = stack.pop();\n      while (tmpchar != "[") {\n        tmpstr = tmpchar + tmpstr;\n        tmpchar = stack.pop();\n      }\n      stack.push(calc(tmpstr));\n    } else if (char === "}") {\n      // 解析{}\n      let tmpstr = "";\n      let tmpchar = stack.pop();\n      while (tmpchar != "{") {\n        tmpstr = tmpchar + tmpstr;\n        tmpchar = stack.pop();\n      }\n      stack.push(calc(tmpstr));\n    } else {\n      stack.push(char);\n    }\n    offset++;\n  }\n  // 解析不带括号的表达式的结果\n  let tmpstr = "";\n  while (stack.length) {\n    tmpstr = stack.pop() + tmpstr;\n  }\n  let val = calc(tmpstr);\n  return val;\n};\n',charsets:{cjk:!0}},{title:"KMP 算法",frontmatter:{},regularPath:"/data-structure/string/KMP.html",relativePath:"data-structure/string/KMP.md",key:"v-0f60c256",path:"/data-structure/string/KMP.html",headers:[{level:2,title:"KMP 算法",slug:"kmp-算法",normalizedTitle:"kmp 算法",charIndex:2},{level:3,title:"朴素法",slug:"朴素法",normalizedTitle:"朴素法",charIndex:339},{level:3,title:"KMP",slug:"kmp",normalizedTitle:"kmp",charIndex:2}],headersStr:"KMP 算法 朴素法 KMP",content:'# KMP 算法\n\nKMP 算法是什么？主要解决的问题是在给定一个字符串 template,快速的发现是否在 template 存在子串 pattern。\n\nKMP 算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris 和 V.R.Pratt 提出的，所以由 3 位杰出的前辈的名字各取了一个字母得名。在某些版本的《数据结构》这门课中，存在于“串”这一章节。\n\nKMP 算法是出了名的难，其思想可能大多数同学都能掌握，但关键是求next数组，很多同学都没有理解为什么简短的几行代码就可实现神奇的效果，网上的博客或视频大多对于next数组对求解过程也是一笔带过，而KMP算法如果你不搞懂对next数组求解过程，那么你就不算真正懂得的 KMP 算法。\n\n\n# 朴素法\n\n在介绍 KMP 算法之前不得不提蛮力匹配算法，因为了解了蛮力匹配算法才能通过比较知道 KMP 算法的优势。\n\n之所以说它是蛮力匹配算法，设定 2 个指针，指针表示在主串上移动的位置，j 指针表示在目标字符串上的位置，就是通过一位一位的去比较，如果匹配失败，则 j 指针归 0，i 指针向后挪动一位，这其实并没有把之前子串上已经匹配到的内容利用起来，所以这个算法是快不起来的。\n\nfunction subString(tpl, pattern) {\n  let m = tpl.length;\n  let n = pattern.length;\n  for (let i = 0; i < m - n; ++i) {\n    let j = 0;\n    while (j < n && tpl[i + j] == pattern[j]) {\n      ++j;\n    }\n    if (j == n) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n\n其大概得算法流程如下：\n\n\n"\n"\n当遇到不匹配的时候，i指针向后移动一位，j指针回溯\n\n蛮力匹配的问题就出在这个i,j指针的回溯上，因此`KMP`算法的核心就是解决回溯。\n\n# 朴素法的复杂度分析\n\n朴素法是简单的两个循环相叠加，因此其时间复杂度是O(m*n)，m 和 n 分别为两个字符串的长度\n\n\n# KMP\n\nKMP 算法的聪明之处就是可以把之前已经匹配过的信息利用起来，用最小的代价知道我们下一次应该从哪个位置开始匹配。\n\n\n\n假设现在在 x 和 c 的位置发生失配，那么，我们只需要把模式串pattern向前进 c 之前的最长前后公共子串的长度，即图上的 ab 子串。\n\n因为只有前后公共子串的话，你挪动过去才有可能相配啊。简单一点儿的例子就好比一把两头都可以拧螺丝的扳手，你把这头拿去拧螺丝，跟把另外一头拿去拧螺丝，必须得跟螺丝的规格相配，如果都配的话，那么就无所谓你用那一头拧了。\n\n在明白匹配失败之后的操作之后，我们就需要去计算这个最长前后公共子串，即上文所说的next数组。\n\n为什么我们要先求next数组呢，可以看到，我们的pattern字符串其实是给定的，在匹配的过程中是不会发生变化的，那么，在每次失配的时候，我们一定知道当前失配位置前面是什么样的字符串，利用哈希表的思想，我们可以事先把每个位置的最长公共前后缀先算出来。\n\n接下来就是给出 KMP 算法最关键的 next 数组 求解过程：\n\n假设我们有如下pattern: abcabca\n\n对于子串a（即在匹配的时候，在它的下一个位置 b这个位置发生失配，后面也是这个意思，不赘述），没有公共前后缀，所以计为 0。\n\n对于子串ab，前缀有a, 后缀b,没有相同的前后缀，计为 0；\n\n对于子串abc，前缀a,ab； 后缀c,bc,没有相同的前后缀，计为 0；\n\n对于子串abca，前缀有a，ab，abc；后缀有a，ca，bca，最大公共前后缀a，计为 1；\n\n对于子串abcab，前缀有a，ab，abc，abca；后缀有b，ab，cab，bcab，最大公共前后缀ab，计为 2；\n\n对于子串abcabc，前缀有a，ab，abc，abca，abcab；后缀有c，bc，abc，cabc，bcabc，最大公共前后缀abc，计为 3；\n\n其实最后一个我们是没有多大的算的必要的，因为要在最后一个 a 的后面一位发生失配，这个可能吗？都匹配成功了，还需要什么匹配呢，但是只不过我们算next数组的过程中，没有必要去对这个进行特值处理，为了方便编程，所以还是会将其计算在里面。\n\n所以对于子串abcabca，前缀有a，ab，abc，abca，abcab，abcabc；后缀有 a, ca，bca，abca，cabca，bcabca，最大公共前后缀a，计为 1；\n\n列一个表格，如下：\n\nA   B   C   A   B   C   A\n0   0   0   1   2   3   1\n\n刚才我们已经知道最长公共前后缀的求解方法了，接下来开始思考一下怎么用代码去实现。\n\n首先看一下，比较朴素的方法。\n\n首部取一个字符，尾部取一个字符比较，继续重复这个操作，2 个字符进行比较，不断继续重复这个操作，直到 j 个字符串的长度。\n\n\n\n上述算法的比较次数为：1+2+3+...+(j+1)/2+...+j = O(j²)\n\n这个方法效率不高，因此我们得采取另外的方案，接下来看看三位巨擘是怎么做的。\n\n更好的这个方案是动态规划，主要是利用了回溯的思想。\n\n在阅读下文之前，请先在心里面默念三遍next 数组保存的是子串的最长公共前后缀，加深一下大脑的认识。\n\n下面我们来理解它是怎么样的一个流程：\n\n数组next[X]指向的是前缀，i指向的是后缀，假设在某个时刻如下：\n\n\n\n假设前面最长相同前缀为next[j-1]，最长相同后缀是i-1这个位置，那么，如果next[j-1]+1这个位置和i这个位置上的字符相同的话，那我们至少可以粗略的得出一个结论：\n\nnext[j] >= next[j-1]+1。\n\n有没有可能next[j] > next[j-1]+1呢？\n\n我们先假设可能存在这样的情况\n\n注意：下图中红色色块和蓝色色块并不是它们相等的意思，是描述这两个色块加入能否让next[j]变得更长。\n\n\n\n那么，根据假设，则应该存在：\n\n两个蓝色的色块应该相等才对\n\n\n\n如这种场景：\n\n\n\n那么，对于长度为[0, i-1]的子串，最长公共前缀应该指向next[j-1] + 1才对，而不应该是指向next[j-1]。所以我们可以得出结论，每新增一个字符，最长公共前缀只有可能增加 1，即： next[j-1] + 1 = next[j]\n\n上面我们讨论了匹配成功的情况，那么，如果失配呢？比如下图：\n\n\n\n因为我们的 next[j-1]是一个递推计算的结果，我们此刻是能够知道next[next[j-1]]的。（想不明白的同学可以在此多思考一下，动态规划的问题本来就非常难以让人理解，想想刚才让你默念三遍的话）。 如下图所示：\n\n\n\n因此，我们可以回到如下状态重新开启匹配，如下图所示：\n\n\n\n因此，又重复回到了我们刚才的流程。\n\n这个解题思路非常复杂，它是回溯和动态规划思想的结合，一般回溯都会和递归挂钩，但是递归有时候会存在大量的重复计算，所以会考虑逆向思维将其转变为动规规划问题，这些都是算法里面较难且非常锻炼思维能力的章节（我个人感受是在面试中遇到动态规划算法题，就全靠你和公司的缘分了），这方面比较小白的朋友，可以尝试学习这门课程，相信你学过之后，再回头查看这篇博客，你会有新的理解。\n\n整个求解next数组的算法的实现过程如下：\n\n/**\n * 生成next数组\n * @param {String} pattern\n * @param {Number[]} next\n */\nfunction genNext(pattern) {\n  let m = pattern.length;\n  let next = [];\n  // 因为第一个字符串没有前后缀，所以可以直接赋值0，相当于动态规划可直接求得的初始条件\n  next[0] = 0;\n  //当取一个字符的时候，肯定是一个前后缀都没有的\n  for (let i = 1, j = 0; i < m; ++i) {\n    // 如果没有匹配到，递归的去求之前的最大前缀\n    // 退出循环条件是 k大于0 并且当前位置的字符串要是一样的\n    while (j > 0 && pattern[i] !== pattern[j]) {\n      // 回溯，找到上一次的最大前后缀的长度\n      j = next[j - 1];\n    }\n    // 如果匹配到了，最大的前后缀+1\n    if (pattern[i] == pattern[j]) {\n      j++;\n    }\n    // 求出当前字符串的最大公共前后缀，更新next数组\n    next[i] = j;\n  }\n  return next;\n}\n\n\n看到这儿，如果你全部都理解了的话，恭喜你，其实你已经掌握KMP算法了。\n\nKMP算法搜索流程非常简单，其的实现如下：\n\n/**\n * KMP-Search\n * @param {String} tpl\n * @param {String} pattern\n * @returns\n */\nfunction kmpSearch(tpl, pattern) {\n  let n = tpl.length,\n    m = pattern.length;\n  let pos = -1;\n  let next = genNext(pattern);\n  for (let i = 0, q = 0; i < n; i++) {\n    /* 不断回溯，直到存在最长公共前后缀或回退到0，此处思路和求next数组求解思路一致。 */\n    while (q > 0 && pattern[q] != tpl[i]) {\n      q = next[q - 1];\n    }\n    // 如果当前字符和模式字符串指针位上的字符相等, 模式指针后移一位\n    if (pattern[q] == tpl[i]) {\n      q++;\n    }\n    /*\n     *  上述2个if不能交换位置，必须先判断是否匹配失败，才能继续进行匹配，如果交换的话，q指针先向后移动了一位，当前循环并没有结束，i指针还在前一个位置，此刻出现了错位，那么函数将不会正常运行。\n     */\n    // 如果模式字符串指针的位置走到了最后一位，则说明匹配成功了\n    if (q == m) {\n      // 因为当前匹配的位置实际上是在pattern的length-1的位置上\n      pos = i - m + 1;\n      break;\n    }\n  }\n  return pos;\n}\n\n\n# KMP 的复杂度分析\n\n在生成next数组的时候，我们看到是一个for循环和while循环嵌套，可以看到的是，每次j最坏退到0，但是只有在pattern[i] === pattern[j]的时候，j 才会递增的。j回退的总次数，是不会超过j增加的总次数的，最坏情况下，j累加的总次数是不会超过m的，所以while循环的执行次数是不会超过O(m)。所以生成next数组的时间复杂度是O(m)。在搜索过程中，同理。因此算法总的时间复杂度为 O(m+n)，m 和 n 分别为两个字符串的长度；\n\n因为生成next数组占用了一定的空间，所以空间复杂度为O(m)，m 为子字符串的长度。',normalizedContent:'# kmp 算法\n\nkmp 算法是什么？主要解决的问题是在给定一个字符串 template,快速的发现是否在 template 存在子串 pattern。\n\nkmp 算法是一种改进的字符串匹配算法，由d.e.knuth，j.h.morris 和 v.r.pratt 提出的，所以由 3 位杰出的前辈的名字各取了一个字母得名。在某些版本的《数据结构》这门课中，存在于“串”这一章节。\n\nkmp 算法是出了名的难，其思想可能大多数同学都能掌握，但关键是求next数组，很多同学都没有理解为什么简短的几行代码就可实现神奇的效果，网上的博客或视频大多对于next数组对求解过程也是一笔带过，而kmp算法如果你不搞懂对next数组求解过程，那么你就不算真正懂得的 kmp 算法。\n\n\n# 朴素法\n\n在介绍 kmp 算法之前不得不提蛮力匹配算法，因为了解了蛮力匹配算法才能通过比较知道 kmp 算法的优势。\n\n之所以说它是蛮力匹配算法，设定 2 个指针，指针表示在主串上移动的位置，j 指针表示在目标字符串上的位置，就是通过一位一位的去比较，如果匹配失败，则 j 指针归 0，i 指针向后挪动一位，这其实并没有把之前子串上已经匹配到的内容利用起来，所以这个算法是快不起来的。\n\nfunction substring(tpl, pattern) {\n  let m = tpl.length;\n  let n = pattern.length;\n  for (let i = 0; i < m - n; ++i) {\n    let j = 0;\n    while (j < n && tpl[i + j] == pattern[j]) {\n      ++j;\n    }\n    if (j == n) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n\n其大概得算法流程如下：\n\n\n"\n"\n当遇到不匹配的时候，i指针向后移动一位，j指针回溯\n\n蛮力匹配的问题就出在这个i,j指针的回溯上，因此`kmp`算法的核心就是解决回溯。\n\n# 朴素法的复杂度分析\n\n朴素法是简单的两个循环相叠加，因此其时间复杂度是o(m*n)，m 和 n 分别为两个字符串的长度\n\n\n# kmp\n\nkmp 算法的聪明之处就是可以把之前已经匹配过的信息利用起来，用最小的代价知道我们下一次应该从哪个位置开始匹配。\n\n\n\n假设现在在 x 和 c 的位置发生失配，那么，我们只需要把模式串pattern向前进 c 之前的最长前后公共子串的长度，即图上的 ab 子串。\n\n因为只有前后公共子串的话，你挪动过去才有可能相配啊。简单一点儿的例子就好比一把两头都可以拧螺丝的扳手，你把这头拿去拧螺丝，跟把另外一头拿去拧螺丝，必须得跟螺丝的规格相配，如果都配的话，那么就无所谓你用那一头拧了。\n\n在明白匹配失败之后的操作之后，我们就需要去计算这个最长前后公共子串，即上文所说的next数组。\n\n为什么我们要先求next数组呢，可以看到，我们的pattern字符串其实是给定的，在匹配的过程中是不会发生变化的，那么，在每次失配的时候，我们一定知道当前失配位置前面是什么样的字符串，利用哈希表的思想，我们可以事先把每个位置的最长公共前后缀先算出来。\n\n接下来就是给出 kmp 算法最关键的 next 数组 求解过程：\n\n假设我们有如下pattern: abcabca\n\n对于子串a（即在匹配的时候，在它的下一个位置 b这个位置发生失配，后面也是这个意思，不赘述），没有公共前后缀，所以计为 0。\n\n对于子串ab，前缀有a, 后缀b,没有相同的前后缀，计为 0；\n\n对于子串abc，前缀a,ab； 后缀c,bc,没有相同的前后缀，计为 0；\n\n对于子串abca，前缀有a，ab，abc；后缀有a，ca，bca，最大公共前后缀a，计为 1；\n\n对于子串abcab，前缀有a，ab，abc，abca；后缀有b，ab，cab，bcab，最大公共前后缀ab，计为 2；\n\n对于子串abcabc，前缀有a，ab，abc，abca，abcab；后缀有c，bc，abc，cabc，bcabc，最大公共前后缀abc，计为 3；\n\n其实最后一个我们是没有多大的算的必要的，因为要在最后一个 a 的后面一位发生失配，这个可能吗？都匹配成功了，还需要什么匹配呢，但是只不过我们算next数组的过程中，没有必要去对这个进行特值处理，为了方便编程，所以还是会将其计算在里面。\n\n所以对于子串abcabca，前缀有a，ab，abc，abca，abcab，abcabc；后缀有 a, ca，bca，abca，cabca，bcabca，最大公共前后缀a，计为 1；\n\n列一个表格，如下：\n\na   b   c   a   b   c   a\n0   0   0   1   2   3   1\n\n刚才我们已经知道最长公共前后缀的求解方法了，接下来开始思考一下怎么用代码去实现。\n\n首先看一下，比较朴素的方法。\n\n首部取一个字符，尾部取一个字符比较，继续重复这个操作，2 个字符进行比较，不断继续重复这个操作，直到 j 个字符串的长度。\n\n\n\n上述算法的比较次数为：1+2+3+...+(j+1)/2+...+j = o(j²)\n\n这个方法效率不高，因此我们得采取另外的方案，接下来看看三位巨擘是怎么做的。\n\n更好的这个方案是动态规划，主要是利用了回溯的思想。\n\n在阅读下文之前，请先在心里面默念三遍next 数组保存的是子串的最长公共前后缀，加深一下大脑的认识。\n\n下面我们来理解它是怎么样的一个流程：\n\n数组next[x]指向的是前缀，i指向的是后缀，假设在某个时刻如下：\n\n\n\n假设前面最长相同前缀为next[j-1]，最长相同后缀是i-1这个位置，那么，如果next[j-1]+1这个位置和i这个位置上的字符相同的话，那我们至少可以粗略的得出一个结论：\n\nnext[j] >= next[j-1]+1。\n\n有没有可能next[j] > next[j-1]+1呢？\n\n我们先假设可能存在这样的情况\n\n注意：下图中红色色块和蓝色色块并不是它们相等的意思，是描述这两个色块加入能否让next[j]变得更长。\n\n\n\n那么，根据假设，则应该存在：\n\n两个蓝色的色块应该相等才对\n\n\n\n如这种场景：\n\n\n\n那么，对于长度为[0, i-1]的子串，最长公共前缀应该指向next[j-1] + 1才对，而不应该是指向next[j-1]。所以我们可以得出结论，每新增一个字符，最长公共前缀只有可能增加 1，即： next[j-1] + 1 = next[j]\n\n上面我们讨论了匹配成功的情况，那么，如果失配呢？比如下图：\n\n\n\n因为我们的 next[j-1]是一个递推计算的结果，我们此刻是能够知道next[next[j-1]]的。（想不明白的同学可以在此多思考一下，动态规划的问题本来就非常难以让人理解，想想刚才让你默念三遍的话）。 如下图所示：\n\n\n\n因此，我们可以回到如下状态重新开启匹配，如下图所示：\n\n\n\n因此，又重复回到了我们刚才的流程。\n\n这个解题思路非常复杂，它是回溯和动态规划思想的结合，一般回溯都会和递归挂钩，但是递归有时候会存在大量的重复计算，所以会考虑逆向思维将其转变为动规规划问题，这些都是算法里面较难且非常锻炼思维能力的章节（我个人感受是在面试中遇到动态规划算法题，就全靠你和公司的缘分了），这方面比较小白的朋友，可以尝试学习这门课程，相信你学过之后，再回头查看这篇博客，你会有新的理解。\n\n整个求解next数组的算法的实现过程如下：\n\n/**\n * 生成next数组\n * @param {string} pattern\n * @param {number[]} next\n */\nfunction gennext(pattern) {\n  let m = pattern.length;\n  let next = [];\n  // 因为第一个字符串没有前后缀，所以可以直接赋值0，相当于动态规划可直接求得的初始条件\n  next[0] = 0;\n  //当取一个字符的时候，肯定是一个前后缀都没有的\n  for (let i = 1, j = 0; i < m; ++i) {\n    // 如果没有匹配到，递归的去求之前的最大前缀\n    // 退出循环条件是 k大于0 并且当前位置的字符串要是一样的\n    while (j > 0 && pattern[i] !== pattern[j]) {\n      // 回溯，找到上一次的最大前后缀的长度\n      j = next[j - 1];\n    }\n    // 如果匹配到了，最大的前后缀+1\n    if (pattern[i] == pattern[j]) {\n      j++;\n    }\n    // 求出当前字符串的最大公共前后缀，更新next数组\n    next[i] = j;\n  }\n  return next;\n}\n\n\n看到这儿，如果你全部都理解了的话，恭喜你，其实你已经掌握kmp算法了。\n\nkmp算法搜索流程非常简单，其的实现如下：\n\n/**\n * kmp-search\n * @param {string} tpl\n * @param {string} pattern\n * @returns\n */\nfunction kmpsearch(tpl, pattern) {\n  let n = tpl.length,\n    m = pattern.length;\n  let pos = -1;\n  let next = gennext(pattern);\n  for (let i = 0, q = 0; i < n; i++) {\n    /* 不断回溯，直到存在最长公共前后缀或回退到0，此处思路和求next数组求解思路一致。 */\n    while (q > 0 && pattern[q] != tpl[i]) {\n      q = next[q - 1];\n    }\n    // 如果当前字符和模式字符串指针位上的字符相等, 模式指针后移一位\n    if (pattern[q] == tpl[i]) {\n      q++;\n    }\n    /*\n     *  上述2个if不能交换位置，必须先判断是否匹配失败，才能继续进行匹配，如果交换的话，q指针先向后移动了一位，当前循环并没有结束，i指针还在前一个位置，此刻出现了错位，那么函数将不会正常运行。\n     */\n    // 如果模式字符串指针的位置走到了最后一位，则说明匹配成功了\n    if (q == m) {\n      // 因为当前匹配的位置实际上是在pattern的length-1的位置上\n      pos = i - m + 1;\n      break;\n    }\n  }\n  return pos;\n}\n\n\n# kmp 的复杂度分析\n\n在生成next数组的时候，我们看到是一个for循环和while循环嵌套，可以看到的是，每次j最坏退到0，但是只有在pattern[i] === pattern[j]的时候，j 才会递增的。j回退的总次数，是不会超过j增加的总次数的，最坏情况下，j累加的总次数是不会超过m的，所以while循环的执行次数是不会超过o(m)。所以生成next数组的时间复杂度是o(m)。在搜索过程中，同理。因此算法总的时间复杂度为 o(m+n)，m 和 n 分别为两个字符串的长度；\n\n因为生成next数组占用了一定的空间，所以空间复杂度为o(m)，m 为子字符串的长度。',charsets:{cjk:!0}},{title:"字典树",frontmatter:{},regularPath:"/data-structure/tree/N-Tree/Trie.html",relativePath:"data-structure/tree/N-Tree/Trie.md",key:"v-02a48cf5",path:"/data-structure/tree/N-Tree/Trie.html",headers:[{level:2,title:"字典树",slug:"字典树",normalizedTitle:"字典树",charIndex:2},{level:3,title:"基本概念",slug:"基本概念",normalizedTitle:"基本概念",charIndex:202},{level:3,title:"字典树的插入和查询",slug:"字典树的插入和查询",normalizedTitle:"字典树的插入和查询",charIndex:566},{level:3,title:"应用场景——统计词频",slug:"应用场景-统计词频",normalizedTitle:"应用场景——统计词频",charIndex:2444}],headersStr:"字典树 基本概念 字典树的插入和查询 应用场景——统计词频",content:"# 字典树\n\n我们每天都可能会用到的有道词典，但是却没有思考过计算机是如何在几十万级别的数据中快速的查出单词的含义及例句的，本文即讲述一个词频统计的高效的数据结构字典树。\n\n字典树，也叫前缀树，是一颗N-叉树，典型应用是用于统计，排序和保存大量的字符串，所以经常被搜索引擎系统用于文本词频统计。\n\n它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率非常高。\n\n\n# 基本概念\n\n如果大家不了解字典树的话，有业务需要存储一堆单词，传统的手段一般都是会考虑使用数组进行存储，然后要查找一个单词是否存在的话，我们需要对这个数组进行遍历，这个时间复杂度至少是O(N*K)，N是单词的个数，K是单词的长度。\n\n这儿有个问题，就是可能有些单词是相同的，但是我们却不得不把它的共同的前缀存M遍，其实也是大大的浪费了空间的。\n\n字典树是一种聪明的办法，它将单词拆分成字母，然后对于个字符成为一个树节点，并且指向它的后面的字符节点。这样，其实对于一些单词拥有相同的前缀的话，只需要存储一份即可，并且这样设计查询效率非常快，O(K)，K为单词的长度。\n\n下图表示的就是一个字典树：\n\n\n\n这个字典树目前存储的单词有：wc， word，world，app, apple，非蓝色节点表示的就是当前单词的结尾。\n\n\n# 字典树的插入和查询\n\n将字典树的节点定义为如下，主要是为了方便找词和统计相同单词出现的业务（如果不需要，可以去掉times和word域）\n\ninterface TrieNode {\n  /**\n   * 字典树当前对应的字符\n   */\n  char: string;\n\n  /**\n   * 如果这个位置对应的是一个单词，则次数不为0，否则为0\n   */\n  times: number;\n\n  /**\n   * 当前字符是否存在以当前字符结尾的单词\n   */\n  word: string | null;\n\n  /**\n   * 子树\n   */\n  children: Map<string, TrieNode> | null;\n}\n\n\n根据上述的树节点定义，字典树的查询和插入实现如下：\n\n/**\n * 字典树\n */\nclass Trie {\n  /**\n   * 前缀树的根节点\n   */\n  private root = new Map<string, TrieNode>();\n\n  /**\n   * 向字典树中插入单词\n   * @param word\n   */\n  insert(word: string) {\n    let parentNode = this.root;\n    let lastIndex = word.length - 1;\n    for (let i = 0; i < word.length; i++) {\n      const char = word[i];\n      const isLast = i === lastIndex;\n      let trieNode = parentNode.get(char);\n      if (!trieNode) {\n        trieNode = {\n          char,\n          times: isLast ? 1 : 0,\n          word: isLast ? word : null,\n          children: isLast ? new Map() : null,\n        };\n        parentNode.set(char, trieNode);\n      } else if (trieNode && isLast) {\n        // 更新词频和单词\n        trieNode.times++;\n        trieNode.word = word;\n      }\n      // 如果当前节点是早些时候的叶节点，继续向后插入\n      if (!trieNode.children) {\n        trieNode.children = new Map();\n      }\n      // 将父节点指针向下沉\n      parentNode = trieNode.children;\n    }\n  }\n  /**\n   * 在字典树中查询单词\n   * @param word\n   * @returns\n   */\n  search(word: string) {\n    let parentNode = this.root;\n    let lastIndex = word.length - 1;\n    for (let i = 0; i < word.length; i++) {\n      const char = word[i];\n      const isLast = i === lastIndex;\n      let trieNode = parentNode.get(char);\n      // 如果当前字幕不匹配。或者如果找到了尽头还没有找到，说明单词不匹配\n      if (!trieNode || !trieNode.children) {\n        return false;\n      }\n      // 如果遇到了结尾标志，需要判断以当前字母结尾的单词是不是我们想找的单词\n      if (isLast) {\n        return trieNode.word === word;\n      }\n      // 将父节点指针向下沉\n      parentNode = trieNode.children;\n    }\n  }\n}\n\n\n\n# 应用场景——统计词频\n\n",normalizedContent:"# 字典树\n\n我们每天都可能会用到的有道词典，但是却没有思考过计算机是如何在几十万级别的数据中快速的查出单词的含义及例句的，本文即讲述一个词频统计的高效的数据结构字典树。\n\n字典树，也叫前缀树，是一颗n-叉树，典型应用是用于统计，排序和保存大量的字符串，所以经常被搜索引擎系统用于文本词频统计。\n\n它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率非常高。\n\n\n# 基本概念\n\n如果大家不了解字典树的话，有业务需要存储一堆单词，传统的手段一般都是会考虑使用数组进行存储，然后要查找一个单词是否存在的话，我们需要对这个数组进行遍历，这个时间复杂度至少是o(n*k)，n是单词的个数，k是单词的长度。\n\n这儿有个问题，就是可能有些单词是相同的，但是我们却不得不把它的共同的前缀存m遍，其实也是大大的浪费了空间的。\n\n字典树是一种聪明的办法，它将单词拆分成字母，然后对于个字符成为一个树节点，并且指向它的后面的字符节点。这样，其实对于一些单词拥有相同的前缀的话，只需要存储一份即可，并且这样设计查询效率非常快，o(k)，k为单词的长度。\n\n下图表示的就是一个字典树：\n\n\n\n这个字典树目前存储的单词有：wc， word，world，app, apple，非蓝色节点表示的就是当前单词的结尾。\n\n\n# 字典树的插入和查询\n\n将字典树的节点定义为如下，主要是为了方便找词和统计相同单词出现的业务（如果不需要，可以去掉times和word域）\n\ninterface trienode {\n  /**\n   * 字典树当前对应的字符\n   */\n  char: string;\n\n  /**\n   * 如果这个位置对应的是一个单词，则次数不为0，否则为0\n   */\n  times: number;\n\n  /**\n   * 当前字符是否存在以当前字符结尾的单词\n   */\n  word: string | null;\n\n  /**\n   * 子树\n   */\n  children: map<string, trienode> | null;\n}\n\n\n根据上述的树节点定义，字典树的查询和插入实现如下：\n\n/**\n * 字典树\n */\nclass trie {\n  /**\n   * 前缀树的根节点\n   */\n  private root = new map<string, trienode>();\n\n  /**\n   * 向字典树中插入单词\n   * @param word\n   */\n  insert(word: string) {\n    let parentnode = this.root;\n    let lastindex = word.length - 1;\n    for (let i = 0; i < word.length; i++) {\n      const char = word[i];\n      const islast = i === lastindex;\n      let trienode = parentnode.get(char);\n      if (!trienode) {\n        trienode = {\n          char,\n          times: islast ? 1 : 0,\n          word: islast ? word : null,\n          children: islast ? new map() : null,\n        };\n        parentnode.set(char, trienode);\n      } else if (trienode && islast) {\n        // 更新词频和单词\n        trienode.times++;\n        trienode.word = word;\n      }\n      // 如果当前节点是早些时候的叶节点，继续向后插入\n      if (!trienode.children) {\n        trienode.children = new map();\n      }\n      // 将父节点指针向下沉\n      parentnode = trienode.children;\n    }\n  }\n  /**\n   * 在字典树中查询单词\n   * @param word\n   * @returns\n   */\n  search(word: string) {\n    let parentnode = this.root;\n    let lastindex = word.length - 1;\n    for (let i = 0; i < word.length; i++) {\n      const char = word[i];\n      const islast = i === lastindex;\n      let trienode = parentnode.get(char);\n      // 如果当前字幕不匹配。或者如果找到了尽头还没有找到，说明单词不匹配\n      if (!trienode || !trienode.children) {\n        return false;\n      }\n      // 如果遇到了结尾标志，需要判断以当前字母结尾的单词是不是我们想找的单词\n      if (islast) {\n        return trienode.word === word;\n      }\n      // 将父节点指针向下沉\n      parentnode = trienode.children;\n    }\n  }\n}\n\n\n\n# 应用场景——统计词频\n\n",charsets:{cjk:!0}},{title:"描述",frontmatter:{},regularPath:"/data-structure/tree/N-Tree/bfsVisit.html",relativePath:"data-structure/tree/N-Tree/bfsVisit.md",key:"v-0171d335",path:"/data-structure/tree/N-Tree/bfsVisit.html",headers:[{level:2,title:"描述",slug:"描述",normalizedTitle:"描述",charIndex:2},{level:2,title:"N-叉树的 BFS",slug:"n-叉树的-bfs",normalizedTitle:"n-叉树的 bfs",charIndex:280},{level:2,title:"复杂度分析",slug:"复杂度分析",normalizedTitle:"复杂度分析",charIndex:775},{level:2,title:"应用场景",slug:"应用场景",normalizedTitle:"应用场景",charIndex:836}],headersStr:"描述 N-叉树的 BFS 复杂度分析 应用场景",content:'# 描述\n\n假设我们的树节点的定义如下：\n\ninterface NTreeNode<T> {\n  left: TreeNode | null;\n  right: TreeNode | null;\n  children: T[] | undefined;\n  data: T;\n}\n\n\n在二叉树的层序遍历时，我们即已掌握广度优先遍历，但是只是没有这样提而已。对于图这类复杂的数据结构，我们总是从当前节点出发，每次遍历当前节点的所有邻接节点（遍历一层），直至遍历完整个结构的遍历方法(即广度优先遍历（BFS: breadth-first-search）)\n\n\n# N-叉树的 BFS\n\n/**\n * N叉树广度优先遍历\n * @param {NTreeNode<number>[]} treeNodes\n */\nfunction bfs(treeNodes) {\n  if (!Array.isArray(treeNodes) || treeNodes.length === 0) {\n    console.log("treeNodes empty");\n    return;\n  }\n  const queue = [];\n  treeNodes.forEach((treeNode) => {\n    queue.push(treeNode);\n  });\n  while (queue.length) {\n    const treeNode = queue.shift();\n    console.log(treeNode.data);\n    if (Array.isArray(treeNode.children)) {\n      queue.push(...treeNode.children);\n    }\n  }\n}\n\n\n\n# 复杂度分析\n\n时间复杂度O(n)；平均空间复杂度O(m*w)，为 N-叉树的最大宽度,m为N-叉树的子节点个数;\n\n\n# 应用场景\n\n电脑中的文件目录；\n\n权限管理中的权限列表；\n\n设备管理中的设备树；\n\n前端的路由表等；',normalizedContent:'# 描述\n\n假设我们的树节点的定义如下：\n\ninterface ntreenode<t> {\n  left: treenode | null;\n  right: treenode | null;\n  children: t[] | undefined;\n  data: t;\n}\n\n\n在二叉树的层序遍历时，我们即已掌握广度优先遍历，但是只是没有这样提而已。对于图这类复杂的数据结构，我们总是从当前节点出发，每次遍历当前节点的所有邻接节点（遍历一层），直至遍历完整个结构的遍历方法(即广度优先遍历（bfs: breadth-first-search）)\n\n\n# n-叉树的 bfs\n\n/**\n * n叉树广度优先遍历\n * @param {ntreenode<number>[]} treenodes\n */\nfunction bfs(treenodes) {\n  if (!array.isarray(treenodes) || treenodes.length === 0) {\n    console.log("treenodes empty");\n    return;\n  }\n  const queue = [];\n  treenodes.foreach((treenode) => {\n    queue.push(treenode);\n  });\n  while (queue.length) {\n    const treenode = queue.shift();\n    console.log(treenode.data);\n    if (array.isarray(treenode.children)) {\n      queue.push(...treenode.children);\n    }\n  }\n}\n\n\n\n# 复杂度分析\n\n时间复杂度o(n)；平均空间复杂度o(m*w)，为 n-叉树的最大宽度,m为n-叉树的子节点个数;\n\n\n# 应用场景\n\n电脑中的文件目录；\n\n权限管理中的权限列表；\n\n设备管理中的设备树；\n\n前端的路由表等；',charsets:{cjk:!0}},{title:"描述",frontmatter:{},regularPath:"/data-structure/tree/N-Tree/dfsVisit.html",relativePath:"data-structure/tree/N-Tree/dfsVisit.md",key:"v-3a2914f5",path:"/data-structure/tree/N-Tree/dfsVisit.html",headers:[{level:2,title:"描述",slug:"描述",normalizedTitle:"描述",charIndex:2},{level:2,title:"N-叉树的 DFS 递归实现",slug:"n-叉树的-dfs-递归实现",normalizedTitle:"n-叉树的 dfs 递归实现",charIndex:267},{level:2,title:"N-叉树的 DFS 非递归实现",slug:"n-叉树的-dfs-非递归实现",normalizedTitle:"n-叉树的 dfs 非递归实现",charIndex:677},{level:2,title:"复杂度分析",slug:"复杂度分析",normalizedTitle:"复杂度分析",charIndex:2258},{level:2,title:"应用场景",slug:"应用场景",normalizedTitle:"应用场景",charIndex:2319}],headersStr:"描述 N-叉树的 DFS 递归实现 N-叉树的 DFS 非递归实现 复杂度分析 应用场景",content:'# 描述\n\n假设我们的树节点的定义如下：\n\ninterface NTreeNode<T> {\n  left: TreeNode | null;\n  right: TreeNode | null;\n  children: T[] | undefined;\n  data: T;\n}\n\n\n对于 N-叉树则不存在先序、中序、后序的提法，但是我们可以在每次遍历的时候，总是先遍历当前节点的最左边的至树的叶节点，然后再向上回溯，再遍历后续的节点，直到完成所有节点的遍历(即深度优先遍历（DFS: deep-first-search）)\n\n\n# N-叉树的 DFS 递归实现\n\n/**\n * N叉树深度优先递归遍历\n * @param {NTreeNode<number>[]} treeNodes\n */\nfunction dfsVisitRecursion(treeNodes) {\n  if (!Array.isArray(treeNodes) || treeNodes.length === 0) {\n    console.log("treeNodes empty");\n    return;\n  }\n\n  treeNodes.forEach((treeNode) => {\n    if (Array.isArray(treeNode.children)) {\n      dfsVisitRecursion(treeNode.children);\n    }\n    console.log(treeNode.data);\n  });\n}\n\n\n\n# N-叉树的 DFS 非递归实现\n\n/**\n * N叉树非递归深度优先遍历\n * @param { NTreeNode<number>[] } treeNodes\n */\nfunction dfsVisit(treeNodes) {\n  if (!Array.isArray(treeNodes) || treeNodes.length === 0) {\n    console.warn("treeNodes empty");\n    return;\n  }\n  let stack = [];\n  // 用来记住每个节点的下一个兄弟节点\n  let nextSiblingMap = new Map();\n  // 建立下一个兄弟节点的关系\n  for (let i = 0; i < treeNodes.length; i++) {\n    const curNode = treeNodes[i];\n    const nextNode = treeNodes[i + 1] || null;\n    nextSiblingMap.set(curNode, nextNode);\n  }\n  let treeNode = treeNodes[0];\n  while (stack.length || treeNode) {\n    // 当节点为空时，说明已经迭代到最叶节点了，退出循环\n    while (treeNode) {\n      console.log(treeNode.data);\n      stack.push(treeNode);\n      let subNodes = Array.isArray(treeNode.children) ? treeNode.children : [];\n      // 每一层都建立下一个兄弟节点的关系\n      for (let k = 0; k < subNodes.length; k++) {\n        const curNode = subNodes[k];\n        const nextNode = subNodes[k + 1] || null;\n        nextSiblingMap.set(curNode, nextNode);\n      }\n      // 下滤节点\n      treeNode = subNodes[0] || null;\n    }\n    if (stack.length) {\n      treeNode = stack.pop();\n      // 根据当前节点到map里面找当前节点的下一个兄弟节点\n      let nextSiblingNode = nextSiblingMap.get(treeNode);\n      if (nextSiblingNode) {\n        treeNode = nextSiblingNode;\n      } else {\n        // 如果没有下一个兄弟节点了，说明需要回退到父亲节点，父亲节点处理完成之后，准备处理父亲节点的下一个兄弟节点\n        if (stack.length) {\n          treeNode = stack.pop();\n          // 继续切换到父节点的兄弟节点\n          treeNode = nextSiblingMap.get(treeNode);\n        } else {\n          // 已经将所有的节点处理完成，可以功成身退\n          treeNode = null;\n        }\n      }\n    }\n  }\n}\n\n\n\n# 复杂度分析\n\n时间复杂度O(n)；平均空间复杂度O(m*h)，为 N-叉树的最大高度,m为N-叉树的子节点个数;\n\n\n# 应用场景\n\n电脑中的文件目录；\n\n权限管理中的权限列表；\n\n设备管理中的设备树等；\n\n前端的路由表等；',normalizedContent:'# 描述\n\n假设我们的树节点的定义如下：\n\ninterface ntreenode<t> {\n  left: treenode | null;\n  right: treenode | null;\n  children: t[] | undefined;\n  data: t;\n}\n\n\n对于 n-叉树则不存在先序、中序、后序的提法，但是我们可以在每次遍历的时候，总是先遍历当前节点的最左边的至树的叶节点，然后再向上回溯，再遍历后续的节点，直到完成所有节点的遍历(即深度优先遍历（dfs: deep-first-search）)\n\n\n# n-叉树的 dfs 递归实现\n\n/**\n * n叉树深度优先递归遍历\n * @param {ntreenode<number>[]} treenodes\n */\nfunction dfsvisitrecursion(treenodes) {\n  if (!array.isarray(treenodes) || treenodes.length === 0) {\n    console.log("treenodes empty");\n    return;\n  }\n\n  treenodes.foreach((treenode) => {\n    if (array.isarray(treenode.children)) {\n      dfsvisitrecursion(treenode.children);\n    }\n    console.log(treenode.data);\n  });\n}\n\n\n\n# n-叉树的 dfs 非递归实现\n\n/**\n * n叉树非递归深度优先遍历\n * @param { ntreenode<number>[] } treenodes\n */\nfunction dfsvisit(treenodes) {\n  if (!array.isarray(treenodes) || treenodes.length === 0) {\n    console.warn("treenodes empty");\n    return;\n  }\n  let stack = [];\n  // 用来记住每个节点的下一个兄弟节点\n  let nextsiblingmap = new map();\n  // 建立下一个兄弟节点的关系\n  for (let i = 0; i < treenodes.length; i++) {\n    const curnode = treenodes[i];\n    const nextnode = treenodes[i + 1] || null;\n    nextsiblingmap.set(curnode, nextnode);\n  }\n  let treenode = treenodes[0];\n  while (stack.length || treenode) {\n    // 当节点为空时，说明已经迭代到最叶节点了，退出循环\n    while (treenode) {\n      console.log(treenode.data);\n      stack.push(treenode);\n      let subnodes = array.isarray(treenode.children) ? treenode.children : [];\n      // 每一层都建立下一个兄弟节点的关系\n      for (let k = 0; k < subnodes.length; k++) {\n        const curnode = subnodes[k];\n        const nextnode = subnodes[k + 1] || null;\n        nextsiblingmap.set(curnode, nextnode);\n      }\n      // 下滤节点\n      treenode = subnodes[0] || null;\n    }\n    if (stack.length) {\n      treenode = stack.pop();\n      // 根据当前节点到map里面找当前节点的下一个兄弟节点\n      let nextsiblingnode = nextsiblingmap.get(treenode);\n      if (nextsiblingnode) {\n        treenode = nextsiblingnode;\n      } else {\n        // 如果没有下一个兄弟节点了，说明需要回退到父亲节点，父亲节点处理完成之后，准备处理父亲节点的下一个兄弟节点\n        if (stack.length) {\n          treenode = stack.pop();\n          // 继续切换到父节点的兄弟节点\n          treenode = nextsiblingmap.get(treenode);\n        } else {\n          // 已经将所有的节点处理完成，可以功成身退\n          treenode = null;\n        }\n      }\n    }\n  }\n}\n\n\n\n# 复杂度分析\n\n时间复杂度o(n)；平均空间复杂度o(m*h)，为 n-叉树的最大高度,m为n-叉树的子节点个数;\n\n\n# 应用场景\n\n电脑中的文件目录；\n\n权限管理中的权限列表；\n\n设备管理中的设备树等；\n\n前端的路由表等；',charsets:{cjk:!0}},{title:"树的构建",frontmatter:{},regularPath:"/data-structure/tree/binaryTree/construct.html",relativePath:"data-structure/tree/binaryTree/construct.md",key:"v-0352edef",path:"/data-structure/tree/binaryTree/construct.html",headers:[{level:2,title:"树的构建",slug:"树的构建",normalizedTitle:"树的构建",charIndex:2},{level:3,title:"1. 把后端返回的数据构建成树",slug:"_1-把后端返回的数据构建成树",normalizedTitle:"1. 把后端返回的数据构建成树",charIndex:11},{level:3,title:"2. 从二叉树的两个遍历序列构建二叉树",slug:"_2-从二叉树的两个遍历序列构建二叉树",normalizedTitle:"2. 从二叉树的两个遍历序列构建二叉树",charIndex:2115}],headersStr:"树的构建 1. 把后端返回的数据构建成树 2. 从二叉树的两个遍历序列构建二叉树",content:"# 树的构建\n\n\n# 1. 把后端返回的数据构建成树\n\n这是一个很常见的操作，有些时候，是因为后端直接返回树结构的话，序列化时i/o开销比较大，在高并发场景下，会使得服务器的效率降低，因此不得不让前端自行构建树型结构的数据。\n\n还有一种情况就比较搞笑了，这种情况一般出现在小公司，你的后端因为某些不可告人的秘密，告诉你只能给你返回数组。但是我们前端又必须需要一个树状结构。此时为了避免尴尬，前端可能会要求后端怎么样操作简单就怎么样约定数据格式了，然后前端按照相应的规格自己将其构建成树。\n\n一般，后端给到前端的数据是这样的，我就以文件列表的例子来举例。\n\n/**\n * 文件信息\n */\ninterface File {\n  /**\n   * 文件的ID，需要使用string类型，若使用number类型，当id特别大的时候，前端解析的结果将不正确\n   */\n  id: string;\n\n  /**\n   * 文件的父级ID, 可能不存在\n   */\n  pid: string | null;\n\n  /**\n   * 文件名\n   */\n  filename: string;\n\n  /**\n   * 文件类型，比如是文件还是文件夹\n   */\n  type: number;\n\n  /**\n   * 子文件列表\n   */\n  children?: File[];\n}\n\n\n# 方案 1 使用递归\n\n/**\n * 构建文件树\n * @param file 文件信息\n * @param file 文件列表信息\n */\nfunction buildTree(file: File, files: File[]) {\n  // 找到当前文件的子文件列表\n  let children = files.filter((fileEle: File) => {\n    return fileEle.pid === file.id;\n  });\n  // 递归的处理当前文件子文件列表的子文件\n  file.children =\n    children.length === 0\n      ? undefined\n      : children.map((subFile: File) => buildTree(subFile, files));\n  return file;\n}\n\n/**\n * 将文件列表转为文件树，并且返回根节点\n * @param files 文件列表\n */\nfunction build(files: File[]) {\n  // 构建结果\n  const roots = files\n    .filter((file) => {\n      // 这一步操作是为了找到所有的根节点\n      return file.pid === null;\n    })\n    .map((file) => {\n      // 对根节点的数据进行构建\n      return buildTree(file, files);\n    });\n  return roots;\n}\n\n\n# 方案 2 使用哈希表\n\n这个方案是有点儿取巧的一种做法了，因为其完美的利用了引用类型数据的特征，因为引用数据类型，大家都同时持有一块相同的内存区域，不同的人对它进行修改，都会在它的身上得到体现。\n\n/**\n * 将文件列表转换成为哈希表\n * @param {File[]} files\n */\nfunction makeHashMap(files) {\n  const map = new Map();\n  files.forEach((file) => {\n    // 以ID为主键建立哈希映射\n    map.set(file.id, file);\n  });\n  return map;\n}\n\nfunction buildTree(files) {\n  // 将文件构建成哈希表，主要是为了后续的查找方便\n  const fileMap = makeHashMap(files);\n  const roots = [];\n  // 逐个的对每个文件增加子元素\n  files.forEach((file) => {\n    // 找父级文件，如果找不到的话，说明是根节点\n    const parentFile = fileMap.get(file.pid);\n    if (parentFile) {\n      if (!Array.isArray(parentFile.children)) {\n        parentFile.children = [file];\n      } else {\n        parentFile.children.push(file);\n      }\n    } else {\n      roots.push(file);\n    }\n  });\n  // 最后只需要找出根节点的文件列表即可完成构建\n  return roots;\n}\n\n\n\n# 2. 从二叉树的两个遍历序列构建二叉树\n\n通过无重复值的二叉树遍历中序序列+先序（或后序）序列能唯一确定一颗二叉树。\n\n注意事项\n\n仅凭先序和后序序列无法唯一确定一颗二叉树。\n\n先序序列的第一个节点一定是根节点，然后我们就可以通过这个根节点，在中序序列中确定其根节点的位置。一旦确定了中序序列的根节点位置，那就可以得到左子树序列和右子树序列。而同一颗二叉树的左右子树序列长度是相同的，因此，我们可以根据从中序序列获取到的左右子树片段，找出先序序列的左右子树片段。重复这个过程，直到构建完成。\n\n后序序列+中序序列构建思路还先序序列+中序序列构建思路类似。\n\n# 通过先序序列+中序序列构建二叉树\n\n二叉树结构定义如下：\n\ninterface TreeNode<T> {\n  left: TreeNode<T> | null;\n  right: TreeNode<T> | null;\n  val: T;\n}\n\n\n算法实现如下：\n\n/**\n * 从二叉树的先序序列+中序序列构建二叉树\n * @param {number[]} preorder 先序序列\n * @param {number[]} inorder 中序序列\n * @return {TreeNode}\n */\nvar buildTree = function (preorder, inorder) {\n  if (\n    !Array.isArray(preorder) ||\n    preorder.length === 0 ||\n    !Array.isArray(inorder) ||\n    inorder.length === 0 ||\n    preorder.length != inorder.length\n  ) {\n    return null;\n  }\n  let rootVal = preorder[0];\n  // 在中序遍历的结果中找到根节点所在的位置，则【0，idx】的是左子树，【idx+1，length】的是右子树\n  let rootNodeIdx = inorder.findIndex((x) => x === rootVal);\n  let inLeftSubtreeNodes = inorder.slice(0, rootNodeIdx);\n  let inRightSubtreeNodes = inorder.slice(rootNodeIdx + 1);\n  // 在先序遍历的结果中提取对应长度的的子集 可以得到对应的左子树结果集合\n  let preLeftSubtreeNodes = preorder.slice(1, inLeftSubtreeNodes.length + 1);\n  // 继续在先序遍历的结果中提取对应长度的子集，可以得到对应右子树结果集合\n  let preRightSubtreeNodes = preorder.slice(1 + inLeftSubtreeNodes.length);\n  return {\n    val: rootVal,\n    left: buildTree(preLeftSubtreeNodes, inLeftSubtreeNodes),\n    right: buildTree(preRightSubtreeNodes, inRightSubtreeNodes),\n  };\n};\n\n\n# 通过后序序列+中序序列构建二叉树\n\n算法实现如下：\n\n/**\n * 通过后序序列+中序序列构建二叉树\n * @param {number[]} inorder\n * @param {number[]} postorder\n * @return {TreeNode}\n */\nvar buildTree = function (inorder, postorder) {\n  if (\n    !Array.isArray(inorder) ||\n    inorder.length === 0 ||\n    !Array.isArray(postorder) ||\n    postorder.length === 0 ||\n    inorder.length != postorder.length\n  ) {\n    return null;\n  }\n  let len = postorder.length;\n  let rootVal = postorder[len - 1];\n  // 在中序遍历的结果中找到根节点所在的位置，则【0，idx】的是左子树，【idx+1，length】的是右子树\n  let rootNodeIdx = inorder.findIndex((x) => x === rootVal);\n  let inLeftSubtreeNodes = inorder.slice(0, rootNodeIdx);\n  let inRightSubtreeNodes = inorder.slice(rootNodeIdx + 1);\n  // 在后序遍历的结果中提取对应长度的的子集 可以得到对应的左子树结果集合\n  let posLeftSubtreeNodes = postorder.slice(0, inLeftSubtreeNodes.length);\n  // 继续在后序遍历的结果中提取对应长度的子集，可以得到对应右子树结果集合\n  let postRightSubtreeNodes = postorder.slice(\n    posLeftSubtreeNodes.length,\n    postorder.length - 1\n  );\n  return {\n    val: rootVal,\n    left: buildTree(inLeftSubtreeNodes, posLeftSubtreeNodes),\n    right: buildTree(inRightSubtreeNodes, postRightSubtreeNodes),\n  };\n};\n\n\n为什么同一颗二叉树的先序序列+后序序列不能唯一确定一颗二叉树呢，我们通过举反例来证明这个结论。\n\n假设我们有一个二叉树的先序序列 ABC，一个后序序列 CBA\n\n那么，能够得到 ABC 先序序列的可能的二叉树如下：\n\n\n\n那么，能够得到 CBA 后续序列可能的二叉树如下：\n\n\n\n可以看到，同一颗二叉树的先序和后序序列，但是可以构造出不同的二叉树。",normalizedContent:"# 树的构建\n\n\n# 1. 把后端返回的数据构建成树\n\n这是一个很常见的操作，有些时候，是因为后端直接返回树结构的话，序列化时i/o开销比较大，在高并发场景下，会使得服务器的效率降低，因此不得不让前端自行构建树型结构的数据。\n\n还有一种情况就比较搞笑了，这种情况一般出现在小公司，你的后端因为某些不可告人的秘密，告诉你只能给你返回数组。但是我们前端又必须需要一个树状结构。此时为了避免尴尬，前端可能会要求后端怎么样操作简单就怎么样约定数据格式了，然后前端按照相应的规格自己将其构建成树。\n\n一般，后端给到前端的数据是这样的，我就以文件列表的例子来举例。\n\n/**\n * 文件信息\n */\ninterface file {\n  /**\n   * 文件的id，需要使用string类型，若使用number类型，当id特别大的时候，前端解析的结果将不正确\n   */\n  id: string;\n\n  /**\n   * 文件的父级id, 可能不存在\n   */\n  pid: string | null;\n\n  /**\n   * 文件名\n   */\n  filename: string;\n\n  /**\n   * 文件类型，比如是文件还是文件夹\n   */\n  type: number;\n\n  /**\n   * 子文件列表\n   */\n  children?: file[];\n}\n\n\n# 方案 1 使用递归\n\n/**\n * 构建文件树\n * @param file 文件信息\n * @param file 文件列表信息\n */\nfunction buildtree(file: file, files: file[]) {\n  // 找到当前文件的子文件列表\n  let children = files.filter((fileele: file) => {\n    return fileele.pid === file.id;\n  });\n  // 递归的处理当前文件子文件列表的子文件\n  file.children =\n    children.length === 0\n      ? undefined\n      : children.map((subfile: file) => buildtree(subfile, files));\n  return file;\n}\n\n/**\n * 将文件列表转为文件树，并且返回根节点\n * @param files 文件列表\n */\nfunction build(files: file[]) {\n  // 构建结果\n  const roots = files\n    .filter((file) => {\n      // 这一步操作是为了找到所有的根节点\n      return file.pid === null;\n    })\n    .map((file) => {\n      // 对根节点的数据进行构建\n      return buildtree(file, files);\n    });\n  return roots;\n}\n\n\n# 方案 2 使用哈希表\n\n这个方案是有点儿取巧的一种做法了，因为其完美的利用了引用类型数据的特征，因为引用数据类型，大家都同时持有一块相同的内存区域，不同的人对它进行修改，都会在它的身上得到体现。\n\n/**\n * 将文件列表转换成为哈希表\n * @param {file[]} files\n */\nfunction makehashmap(files) {\n  const map = new map();\n  files.foreach((file) => {\n    // 以id为主键建立哈希映射\n    map.set(file.id, file);\n  });\n  return map;\n}\n\nfunction buildtree(files) {\n  // 将文件构建成哈希表，主要是为了后续的查找方便\n  const filemap = makehashmap(files);\n  const roots = [];\n  // 逐个的对每个文件增加子元素\n  files.foreach((file) => {\n    // 找父级文件，如果找不到的话，说明是根节点\n    const parentfile = filemap.get(file.pid);\n    if (parentfile) {\n      if (!array.isarray(parentfile.children)) {\n        parentfile.children = [file];\n      } else {\n        parentfile.children.push(file);\n      }\n    } else {\n      roots.push(file);\n    }\n  });\n  // 最后只需要找出根节点的文件列表即可完成构建\n  return roots;\n}\n\n\n\n# 2. 从二叉树的两个遍历序列构建二叉树\n\n通过无重复值的二叉树遍历中序序列+先序（或后序）序列能唯一确定一颗二叉树。\n\n注意事项\n\n仅凭先序和后序序列无法唯一确定一颗二叉树。\n\n先序序列的第一个节点一定是根节点，然后我们就可以通过这个根节点，在中序序列中确定其根节点的位置。一旦确定了中序序列的根节点位置，那就可以得到左子树序列和右子树序列。而同一颗二叉树的左右子树序列长度是相同的，因此，我们可以根据从中序序列获取到的左右子树片段，找出先序序列的左右子树片段。重复这个过程，直到构建完成。\n\n后序序列+中序序列构建思路还先序序列+中序序列构建思路类似。\n\n# 通过先序序列+中序序列构建二叉树\n\n二叉树结构定义如下：\n\ninterface treenode<t> {\n  left: treenode<t> | null;\n  right: treenode<t> | null;\n  val: t;\n}\n\n\n算法实现如下：\n\n/**\n * 从二叉树的先序序列+中序序列构建二叉树\n * @param {number[]} preorder 先序序列\n * @param {number[]} inorder 中序序列\n * @return {treenode}\n */\nvar buildtree = function (preorder, inorder) {\n  if (\n    !array.isarray(preorder) ||\n    preorder.length === 0 ||\n    !array.isarray(inorder) ||\n    inorder.length === 0 ||\n    preorder.length != inorder.length\n  ) {\n    return null;\n  }\n  let rootval = preorder[0];\n  // 在中序遍历的结果中找到根节点所在的位置，则【0，idx】的是左子树，【idx+1，length】的是右子树\n  let rootnodeidx = inorder.findindex((x) => x === rootval);\n  let inleftsubtreenodes = inorder.slice(0, rootnodeidx);\n  let inrightsubtreenodes = inorder.slice(rootnodeidx + 1);\n  // 在先序遍历的结果中提取对应长度的的子集 可以得到对应的左子树结果集合\n  let preleftsubtreenodes = preorder.slice(1, inleftsubtreenodes.length + 1);\n  // 继续在先序遍历的结果中提取对应长度的子集，可以得到对应右子树结果集合\n  let prerightsubtreenodes = preorder.slice(1 + inleftsubtreenodes.length);\n  return {\n    val: rootval,\n    left: buildtree(preleftsubtreenodes, inleftsubtreenodes),\n    right: buildtree(prerightsubtreenodes, inrightsubtreenodes),\n  };\n};\n\n\n# 通过后序序列+中序序列构建二叉树\n\n算法实现如下：\n\n/**\n * 通过后序序列+中序序列构建二叉树\n * @param {number[]} inorder\n * @param {number[]} postorder\n * @return {treenode}\n */\nvar buildtree = function (inorder, postorder) {\n  if (\n    !array.isarray(inorder) ||\n    inorder.length === 0 ||\n    !array.isarray(postorder) ||\n    postorder.length === 0 ||\n    inorder.length != postorder.length\n  ) {\n    return null;\n  }\n  let len = postorder.length;\n  let rootval = postorder[len - 1];\n  // 在中序遍历的结果中找到根节点所在的位置，则【0，idx】的是左子树，【idx+1，length】的是右子树\n  let rootnodeidx = inorder.findindex((x) => x === rootval);\n  let inleftsubtreenodes = inorder.slice(0, rootnodeidx);\n  let inrightsubtreenodes = inorder.slice(rootnodeidx + 1);\n  // 在后序遍历的结果中提取对应长度的的子集 可以得到对应的左子树结果集合\n  let posleftsubtreenodes = postorder.slice(0, inleftsubtreenodes.length);\n  // 继续在后序遍历的结果中提取对应长度的子集，可以得到对应右子树结果集合\n  let postrightsubtreenodes = postorder.slice(\n    posleftsubtreenodes.length,\n    postorder.length - 1\n  );\n  return {\n    val: rootval,\n    left: buildtree(inleftsubtreenodes, posleftsubtreenodes),\n    right: buildtree(inrightsubtreenodes, postrightsubtreenodes),\n  };\n};\n\n\n为什么同一颗二叉树的先序序列+后序序列不能唯一确定一颗二叉树呢，我们通过举反例来证明这个结论。\n\n假设我们有一个二叉树的先序序列 abc，一个后序序列 cba\n\n那么，能够得到 abc 先序序列的可能的二叉树如下：\n\n\n\n那么，能够得到 cba 后续序列可能的二叉树如下：\n\n\n\n可以看到，同一颗二叉树的先序和后序序列，但是可以构造出不同的二叉树。",charsets:{cjk:!0}},{title:"二叉搜索树",frontmatter:{},regularPath:"/data-structure/tree/binarySearchTree/desc.html",relativePath:"data-structure/tree/binarySearchTree/desc.md",key:"v-f3313c56",path:"/data-structure/tree/binarySearchTree/desc.html",headers:[{level:2,title:"二叉搜索树",slug:"二叉搜索树",normalizedTitle:"二叉搜索树",charIndex:2},{level:2,title:"二叉搜索树的实现",slug:"二叉搜索树的实现",normalizedTitle:"二叉搜索树的实现",charIndex:133},{level:3,title:"递归实现",slug:"递归实现",normalizedTitle:"递归实现",charIndex:513},{level:3,title:"非递归实现",slug:"非递归实现",normalizedTitle:"非递归实现",charIndex:3479},{level:2,title:"复杂度分析",slug:"复杂度分析",normalizedTitle:"复杂度分析",charIndex:9101}],headersStr:"二叉搜索树 二叉搜索树的实现 递归实现 非递归实现 复杂度分析",content:'# 二叉搜索树\n\n二叉搜索树（或者叫二叉排序树），是一种特殊的二叉树，其中一个重要的性质是它的左子树的节点值均比根节点小，右子树的节点值均比根节点值大，并且其左右子树也是一颗二叉搜索树。\n\n正是因为这个性质，通常会采用二叉搜索树进行高效率的检索和删除操作。\n\n\n# 二叉搜索树的实现\n\n首先定义树节点的结构定义如下：\n\ninterface TreeNode<T> {\n  // 树节点的值域\n  val: T;\n  // 树节点的左子节点\n  left: TreeNode<T> | null;\n  // 树节点的右子节点\n  right: TreeNode<T> | null;\n}\n\n\n根据二叉搜索性质，我们可以得出一个结论:\n\n最大节点一定是在右子树上，并且一定没有右子节点。\n\n最小节点一定是在左子树上，并且这个节点一定没有左右儿子节点，即叶节点。\n\n二叉树的中序遍历序列一定是一个非降序的序列\n\n编程技巧\n\n二叉树的中序遍历序列一定是一个非降序的序列，因此可以用一颗树的中序序列来判断一颗树是否是二叉搜索树。\n\n二叉搜索树的主要操作有 find,findMin,findMax,insert,delete。\n\n\n# 递归实现\n\n# 查找\n\n根据二叉搜索树的定义，左儿子一定会比右儿子小。因此，如果我们当前起始节点不存在的话，说明对应的值在二叉树中不存在，如果当前节点存在，并且恰好和我们要找的节点值相等的话，那么就说明找到了，因此我们可以直接返回当前节点，如果待查找值比当前节点的值小，那么它只有可能在左子树上找的到，因次，我们沿着左子树递归，反之，我们则沿着右子树递归。\n\n# 插入\n\n对于插入，如果树是空，直接插入返回新树即可，如果树不为空，若待插入的值比根节点的值小，则沿着左子树进行插入，否则沿着右子树进行插入，重复这个过程直到找到合适的位置，完成插入。\n\n# 删除\n\n二叉搜索树的删除相比插入要复杂的多，我们需要考虑的情况比较多： 首先，递归的思路此处不再赘述了，如果传入的节点就不存在，说明要删除的值肯定在搜索树中根本不存在。\n\n我们主要考虑能找到待删除节点的情况，如下：\n\n * 1、没有左右儿子节点。\n * 2、仅有左儿子节点。\n * 3、仅有右儿子节点。\n * 4、同时具有左右儿子节点。\n\n对于 case1,因为不需要进行任何操作。 传入的是有值的节点，返回空，我们给上层节点的左（或者 右）儿子接上这个空，则完成了删除。\n\n对于 case2,也不难，不就是要删除当前节点嘛，好呀，我直接把当前节点变成当前节点的左儿子给你返回，你上层递归调用的函数不就老老实实的给我接上了吗，嘿嘿（或者，把当前节点的左儿子的值拷贝给自己，然后把当前节点的左儿子指针置为空，然后返回这个节点，不过好像没有必要这样做呢）。\n\n对于 case3,同 case2，只不过我们操作的是右儿子。\n\n对于 case4,也就是最关键的，这个问题需要利用转化的思想。首先，因为总是有右子树的任何节点比当前待删除节点大，左子树的任何节点比当前待删除节点的值小的性质。我们可以换个角度想，我从右子树里面先找一个最小值节点替换到当前的这个待删除节点上，如果不考虑之前找到的最小值节点，是否仍然满足二叉搜索树的性质呀，nice，那我再从这个位置开始把之前找到的最小值节点删了不就行了吗，哈哈哈。有的朋友会说了，待删除右子树的最小值节点可能同时有左右儿子节点嘛，不就又绕回来了吗。根据二叉搜索树的性质，当前子树的最小值肯定是不会再有左子节点的了。所以，我们再从待删除节点出发，递归的删除当前节点右子树的最小值即可（上述操作找左子树的最大值也可以）。\n\n/**\n * 二叉搜索树类\n */\nclass BST {\n  /**\n   * @type {TreeNode}\n   */\n  #tree = null;\n\n  /**\n   * 创建一个树节点\n   * @param {number} val\n   * @returns {TreeNode}\n   */\n  #createTreeNode(val) {\n    return {\n      val,\n      left: null,\n      right: null,\n    };\n  }\n\n  /**\n   * 查找指定值是否在二叉搜索树中存在\n   * @param {number} val\n   * @returns {TreeNode}\n   */\n  find(val) {\n    return this.#find(val, this.#tree);\n  }\n\n  #find(val, node) {\n    if (!node) {\n      return null;\n    }\n    if (node.val === val) {\n      return node;\n    } else if (node.val > val) {\n      return this.#find(val, node.left);\n    } else if (node.val < val) {\n      return this.#find(val, node.right);\n    }\n  }\n\n  insert(val) {\n    this.tree = this.#insert(val, this.tree);\n  }\n\n  /**\n   * 使用递归的方式向搜索树中插入一个节点\n   * @param {number} val\n   * @param {Node} node\n   * @returns\n   */\n  #insert(val, node) {\n    if (!node) {\n      node = this.#createTreeNode(val);\n    } else {\n      if (val < node.val) {\n        node.left = this.#insert(val, node.left);\n      } else if (val > node.val) {\n        node.right = this.#insert(val, node.right);\n      }\n    }\n    return node;\n  }\n\n  delete(val) {\n    this.tree = this.#delete(val, this.tree);\n  }\n\n  /**\n   * 使用递归的方式删除一个节点\n   * @param {number} val 待删除的值\n   * @param {TreeNode} node 从指定的节点开始删除\n   * @returns\n   */\n  #delete(val, node) {\n    if (!node) {\n      console.warn("无法找到需要删除的值");\n      return null;\n    } else if (val > node.val) {\n      node.right = this.#delete(val, node.right);\n    } else if (val < node.val) {\n      node.left = this.#delete(val, node.left);\n    } else {\n      if (node.left && node.right) {\n        let rightMin = this.#findMinPosition(node.right);\n        node.val = rightMin.val;\n        node.right = this.#delete(rightMin.val, node.right);\n      } else if (node.left) {\n        node = node.left;\n      } else if (node.right) {\n        node = node.right;\n      } else {\n        node = null;\n      }\n    }\n    return node;\n  }\n}\n\n\n\n# 非递归实现\n\n# 查找\n\n对于查找此处不再赘述，递归和非递归完全类似\n\n# 插入\n\n对于插入，如果当前树是空的话直接插入即可。\n\n如果有插入相同的值肯定不允许插入。\n\n如果当前的节点值比待插入值小的话，说明我们应该往当前节点的右子树找位置插入才对。如果当前节点的右子树不存在的话，OK，恭喜你，这个位置就是你要插入的位置啦。我们的循环就没有必要再继续做下去了。否则，我们就接着从右子树下面找插入位置往下找呗。\n\n如果当前的节点值比待插入值大的话，说明我们应该往当前节点的左子树找位置插入才对。如果当前节点的左子树不存在，OK，恭喜你，这个位置就是你要插入的位置啦，结束循环。否则，我们接着从左子树下面找合适的插入位置。\n\n# 删除\n\n使用非递归删除二叉搜素树的思路和递归一致，但是代码的实现复杂程度一下子提高了很多。\n\n在使用递归删除的过程中，因为我们借用了系统的调用栈，我们可以很好的处理删除之后的节点引用关系，而使用非递归操作，这个过程完全就交给我们自己了，正所谓划了多少水，迟早要还的。\n\n首先，我们需要定义一个 parent 指针，因为一会儿需要用这个指针来连接子树。迭代步骤跟插入查找一致，此处不再赘述。退出第一个循环有 2 种情况: 树为空 或者 找到了待删除的节点。 如果是第一种情况，那好说，直接就啥事儿不用干，多好啊，哈哈哈。\n\n主要就是看第二种情况,这种情况下仍然和之前递归删除的时候我们需要考虑的问题是一致的，仍然是 4 种 case。\n\n首先考虑最简单的 case，当前待删除节点无左右儿子，此时 parent 指针指向的是父节点，但是有个问题需要注意哦，当前这个待删除节点是左儿子还是右儿子得根据父节点的值来确定哦。\n\n接着考虑待删除节点仅有右子节点的 case，这个 case 和删除没有左右儿子节点的节点的 case 类似，只需要把当前待删除节点的右子树接上就可以了。同样，还是需要考虑是用父节点的左儿子指针接还是右儿子指针接。\n\n待删除节点仅有左子节点的 case 和待删除节点仅有右子节点的 case 类似，此处也不再赘述。\n\n最后考虑同时有左右儿子的 case，好想递归调用删除节点方法有没有？哈哈哈哈。既然我们使用非递归删除，那就完完全全的用非递归实现吧。我们先用一个变量先把当前这个节点的位置先记住，免得一会儿向下迭代的时候找不到了。还是和递归删除的思路一致，当前节点的左子树找一个最大值或者右子树里面找一个最小值。找到之后把这个值拷贝到之前我们事先记住的那个节点上去，然后删除这个节点，又变成了删除只有单子节点的 case 了。\n\n这儿有一个需要注意的店是假设我们删除的时候以当前节点的左子树最大值替换待删除节点的值。\n\nDANGER\n\n一定不要忘了，左子树的最大值是有可能有左子树的，一定不要忘了把这个子树给拼接上，否则就会丢失这一大块存储区域。\n\nleftMaxParentNode.right = leftMaxNode.left; // 拼接左子树，有可能没有左子树，但此步骤不能少。\n\n\n/**\n * 二叉搜索树的非递归实现\n */\nclass BST {\n  /**\n   * @type {TreeNode}\n   */\n  #tree = null;\n\n  /**\n   * 创建一个树节点\n   * @param {number} val\n   * @returns {TreeNode}\n   */\n  #createTreeNode(val) {\n    return {\n      val,\n      left: null,\n      right: null,\n    };\n  }\n\n  /**\n   * 查找二叉树中值为val的节点\n   * @param {number} val\n   * @returns\n   */\n  #findPosition(val) {\n    let node = this.#tree;\n    let targetNode = null;\n    while (node) {\n      if (node.val === val) {\n        targetNode = node;\n        break;\n      } else if (val > node.val) {\n        node = node.right;\n      } else if (val < node.val) {\n        node = node.left;\n      }\n    }\n    return targetNode;\n  }\n\n  /**\n   * 从二叉搜素树中删除一个值\n   * @param {number} val\n   */\n  delete(val) {\n    let node = this.#tree;\n    let parent = null;\n    while (node) {\n      // 如果找到了当前节点 则中断循环\n      if (node.val === val) {\n        break;\n      }\n      parent = node;\n      // 如果当前节点的值比val小，说明待删除的节点在右子树上\n      if (node.val < val) {\n        node = node.right;\n        // 如果当前节点的值比val大，说明待删除的节点在左子树上\n      } else if (node.val > val) {\n        node = node.left;\n      }\n    }\n    if (!node) {\n      console.warn("要删除的节点不存在");\n    } else if (node.left && node.right) {\n      let leftMaxParentNode = node;\n      let leftMaxNode = node.left;\n      // 退出循环的时候，leftMaxNode是肯定没有右子树节点的了\n      while (leftMaxNode.right) {\n        leftMaxParentNode = leftMaxNode;\n        leftMaxNode = leftMaxNode.right;\n      }\n      // 先把左子树的最大值拷贝到当前要删除的节点上去，然后从左子树删除左子树的最大值节点\n      node.val = leftMaxNode.val;\n      // 前驱节点的右指针指向当前节点的左指针 虽然leftMaxNode.left可能不存在，但是还是要将其链接在前驱节点的右子节点上\n      leftMaxParentNode.right = leftMaxNode.left;\n    } else if (node.left) {\n      if (parent === null) {\n        this.#tree = node.left;\n      } else {\n        // 判断当前节点是来源于左子节点还是右子节点\n        if (parent.val > node.val) {\n          parent.left = node.left;\n        } else {\n          parent.right = node.left;\n        }\n      }\n    } else if (node.right) {\n      if (parent === null) {\n        this.#tree = node.right;\n      } else {\n        // 判断当前节点是来源于左子节点还是右子节点\n        if (parent.val > node.val) {\n          parent.left = node.right;\n        } else {\n          parent.right = node.right;\n        }\n        node = null;\n      }\n    } else {\n      if (parent === null) {\n        this.#tree = null;\n      } else {\n        // 判断当前节点是来源于左子节点还是右子节点\n        if (parent.val > node.val) {\n          parent.left = null;\n        } else {\n          parent.right = null;\n        }\n      }\n      node = null;\n    }\n  }\n\n  /**\n   * 向二叉搜索树中插入一个值\n   * @param {number} val\n   */\n  insert(val) {\n    // 创建一个新的节点\n    let newNode = this.#createTreeNode(val);\n    // 如果当前树为空, 直接将节点插入根节点\n    if (!this.#tree) {\n      this.#tree = newNode;\n      return;\n    }\n    let node = this.#tree;\n    while (true) {\n      // 如果插入相同值，直接报错\n      if (val === node.val) {\n        console.warn("不允许插入相同值的节点");\n        break;\n      }\n      // 如果当前值比节点值大，node向右子树下滤\n      else if (val > node.val) {\n        // 如果当前节点的右儿子没了，说明这个就是一个合适的插入位置\n        if (!node.right) {\n          node.right = newNode;\n          break;\n        }\n        // 沿着右子树下滤\n        node = node.right;\n        // 如果当前值比节点值小，node向左子树下滤\n      } else if (val < node.val) {\n        // 如果当前节点的左儿子没了，说明这个就是一个合适的插入位置\n        if (!node.left) {\n          node.left = newNode;\n          break;\n        }\n        // 沿着左子树下滤\n        node = node.left;\n      }\n    }\n  }\n\n  /**\n   * 查找树中最大值\n   */\n  findMax() {\n    let node = this.#findMaxPosition();\n    return node ? node.val : null;\n  }\n\n  /**\n   * 查找树中最大值的位置\n   * @param {TreeNode} startNode 从指定节点开始查询\n   * @returns {TreeNode}\n   */\n  #findMaxPosition(startNode) {\n    startNode = startNode || this.#tree;\n    if (!startNode) {\n      console.warn("empty tree");\n      return null;\n    }\n    let node = startNode;\n    while (node.right) {\n      node = node.right;\n    }\n    return node;\n  }\n\n  /**\n   * 查找树中最小值\n   * @returns {number}\n   */\n  findMin() {\n    let node = this.#findMinPosition();\n    return node ? node.val : null;\n  }\n\n  /**\n   * 查找树中最小值的节点\n   * @param {TreeNode} startNode 从指定节点开始查询\n   * @returns {TreeNode}\n   */\n  #findMinPosition(startNode) {\n    startNode = startNode || this.#tree;\n    if (startNode) {\n      console.warn("empty tree");\n      return;\n    }\n    let node = startNode;\n    while (node.left) {\n      node = node.left;\n    }\n    return node;\n  }\n}\n\n\n\n# 复杂度分析\n\n二叉搜索树理想情况插入、查找、删除的效率是非常高的，是典型的二分查找思想，能达到 O(logN)，但是理想很丰满，现实很骨感。假设我们插入有序序列或者总是删除二叉搜索树的最大值或者最小值，最终我们的二叉搜索树竟然会成为一个链表，效率直接降到 O(N)，所以如何在插入或删除的时候总是使得我们的树左半部分和右半部分节点数差异不大，那么我们查找和删除的效率总能达到 O(logN)，这便是 AVL树或红黑树。AVL 树或红黑树在后面我们会详细讨论。',normalizedContent:'# 二叉搜索树\n\n二叉搜索树（或者叫二叉排序树），是一种特殊的二叉树，其中一个重要的性质是它的左子树的节点值均比根节点小，右子树的节点值均比根节点值大，并且其左右子树也是一颗二叉搜索树。\n\n正是因为这个性质，通常会采用二叉搜索树进行高效率的检索和删除操作。\n\n\n# 二叉搜索树的实现\n\n首先定义树节点的结构定义如下：\n\ninterface treenode<t> {\n  // 树节点的值域\n  val: t;\n  // 树节点的左子节点\n  left: treenode<t> | null;\n  // 树节点的右子节点\n  right: treenode<t> | null;\n}\n\n\n根据二叉搜索性质，我们可以得出一个结论:\n\n最大节点一定是在右子树上，并且一定没有右子节点。\n\n最小节点一定是在左子树上，并且这个节点一定没有左右儿子节点，即叶节点。\n\n二叉树的中序遍历序列一定是一个非降序的序列\n\n编程技巧\n\n二叉树的中序遍历序列一定是一个非降序的序列，因此可以用一颗树的中序序列来判断一颗树是否是二叉搜索树。\n\n二叉搜索树的主要操作有 find,findmin,findmax,insert,delete。\n\n\n# 递归实现\n\n# 查找\n\n根据二叉搜索树的定义，左儿子一定会比右儿子小。因此，如果我们当前起始节点不存在的话，说明对应的值在二叉树中不存在，如果当前节点存在，并且恰好和我们要找的节点值相等的话，那么就说明找到了，因此我们可以直接返回当前节点，如果待查找值比当前节点的值小，那么它只有可能在左子树上找的到，因次，我们沿着左子树递归，反之，我们则沿着右子树递归。\n\n# 插入\n\n对于插入，如果树是空，直接插入返回新树即可，如果树不为空，若待插入的值比根节点的值小，则沿着左子树进行插入，否则沿着右子树进行插入，重复这个过程直到找到合适的位置，完成插入。\n\n# 删除\n\n二叉搜索树的删除相比插入要复杂的多，我们需要考虑的情况比较多： 首先，递归的思路此处不再赘述了，如果传入的节点就不存在，说明要删除的值肯定在搜索树中根本不存在。\n\n我们主要考虑能找到待删除节点的情况，如下：\n\n * 1、没有左右儿子节点。\n * 2、仅有左儿子节点。\n * 3、仅有右儿子节点。\n * 4、同时具有左右儿子节点。\n\n对于 case1,因为不需要进行任何操作。 传入的是有值的节点，返回空，我们给上层节点的左（或者 右）儿子接上这个空，则完成了删除。\n\n对于 case2,也不难，不就是要删除当前节点嘛，好呀，我直接把当前节点变成当前节点的左儿子给你返回，你上层递归调用的函数不就老老实实的给我接上了吗，嘿嘿（或者，把当前节点的左儿子的值拷贝给自己，然后把当前节点的左儿子指针置为空，然后返回这个节点，不过好像没有必要这样做呢）。\n\n对于 case3,同 case2，只不过我们操作的是右儿子。\n\n对于 case4,也就是最关键的，这个问题需要利用转化的思想。首先，因为总是有右子树的任何节点比当前待删除节点大，左子树的任何节点比当前待删除节点的值小的性质。我们可以换个角度想，我从右子树里面先找一个最小值节点替换到当前的这个待删除节点上，如果不考虑之前找到的最小值节点，是否仍然满足二叉搜索树的性质呀，nice，那我再从这个位置开始把之前找到的最小值节点删了不就行了吗，哈哈哈。有的朋友会说了，待删除右子树的最小值节点可能同时有左右儿子节点嘛，不就又绕回来了吗。根据二叉搜索树的性质，当前子树的最小值肯定是不会再有左子节点的了。所以，我们再从待删除节点出发，递归的删除当前节点右子树的最小值即可（上述操作找左子树的最大值也可以）。\n\n/**\n * 二叉搜索树类\n */\nclass bst {\n  /**\n   * @type {treenode}\n   */\n  #tree = null;\n\n  /**\n   * 创建一个树节点\n   * @param {number} val\n   * @returns {treenode}\n   */\n  #createtreenode(val) {\n    return {\n      val,\n      left: null,\n      right: null,\n    };\n  }\n\n  /**\n   * 查找指定值是否在二叉搜索树中存在\n   * @param {number} val\n   * @returns {treenode}\n   */\n  find(val) {\n    return this.#find(val, this.#tree);\n  }\n\n  #find(val, node) {\n    if (!node) {\n      return null;\n    }\n    if (node.val === val) {\n      return node;\n    } else if (node.val > val) {\n      return this.#find(val, node.left);\n    } else if (node.val < val) {\n      return this.#find(val, node.right);\n    }\n  }\n\n  insert(val) {\n    this.tree = this.#insert(val, this.tree);\n  }\n\n  /**\n   * 使用递归的方式向搜索树中插入一个节点\n   * @param {number} val\n   * @param {node} node\n   * @returns\n   */\n  #insert(val, node) {\n    if (!node) {\n      node = this.#createtreenode(val);\n    } else {\n      if (val < node.val) {\n        node.left = this.#insert(val, node.left);\n      } else if (val > node.val) {\n        node.right = this.#insert(val, node.right);\n      }\n    }\n    return node;\n  }\n\n  delete(val) {\n    this.tree = this.#delete(val, this.tree);\n  }\n\n  /**\n   * 使用递归的方式删除一个节点\n   * @param {number} val 待删除的值\n   * @param {treenode} node 从指定的节点开始删除\n   * @returns\n   */\n  #delete(val, node) {\n    if (!node) {\n      console.warn("无法找到需要删除的值");\n      return null;\n    } else if (val > node.val) {\n      node.right = this.#delete(val, node.right);\n    } else if (val < node.val) {\n      node.left = this.#delete(val, node.left);\n    } else {\n      if (node.left && node.right) {\n        let rightmin = this.#findminposition(node.right);\n        node.val = rightmin.val;\n        node.right = this.#delete(rightmin.val, node.right);\n      } else if (node.left) {\n        node = node.left;\n      } else if (node.right) {\n        node = node.right;\n      } else {\n        node = null;\n      }\n    }\n    return node;\n  }\n}\n\n\n\n# 非递归实现\n\n# 查找\n\n对于查找此处不再赘述，递归和非递归完全类似\n\n# 插入\n\n对于插入，如果当前树是空的话直接插入即可。\n\n如果有插入相同的值肯定不允许插入。\n\n如果当前的节点值比待插入值小的话，说明我们应该往当前节点的右子树找位置插入才对。如果当前节点的右子树不存在的话，ok，恭喜你，这个位置就是你要插入的位置啦。我们的循环就没有必要再继续做下去了。否则，我们就接着从右子树下面找插入位置往下找呗。\n\n如果当前的节点值比待插入值大的话，说明我们应该往当前节点的左子树找位置插入才对。如果当前节点的左子树不存在，ok，恭喜你，这个位置就是你要插入的位置啦，结束循环。否则，我们接着从左子树下面找合适的插入位置。\n\n# 删除\n\n使用非递归删除二叉搜素树的思路和递归一致，但是代码的实现复杂程度一下子提高了很多。\n\n在使用递归删除的过程中，因为我们借用了系统的调用栈，我们可以很好的处理删除之后的节点引用关系，而使用非递归操作，这个过程完全就交给我们自己了，正所谓划了多少水，迟早要还的。\n\n首先，我们需要定义一个 parent 指针，因为一会儿需要用这个指针来连接子树。迭代步骤跟插入查找一致，此处不再赘述。退出第一个循环有 2 种情况: 树为空 或者 找到了待删除的节点。 如果是第一种情况，那好说，直接就啥事儿不用干，多好啊，哈哈哈。\n\n主要就是看第二种情况,这种情况下仍然和之前递归删除的时候我们需要考虑的问题是一致的，仍然是 4 种 case。\n\n首先考虑最简单的 case，当前待删除节点无左右儿子，此时 parent 指针指向的是父节点，但是有个问题需要注意哦，当前这个待删除节点是左儿子还是右儿子得根据父节点的值来确定哦。\n\n接着考虑待删除节点仅有右子节点的 case，这个 case 和删除没有左右儿子节点的节点的 case 类似，只需要把当前待删除节点的右子树接上就可以了。同样，还是需要考虑是用父节点的左儿子指针接还是右儿子指针接。\n\n待删除节点仅有左子节点的 case 和待删除节点仅有右子节点的 case 类似，此处也不再赘述。\n\n最后考虑同时有左右儿子的 case，好想递归调用删除节点方法有没有？哈哈哈哈。既然我们使用非递归删除，那就完完全全的用非递归实现吧。我们先用一个变量先把当前这个节点的位置先记住，免得一会儿向下迭代的时候找不到了。还是和递归删除的思路一致，当前节点的左子树找一个最大值或者右子树里面找一个最小值。找到之后把这个值拷贝到之前我们事先记住的那个节点上去，然后删除这个节点，又变成了删除只有单子节点的 case 了。\n\n这儿有一个需要注意的店是假设我们删除的时候以当前节点的左子树最大值替换待删除节点的值。\n\ndanger\n\n一定不要忘了，左子树的最大值是有可能有左子树的，一定不要忘了把这个子树给拼接上，否则就会丢失这一大块存储区域。\n\nleftmaxparentnode.right = leftmaxnode.left; // 拼接左子树，有可能没有左子树，但此步骤不能少。\n\n\n/**\n * 二叉搜索树的非递归实现\n */\nclass bst {\n  /**\n   * @type {treenode}\n   */\n  #tree = null;\n\n  /**\n   * 创建一个树节点\n   * @param {number} val\n   * @returns {treenode}\n   */\n  #createtreenode(val) {\n    return {\n      val,\n      left: null,\n      right: null,\n    };\n  }\n\n  /**\n   * 查找二叉树中值为val的节点\n   * @param {number} val\n   * @returns\n   */\n  #findposition(val) {\n    let node = this.#tree;\n    let targetnode = null;\n    while (node) {\n      if (node.val === val) {\n        targetnode = node;\n        break;\n      } else if (val > node.val) {\n        node = node.right;\n      } else if (val < node.val) {\n        node = node.left;\n      }\n    }\n    return targetnode;\n  }\n\n  /**\n   * 从二叉搜素树中删除一个值\n   * @param {number} val\n   */\n  delete(val) {\n    let node = this.#tree;\n    let parent = null;\n    while (node) {\n      // 如果找到了当前节点 则中断循环\n      if (node.val === val) {\n        break;\n      }\n      parent = node;\n      // 如果当前节点的值比val小，说明待删除的节点在右子树上\n      if (node.val < val) {\n        node = node.right;\n        // 如果当前节点的值比val大，说明待删除的节点在左子树上\n      } else if (node.val > val) {\n        node = node.left;\n      }\n    }\n    if (!node) {\n      console.warn("要删除的节点不存在");\n    } else if (node.left && node.right) {\n      let leftmaxparentnode = node;\n      let leftmaxnode = node.left;\n      // 退出循环的时候，leftmaxnode是肯定没有右子树节点的了\n      while (leftmaxnode.right) {\n        leftmaxparentnode = leftmaxnode;\n        leftmaxnode = leftmaxnode.right;\n      }\n      // 先把左子树的最大值拷贝到当前要删除的节点上去，然后从左子树删除左子树的最大值节点\n      node.val = leftmaxnode.val;\n      // 前驱节点的右指针指向当前节点的左指针 虽然leftmaxnode.left可能不存在，但是还是要将其链接在前驱节点的右子节点上\n      leftmaxparentnode.right = leftmaxnode.left;\n    } else if (node.left) {\n      if (parent === null) {\n        this.#tree = node.left;\n      } else {\n        // 判断当前节点是来源于左子节点还是右子节点\n        if (parent.val > node.val) {\n          parent.left = node.left;\n        } else {\n          parent.right = node.left;\n        }\n      }\n    } else if (node.right) {\n      if (parent === null) {\n        this.#tree = node.right;\n      } else {\n        // 判断当前节点是来源于左子节点还是右子节点\n        if (parent.val > node.val) {\n          parent.left = node.right;\n        } else {\n          parent.right = node.right;\n        }\n        node = null;\n      }\n    } else {\n      if (parent === null) {\n        this.#tree = null;\n      } else {\n        // 判断当前节点是来源于左子节点还是右子节点\n        if (parent.val > node.val) {\n          parent.left = null;\n        } else {\n          parent.right = null;\n        }\n      }\n      node = null;\n    }\n  }\n\n  /**\n   * 向二叉搜索树中插入一个值\n   * @param {number} val\n   */\n  insert(val) {\n    // 创建一个新的节点\n    let newnode = this.#createtreenode(val);\n    // 如果当前树为空, 直接将节点插入根节点\n    if (!this.#tree) {\n      this.#tree = newnode;\n      return;\n    }\n    let node = this.#tree;\n    while (true) {\n      // 如果插入相同值，直接报错\n      if (val === node.val) {\n        console.warn("不允许插入相同值的节点");\n        break;\n      }\n      // 如果当前值比节点值大，node向右子树下滤\n      else if (val > node.val) {\n        // 如果当前节点的右儿子没了，说明这个就是一个合适的插入位置\n        if (!node.right) {\n          node.right = newnode;\n          break;\n        }\n        // 沿着右子树下滤\n        node = node.right;\n        // 如果当前值比节点值小，node向左子树下滤\n      } else if (val < node.val) {\n        // 如果当前节点的左儿子没了，说明这个就是一个合适的插入位置\n        if (!node.left) {\n          node.left = newnode;\n          break;\n        }\n        // 沿着左子树下滤\n        node = node.left;\n      }\n    }\n  }\n\n  /**\n   * 查找树中最大值\n   */\n  findmax() {\n    let node = this.#findmaxposition();\n    return node ? node.val : null;\n  }\n\n  /**\n   * 查找树中最大值的位置\n   * @param {treenode} startnode 从指定节点开始查询\n   * @returns {treenode}\n   */\n  #findmaxposition(startnode) {\n    startnode = startnode || this.#tree;\n    if (!startnode) {\n      console.warn("empty tree");\n      return null;\n    }\n    let node = startnode;\n    while (node.right) {\n      node = node.right;\n    }\n    return node;\n  }\n\n  /**\n   * 查找树中最小值\n   * @returns {number}\n   */\n  findmin() {\n    let node = this.#findminposition();\n    return node ? node.val : null;\n  }\n\n  /**\n   * 查找树中最小值的节点\n   * @param {treenode} startnode 从指定节点开始查询\n   * @returns {treenode}\n   */\n  #findminposition(startnode) {\n    startnode = startnode || this.#tree;\n    if (startnode) {\n      console.warn("empty tree");\n      return;\n    }\n    let node = startnode;\n    while (node.left) {\n      node = node.left;\n    }\n    return node;\n  }\n}\n\n\n\n# 复杂度分析\n\n二叉搜索树理想情况插入、查找、删除的效率是非常高的，是典型的二分查找思想，能达到 o(logn)，但是理想很丰满，现实很骨感。假设我们插入有序序列或者总是删除二叉搜索树的最大值或者最小值，最终我们的二叉搜索树竟然会成为一个链表，效率直接降到 o(n)，所以如何在插入或删除的时候总是使得我们的树左半部分和右半部分节点数差异不大，那么我们查找和删除的效率总能达到 o(logn)，这便是 avl树或红黑树。avl 树或红黑树在后面我们会详细讨论。',charsets:{cjk:!0}},{title:"中序遍历",frontmatter:{},regularPath:"/data-structure/tree/binaryTree/inOrderVisit.html",relativePath:"data-structure/tree/binaryTree/inOrderVisit.md",key:"v-f5497496",path:"/data-structure/tree/binaryTree/inOrderVisit.html",headers:[{level:2,title:"中序遍历",slug:"中序遍历",normalizedTitle:"中序遍历",charIndex:2},{level:2,title:"递归遍历",slug:"递归遍历",normalizedTitle:"递归遍历",charIndex:146},{level:2,title:"非递归遍历",slug:"非递归遍历",normalizedTitle:"非递归遍历",charIndex:526},{level:2,title:"复杂度分析",slug:"复杂度分析",normalizedTitle:"复杂度分析",charIndex:1032}],headersStr:"中序遍历 递归遍历 非递归遍历 复杂度分析",content:'# 中序遍历\n\n假设我们的树节点的定义如下：\n\ninterface TreeNode<T> {\n  left: TreeNode | null;\n  right: TreeNode | null;\n  data: T;\n}\n\n\nTIP\n\n总是以左->根->右的顺序输出二叉树中的节点\n\n\n# 递归遍历\n\n/**\n * 中序递归遍历二叉树\n * @param {TreeNode<number>} tree 树的根节点\n */\nfunction treeInOrderTraverseRecursion(tree) {\n  if (!tree) {\n    console.log("empty tree");\n    return;\n  }\n  // 和先序递归遍历区别仅体现在输出的时机不同，因为代码的顺序会导致调用堆栈的循序的改变，因此可以完成中序遍历\n  tree.left && treeInOrderTraverseRecursion(tree.left);\n  console.log(tree.data);\n  tree.right && treeInOrderTraverseRecursion(tree.right);\n}\n\n\n\n# 非递归遍历\n\n/**\n * 二叉树非递归中序遍历\n * @param {TreeNode<number>} tree 树的根节点\n */\nfunction treeInOrderTraverse(tree) {\n  if (!tree) {\n    console.log("empty tree");\n    return;\n  }\n  let stack = [];\n  let node = tree;\n  while (stack.length > 0 || node) {\n    // 压栈的时候不能立即输出节点\n    while (node) {\n      stack.push(node);\n      node = node.left;\n    }\n    if (stack.length > 0) {\n      // 当从栈中取出节点时，方可以输出节点，接着再从当前节点的右子树进行遍历\n      node = stack.pop();\n      console.log(node.data);\n      node = node.right;\n    }\n  }\n}\n\n\n\n# 复杂度分析\n\n时间复杂度O(n)；空间复杂度O(h);',normalizedContent:'# 中序遍历\n\n假设我们的树节点的定义如下：\n\ninterface treenode<t> {\n  left: treenode | null;\n  right: treenode | null;\n  data: t;\n}\n\n\ntip\n\n总是以左->根->右的顺序输出二叉树中的节点\n\n\n# 递归遍历\n\n/**\n * 中序递归遍历二叉树\n * @param {treenode<number>} tree 树的根节点\n */\nfunction treeinordertraverserecursion(tree) {\n  if (!tree) {\n    console.log("empty tree");\n    return;\n  }\n  // 和先序递归遍历区别仅体现在输出的时机不同，因为代码的顺序会导致调用堆栈的循序的改变，因此可以完成中序遍历\n  tree.left && treeinordertraverserecursion(tree.left);\n  console.log(tree.data);\n  tree.right && treeinordertraverserecursion(tree.right);\n}\n\n\n\n# 非递归遍历\n\n/**\n * 二叉树非递归中序遍历\n * @param {treenode<number>} tree 树的根节点\n */\nfunction treeinordertraverse(tree) {\n  if (!tree) {\n    console.log("empty tree");\n    return;\n  }\n  let stack = [];\n  let node = tree;\n  while (stack.length > 0 || node) {\n    // 压栈的时候不能立即输出节点\n    while (node) {\n      stack.push(node);\n      node = node.left;\n    }\n    if (stack.length > 0) {\n      // 当从栈中取出节点时，方可以输出节点，接着再从当前节点的右子树进行遍历\n      node = stack.pop();\n      console.log(node.data);\n      node = node.right;\n    }\n  }\n}\n\n\n\n# 复杂度分析\n\n时间复杂度o(n)；空间复杂度o(h);',charsets:{cjk:!0}},{title:"层序遍历",frontmatter:{},regularPath:"/data-structure/tree/binaryTree/levelOrderVisit.html",relativePath:"data-structure/tree/binaryTree/levelOrderVisit.md",key:"v-23d56c5b",path:"/data-structure/tree/binaryTree/levelOrderVisit.html",headers:[{level:2,title:"层序遍历",slug:"层序遍历",normalizedTitle:"层序遍历",charIndex:2},{level:2,title:"复杂度分析",slug:"复杂度分析",normalizedTitle:"复杂度分析",charIndex:736}],headersStr:"层序遍历 复杂度分析",content:'# 层序遍历\n\n假设我们的树节点的定义如下：\n\ninterface TreeNode<T> {\n  left: TreeNode | null;\n  right: TreeNode | null;\n  data: T;\n}\n\n\nTIP\n\n总是按每层从左到右的顺序输出二叉树中的节点\n\n算法实现：\n\n/**\n * 二叉树的层序遍历\n * @param {TreeNode} tree 树的根节点\n */\nfunction treeLevelTraverse(tree) {\n  if (!tree) {\n    console.log("empty tree");\n    return;\n  }\n  let node = tree;\n  let list = [];\n  // 将跟节点入队\n  list.push(node);\n  // 如果队列不为空，则进行遍历\n  while (list.length > 0) {\n    // 从队首取出一个元素用以处理\n    const curNode = list.shift();\n    console.log(curNode.data);\n    // 如果存在左子树，将左子树入队\n    if (curNode.left) {\n      list.push(curNode.left);\n    }\n    // 如果存在右子树，将右子树入队\n    if (curNode.right) {\n      list.push(curNode.right);\n    }\n  }\n  /**\n   * 因为队列先入先出的特性，所以最后的打印顺序总是按层从上至下，每层从左到右的顺序输出\n   */\n}\n\n\n\n# 复杂度分析\n\n时间复杂度O(n)；空间复杂度O(w)，为二叉树的最大宽度;',normalizedContent:'# 层序遍历\n\n假设我们的树节点的定义如下：\n\ninterface treenode<t> {\n  left: treenode | null;\n  right: treenode | null;\n  data: t;\n}\n\n\ntip\n\n总是按每层从左到右的顺序输出二叉树中的节点\n\n算法实现：\n\n/**\n * 二叉树的层序遍历\n * @param {treenode} tree 树的根节点\n */\nfunction treeleveltraverse(tree) {\n  if (!tree) {\n    console.log("empty tree");\n    return;\n  }\n  let node = tree;\n  let list = [];\n  // 将跟节点入队\n  list.push(node);\n  // 如果队列不为空，则进行遍历\n  while (list.length > 0) {\n    // 从队首取出一个元素用以处理\n    const curnode = list.shift();\n    console.log(curnode.data);\n    // 如果存在左子树，将左子树入队\n    if (curnode.left) {\n      list.push(curnode.left);\n    }\n    // 如果存在右子树，将右子树入队\n    if (curnode.right) {\n      list.push(curnode.right);\n    }\n  }\n  /**\n   * 因为队列先入先出的特性，所以最后的打印顺序总是按层从上至下，每层从左到右的顺序输出\n   */\n}\n\n\n\n# 复杂度分析\n\n时间复杂度o(n)；空间复杂度o(w)，为二叉树的最大宽度;',charsets:{cjk:!0}},{title:"二叉树的 Morris 遍历法",frontmatter:{},regularPath:"/data-structure/tree/binaryTree/morrisVisit%20copy.html",relativePath:"data-structure/tree/binaryTree/morrisVisit copy.md",key:"v-a66e355c",path:"/data-structure/tree/binaryTree/morrisVisit%20copy.html",headers:[{level:2,title:"二叉树的 Morris 遍历法",slug:"二叉树的-morris-遍历法",normalizedTitle:"二叉树的 morris 遍历法",charIndex:2},{level:2,title:"递归序",slug:"递归序",normalizedTitle:"递归序",charIndex:261},{level:2,title:"Morris 先序",slug:"morris-先序",normalizedTitle:"morris 先序",charIndex:401},{level:2,title:"Morris 中序",slug:"morris-中序",normalizedTitle:"morris 中序",charIndex:415},{level:2,title:"Morris 后序",slug:"morris-后序",normalizedTitle:"morris 后序",charIndex:429},{level:2,title:"复杂度分析",slug:"复杂度分析",normalizedTitle:"复杂度分析",charIndex:443}],headersStr:"二叉树的 Morris 遍历法 递归序 Morris 先序 Morris 中序 Morris 后序 复杂度分析",content:"# 二叉树的 Morris 遍历法\n\n二叉树的 Morris遍历法是在传统二叉树遍历法的又一次改进。\n\n正常我们遍历二叉树时，都会有一定的空间复杂度，不管是利用递归还是非递归遍历，栈里面都要把树节点存起来，因为在遍历完成底部的也节点之后，我们需要顺着栈里面记录线索去找上层后面的节点。对于层序遍历来说，仍然需要把当前处理的儿子节点（若有）加入到队列中，也需要占用额外的内存。而Morris遍历法利用了二叉树的空闲指针，巧妙的用它记录后续的需要处理的节点，在完成底部的叶节点之后清楚的知道后面需要处理的节点在哪儿。\n\n\n# 递归序\n\n首先，我们得明白什么是递归序。\n\n对于这颗二叉树：\n\n\n\n不管怎么样，3 节点永远会比 2 节点和 4 节点先访问到，只不过，我们在某些场合，不是遇到 3 节点就立刻将其输出。因为有栈的关系，当我们处理到最叶节点的时候，能够根据栈内容清楚的知道回溯的准确位置。\n\n\n# Morris 先序\n\n\n# Morris 中序\n\n\n# Morris 后序\n\n\n# 复杂度分析",normalizedContent:"# 二叉树的 morris 遍历法\n\n二叉树的 morris遍历法是在传统二叉树遍历法的又一次改进。\n\n正常我们遍历二叉树时，都会有一定的空间复杂度，不管是利用递归还是非递归遍历，栈里面都要把树节点存起来，因为在遍历完成底部的也节点之后，我们需要顺着栈里面记录线索去找上层后面的节点。对于层序遍历来说，仍然需要把当前处理的儿子节点（若有）加入到队列中，也需要占用额外的内存。而morris遍历法利用了二叉树的空闲指针，巧妙的用它记录后续的需要处理的节点，在完成底部的叶节点之后清楚的知道后面需要处理的节点在哪儿。\n\n\n# 递归序\n\n首先，我们得明白什么是递归序。\n\n对于这颗二叉树：\n\n\n\n不管怎么样，3 节点永远会比 2 节点和 4 节点先访问到，只不过，我们在某些场合，不是遇到 3 节点就立刻将其输出。因为有栈的关系，当我们处理到最叶节点的时候，能够根据栈内容清楚的知道回溯的准确位置。\n\n\n# morris 先序\n\n\n# morris 中序\n\n\n# morris 后序\n\n\n# 复杂度分析",charsets:{cjk:!0}},{title:"二叉树的 Morris 遍历法",frontmatter:{},regularPath:"/data-structure/tree/binaryTree/morrisVisit.html",relativePath:"data-structure/tree/binaryTree/morrisVisit.md",key:"v-aaa51dc2",path:"/data-structure/tree/binaryTree/morrisVisit.html",headers:[{level:2,title:"二叉树的 Morris 遍历法",slug:"二叉树的-morris-遍历法",normalizedTitle:"二叉树的 morris 遍历法",charIndex:2}],headersStr:"二叉树的 Morris 遍历法",content:"# 二叉树的 Morris 遍历法\n\n建设中，敬请期待...",normalizedContent:"# 二叉树的 morris 遍历法\n\n建设中，敬请期待...",charsets:{cjk:!0}},{title:"后序遍历",frontmatter:{},regularPath:"/data-structure/tree/binaryTree/postOrderVisit.html",relativePath:"data-structure/tree/binaryTree/postOrderVisit.md",key:"v-785b8656",path:"/data-structure/tree/binaryTree/postOrderVisit.html",headers:[{level:2,title:"后序遍历",slug:"后序遍历",normalizedTitle:"后序遍历",charIndex:2},{level:2,title:"递归遍历",slug:"递归遍历",normalizedTitle:"递归遍历",charIndex:146},{level:2,title:"非递归遍历",slug:"非递归遍历",normalizedTitle:"非递归遍历",charIndex:509},{level:2,title:"复杂度分析",slug:"复杂度分析",normalizedTitle:"复杂度分析",charIndex:1245}],headersStr:"后序遍历 递归遍历 非递归遍历 复杂度分析",content:'# 后序遍历\n\n假设我们的树节点的定义如下：\n\ninterface TreeNode<T> {\n  left: TreeNode | null;\n  right: TreeNode | null;\n  data: T;\n}\n\n\nTIP\n\n总是以左->右->根的顺序输出二叉树中的节点\n\n\n# 递归遍历\n\n/**\n * 后序递归遍历二叉树\n * @param {TreeNode} tree 树的根节点\n */\nfunction treePostTraverseRecursion(tree) {\n  if (!tree) {\n    console.log("empty tree");\n    return;\n  }\n  // 和先序递归遍历区别仅体现在输出的时机不同，因为代码的顺序会导致调用堆栈的循序的改变，因此可以完成后序遍历\n  tree.left && treePostTraverseRecursion(tree.left);\n  tree.right && treePostTraverseRecursion(tree.right);\n  console.log(tree.data);\n}\n\n\n\n# 非递归遍历\n\n/**\n * 二叉树非递归后序遍历\n * @param {TreeNode} tree 树的根节点\n */\nfunction treePostTraverse(tree) {\n  if (!tree) {\n    console.log("empty tree");\n    return;\n  }\n  // 栈1用于遍历\n  let stack1 = [];\n  // 栈2用于保持输出顺序\n  let stack2 = [];\n  let node = tree;\n  stack1.push(node);\n  while (stack1.length > 0) {\n    node = stack1.pop();\n    // 将根节点加入栈2，先加入的后输出\n    stack2.push(node);\n    // 如果左子树存在，将左子树节点加入到栈1中\n    if (node.left != null) {\n      stack1.push(node.left);\n    }\n    // 如果右子树存在，将右子树节点加入到栈1中\n    if (node.right != null) {\n      stack1.push(node.right);\n    }\n    /**\n     * 因为先加入栈1的节点，会后输出，但是再加入栈2，又会先输出，所以这儿要先处理左子树，才能处理右子树\n     */\n  }\n  while (stack2.length > 0) {\n    let tempNode = stack2.pop();\n    console.log(tempNode.data);\n  }\n}\n\n\n\n# 复杂度分析\n\n时间复杂度O(n)；空间复杂度O(h);',normalizedContent:'# 后序遍历\n\n假设我们的树节点的定义如下：\n\ninterface treenode<t> {\n  left: treenode | null;\n  right: treenode | null;\n  data: t;\n}\n\n\ntip\n\n总是以左->右->根的顺序输出二叉树中的节点\n\n\n# 递归遍历\n\n/**\n * 后序递归遍历二叉树\n * @param {treenode} tree 树的根节点\n */\nfunction treeposttraverserecursion(tree) {\n  if (!tree) {\n    console.log("empty tree");\n    return;\n  }\n  // 和先序递归遍历区别仅体现在输出的时机不同，因为代码的顺序会导致调用堆栈的循序的改变，因此可以完成后序遍历\n  tree.left && treeposttraverserecursion(tree.left);\n  tree.right && treeposttraverserecursion(tree.right);\n  console.log(tree.data);\n}\n\n\n\n# 非递归遍历\n\n/**\n * 二叉树非递归后序遍历\n * @param {treenode} tree 树的根节点\n */\nfunction treeposttraverse(tree) {\n  if (!tree) {\n    console.log("empty tree");\n    return;\n  }\n  // 栈1用于遍历\n  let stack1 = [];\n  // 栈2用于保持输出顺序\n  let stack2 = [];\n  let node = tree;\n  stack1.push(node);\n  while (stack1.length > 0) {\n    node = stack1.pop();\n    // 将根节点加入栈2，先加入的后输出\n    stack2.push(node);\n    // 如果左子树存在，将左子树节点加入到栈1中\n    if (node.left != null) {\n      stack1.push(node.left);\n    }\n    // 如果右子树存在，将右子树节点加入到栈1中\n    if (node.right != null) {\n      stack1.push(node.right);\n    }\n    /**\n     * 因为先加入栈1的节点，会后输出，但是再加入栈2，又会先输出，所以这儿要先处理左子树，才能处理右子树\n     */\n  }\n  while (stack2.length > 0) {\n    let tempnode = stack2.pop();\n    console.log(tempnode.data);\n  }\n}\n\n\n\n# 复杂度分析\n\n时间复杂度o(n)；空间复杂度o(h);',charsets:{cjk:!0}},{title:"桥接模式",frontmatter:{},regularPath:"/design-pattern/bridge.html",relativePath:"design-pattern/bridge.md",key:"v-4ff83756",path:"/design-pattern/bridge.html",headersStr:null,content:"",normalizedContent:"",charsets:{}},{title:"命令模式",frontmatter:{},regularPath:"/design-pattern/command.html",relativePath:"design-pattern/command.md",key:"v-20aeabe7",path:"/design-pattern/command.html",headersStr:null,content:"",normalizedContent:"",charsets:{}},{title:"先序遍历",frontmatter:{},regularPath:"/data-structure/tree/binaryTree/preOrderVisit.html",relativePath:"data-structure/tree/binaryTree/preOrderVisit.md",key:"v-56edd5c6",path:"/data-structure/tree/binaryTree/preOrderVisit.html",headers:[{level:2,title:"先序遍历",slug:"先序遍历",normalizedTitle:"先序遍历",charIndex:2},{level:2,title:"递归遍历",slug:"递归遍历",normalizedTitle:"递归遍历",charIndex:146},{level:2,title:"非递归遍历",slug:"非递归遍历",normalizedTitle:"非递归遍历",charIndex:514},{level:2,title:"复杂度分析",slug:"复杂度分析",normalizedTitle:"复杂度分析",charIndex:1103}],headersStr:"先序遍历 递归遍历 非递归遍历 复杂度分析",content:'# 先序遍历\n\n假设我们的树节点的定义如下：\n\ninterface TreeNode<T> {\n  left: TreeNode | null;\n  right: TreeNode | null;\n  data: T;\n}\n\n\nTIP\n\n总是以根->左->右的顺序输出二叉树中的节点\n\n\n# 递归遍历\n\n/**\n * 先序递归遍历二叉树\n * @param {TreeNode<number>} tree\n */\nfunction treePreOrderRecursion(tree) {\n  // 如果树空，则完成遍历\n  if (!tree) {\n    console.log("tree empty!");\n    return;\n  }\n  // 打印当前节点的值\n  console.log(tree.data);\n  // 如果左子树存在，递归遍历左子树\n  tree.left && treePreOrderRecursion(tree.left);\n  // 如果右子树存在，递归遍历右子树\n  tree.right && treePreOrderRecursion(tree.right);\n}\n\n\n\n# 非递归遍历\n\n/**\n * 先序非递归遍历二叉树\n * @param {TreeNode<number>} tree\n */\nfunction treePreOrder(tree) {\n  if (!tree) {\n    console.log("empty tree!");\n    return;\n  }\n  // 定义一个栈用于模拟系统提供的堆栈\n  let stack = [];\n  // 让node指向树的跟节点，准备开始遍历\n  let node = tree;\n  // 如果树不空，或者栈中还有内容，则应该继续进行遍历\n  while (stack.length > 0 || node) {\n    // 如果node节点不为空的话，不断的向左压栈，直到为空\n    while (node) {\n      stack.push(node);\n      console.log(node.data);\n      node = node.left;\n    }\n    // 向左走到头了，若当前栈中还有内容，则从栈中取出一个内容，从当前内容的右子树继续遍历\n    if (stack.length > 0) {\n      node = stack.pop();\n      node = node.right;\n    }\n  }\n}\n\n\n\n# 复杂度分析\n\n不管是非递归遍历还是递归遍历，二叉树遍历的时间复杂度是O(n)(不管怎么样，你总得把所有的树节点都看一遍),空间复杂度为O(h)，h 为树的高度，使用递归遍历是用的系统的堆栈，而非递归遍历需要我们自己用一个栈去模拟系统堆栈的行为。',normalizedContent:'# 先序遍历\n\n假设我们的树节点的定义如下：\n\ninterface treenode<t> {\n  left: treenode | null;\n  right: treenode | null;\n  data: t;\n}\n\n\ntip\n\n总是以根->左->右的顺序输出二叉树中的节点\n\n\n# 递归遍历\n\n/**\n * 先序递归遍历二叉树\n * @param {treenode<number>} tree\n */\nfunction treepreorderrecursion(tree) {\n  // 如果树空，则完成遍历\n  if (!tree) {\n    console.log("tree empty!");\n    return;\n  }\n  // 打印当前节点的值\n  console.log(tree.data);\n  // 如果左子树存在，递归遍历左子树\n  tree.left && treepreorderrecursion(tree.left);\n  // 如果右子树存在，递归遍历右子树\n  tree.right && treepreorderrecursion(tree.right);\n}\n\n\n\n# 非递归遍历\n\n/**\n * 先序非递归遍历二叉树\n * @param {treenode<number>} tree\n */\nfunction treepreorder(tree) {\n  if (!tree) {\n    console.log("empty tree!");\n    return;\n  }\n  // 定义一个栈用于模拟系统提供的堆栈\n  let stack = [];\n  // 让node指向树的跟节点，准备开始遍历\n  let node = tree;\n  // 如果树不空，或者栈中还有内容，则应该继续进行遍历\n  while (stack.length > 0 || node) {\n    // 如果node节点不为空的话，不断的向左压栈，直到为空\n    while (node) {\n      stack.push(node);\n      console.log(node.data);\n      node = node.left;\n    }\n    // 向左走到头了，若当前栈中还有内容，则从栈中取出一个内容，从当前内容的右子树继续遍历\n    if (stack.length > 0) {\n      node = stack.pop();\n      node = node.right;\n    }\n  }\n}\n\n\n\n# 复杂度分析\n\n不管是非递归遍历还是递归遍历，二叉树遍历的时间复杂度是o(n)(不管怎么样，你总得把所有的树节点都看一遍),空间复杂度为o(h)，h 为树的高度，使用递归遍历是用的系统的堆栈，而非递归遍历需要我们自己用一个栈去模拟系统堆栈的行为。',charsets:{cjk:!0}},{title:"适配器模式",frontmatter:{},regularPath:"/design-pattern/adaptor.html",relativePath:"design-pattern/adaptor.md",key:"v-d039a31a",path:"/design-pattern/adaptor.html",headers:[{level:2,title:"适配器模式",slug:"适配器模式",normalizedTitle:"适配器模式",charIndex:2},{level:3,title:"1、基本概念",slug:"_1、基本概念",normalizedTitle:"1、基本概念",charIndex:12},{level:3,title:"2、代码范式",slug:"_2、代码范式",normalizedTitle:"2、代码范式",charIndex:250},{level:3,title:"3、在前端开发中的实践",slug:"_3、在前端开发中的实践",normalizedTitle:"3、在前端开发中的实践",charIndex:695}],headersStr:"适配器模式 1、基本概念 2、代码范式 3、在前端开发中的实践",content:'# 适配器模式\n\n\n# 1、基本概念\n\n适配器模式，将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。\n\n\n\n适配器模式的UML图如上述，其实挺简单的。\n\nTarget类定义了一套标准的API，但是因为现在Adaptee无法兼容Target的API，因此，编写了一个Adaptor类来保证API和Target的规格相同（所以Adaptor内部持有Adaptee），其内部实现就根据Target的规格调用与之能匹配的Adaptee的API。\n\n\n# 2、代码范式\n\nabstract class Target {\n  abstract render(): void;\n}\n\nclass Adaptee {\n  mount() {\n    console.log("渲染页面");\n  }\n}\n\nclass Adaptor extends Target {\n  private adaptee: Adaptee;\n\n  constructor(adaptee: Adaptee) {\n    this.adaptee = adaptee;\n  }\n\n  render() {\n    this.adaptee();\n  }\n}\n\nfunction bootstrap() {\n  const adaptor = new Adaptor(new Adaptee());\n  adaptor.render();\n}\n\n\n有了Adaptor，比如你的项目最开始用的是高德地图API，现在换成百度地图API，只需要修改Adaptor类即可。\n\n\n# 3、在前端开发中的实践\n\n适配器模式也是前端开发中常用的设计模式，而且是一个能够帮助你提高KPI的设计模式。\n\n举两个实际开发中可能遇到的例子：\n\n第一个例子，相信大家一定都听说过uni-app，taro这类跨平台的框架（还有比如typeorm能支持不同数据库的dialect），这些跨平台框架除了能够支持将一份的代码编译到对应的平台（因为写法不同），还能支持在它顶层暴露一些可以支持操作各个平台都支持的API。\n\n本文就以滴滴的mpx框架（一个增强Vue的跨平台框架）来阐述。\n\n比如有一个API，叫createApp，对于H5来说，可能这个API是从Vue里面导出的，对于小程序来说，可能这个API是存在于wx这个全局变量上的。\n\n但是对于写业务代码的同学来说，他可不想在调用createApp这个API的时候还关心特定的环境，如果每个操作，代码都需要这样写的话，那么用跨平台框架的意义又是什么呢？所以框架的设计者对用户暴露的API必须是统一的。此刻，在框架设计时就可以引入一个适配器来处理根据当前环境应用不同的宿主能力了。\n\nimport { createApp as createAppInH5 } from "vue";\n// 微信小程序 适配器，适配在微信小程序中的处理\nfunction wxAdaptor() {\n  return wx.createApp();\n}\n\n// vue 适配器，适配在浏览器中的处理\nfunction vueAdaptor() {\n  return createAppInH5();\n}\n\n// 适配器工厂，根据mpx提供的宿主环境选择对应平台的API处理\nfunction getAdaptor() {\n  let selectedAdaptor = null;\n  switch (mode) {\n    case "wx":\n      selectedAdaptor = wxAdaptor;\n      break;\n    default:\n      selectedAdaptor = vueAdaptor;\n      break;\n  }\n  return selectedAdaptor;\n}\n\n// 对外暴露一个包裹好的API，业务开发人员可以毫无心智负担的调用\nexport function createApp(...args) {\n  const adaptor = getAdaptor();\n  return adaptor.apply(this, args);\n}\n\n\n第二个例子，就拿现在我所在的业务团队来举例吧，因为公司的业务调整，原来北京的研发团队全部被解散，在成都新建了研发团队。\n\n由于不同的团队，有自己的编码风格，所以后来后端的接口就有一些调整，比如原来北京的同事取名叫user_id，现在的同事取名叫userId，还有些项目叫userid，拉齐他们的接口有一定的历史包袱，所以不能100%的做到拉齐。因此就只能通过业务开发去做这个兜底。\n\n此时，如果去改业务代码是不太聪明的，而且改动量不可估量，容易产生潜在的 bug，这显然是不太符合开闭原则的。\n\n但是我们有个比较好的办法，因为原来的数据接口（axios请求后端的接口）全部抽离在了一个数据访问层的，此刻就可以给它套一个适配器就可以精准解决这个问题。\n\n没有修改之前的代码如下：\n\n// 获取榜单数据列表\nfunction getRankList() {\n  return fetch("https://xxx.com/v2/api/getRankList").then((res) => res.json());\n}\n\n\n添加适配器之后的代码如下：\n\nfunction getRankList() {\n  return fetch("https://xxx.com/v2/api/getRankList")\n    .then((res) => res.json())\n    .then((res) => {\n      return {\n        ...res,\n        data: {\n          list: res.data.list.map((row) => {\n            const userId = row.userid || row.userId || row.user_id;\n            // 兜底全部可能的key，这样业务代码不需要进行修改\n            return {\n              ...row,\n              userId,\n              user_id: userId,\n              userid: userId,\n            };\n          }),\n        },\n      };\n    });\n}\n\n\n还有一个场景也与这个场景类似，其实我们在写的业务组件内部兜底需要做很多事儿的，而且代码也会比较多，如果我们直接用验证器校验数据，然后在组件内部就不在需要做兜底的话，那代码写起来肯定要舒服很多，此刻就可以利用迭代器的思路，在给组件传递数据之前对其进行标准化。\n\n下述代码是一个简单的例子：\n\n// 数据访问层\nfunction standardUserInfo(user) {\n  return {\n    ...user,\n    address: user.address || {\n      province: "北京市",\n      city: "北京市",\n      area: "海淀区",\n    },\n  };\n}\n\nfunction getUserList() {\n  return fetch("/getUsers").then((res) => {\n    return {\n      ...res,\n      data: (res.data || []).map(standardUserInfo),\n    };\n  });\n}\n\n\n// 业务组件\nimport React from "react";\nimport getUserList from "repository";\n\nclass UserList extends React.Component {\n  constructor() {\n    super();\n    this.state = {\n      userList: [],\n    };\n  }\n\n  componentDidMount() {\n    getUserList().then((res) => {\n      this.setState({\n        userList: res.data,\n      });\n    });\n  }\n\n  render() {\n    return (\n      <div class="wrapper">\n        {this.state.userList.map((u, idx) => {\n          return <User info={u} key={idx} />;\n        })}\n      </div>\n    );\n  }\n}\n\n\n阅读完本文的读者，快快把适配器模式用起来，提高你的KPI吧~',normalizedContent:'# 适配器模式\n\n\n# 1、基本概念\n\n适配器模式，将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。\n\n\n\n适配器模式的uml图如上述，其实挺简单的。\n\ntarget类定义了一套标准的api，但是因为现在adaptee无法兼容target的api，因此，编写了一个adaptor类来保证api和target的规格相同（所以adaptor内部持有adaptee），其内部实现就根据target的规格调用与之能匹配的adaptee的api。\n\n\n# 2、代码范式\n\nabstract class target {\n  abstract render(): void;\n}\n\nclass adaptee {\n  mount() {\n    console.log("渲染页面");\n  }\n}\n\nclass adaptor extends target {\n  private adaptee: adaptee;\n\n  constructor(adaptee: adaptee) {\n    this.adaptee = adaptee;\n  }\n\n  render() {\n    this.adaptee();\n  }\n}\n\nfunction bootstrap() {\n  const adaptor = new adaptor(new adaptee());\n  adaptor.render();\n}\n\n\n有了adaptor，比如你的项目最开始用的是高德地图api，现在换成百度地图api，只需要修改adaptor类即可。\n\n\n# 3、在前端开发中的实践\n\n适配器模式也是前端开发中常用的设计模式，而且是一个能够帮助你提高kpi的设计模式。\n\n举两个实际开发中可能遇到的例子：\n\n第一个例子，相信大家一定都听说过uni-app，taro这类跨平台的框架（还有比如typeorm能支持不同数据库的dialect），这些跨平台框架除了能够支持将一份的代码编译到对应的平台（因为写法不同），还能支持在它顶层暴露一些可以支持操作各个平台都支持的api。\n\n本文就以滴滴的mpx框架（一个增强vue的跨平台框架）来阐述。\n\n比如有一个api，叫createapp，对于h5来说，可能这个api是从vue里面导出的，对于小程序来说，可能这个api是存在于wx这个全局变量上的。\n\n但是对于写业务代码的同学来说，他可不想在调用createapp这个api的时候还关心特定的环境，如果每个操作，代码都需要这样写的话，那么用跨平台框架的意义又是什么呢？所以框架的设计者对用户暴露的api必须是统一的。此刻，在框架设计时就可以引入一个适配器来处理根据当前环境应用不同的宿主能力了。\n\nimport { createapp as createappinh5 } from "vue";\n// 微信小程序 适配器，适配在微信小程序中的处理\nfunction wxadaptor() {\n  return wx.createapp();\n}\n\n// vue 适配器，适配在浏览器中的处理\nfunction vueadaptor() {\n  return createappinh5();\n}\n\n// 适配器工厂，根据mpx提供的宿主环境选择对应平台的api处理\nfunction getadaptor() {\n  let selectedadaptor = null;\n  switch (mode) {\n    case "wx":\n      selectedadaptor = wxadaptor;\n      break;\n    default:\n      selectedadaptor = vueadaptor;\n      break;\n  }\n  return selectedadaptor;\n}\n\n// 对外暴露一个包裹好的api，业务开发人员可以毫无心智负担的调用\nexport function createapp(...args) {\n  const adaptor = getadaptor();\n  return adaptor.apply(this, args);\n}\n\n\n第二个例子，就拿现在我所在的业务团队来举例吧，因为公司的业务调整，原来北京的研发团队全部被解散，在成都新建了研发团队。\n\n由于不同的团队，有自己的编码风格，所以后来后端的接口就有一些调整，比如原来北京的同事取名叫user_id，现在的同事取名叫userid，还有些项目叫userid，拉齐他们的接口有一定的历史包袱，所以不能100%的做到拉齐。因此就只能通过业务开发去做这个兜底。\n\n此时，如果去改业务代码是不太聪明的，而且改动量不可估量，容易产生潜在的 bug，这显然是不太符合开闭原则的。\n\n但是我们有个比较好的办法，因为原来的数据接口（axios请求后端的接口）全部抽离在了一个数据访问层的，此刻就可以给它套一个适配器就可以精准解决这个问题。\n\n没有修改之前的代码如下：\n\n// 获取榜单数据列表\nfunction getranklist() {\n  return fetch("https://xxx.com/v2/api/getranklist").then((res) => res.json());\n}\n\n\n添加适配器之后的代码如下：\n\nfunction getranklist() {\n  return fetch("https://xxx.com/v2/api/getranklist")\n    .then((res) => res.json())\n    .then((res) => {\n      return {\n        ...res,\n        data: {\n          list: res.data.list.map((row) => {\n            const userid = row.userid || row.userid || row.user_id;\n            // 兜底全部可能的key，这样业务代码不需要进行修改\n            return {\n              ...row,\n              userid,\n              user_id: userid,\n              userid: userid,\n            };\n          }),\n        },\n      };\n    });\n}\n\n\n还有一个场景也与这个场景类似，其实我们在写的业务组件内部兜底需要做很多事儿的，而且代码也会比较多，如果我们直接用验证器校验数据，然后在组件内部就不在需要做兜底的话，那代码写起来肯定要舒服很多，此刻就可以利用迭代器的思路，在给组件传递数据之前对其进行标准化。\n\n下述代码是一个简单的例子：\n\n// 数据访问层\nfunction standarduserinfo(user) {\n  return {\n    ...user,\n    address: user.address || {\n      province: "北京市",\n      city: "北京市",\n      area: "海淀区",\n    },\n  };\n}\n\nfunction getuserlist() {\n  return fetch("/getusers").then((res) => {\n    return {\n      ...res,\n      data: (res.data || []).map(standarduserinfo),\n    };\n  });\n}\n\n\n// 业务组件\nimport react from "react";\nimport getuserlist from "repository";\n\nclass userlist extends react.component {\n  constructor() {\n    super();\n    this.state = {\n      userlist: [],\n    };\n  }\n\n  componentdidmount() {\n    getuserlist().then((res) => {\n      this.setstate({\n        userlist: res.data,\n      });\n    });\n  }\n\n  render() {\n    return (\n      <div class="wrapper">\n        {this.state.userlist.map((u, idx) => {\n          return <user info={u} key={idx} />;\n        })}\n      </div>\n    );\n  }\n}\n\n\n阅读完本文的读者，快快把适配器模式用起来，提高你的kpi吧~',charsets:{cjk:!0}},{title:"装饰模式",frontmatter:{},regularPath:"/design-pattern/decorator.html",relativePath:"design-pattern/decorator.md",key:"v-e73b2872",path:"/design-pattern/decorator.html",headers:[{level:2,title:"装饰模式",slug:"装饰模式",normalizedTitle:"装饰模式",charIndex:2},{level:3,title:"1、基本概念",slug:"_1、基本概念",normalizedTitle:"1、基本概念",charIndex:11},{level:3,title:"2、代码示例",slug:"_2、代码示例",normalizedTitle:"2、代码示例",charIndex:210},{level:3,title:"3、在前端开发中的实践",slug:"_3、在前端开发中的实践",normalizedTitle:"3、在前端开发中的实践",charIndex:2166}],headersStr:"装饰模式 1、基本概念 2、代码示例 3、在前端开发中的实践",content:'# 装饰模式\n\n\n# 1、基本概念\n\n装饰模式是为已有功能动态的添加更多功能的一种方式\n\n当系统需要新功能的时候，是向旧的类中添加新的代码，这些新加的代码通常装饰了原有类的核心职责或者主要行为。\n\n\n\n上述UML图含义如下：Decorator不仅需要实现Component类，并且其内部还需要依赖一个Component类（承载内部Component对象链的起始点），具体的业务根据需要来继承Decorator类\n\n\n# 2、代码示例\n\ninterface Component {\n  run(): void;\n}\n\nclass Decorator implements Component {\n  protected component: Component | null;\n\n  constructor(component?: Component) {\n    this.component = component || null;\n  }\n\n  run(): void {\n    if (this.component) {\n      this.component.run();\n    }\n  }\n\n  decorate(com: Component): Component {\n    this.component = com;\n    return this;\n  }\n}\n\nclass GotoWork implements Component {\n  run(): void {\n    console.log("去上班了，不上班没有钱啊");\n  }\n}\n\nclass TakePhotoDecorator extends Decorator {\n  run(): void {\n    console.log("拍照，记录下春天美美的花草");\n    super.run();\n  }\n}\n\nclass LookBeautyDecorator extends Decorator {\n  run(): void {\n    console.log("男人至死是少年，不看美女怎么行呢");\n    super.run();\n  }\n}\n\nlet work = new GotoWork();\nconst take = new TakePhotoDecorator();\nconst look = new LookBeautyDecorator();\nwork = take.decorate(work);\nwork = look.decorate(work);\nwork.run();\n\n\n上述代码中，我稍微做了一点儿处理，Decorator类的装饰方法返回的是Component，这样就可以把装饰好的结果赋值给最开始的对象（work = take.decorate(work);，改写了初始化的work对象，而不用最终调用look.run方法）最好执行方法的时候，逻辑上看起来比较好理解一些。\n\n或者，我又思考了另外一种实现：\n\ninterface Component {\n  run(): void;\n}\n\nclass DecorateAbility implements Component {\n  /**\n   * 可以根据自己的需要用数组还是用Set来存储装饰类\n   */\n  protected components: Set<Component> = new Set();\n\n  run(): void {\n    this.components.forEach((com) => {\n      com.run();\n    });\n  }\n\n  decorate(com: Component) {\n    // 保证唯一值\n    this.components.add(com);\n  }\n}\n\nclass TakePhotoComponent implements Component {\n  run(): void {\n    console.log("拍照，记录下春天美美的花草");\n  }\n}\n\nclass LookBeautyComponent implements Component {\n  run(): void {\n    console.log("男人至死是少年，不看美女怎么行呢");\n  }\n}\n\nclass Work extends DecorateAbility {\n  run(): void {\n    super.run();\n    console.log("要上班啊，不上班怎么有钱呢?");\n  }\n}\n\nconst work = new Work();\nconst take = new TakePhotoComponent();\nconst look = new LookBeautyComponent();\nwork.decorate(take);\nwork.decorate(look);\nwork.run();\n\n\n这样，当每次调用decorate方法时，就是在给Work类的实例增加能力，不需要再考虑实例，逻辑上更好理解。\n\n\n# 3、在前端开发中的实践\n\n装饰模式的思想我们已经领悟到了其关键点—>不修改原本的内容，扩展其能力，但是如果真的把代码写成这样的话，还是比较复杂的。\n\n如果有学习过Spring这类框架的同学一定对AOP（面向切面编程）有所了解，装饰模式就是这个思想，那抓住重点，我们就可以使用AOP来实现装饰模式。\n\n因为JS有自己的语法特性，所以我们实现起来就不必那么绕了。\n\n/**\n * 增加前置执行的函数\n */\nFunction.prototype.beforeExec = function (fn) {\n  const _this = this;\n  return function wrapper() {\n    fn.apply(this, arguments);\n    return _this.apply(this, arguments);\n  };\n};\n/**\n * 增加后置执行的函数\n */\nFunction.prototype.afterExec = function (fn) {\n  const _this = this;\n  return function wrapper() {\n    const response = _this.apply(_this, arguments);\n    fn.apply(_this, arguments);\n    return response;\n  };\n};\n\n\n为原型绑定这两个函数之后，比如在多人合作开发一个项目时，我们其实不知道window.onload上目前挂载了什么业务逻辑需要处理，但是又不敢贸然直接给window.onload赋值一个新函数，此刻，上述装饰模式的实现方式就派上了大用处。\n\nfunction onLoad() {\n  console.log("我想处理一些业务逻辑");\n}\n// 不需要担心覆盖其它开发者增加的onload事件\nwindow.onload =\n  typeof window.onload === "function"\n    ? window.onload.beforeExec(onLoad)\n    : onLoad;\n\n\n并且，再执行这个操作，仍然可以扩展window.onload回调函数的能力不用担心覆盖之前的内容。\n\n以下是使用装饰模式处理axios请求增加loading提示的例子：\n\nimport fetch from "axios";\nimport Vue from "vue";\n/**\n * 为请求注入loading\n * @param {Function} fn 请求后端的函数\n * @param {String} msg loading提示信息\n * @returns\n */\nfunction decorate(fn, msg = "") {\n  return function enhance() {\n    Vue.prototype.$loading.show(msg);\n    const result = fn.apply(this, arguments);\n    if (result && typeof result.then === "function") {\n      return result\n        .then((resp) => {\n          Vue.prototype.$loading.hide();\n          return resp;\n        })\n        .catch(() => {\n          Vue.prototype.$loading.hide();\n        });\n    }\n    return result;\n  };\n}\n\n/**\n * 获取活动配置\n */\nexport const getAppInfo = decorate(function getAppInfo() {\n  return fetch("/api/baofang/y2023/y2023/TombSweepingDay0403/index");\n});\n\n\n经过这个装饰函数之后，业务侧只需要关心数据处理逻辑，不用再关注处理页面的提示信息，简化调用。而对于一些不需要loading提示，或者处理比较复杂的loading就不走这个decorate装饰函数，根据业务需要灵活的控制。\n\n在ES5及之前，我们只能通过这种办法实现装饰模式，但是ES6引入了一个新的语法：Decorator（不仅可以增加原对象的能力，还可以削弱原对象的能力），同样可以实现上述方式。\n\n因为Decorator在ES6仍然是一个提案，其语法仍然在变化当中，本文以2020年的装饰器语法进行阐述：\n\nfunction log(target: Object, name: string, descriptor: PropertyDescriptor) {\n  var oldValue = descriptor.value;\n  descriptor.value = function () {\n    console.log(`Calling ${name} with`, arguments);\n    return oldValue.apply(this, arguments);\n  };\n  return descriptor;\n}\n\nclass MyClass {\n  @log\n  handleClick() {\n    console.log("用户点击了按钮");\n  }\n}\n\n\n目前装饰器的语法，上述代码可能已经无法正常运行了。\n\n其实它的思路和我们写的AOP函数是一样的，也是通过重写原函数增强了原函数的能力，未来装饰器的语法何去何从还不得而知，大家就权当看看稀奇吧。',normalizedContent:'# 装饰模式\n\n\n# 1、基本概念\n\n装饰模式是为已有功能动态的添加更多功能的一种方式\n\n当系统需要新功能的时候，是向旧的类中添加新的代码，这些新加的代码通常装饰了原有类的核心职责或者主要行为。\n\n\n\n上述uml图含义如下：decorator不仅需要实现component类，并且其内部还需要依赖一个component类（承载内部component对象链的起始点），具体的业务根据需要来继承decorator类\n\n\n# 2、代码示例\n\ninterface component {\n  run(): void;\n}\n\nclass decorator implements component {\n  protected component: component | null;\n\n  constructor(component?: component) {\n    this.component = component || null;\n  }\n\n  run(): void {\n    if (this.component) {\n      this.component.run();\n    }\n  }\n\n  decorate(com: component): component {\n    this.component = com;\n    return this;\n  }\n}\n\nclass gotowork implements component {\n  run(): void {\n    console.log("去上班了，不上班没有钱啊");\n  }\n}\n\nclass takephotodecorator extends decorator {\n  run(): void {\n    console.log("拍照，记录下春天美美的花草");\n    super.run();\n  }\n}\n\nclass lookbeautydecorator extends decorator {\n  run(): void {\n    console.log("男人至死是少年，不看美女怎么行呢");\n    super.run();\n  }\n}\n\nlet work = new gotowork();\nconst take = new takephotodecorator();\nconst look = new lookbeautydecorator();\nwork = take.decorate(work);\nwork = look.decorate(work);\nwork.run();\n\n\n上述代码中，我稍微做了一点儿处理，decorator类的装饰方法返回的是component，这样就可以把装饰好的结果赋值给最开始的对象（work = take.decorate(work);，改写了初始化的work对象，而不用最终调用look.run方法）最好执行方法的时候，逻辑上看起来比较好理解一些。\n\n或者，我又思考了另外一种实现：\n\ninterface component {\n  run(): void;\n}\n\nclass decorateability implements component {\n  /**\n   * 可以根据自己的需要用数组还是用set来存储装饰类\n   */\n  protected components: set<component> = new set();\n\n  run(): void {\n    this.components.foreach((com) => {\n      com.run();\n    });\n  }\n\n  decorate(com: component) {\n    // 保证唯一值\n    this.components.add(com);\n  }\n}\n\nclass takephotocomponent implements component {\n  run(): void {\n    console.log("拍照，记录下春天美美的花草");\n  }\n}\n\nclass lookbeautycomponent implements component {\n  run(): void {\n    console.log("男人至死是少年，不看美女怎么行呢");\n  }\n}\n\nclass work extends decorateability {\n  run(): void {\n    super.run();\n    console.log("要上班啊，不上班怎么有钱呢?");\n  }\n}\n\nconst work = new work();\nconst take = new takephotocomponent();\nconst look = new lookbeautycomponent();\nwork.decorate(take);\nwork.decorate(look);\nwork.run();\n\n\n这样，当每次调用decorate方法时，就是在给work类的实例增加能力，不需要再考虑实例，逻辑上更好理解。\n\n\n# 3、在前端开发中的实践\n\n装饰模式的思想我们已经领悟到了其关键点—>不修改原本的内容，扩展其能力，但是如果真的把代码写成这样的话，还是比较复杂的。\n\n如果有学习过spring这类框架的同学一定对aop（面向切面编程）有所了解，装饰模式就是这个思想，那抓住重点，我们就可以使用aop来实现装饰模式。\n\n因为js有自己的语法特性，所以我们实现起来就不必那么绕了。\n\n/**\n * 增加前置执行的函数\n */\nfunction.prototype.beforeexec = function (fn) {\n  const _this = this;\n  return function wrapper() {\n    fn.apply(this, arguments);\n    return _this.apply(this, arguments);\n  };\n};\n/**\n * 增加后置执行的函数\n */\nfunction.prototype.afterexec = function (fn) {\n  const _this = this;\n  return function wrapper() {\n    const response = _this.apply(_this, arguments);\n    fn.apply(_this, arguments);\n    return response;\n  };\n};\n\n\n为原型绑定这两个函数之后，比如在多人合作开发一个项目时，我们其实不知道window.onload上目前挂载了什么业务逻辑需要处理，但是又不敢贸然直接给window.onload赋值一个新函数，此刻，上述装饰模式的实现方式就派上了大用处。\n\nfunction onload() {\n  console.log("我想处理一些业务逻辑");\n}\n// 不需要担心覆盖其它开发者增加的onload事件\nwindow.onload =\n  typeof window.onload === "function"\n    ? window.onload.beforeexec(onload)\n    : onload;\n\n\n并且，再执行这个操作，仍然可以扩展window.onload回调函数的能力不用担心覆盖之前的内容。\n\n以下是使用装饰模式处理axios请求增加loading提示的例子：\n\nimport fetch from "axios";\nimport vue from "vue";\n/**\n * 为请求注入loading\n * @param {function} fn 请求后端的函数\n * @param {string} msg loading提示信息\n * @returns\n */\nfunction decorate(fn, msg = "") {\n  return function enhance() {\n    vue.prototype.$loading.show(msg);\n    const result = fn.apply(this, arguments);\n    if (result && typeof result.then === "function") {\n      return result\n        .then((resp) => {\n          vue.prototype.$loading.hide();\n          return resp;\n        })\n        .catch(() => {\n          vue.prototype.$loading.hide();\n        });\n    }\n    return result;\n  };\n}\n\n/**\n * 获取活动配置\n */\nexport const getappinfo = decorate(function getappinfo() {\n  return fetch("/api/baofang/y2023/y2023/tombsweepingday0403/index");\n});\n\n\n经过这个装饰函数之后，业务侧只需要关心数据处理逻辑，不用再关注处理页面的提示信息，简化调用。而对于一些不需要loading提示，或者处理比较复杂的loading就不走这个decorate装饰函数，根据业务需要灵活的控制。\n\n在es5及之前，我们只能通过这种办法实现装饰模式，但是es6引入了一个新的语法：decorator（不仅可以增加原对象的能力，还可以削弱原对象的能力），同样可以实现上述方式。\n\n因为decorator在es6仍然是一个提案，其语法仍然在变化当中，本文以2020年的装饰器语法进行阐述：\n\nfunction log(target: object, name: string, descriptor: propertydescriptor) {\n  var oldvalue = descriptor.value;\n  descriptor.value = function () {\n    console.log(`calling ${name} with`, arguments);\n    return oldvalue.apply(this, arguments);\n  };\n  return descriptor;\n}\n\nclass myclass {\n  @log\n  handleclick() {\n    console.log("用户点击了按钮");\n  }\n}\n\n\n目前装饰器的语法，上述代码可能已经无法正常运行了。\n\n其实它的思路和我们写的aop函数是一样的，也是通过重写原函数增强了原函数的能力，未来装饰器的语法何去何从还不得而知，大家就权当看看稀奇吧。',charsets:{cjk:!0}},{title:"工厂模式",frontmatter:{},regularPath:"/design-pattern/factory.html",relativePath:"design-pattern/factory.md",key:"v-0d51cfe9",path:"/design-pattern/factory.html",headers:[{level:2,title:"工厂模式",slug:"工厂模式",normalizedTitle:"工厂模式",charIndex:2}],headersStr:"工厂模式",content:'# 工厂模式\n\n// 简单工厂模式\ninterface Component {\n  render(): void;\n}\n\nclass Button implements Component {\n  constructor(private text: string) {}\n  render() {\n    console.log(`Rendering button: ${this.text}`);\n  }\n}\n\nclass Input implements Component {\n  constructor(private placeholder: string) {}\n  render() {\n    console.log(`Rendering input: ${this.placeholder}`);\n  }\n}\n\nclass ComponentFactory {\n  static create(type: string, props: Record<string, any>): Component {\n    switch (type) {\n      case "button":\n        return new Button(props.text);\n      case "input":\n        return new Input(props.placeholder);\n      default:\n        throw new Error(`Type ${type} is not supported`);\n    }\n  }\n}\n\n// 创建按钮组件\nconst button = ComponentFactory.create("button", { text: "Click me!" });\nbutton.render();\n\n\n// 工厂方法模式\ninterface Component {\n  render(): void;\n}\n\nclass Button implements Component {\n  constructor(private text: string) {}\n  render() {\n    console.log(`Rendering button: ${this.text}`);\n  }\n}\n\nclass Input implements Component {\n  constructor(private placeholder: string) {}\n  render() {\n    console.log(`Rendering input: ${this.placeholder}`);\n  }\n}\n\nabstract class ComponentFactory {\n  abstract create(props: Record<string, any>): Component;\n}\n\nclass ButtonFactory extends ComponentFactory {\n  create(props: Record<string, any>) {\n    return new Button(props.text);\n  }\n}\n\nclass InputFactory extends ComponentFactory {\n  create(props: Record<string, any>) {\n    return new Input(props.placeholder);\n  }\n}\n\n// 创建输入框组件\nconst inputFactory = new InputFactory();\nconst input = inputFactory.create({ placeholder: \'Please input\' });\ninput.render();\n\n\n\n// 抽象工厂接口\ninterface UIComponentFactory {\n  createButton(): ButtonComponent;\n  createInput(): InputComponent;\n}\n\n// 抽象按钮组件\ninterface ButtonComponent {\n  render(): void;\n  onClick(handler: () => void): void;\n}\n\n// 抽象输入框组件\ninterface InputComponent {\n  render(): void;\n  onInput(handler: (value: string) => void): void;\n}\n\n// 具体工厂：Bootstrap 组件工厂\nclass BootstrapUIComponentFactory implements UIComponentFactory {\n  createButton(): ButtonComponent {\n    return new BootstrapButtonComponent();\n  }\n\n  createInput(): InputComponent {\n    return new BootstrapInputComponent();\n  }\n}\n\n// 具体工厂：Material 组件工厂\nclass MaterialUIComponentFactory implements UIComponentFactory {\n  createButton(): ButtonComponent {\n    return new MaterialButtonComponent();\n  }\n\n  createInput(): InputComponent {\n    return new MaterialInputComponent();\n  }\n}\n\n// 具体按钮组件：Bootstrap 按钮\nclass BootstrapButtonComponent implements ButtonComponent {\n  render() {\n    console.log("Rendering Bootstrap button component");\n  }\n\n  onClick(handler: () => void) {\n    console.log("Attaching onClick event for Bootstrap button component");\n  }\n}\n\n// 具体按钮组件：Material 按钮\nclass MaterialButtonComponent implements ButtonComponent {\n  render() {\n    console.log("Rendering Material button component");\n  }\n\n  onClick(handler: () => void) {\n    console.log("Attaching onClick event for Material button component");\n  }\n}\n\n// 具体输入框组件：Bootstrap 输入框\nclass BootstrapInputComponent implements InputComponent {\n  render() {\n    console.log("Rendering Bootstrap input component");\n  }\n\n  onInput(handler: (value: string) => void) {\n    console.log("Attaching onInput event for Bootstrap input component");\n  }\n}\n\n// 具体输入框组件：Material 输入框\nclass MaterialInputComponent implements InputComponent {\n  render() {\n    console.log("Rendering Material input component");\n  }\n\n  onInput(handler: (value: string) => void) {\n    console.log("Attaching onInput event for Material input component");\n  }\n}\n\n// 客户端代码\nconst bootstrapFactory = new BootstrapUIComponentFactory();\nconst button1 = bootstrapFactory.createButton();\nconst input1 = bootstrapFactory.createInput();\nbutton1.render();\ninput1.render();\n\nconst materialFactory = new MaterialUIComponentFactory();\nconst button2 = materialFactory.createButton();\nconst input2 = materialFactory.createInput();\nbutton2.render();\ninput2.render();\n',normalizedContent:'# 工厂模式\n\n// 简单工厂模式\ninterface component {\n  render(): void;\n}\n\nclass button implements component {\n  constructor(private text: string) {}\n  render() {\n    console.log(`rendering button: ${this.text}`);\n  }\n}\n\nclass input implements component {\n  constructor(private placeholder: string) {}\n  render() {\n    console.log(`rendering input: ${this.placeholder}`);\n  }\n}\n\nclass componentfactory {\n  static create(type: string, props: record<string, any>): component {\n    switch (type) {\n      case "button":\n        return new button(props.text);\n      case "input":\n        return new input(props.placeholder);\n      default:\n        throw new error(`type ${type} is not supported`);\n    }\n  }\n}\n\n// 创建按钮组件\nconst button = componentfactory.create("button", { text: "click me!" });\nbutton.render();\n\n\n// 工厂方法模式\ninterface component {\n  render(): void;\n}\n\nclass button implements component {\n  constructor(private text: string) {}\n  render() {\n    console.log(`rendering button: ${this.text}`);\n  }\n}\n\nclass input implements component {\n  constructor(private placeholder: string) {}\n  render() {\n    console.log(`rendering input: ${this.placeholder}`);\n  }\n}\n\nabstract class componentfactory {\n  abstract create(props: record<string, any>): component;\n}\n\nclass buttonfactory extends componentfactory {\n  create(props: record<string, any>) {\n    return new button(props.text);\n  }\n}\n\nclass inputfactory extends componentfactory {\n  create(props: record<string, any>) {\n    return new input(props.placeholder);\n  }\n}\n\n// 创建输入框组件\nconst inputfactory = new inputfactory();\nconst input = inputfactory.create({ placeholder: \'please input\' });\ninput.render();\n\n\n\n// 抽象工厂接口\ninterface uicomponentfactory {\n  createbutton(): buttoncomponent;\n  createinput(): inputcomponent;\n}\n\n// 抽象按钮组件\ninterface buttoncomponent {\n  render(): void;\n  onclick(handler: () => void): void;\n}\n\n// 抽象输入框组件\ninterface inputcomponent {\n  render(): void;\n  oninput(handler: (value: string) => void): void;\n}\n\n// 具体工厂：bootstrap 组件工厂\nclass bootstrapuicomponentfactory implements uicomponentfactory {\n  createbutton(): buttoncomponent {\n    return new bootstrapbuttoncomponent();\n  }\n\n  createinput(): inputcomponent {\n    return new bootstrapinputcomponent();\n  }\n}\n\n// 具体工厂：material 组件工厂\nclass materialuicomponentfactory implements uicomponentfactory {\n  createbutton(): buttoncomponent {\n    return new materialbuttoncomponent();\n  }\n\n  createinput(): inputcomponent {\n    return new materialinputcomponent();\n  }\n}\n\n// 具体按钮组件：bootstrap 按钮\nclass bootstrapbuttoncomponent implements buttoncomponent {\n  render() {\n    console.log("rendering bootstrap button component");\n  }\n\n  onclick(handler: () => void) {\n    console.log("attaching onclick event for bootstrap button component");\n  }\n}\n\n// 具体按钮组件：material 按钮\nclass materialbuttoncomponent implements buttoncomponent {\n  render() {\n    console.log("rendering material button component");\n  }\n\n  onclick(handler: () => void) {\n    console.log("attaching onclick event for material button component");\n  }\n}\n\n// 具体输入框组件：bootstrap 输入框\nclass bootstrapinputcomponent implements inputcomponent {\n  render() {\n    console.log("rendering bootstrap input component");\n  }\n\n  oninput(handler: (value: string) => void) {\n    console.log("attaching oninput event for bootstrap input component");\n  }\n}\n\n// 具体输入框组件：material 输入框\nclass materialinputcomponent implements inputcomponent {\n  render() {\n    console.log("rendering material input component");\n  }\n\n  oninput(handler: (value: string) => void) {\n    console.log("attaching oninput event for material input component");\n  }\n}\n\n// 客户端代码\nconst bootstrapfactory = new bootstrapuicomponentfactory();\nconst button1 = bootstrapfactory.createbutton();\nconst input1 = bootstrapfactory.createinput();\nbutton1.render();\ninput1.render();\n\nconst materialfactory = new materialuicomponentfactory();\nconst button2 = materialfactory.createbutton();\nconst input2 = materialfactory.createinput();\nbutton2.render();\ninput2.render();\n',charsets:{cjk:!0}},{title:"享元模式",frontmatter:{},regularPath:"/design-pattern/flyweight.html",relativePath:"design-pattern/flyweight.md",key:"v-73b8d232",path:"/design-pattern/flyweight.html",headers:[{level:2,title:"享元模式",slug:"享元模式",normalizedTitle:"享元模式",charIndex:2},{level:3,title:"1、基本概念",slug:"_1、基本概念",normalizedTitle:"1、基本概念",charIndex:11},{level:3,title:"2、代码示例",slug:"_2、代码示例",normalizedTitle:"2、代码示例",charIndex:582},{level:3,title:"3、前端开发中的实践",slug:"_3、前端开发中的实践",normalizedTitle:"3、前端开发中的实践",charIndex:1839}],headersStr:"享元模式 1、基本概念 2、代码示例 3、前端开发中的实践",content:'# 享元模式\n\n\n# 1、基本概念\n\n享元模式，是一种用于性能优化的设计模式，享元模式的英文叫fly-weight，其含义是蝇量级，主要用于减少创建对象的数量，以减少内存占用和提高性能。\n\n享元模式的关键是划分内部和外部状态（变化和不变，不变的就是复用对象的内部状态，变化的内容则由外界传递进来，在某一刻得到执行（有点儿依赖注入：Dependencies Inject，简称DI的味道））来实现对象的复用的，另外，享元模式会有工厂模式的思想在其中，工厂实现对象的复用逻辑的控制。\n\n我将其字面意思理解成”共享-元数据“(仅仅是我个人的理解，非官方解释，因为享元模式需要划分内部和外部的状态，内部的状态数据不就是复用对象的元数据嘛，而外部的数据是根据需求传递的，内部数据不就成了共享的嘛，哈哈哈)。\n\n以下是享元模式的UML图：\n\n\n\n上图的含义是，FlyWeight抽象了一个功能，通过ConcreteFlyWeight和UnsharedConcreteFlyWeight去实现它，同时定义了一个享元工厂，FlyWeightFactory，其对外暴露一个获取FlyWeight对象实例的方法，当我们需用用到ConcreteFlyWeight的实例时，从FlyWeightFactory取，如果去不到，则初始化，并将其存储起来，如果已经初始化，则直接复用。\n\n\n# 2、代码示例\n\nabstract class FlyWeight {\n  abstract notify(msg: string): void;\n}\n\nclass ConcreteFlyWeight extends FlyWeight {\n  notify(msg: string): void {\n    console.log("我是享元对象输出消息：" + msg);\n  }\n}\n\nclass UnsharedConcreteFlyWeight extends FlyWeight {\n  notify(msg: string): void {\n    console.log("我是非享元对象输出消息：" + msg);\n  }\n}\n\nclass FlyWeightFactory {\n  private static map: Map<string, FlyWeight> = new Map();\n\n  static {\n    // 系统初始化一些干活儿的对象\n    this.map.set("A", new ConcreteFlyWeight());\n    this.map.set("B", new ConcreteFlyWeight());\n  }\n\n  static getFlyWeight(type: string): FlyWeight {\n    // 如果对象不存在，则创建，如果存在，直接复用对象\n    let flyWeightInstance = this.map.get(type);\n    if (!flyWeightInstance) {\n      flyWeightInstance = new ConcreteFlyWeight();\n      this.map.set(type, flyWeightInstance);\n    }\n    return flyWeightInstance;\n  }\n}\n\nfunction bootstrap() {\n  const flyA = FlyWeightFactory.getFlyWeight("A");\n  const flyB = FlyWeightFactory.getFlyWeight("B");\n  const flyC = FlyWeightFactory.getFlyWeight("C");\n  const flyD = FlyWeightFactory.getFlyWeight("A");\n  const normalObj = new UnsharedConcreteFlyWeight();\n  flyA.notify("你好，比尔盖茨~");\n  flyB.notify("你好，库克~");\n  flyC.notify("你好，乔布斯~");\n  flyD.notify("你好，马云~");\n  normalObj.notify("你好，雷军~");\n}\n\n\n\n# 3、前端开发中的实践\n\n由于现代Web前端开发一般都会基于Vue，React等基于虚拟DOM的框架进行开发，再加上ESM语法的出现，享元模式的在实际的业务开发场景不常见。\n\n像一些设计模式书上给出的例子，可能某些时候基于框架开发，就完全不会那样去写代码了，设计模式是为了降低我们代码的复杂度，增加软件的可维护性，所以不要为了设计模式而设计模式。\n\n比如曾探先生所著的《JavaScript设计模式与开发实际》一书中，对于享元模式给的示例是一个文件上传的例子，但是如果基于Vue或者React框架编写代码，可能就直接让文件上传这个功能模块成为一个组件了（可以用虚拟滚动来处理上传文件的列表项过多；可以用一个任务管理器控制并发以防止一下并发过大，造成浏览器卡死，这个场景会限制并发，但也不是套用享元模式的代码范式）。\n\n以下是一个我最近在一个实际开发中出现的例子，这个场景就是一个十分恰当的例子。\n\n它是一个弹幕组件，系统需要支持有5000条弹幕推送，如果这5000条数据完全交给框架处理的话，将会建立超多的双向绑定（以Vue框架为例），此时肯定性能上是达不到要求的，另外，也不可能一下子把5000条数据一下渲染出来，否则就没法看了。\n\n同时，这些消息还有优先级，比如如果是付费用户的消息，它的优先级要求比普通用户优先展示，直接一下子渲染出来，这个逻辑也不太好写。\n\n根据享元模式的思想启发，实际上我们可以创造一定的弹幕内容节点（搬运工），首先为它准备好它要展示的内容(外部状态)，然后事先让两者进行绑定，让它从屏幕的右边滚动到左边，然后它可以再回到右边，解绑。然后重新为它绑定新的弹幕信息展示，重复这个过程，直到把所有的消息都展示完毕。这样就可以使得我们在有限的DOM上展示很多的信息，同时，处理消息的优先级就变成了处理队列或者处理堆了，也将核心业务逻辑解放了出来。\n\n下图是我编写的组件的运行效果：\n\n\n\n以下是上述逻辑的vue编码实现。\n\n<template>\n  <div class="danmu">\n    \x3c!-- 只渲染有限的DOM节点，进行数据的展示 --\x3e\n    <div\n      class="danmu-wrapper"\n      v-for="(ctx, idx) in worker"\n      :key="idx"\n      :style="{\n        transform: `translateX(${worker[idx].offset}%)`,\n        top: `${20 * idx}px`,\n      }"\n    >\n      <div class="danmu-item">\n        <template v-if="ctx.body">\n          <div class="danmu-user">\n            <div class="danmu-user__wrapper u1">\n              <img\n                class="danmu-user__wrapper-img"\n                :src="ctx.body.user1.avatar"\n                alt="用户头像"\n              />\n            </div>\n            <div class="danmu-user__wrapper u2">\n              <img\n                class="danmu-user__wrapper-img"\n                :src="ctx.body.user2.avatar"\n                alt="用户头像"\n              />\n            </div>\n          </div>\n          <p class="danmu-body">{{ ctx.body.message }}</p>\n        </template>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "Danmu",\n  data() {\n    return {\n      initPosition: [140, 100, 120, 170, 110],\n      // 用来从右到左负责搬运弹幕的工人们\n      worker: [\n        {\n          offset: 0,\n          body: null,\n        },\n        {\n          offset: 0,\n          body: null,\n        },\n        {\n          offset: 0,\n          body: null,\n        },\n        {\n          offset: 0,\n          body: null,\n        },\n        {\n          offset: 0,\n          body: null,\n        },\n      ],\n      // 用来记录消息过多时，还没有播放的弹幕信息\n      taskQueue: [],\n      // 用来记录消息是否是优先级较高的\n      map: new WeakMap(),\n    };\n  },\n  mounted() {\n    // 在组件渲染后，开始搬运弹幕信息\n    this.start();\n  },\n  methods: {\n    addTask(task, emergency) {\n      const available = this.worker.filter((v) => v.body === null);\n      // 随机取一个能用的工人\n      const worker = available[Math.floor(Math.random() * available.length)];\n      // 暂时没有可用的搬运工人，加入等待队列\n      if (!worker) {\n        console.log("请稍后，暂时没有工人能够干活啦");\n        if (emergency) {\n          // 找到第一个紧急任务，因为紧急任务也有先来后到的优先级，紧急任务不能直接插入到待处理消息队列的头部\n          let idx = 0;\n          let existTask = this.taskQueue[idx];\n          while (existTask && this.map.get(existTask)) {\n            existTask = this.taskQueue[idx];\n            idx++;\n          }\n          // 将当前任务标记为紧急任务\n          this.map.set(task, true);\n          // 如果当前任务队列里面没有紧急任务，可以直接插入任务\n          if (idx === 0) {\n            this.taskQueue.unshift(task);\n          } else {\n            // 否则，插在紧急任务之后，idx是第一个非紧急任务的下标\n            this.taskQueue.splice(idx - 1, 0, task);\n          }\n        } else {\n          // 非紧急任务，可以直接放在临时消息队列的尾部\n          this.taskQueue.push(task);\n        }\n      } else {\n        // 为当前工人绑定它需要搬运的信息\n        worker.body = task;\n        // 重新开启动画\n        this.startMove(this.worker.findIndex((v) => v === worker));\n      }\n    },\n    start() {\n      // 初始化开启搬运弹幕\n      let idx = 0;\n      this.worker.forEach(() => {\n        this.worker[idx].offset = this.initPosition[idx];\n        this.startMove(idx);\n        idx++;\n      });\n    },\n    startMove(target) {\n      // 如果当前搬运工没有任务需要处理，则不需要后续的流程\n      if (!this.worker[target].body) {\n        return;\n      }\n      // 如果当前搬运工已经将弹幕搬运到了最左边\n      if (this.worker[target].offset <= -100) {\n        this.worker[target].offset = this.initPosition[target];\n        // 卸载当前搬运的内容\n        this.worker[target].body = null;\n        // 如果已经没有资源了，结束当前搬运工的任务\n        if (this.taskQueue.length <= 0) {\n          return;\n        }\n        // 如果已经处理完成了一个内容，发现消息队列里面还有内容，继续搬运\n        if (this.taskQueue.length) {\n          const task = this.taskQueue.shift();\n          this.worker[target].body = task;\n        }\n      }\n      requestAnimationFrame(() => {\n        // 动画处理\n        this.worker[target].offset = (\n          this.worker[target].offset - 0.45\n        ).toFixed(2);\n        this.startMove(target);\n      });\n    },\n  },\n};\n<\/script>\n\n<style lang="scss" scoped>\n.danmu {\n  width: 100%;\n  height: 500px;\n\n  &-wrapper {\n    width: 100%;\n    position: relative;\n  }\n\n  &-item {\n    max-width: 100%;\n    height: 52px;\n    background-image: linear-gradient(180deg, #3b73ff 0%, #2fc7ff 100%);\n    box-shadow: inset 0 -2px 7px 0 rgba(255, 255, 255, 0.71);\n    border-radius: 30px;\n    border: 4px solid azure;\n    font-size: 24px;\n    font-family: PingFangSC-Regular, PingFang SC;\n    font-weight: 400;\n    color: #ffffff;\n    display: inline-block;\n    text-align: right;\n    line-height: 44px;\n    padding-right: 28px;\n    padding-left: 130px;\n    position: relative;\n  }\n\n  &-body {\n    max-width: 360px;\n    white-space: nowrap;\n    overflow-x: hidden;\n    text-overflow: ellipsis;\n  }\n\n  &-user {\n    position: absolute;\n    left: 0;\n    display: flex;\n    align-items: center;\n    top: 50%;\n    transform: translateY(-50%);\n\n    &__wrapper {\n      width: 64px;\n      height: 64px;\n      background: linear-gradient(180deg, #1558fc 0%, #3bb1ff 100%);\n      box-shadow: inset 0 -2px 7px 0 rgba(255, 255, 255, 0.71);\n      border: 4px solid rgba(198, 237, 255, 1);\n      border-radius: 50%;\n      position: relative;\n\n      &-img {\n        width: 100%;\n        height: 100%;\n        border-radius: 50%;\n      }\n    }\n\n    .u1 {\n      z-index: 2;\n    }\n\n    .u2 {\n      transform: translateX(-20px);\n      z-index: 1;\n    }\n  }\n}\n</style>\n\n\n在这个实践中，弹幕信息节点的位置信息就是它的内部状态，弹幕信息节点展示的内容就是它的外部状态。\n\n另外，在这个例子中，任务的优先级只有两个判别依据，所以我们可以简单的用一个WeakMap（是用WeakMap的优势是不用关系消息对象什么时候销毁）来标记，假设您的业务需求可能有好几种优先级判别依据，那么你就只能用堆来解决这个问题了（比如医院急诊科医生处理任务，一个病人已经休克，一个病人的伤口血流不止，一个病人发着高烧，另外一个病人只是感冒了，那么医生肯定会病情的轻重缓急决定先救治哪个病人）。',normalizedContent:'# 享元模式\n\n\n# 1、基本概念\n\n享元模式，是一种用于性能优化的设计模式，享元模式的英文叫fly-weight，其含义是蝇量级，主要用于减少创建对象的数量，以减少内存占用和提高性能。\n\n享元模式的关键是划分内部和外部状态（变化和不变，不变的就是复用对象的内部状态，变化的内容则由外界传递进来，在某一刻得到执行（有点儿依赖注入：dependencies inject，简称di的味道））来实现对象的复用的，另外，享元模式会有工厂模式的思想在其中，工厂实现对象的复用逻辑的控制。\n\n我将其字面意思理解成”共享-元数据“(仅仅是我个人的理解，非官方解释，因为享元模式需要划分内部和外部的状态，内部的状态数据不就是复用对象的元数据嘛，而外部的数据是根据需求传递的，内部数据不就成了共享的嘛，哈哈哈)。\n\n以下是享元模式的uml图：\n\n\n\n上图的含义是，flyweight抽象了一个功能，通过concreteflyweight和unsharedconcreteflyweight去实现它，同时定义了一个享元工厂，flyweightfactory，其对外暴露一个获取flyweight对象实例的方法，当我们需用用到concreteflyweight的实例时，从flyweightfactory取，如果去不到，则初始化，并将其存储起来，如果已经初始化，则直接复用。\n\n\n# 2、代码示例\n\nabstract class flyweight {\n  abstract notify(msg: string): void;\n}\n\nclass concreteflyweight extends flyweight {\n  notify(msg: string): void {\n    console.log("我是享元对象输出消息：" + msg);\n  }\n}\n\nclass unsharedconcreteflyweight extends flyweight {\n  notify(msg: string): void {\n    console.log("我是非享元对象输出消息：" + msg);\n  }\n}\n\nclass flyweightfactory {\n  private static map: map<string, flyweight> = new map();\n\n  static {\n    // 系统初始化一些干活儿的对象\n    this.map.set("a", new concreteflyweight());\n    this.map.set("b", new concreteflyweight());\n  }\n\n  static getflyweight(type: string): flyweight {\n    // 如果对象不存在，则创建，如果存在，直接复用对象\n    let flyweightinstance = this.map.get(type);\n    if (!flyweightinstance) {\n      flyweightinstance = new concreteflyweight();\n      this.map.set(type, flyweightinstance);\n    }\n    return flyweightinstance;\n  }\n}\n\nfunction bootstrap() {\n  const flya = flyweightfactory.getflyweight("a");\n  const flyb = flyweightfactory.getflyweight("b");\n  const flyc = flyweightfactory.getflyweight("c");\n  const flyd = flyweightfactory.getflyweight("a");\n  const normalobj = new unsharedconcreteflyweight();\n  flya.notify("你好，比尔盖茨~");\n  flyb.notify("你好，库克~");\n  flyc.notify("你好，乔布斯~");\n  flyd.notify("你好，马云~");\n  normalobj.notify("你好，雷军~");\n}\n\n\n\n# 3、前端开发中的实践\n\n由于现代web前端开发一般都会基于vue，react等基于虚拟dom的框架进行开发，再加上esm语法的出现，享元模式的在实际的业务开发场景不常见。\n\n像一些设计模式书上给出的例子，可能某些时候基于框架开发，就完全不会那样去写代码了，设计模式是为了降低我们代码的复杂度，增加软件的可维护性，所以不要为了设计模式而设计模式。\n\n比如曾探先生所著的《javascript设计模式与开发实际》一书中，对于享元模式给的示例是一个文件上传的例子，但是如果基于vue或者react框架编写代码，可能就直接让文件上传这个功能模块成为一个组件了（可以用虚拟滚动来处理上传文件的列表项过多；可以用一个任务管理器控制并发以防止一下并发过大，造成浏览器卡死，这个场景会限制并发，但也不是套用享元模式的代码范式）。\n\n以下是一个我最近在一个实际开发中出现的例子，这个场景就是一个十分恰当的例子。\n\n它是一个弹幕组件，系统需要支持有5000条弹幕推送，如果这5000条数据完全交给框架处理的话，将会建立超多的双向绑定（以vue框架为例），此时肯定性能上是达不到要求的，另外，也不可能一下子把5000条数据一下渲染出来，否则就没法看了。\n\n同时，这些消息还有优先级，比如如果是付费用户的消息，它的优先级要求比普通用户优先展示，直接一下子渲染出来，这个逻辑也不太好写。\n\n根据享元模式的思想启发，实际上我们可以创造一定的弹幕内容节点（搬运工），首先为它准备好它要展示的内容(外部状态)，然后事先让两者进行绑定，让它从屏幕的右边滚动到左边，然后它可以再回到右边，解绑。然后重新为它绑定新的弹幕信息展示，重复这个过程，直到把所有的消息都展示完毕。这样就可以使得我们在有限的dom上展示很多的信息，同时，处理消息的优先级就变成了处理队列或者处理堆了，也将核心业务逻辑解放了出来。\n\n下图是我编写的组件的运行效果：\n\n\n\n以下是上述逻辑的vue编码实现。\n\n<template>\n  <div class="danmu">\n    \x3c!-- 只渲染有限的dom节点，进行数据的展示 --\x3e\n    <div\n      class="danmu-wrapper"\n      v-for="(ctx, idx) in worker"\n      :key="idx"\n      :style="{\n        transform: `translatex(${worker[idx].offset}%)`,\n        top: `${20 * idx}px`,\n      }"\n    >\n      <div class="danmu-item">\n        <template v-if="ctx.body">\n          <div class="danmu-user">\n            <div class="danmu-user__wrapper u1">\n              <img\n                class="danmu-user__wrapper-img"\n                :src="ctx.body.user1.avatar"\n                alt="用户头像"\n              />\n            </div>\n            <div class="danmu-user__wrapper u2">\n              <img\n                class="danmu-user__wrapper-img"\n                :src="ctx.body.user2.avatar"\n                alt="用户头像"\n              />\n            </div>\n          </div>\n          <p class="danmu-body">{{ ctx.body.message }}</p>\n        </template>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "danmu",\n  data() {\n    return {\n      initposition: [140, 100, 120, 170, 110],\n      // 用来从右到左负责搬运弹幕的工人们\n      worker: [\n        {\n          offset: 0,\n          body: null,\n        },\n        {\n          offset: 0,\n          body: null,\n        },\n        {\n          offset: 0,\n          body: null,\n        },\n        {\n          offset: 0,\n          body: null,\n        },\n        {\n          offset: 0,\n          body: null,\n        },\n      ],\n      // 用来记录消息过多时，还没有播放的弹幕信息\n      taskqueue: [],\n      // 用来记录消息是否是优先级较高的\n      map: new weakmap(),\n    };\n  },\n  mounted() {\n    // 在组件渲染后，开始搬运弹幕信息\n    this.start();\n  },\n  methods: {\n    addtask(task, emergency) {\n      const available = this.worker.filter((v) => v.body === null);\n      // 随机取一个能用的工人\n      const worker = available[math.floor(math.random() * available.length)];\n      // 暂时没有可用的搬运工人，加入等待队列\n      if (!worker) {\n        console.log("请稍后，暂时没有工人能够干活啦");\n        if (emergency) {\n          // 找到第一个紧急任务，因为紧急任务也有先来后到的优先级，紧急任务不能直接插入到待处理消息队列的头部\n          let idx = 0;\n          let existtask = this.taskqueue[idx];\n          while (existtask && this.map.get(existtask)) {\n            existtask = this.taskqueue[idx];\n            idx++;\n          }\n          // 将当前任务标记为紧急任务\n          this.map.set(task, true);\n          // 如果当前任务队列里面没有紧急任务，可以直接插入任务\n          if (idx === 0) {\n            this.taskqueue.unshift(task);\n          } else {\n            // 否则，插在紧急任务之后，idx是第一个非紧急任务的下标\n            this.taskqueue.splice(idx - 1, 0, task);\n          }\n        } else {\n          // 非紧急任务，可以直接放在临时消息队列的尾部\n          this.taskqueue.push(task);\n        }\n      } else {\n        // 为当前工人绑定它需要搬运的信息\n        worker.body = task;\n        // 重新开启动画\n        this.startmove(this.worker.findindex((v) => v === worker));\n      }\n    },\n    start() {\n      // 初始化开启搬运弹幕\n      let idx = 0;\n      this.worker.foreach(() => {\n        this.worker[idx].offset = this.initposition[idx];\n        this.startmove(idx);\n        idx++;\n      });\n    },\n    startmove(target) {\n      // 如果当前搬运工没有任务需要处理，则不需要后续的流程\n      if (!this.worker[target].body) {\n        return;\n      }\n      // 如果当前搬运工已经将弹幕搬运到了最左边\n      if (this.worker[target].offset <= -100) {\n        this.worker[target].offset = this.initposition[target];\n        // 卸载当前搬运的内容\n        this.worker[target].body = null;\n        // 如果已经没有资源了，结束当前搬运工的任务\n        if (this.taskqueue.length <= 0) {\n          return;\n        }\n        // 如果已经处理完成了一个内容，发现消息队列里面还有内容，继续搬运\n        if (this.taskqueue.length) {\n          const task = this.taskqueue.shift();\n          this.worker[target].body = task;\n        }\n      }\n      requestanimationframe(() => {\n        // 动画处理\n        this.worker[target].offset = (\n          this.worker[target].offset - 0.45\n        ).tofixed(2);\n        this.startmove(target);\n      });\n    },\n  },\n};\n<\/script>\n\n<style lang="scss" scoped>\n.danmu {\n  width: 100%;\n  height: 500px;\n\n  &-wrapper {\n    width: 100%;\n    position: relative;\n  }\n\n  &-item {\n    max-width: 100%;\n    height: 52px;\n    background-image: linear-gradient(180deg, #3b73ff 0%, #2fc7ff 100%);\n    box-shadow: inset 0 -2px 7px 0 rgba(255, 255, 255, 0.71);\n    border-radius: 30px;\n    border: 4px solid azure;\n    font-size: 24px;\n    font-family: pingfangsc-regular, pingfang sc;\n    font-weight: 400;\n    color: #ffffff;\n    display: inline-block;\n    text-align: right;\n    line-height: 44px;\n    padding-right: 28px;\n    padding-left: 130px;\n    position: relative;\n  }\n\n  &-body {\n    max-width: 360px;\n    white-space: nowrap;\n    overflow-x: hidden;\n    text-overflow: ellipsis;\n  }\n\n  &-user {\n    position: absolute;\n    left: 0;\n    display: flex;\n    align-items: center;\n    top: 50%;\n    transform: translatey(-50%);\n\n    &__wrapper {\n      width: 64px;\n      height: 64px;\n      background: linear-gradient(180deg, #1558fc 0%, #3bb1ff 100%);\n      box-shadow: inset 0 -2px 7px 0 rgba(255, 255, 255, 0.71);\n      border: 4px solid rgba(198, 237, 255, 1);\n      border-radius: 50%;\n      position: relative;\n\n      &-img {\n        width: 100%;\n        height: 100%;\n        border-radius: 50%;\n      }\n    }\n\n    .u1 {\n      z-index: 2;\n    }\n\n    .u2 {\n      transform: translatex(-20px);\n      z-index: 1;\n    }\n  }\n}\n</style>\n\n\n在这个实践中，弹幕信息节点的位置信息就是它的内部状态，弹幕信息节点展示的内容就是它的外部状态。\n\n另外，在这个例子中，任务的优先级只有两个判别依据，所以我们可以简单的用一个weakmap（是用weakmap的优势是不用关系消息对象什么时候销毁）来标记，假设您的业务需求可能有好几种优先级判别依据，那么你就只能用堆来解决这个问题了（比如医院急诊科医生处理任务，一个病人已经休克，一个病人的伤口血流不止，一个病人发着高烧，另外一个病人只是感冒了，那么医生肯定会病情的轻重缓急决定先救治哪个病人）。',charsets:{cjk:!0}},{title:"设计模式专题",frontmatter:{title:"设计模式专题"},regularPath:"/design-pattern/",relativePath:"design-pattern/index.md",key:"v-3a2a67dc",path:"/design-pattern/",headers:[{level:2,title:"1. 面向对象的三大特性",slug:"_1-面向对象的三大特性",normalizedTitle:"1. 面向对象的三大特性",charIndex:2},{level:3,title:"封装",slug:"封装",normalizedTitle:"封装",charIndex:19},{level:3,title:"继承",slug:"继承",normalizedTitle:"继承",charIndex:2738},{level:3,title:"多态",slug:"多态",normalizedTitle:"多态",charIndex:3591},{level:2,title:"2. 面向对象的 7 大设计原则",slug:"_2-面向对象的-7-大设计原则",normalizedTitle:"2. 面向对象的 7 大设计原则",charIndex:6046},{level:3,title:"开闭原则",slug:"开闭原则",normalizedTitle:"开闭原则",charIndex:6067},{level:3,title:"里氏代换原则",slug:"里氏代换原则",normalizedTitle:"里氏代换原则",charIndex:7834},{level:3,title:"接口隔离原则",slug:"接口隔离原则",normalizedTitle:"接口隔离原则",charIndex:7845},{level:3,title:"组合代替继承原则",slug:"组合代替继承原则",normalizedTitle:"组合代替继承原则",charIndex:7856},{level:3,title:"单一职责原则",slug:"单一职责原则",normalizedTitle:"单一职责原则",charIndex:7869},{level:3,title:"依赖倒置原则",slug:"依赖倒置原则",normalizedTitle:"依赖倒置原则",charIndex:8163},{level:3,title:"迪米特原则(即最小知识原则，当前类知道的事儿越少越好)",slug:"迪米特原则-即最小知识原则-当前类知道的事儿越少越好",normalizedTitle:"迪米特原则(即最小知识原则，当前类知道的事儿越少越好)",charIndex:8174},{level:2,title:"2.常见的设计模式列表",slug:"_2-常见的设计模式列表",normalizedTitle:"2.常见的设计模式列表",charIndex:8206}],headersStr:"1. 面向对象的三大特性 封装 继承 多态 2. 面向对象的 7 大设计原则 开闭原则 里氏代换原则 接口隔离原则 组合代替继承原则 单一职责原则 依赖倒置原则 迪米特原则(即最小知识原则，当前类知道的事儿越少越好) 2.常见的设计模式列表",content:'# 1. 面向对象的三大特性\n\n\n# 封装\n\n封装：将信息隐藏，也就是说，封装不仅仅是隐藏数据，还包括隐藏实现细节、设计细节以及隐藏对象的类型等，封装使得对象内部的变化对其他对象是不可见的。\n\n对象对它自己的行为负责，其他对象或者用户都不关心它的内部实现。封装使得对象之间的耦合变松散，对象之间只通过暴露的API（Application Program Interface）接口来通信。当我们修改一个对象时，可以随意地修改它的内部实现，只要对外的接口没有变化，就不会影响到程序的其他功能。\n\n下面是一个封装的例子：\n\n\n\n正常的思维，借助一个数组实现，然后会牵涉到对于数组的调整（有杠精会说 JS 不是有数组的shift和push吗？题目已经要求了不要使用内置的Queue，如果这样使用就违背了题目要求），因为有可能对数据进行拷贝，若每个数组项拷贝时间不可忽略的话，这个效率是比较低的。此外数组调整的逻辑也并不简单，还容易犯错。\n\n但题目只要求不使用内置Queue即可，只要满足上述的API定义的要求就可以了，至于队列内部怎么实现，与外界无关。 因此可以自由发挥了，完全没有必要采用数组实现，链表的插入和删除都是O(1)，只要限制队列的最大长度，外界完全感觉不到队列的内容调整。\n\n由此，采用双向链表实现这个循环队列，逻辑简单且高效，具体实现如下：\n\n/**\n * 队列节点定义\n */\ninterface CircularQueueNode<T> {\n  /**\n   * 前驱节点\n   */\n  prev: CircularQueueNode<T> | null;\n  /**\n   * 后继节点\n   */\n  next: CircularQueueNode<T> | null;\n  /**\n   * 数据域\n   */\n  data: T;\n}\n/**\n * 循环双端队列\n */\nclass MyCircularQueue<T> {\n  /**\n   * 队列的最大长度限制\n   */\n  private limit: number = Infinity;\n  /**\n   * 队列当前已存储的长度\n   */\n  private size: number = 0;\n  /**\n   * 链表表头\n   */\n  private head: null | CircularQueueNode<T> = null;\n  /**\n   * 链表表尾\n   */\n  private tail: null | CircularQueueNode<T> = null;\n  /**\n   * 暴露给外界的当前队列的长度，不允许修改\n   */\n  public get count(): number {\n    return this.size;\n  }\n  constructor(k: number) {\n    this.limit = k;\n  }\n  /**\n   * 入队\n   * @param value\n   * @returns\n   */\n  public enQueue(value: T): void {\n    if (this.isFull()) {\n      console.warn("can not enqueue an full queue");\n      return;\n    }\n    let newNode: CircularQueueNode<T> = {\n      prev: null,\n      next: null,\n      data: value,\n    };\n    /* 入队：使用头插法 */\n    if (this.head === null && this.tail === null) {\n      this.head = this.tail = newNode;\n    } else {\n      this.tail!.next = newNode;\n      newNode.prev = this.tail;\n      this.tail = newNode;\n    }\n    this.size++;\n  }\n  /**\n   * 出队\n   * @returns\n   */\n  public deQueue(): null | T {\n    if (this.isEmpty()) {\n      console.warn("can not dequeue from an empty queue");\n      return null;\n    }\n    let node = this.head!;\n    /* 出队：删除尾节点，将尾节点的前驱节点变成尾节点 */\n    if (this.head === this.tail) {\n      this.head = this.tail = null;\n    } else {\n      let nextNode = node.next;\n      nextNode!.prev = null;\n      this.head = nextNode;\n    }\n    this.size--;\n    return node.data;\n  }\n  /**\n   * 获取队首的元素\n   * @returns\n   */\n  public Front(): null | T {\n    return !this.isEmpty() ? this.head!.data : null;\n  }\n  /**\n   * 获取队尾元素\n   */\n  public Rear(): null | T {\n    return !this.isEmpty() ? this.tail!.data : null;\n  }\n  /**\n   * 队列是否为空\n   */\n  public isEmpty(): boolean {\n    return this.size === 0;\n  }\n  /**\n   * 队列是否满\n   */\n  public isFull(): boolean {\n    return this.size === this.limit;\n  }\n}\n\n\n外界看不到内部任何的技术实现细节，只需要按照Queue提供的接口进行调用即可，这样可以使得我们的Queue在不修改代码的前提下又能适应绝大部分的业务场景，由此例完全体现了封装的优势。\n\n\n# 继承\n\n继承：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。\n\n继承的过程，就是从一般到特殊的过程。\n\n在实际的开发中，我们通常会对我们的业务进行抽象，将一些比较宏观的行为编写成一个超类，不同的业务因为特殊的业务，可以对抽象的超类实现以获得更好的代码复用。\n\n下面是一个继承的例子(节选自vue-router@3.5.4)：\n\n/**\n * 操作浏览器History的类\n */\nclass History {\n  cb: (r: Route) => void;\n  ready: boolean;\n  readyCbs: Array<Function>;\n  readyErrorCbs: Array<Function>;\n  errorCbs: Array<Function>;\n  listeners: Array<Function>;\n\n  listen(cb: Function) {\n    this.cb = cb;\n  }\n\n  onReady(cb: Function, errorCb: ?Function) {\n    if (this.ready) {\n      cb();\n    } else {\n      this.readyCbs.push(cb);\n      if (errorCb) {\n        this.readyErrorCbs.push(errorCb);\n      }\n    }\n  }\n\n  onError(errorCb: Function) {\n    this.errorCbs.push(errorCb);\n  }\n}\n\n/**\n * 低版本操作浏览器History的类\n */\nclass HashHistory extends History {}\n\n/**\n * 高版本操作浏览器History的类\n */\nclass HTML5History extends History {}\n\n\n\n# 多态\n\n多态的实际含义是:同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果。\n\n举个例子，假设现在需要给不同的对象发送同一个消息，这些对象会根据这个消息分别给出不同的反馈。\n\n多态的实现有二种方式，重写（也可以叫做覆盖），重载。\n\n重写：对于父类和子类的同一个方法，子类完全（或完全不）舍弃父类的逻辑，并且由自己的业务决定实现一套新的逻辑。\n\n重载：对于一个类中同一个方法名，参数类型不同，参数数量不同，方法执行的结果返回类型不同，均可构成重载。\n\nDANGER\n\n最常见的一个面试题：请问重写和重载什么关系？答案是没有关系\n\n由于JS是弱语言，实际开发中不存在重载，实现多态主要是采用重写。\n\n下面是一个多态的例子(节选自vue-router@3.5.4)：\n\nclass History {\n  go(n: number): never {\n    throw new Error("not implement exception");\n  }\n\n  push(loc: RawLocation, onComplete?: Function, onAbort?: Function): never {\n    throw new Error("not implement exception");\n  }\n\n  replace(loc: RawLocation, onComplete?: Function, onAbort?: Function): never {\n    throw new Error("not implement exception");\n  }\n}\n\n/**\n * 低版本操作浏览器History的类\n */\nclass HashHistory extends History {\n  push(location: RawLocation, onComplete?: Function, onAbort?: Function) {\n    const { current: fromRoute } = this;\n    this.transitionTo(\n      location,\n      (route) => {\n        pushHash(route.fullPath);\n        handleScroll(this.router, route, fromRoute, false);\n        onComplete && onComplete(route);\n      },\n      onAbort\n    );\n  }\n\n  replace(location: RawLocation, onComplete?: Function, onAbort?: Function) {\n    const { current: fromRoute } = this;\n    this.transitionTo(\n      location,\n      (route) => {\n        replaceHash(route.fullPath);\n        handleScroll(this.router, route, fromRoute, false);\n        onComplete && onComplete(route);\n      },\n      onAbort\n    );\n  }\n\n  go(n: number) {\n    window.history.go(n);\n  }\n}\n\n/**\n * 高版本操作浏览器History的类\n */\nclass HTML5History extends History {\n  go(n: number): void {\n    window.history.go(n);\n  }\n\n  push(location: RawLocation, onComplete?: Function, onAbort?: Function) {\n    const { current: fromRoute } = this;\n    this.transitionTo(\n      location,\n      (route) => {\n        pushState(cleanPath(this.base + route.fullPath));\n        handleScroll(this.router, route, fromRoute, false);\n        onComplete && onComplete(route);\n      },\n      onAbort\n    );\n  }\n\n  replace(location: RawLocation, onComplete?: Function, onAbort?: Function) {\n    const { current: fromRoute } = this;\n    this.transitionTo(\n      location,\n      (route) => {\n        replaceState(cleanPath(this.base + route.fullPath));\n        handleScroll(this.router, route, fromRoute, false);\n        onComplete && onComplete(route);\n      },\n      onAbort\n    );\n  }\n}\n\n\n上面的代码，大家如果看不懂没有关系，不用过分关心其中的详细实现，把主要关注点放在类的方法名定义上即可。\n\n在实际开发中，继承和多态几乎都是一起出现的。\n\n\n# 2. 面向对象的 7 大设计原则\n\n\n# 开闭原则\n\n开闭原则（Open-Closed Principle，OCP）是指一个软件实体（如类、模块和函数）应该对扩展开放，对修改关闭。\n\n所谓的开闭，也正是对扩展和修改两个行为的一个原则。它强调的是用抽象构建框架，用实现扩展细节，可以提高软件系统的可复用性及可维护性。\n\n开闭原则的核心思想就是面向抽象编程。\n\n对于前端，我们经常接触到的一个业务，导入导出，就拿导出举例，前端的导出五花八门，可以是xlsx，可以是xml，也可以是json，还可以是普通的text等。\n\n对于导出的业务来说，它不应该预设一些if-else语句去判断系统需要支持导出什么样的文件类型，因为这个关系的维持是脆弱的，设想现在要导出一个yml格式的文件，恭喜你，你的if-else语句就必须要增加分支了，显然已经违背开闭原则。\n\n我们可以设想，这些行为其实都是具有共性的，它们都是向服务器拉取数据，然后向浏览器写文件，回到上文提到的面向抽象编程。\n\n所以导出接口的定义就比较明确了，如下：\n\n/**\n * 定义一个导出接口\n */\ninterface IExporter {\n  /**\n   * 获取导出数据\n   */\n  fetchData(): any[];\n  /**\n   * 导出文件\n   */\n  generateFile(filename: string): void;\n}\n\n/**\n * 定义一个导出Excel文件的实现类\n */\nclass XlsxExporter implements IExporter {\n  fetchData(): any[] {\n    return [];\n  }\n\n  generateFile(filename: string): void {\n    console.log("Generating file..., please wait a moment");\n  }\n}\n\n\n对于我们的业务，比如点击一个按钮实现导出：\n\nimport React, { Component } from "react";\nimport { Factory } from "./utils";\nexport class MyComponent extends Component {\n  onExport = (filename: string) => {\n    const exportInstance: IExport = Factory.getInstance();\n    exportInstance.onExport("爱我中华");\n  };\n\n  render() {\n    return <Button onClick={this.onExport}>导出文件</Button>;\n  }\n}\n\n\n如果产品经理现在来找你说，小杨啊，我导出Excel的时候，发现有很多残缺数据，用户导出这些数据其实没有多大的意义的，能不能前端做一些判断呀？\n\n辛辛苦苦写好的导出，一句话又给加了一个需求，做肯定是要做的，关键是怎么做呢？\n\n上文已经提到了面向对象编程的多态，此刻我们也不需要改动多少代码，大致修改如下：\n\nclass AdvanceXlsxExporter extends XlsxExporter {\n  fetchData(): any[] {\n    const data = super.fetchData();\n    // TODO: 对数据进行一些处理\n    return data;\n  }\n}\n\n\n有的朋友可能不太明白为什么要这样做，觉得这样设计有点儿无病呻吟之嫌，现实场景中产品经理的这个需求其实也是很脆弱的，如果此时产品总监说，不行，我们的系统就需要向用户呈现真实的数据性便于用户进行统计分析，那刚才的需求其实就废了，这样又需要改动XlsxExporter这个类的实现，这类业务场景本来工厂函数就是极易改动的地方，因此把修改动作这种脏活累活交给工厂方法做的话，要好过直接修改XlsxExporter类，所以通过继承+重写较为妥当。\n\nTIP\n\n如果系统现在需要新增导出的文件类型，直接编写一个新的导出类实现相应的业务逻辑即可，无需对业务代码进行修改。\n\n\n# 里氏代换原则\n\n\n# 接口隔离原则\n\n\n# 组合代替继承原则\n\n\n# 单一职责原则\n\n单一职责原则(Single Responsibility Principle，SRP)的职责被定义为“引起变化的原因”。如果我们有两个动机去改写一个方法，那么这个方法就具有两个职责。每个职责都是变化的一个轴线，如果一个方法承担了过多的职责，那么在需求的变迁过程中，需要改写这个方法的可能性就越大。\n\n此时，这个方法通常是一个不稳定的方法，修改代码总是一件危险的事情，特别是当两个职责耦合在一起的时候，一个职责发生变化可能会影响到其他职责的实现，造成意想不到的破坏，这种耦合性得到的是低内聚和脆弱的设计。\n\n因此，SRP原则体现为: 一个对象(方法)只做一件事情。\n\n\n# 依赖倒置原则\n\n\n# 迪米特原则(即最小知识原则，当前类知道的事儿越少越好)\n\n\n# 2.常见的设计模式列表\n\n * 单例模式\n * 工厂模式\n * 命令模式\n * 代理模式\n * 观察者模式\n * 桥接模式\n * 适配器模式\n * 装饰模式\n * 模板方法模式\n * 策略模式\n * 享元模式\n * 中介者模式',normalizedContent:'# 1. 面向对象的三大特性\n\n\n# 封装\n\n封装：将信息隐藏，也就是说，封装不仅仅是隐藏数据，还包括隐藏实现细节、设计细节以及隐藏对象的类型等，封装使得对象内部的变化对其他对象是不可见的。\n\n对象对它自己的行为负责，其他对象或者用户都不关心它的内部实现。封装使得对象之间的耦合变松散，对象之间只通过暴露的api（application program interface）接口来通信。当我们修改一个对象时，可以随意地修改它的内部实现，只要对外的接口没有变化，就不会影响到程序的其他功能。\n\n下面是一个封装的例子：\n\n\n\n正常的思维，借助一个数组实现，然后会牵涉到对于数组的调整（有杠精会说 js 不是有数组的shift和push吗？题目已经要求了不要使用内置的queue，如果这样使用就违背了题目要求），因为有可能对数据进行拷贝，若每个数组项拷贝时间不可忽略的话，这个效率是比较低的。此外数组调整的逻辑也并不简单，还容易犯错。\n\n但题目只要求不使用内置queue即可，只要满足上述的api定义的要求就可以了，至于队列内部怎么实现，与外界无关。 因此可以自由发挥了，完全没有必要采用数组实现，链表的插入和删除都是o(1)，只要限制队列的最大长度，外界完全感觉不到队列的内容调整。\n\n由此，采用双向链表实现这个循环队列，逻辑简单且高效，具体实现如下：\n\n/**\n * 队列节点定义\n */\ninterface circularqueuenode<t> {\n  /**\n   * 前驱节点\n   */\n  prev: circularqueuenode<t> | null;\n  /**\n   * 后继节点\n   */\n  next: circularqueuenode<t> | null;\n  /**\n   * 数据域\n   */\n  data: t;\n}\n/**\n * 循环双端队列\n */\nclass mycircularqueue<t> {\n  /**\n   * 队列的最大长度限制\n   */\n  private limit: number = infinity;\n  /**\n   * 队列当前已存储的长度\n   */\n  private size: number = 0;\n  /**\n   * 链表表头\n   */\n  private head: null | circularqueuenode<t> = null;\n  /**\n   * 链表表尾\n   */\n  private tail: null | circularqueuenode<t> = null;\n  /**\n   * 暴露给外界的当前队列的长度，不允许修改\n   */\n  public get count(): number {\n    return this.size;\n  }\n  constructor(k: number) {\n    this.limit = k;\n  }\n  /**\n   * 入队\n   * @param value\n   * @returns\n   */\n  public enqueue(value: t): void {\n    if (this.isfull()) {\n      console.warn("can not enqueue an full queue");\n      return;\n    }\n    let newnode: circularqueuenode<t> = {\n      prev: null,\n      next: null,\n      data: value,\n    };\n    /* 入队：使用头插法 */\n    if (this.head === null && this.tail === null) {\n      this.head = this.tail = newnode;\n    } else {\n      this.tail!.next = newnode;\n      newnode.prev = this.tail;\n      this.tail = newnode;\n    }\n    this.size++;\n  }\n  /**\n   * 出队\n   * @returns\n   */\n  public dequeue(): null | t {\n    if (this.isempty()) {\n      console.warn("can not dequeue from an empty queue");\n      return null;\n    }\n    let node = this.head!;\n    /* 出队：删除尾节点，将尾节点的前驱节点变成尾节点 */\n    if (this.head === this.tail) {\n      this.head = this.tail = null;\n    } else {\n      let nextnode = node.next;\n      nextnode!.prev = null;\n      this.head = nextnode;\n    }\n    this.size--;\n    return node.data;\n  }\n  /**\n   * 获取队首的元素\n   * @returns\n   */\n  public front(): null | t {\n    return !this.isempty() ? this.head!.data : null;\n  }\n  /**\n   * 获取队尾元素\n   */\n  public rear(): null | t {\n    return !this.isempty() ? this.tail!.data : null;\n  }\n  /**\n   * 队列是否为空\n   */\n  public isempty(): boolean {\n    return this.size === 0;\n  }\n  /**\n   * 队列是否满\n   */\n  public isfull(): boolean {\n    return this.size === this.limit;\n  }\n}\n\n\n外界看不到内部任何的技术实现细节，只需要按照queue提供的接口进行调用即可，这样可以使得我们的queue在不修改代码的前提下又能适应绝大部分的业务场景，由此例完全体现了封装的优势。\n\n\n# 继承\n\n继承：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。\n\n继承的过程，就是从一般到特殊的过程。\n\n在实际的开发中，我们通常会对我们的业务进行抽象，将一些比较宏观的行为编写成一个超类，不同的业务因为特殊的业务，可以对抽象的超类实现以获得更好的代码复用。\n\n下面是一个继承的例子(节选自vue-router@3.5.4)：\n\n/**\n * 操作浏览器history的类\n */\nclass history {\n  cb: (r: route) => void;\n  ready: boolean;\n  readycbs: array<function>;\n  readyerrorcbs: array<function>;\n  errorcbs: array<function>;\n  listeners: array<function>;\n\n  listen(cb: function) {\n    this.cb = cb;\n  }\n\n  onready(cb: function, errorcb: ?function) {\n    if (this.ready) {\n      cb();\n    } else {\n      this.readycbs.push(cb);\n      if (errorcb) {\n        this.readyerrorcbs.push(errorcb);\n      }\n    }\n  }\n\n  onerror(errorcb: function) {\n    this.errorcbs.push(errorcb);\n  }\n}\n\n/**\n * 低版本操作浏览器history的类\n */\nclass hashhistory extends history {}\n\n/**\n * 高版本操作浏览器history的类\n */\nclass html5history extends history {}\n\n\n\n# 多态\n\n多态的实际含义是:同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果。\n\n举个例子，假设现在需要给不同的对象发送同一个消息，这些对象会根据这个消息分别给出不同的反馈。\n\n多态的实现有二种方式，重写（也可以叫做覆盖），重载。\n\n重写：对于父类和子类的同一个方法，子类完全（或完全不）舍弃父类的逻辑，并且由自己的业务决定实现一套新的逻辑。\n\n重载：对于一个类中同一个方法名，参数类型不同，参数数量不同，方法执行的结果返回类型不同，均可构成重载。\n\ndanger\n\n最常见的一个面试题：请问重写和重载什么关系？答案是没有关系\n\n由于js是弱语言，实际开发中不存在重载，实现多态主要是采用重写。\n\n下面是一个多态的例子(节选自vue-router@3.5.4)：\n\nclass history {\n  go(n: number): never {\n    throw new error("not implement exception");\n  }\n\n  push(loc: rawlocation, oncomplete?: function, onabort?: function): never {\n    throw new error("not implement exception");\n  }\n\n  replace(loc: rawlocation, oncomplete?: function, onabort?: function): never {\n    throw new error("not implement exception");\n  }\n}\n\n/**\n * 低版本操作浏览器history的类\n */\nclass hashhistory extends history {\n  push(location: rawlocation, oncomplete?: function, onabort?: function) {\n    const { current: fromroute } = this;\n    this.transitionto(\n      location,\n      (route) => {\n        pushhash(route.fullpath);\n        handlescroll(this.router, route, fromroute, false);\n        oncomplete && oncomplete(route);\n      },\n      onabort\n    );\n  }\n\n  replace(location: rawlocation, oncomplete?: function, onabort?: function) {\n    const { current: fromroute } = this;\n    this.transitionto(\n      location,\n      (route) => {\n        replacehash(route.fullpath);\n        handlescroll(this.router, route, fromroute, false);\n        oncomplete && oncomplete(route);\n      },\n      onabort\n    );\n  }\n\n  go(n: number) {\n    window.history.go(n);\n  }\n}\n\n/**\n * 高版本操作浏览器history的类\n */\nclass html5history extends history {\n  go(n: number): void {\n    window.history.go(n);\n  }\n\n  push(location: rawlocation, oncomplete?: function, onabort?: function) {\n    const { current: fromroute } = this;\n    this.transitionto(\n      location,\n      (route) => {\n        pushstate(cleanpath(this.base + route.fullpath));\n        handlescroll(this.router, route, fromroute, false);\n        oncomplete && oncomplete(route);\n      },\n      onabort\n    );\n  }\n\n  replace(location: rawlocation, oncomplete?: function, onabort?: function) {\n    const { current: fromroute } = this;\n    this.transitionto(\n      location,\n      (route) => {\n        replacestate(cleanpath(this.base + route.fullpath));\n        handlescroll(this.router, route, fromroute, false);\n        oncomplete && oncomplete(route);\n      },\n      onabort\n    );\n  }\n}\n\n\n上面的代码，大家如果看不懂没有关系，不用过分关心其中的详细实现，把主要关注点放在类的方法名定义上即可。\n\n在实际开发中，继承和多态几乎都是一起出现的。\n\n\n# 2. 面向对象的 7 大设计原则\n\n\n# 开闭原则\n\n开闭原则（open-closed principle，ocp）是指一个软件实体（如类、模块和函数）应该对扩展开放，对修改关闭。\n\n所谓的开闭，也正是对扩展和修改两个行为的一个原则。它强调的是用抽象构建框架，用实现扩展细节，可以提高软件系统的可复用性及可维护性。\n\n开闭原则的核心思想就是面向抽象编程。\n\n对于前端，我们经常接触到的一个业务，导入导出，就拿导出举例，前端的导出五花八门，可以是xlsx，可以是xml，也可以是json，还可以是普通的text等。\n\n对于导出的业务来说，它不应该预设一些if-else语句去判断系统需要支持导出什么样的文件类型，因为这个关系的维持是脆弱的，设想现在要导出一个yml格式的文件，恭喜你，你的if-else语句就必须要增加分支了，显然已经违背开闭原则。\n\n我们可以设想，这些行为其实都是具有共性的，它们都是向服务器拉取数据，然后向浏览器写文件，回到上文提到的面向抽象编程。\n\n所以导出接口的定义就比较明确了，如下：\n\n/**\n * 定义一个导出接口\n */\ninterface iexporter {\n  /**\n   * 获取导出数据\n   */\n  fetchdata(): any[];\n  /**\n   * 导出文件\n   */\n  generatefile(filename: string): void;\n}\n\n/**\n * 定义一个导出excel文件的实现类\n */\nclass xlsxexporter implements iexporter {\n  fetchdata(): any[] {\n    return [];\n  }\n\n  generatefile(filename: string): void {\n    console.log("generating file..., please wait a moment");\n  }\n}\n\n\n对于我们的业务，比如点击一个按钮实现导出：\n\nimport react, { component } from "react";\nimport { factory } from "./utils";\nexport class mycomponent extends component {\n  onexport = (filename: string) => {\n    const exportinstance: iexport = factory.getinstance();\n    exportinstance.onexport("爱我中华");\n  };\n\n  render() {\n    return <button onclick={this.onexport}>导出文件</button>;\n  }\n}\n\n\n如果产品经理现在来找你说，小杨啊，我导出excel的时候，发现有很多残缺数据，用户导出这些数据其实没有多大的意义的，能不能前端做一些判断呀？\n\n辛辛苦苦写好的导出，一句话又给加了一个需求，做肯定是要做的，关键是怎么做呢？\n\n上文已经提到了面向对象编程的多态，此刻我们也不需要改动多少代码，大致修改如下：\n\nclass advancexlsxexporter extends xlsxexporter {\n  fetchdata(): any[] {\n    const data = super.fetchdata();\n    // todo: 对数据进行一些处理\n    return data;\n  }\n}\n\n\n有的朋友可能不太明白为什么要这样做，觉得这样设计有点儿无病呻吟之嫌，现实场景中产品经理的这个需求其实也是很脆弱的，如果此时产品总监说，不行，我们的系统就需要向用户呈现真实的数据性便于用户进行统计分析，那刚才的需求其实就废了，这样又需要改动xlsxexporter这个类的实现，这类业务场景本来工厂函数就是极易改动的地方，因此把修改动作这种脏活累活交给工厂方法做的话，要好过直接修改xlsxexporter类，所以通过继承+重写较为妥当。\n\ntip\n\n如果系统现在需要新增导出的文件类型，直接编写一个新的导出类实现相应的业务逻辑即可，无需对业务代码进行修改。\n\n\n# 里氏代换原则\n\n\n# 接口隔离原则\n\n\n# 组合代替继承原则\n\n\n# 单一职责原则\n\n单一职责原则(single responsibility principle，srp)的职责被定义为“引起变化的原因”。如果我们有两个动机去改写一个方法，那么这个方法就具有两个职责。每个职责都是变化的一个轴线，如果一个方法承担了过多的职责，那么在需求的变迁过程中，需要改写这个方法的可能性就越大。\n\n此时，这个方法通常是一个不稳定的方法，修改代码总是一件危险的事情，特别是当两个职责耦合在一起的时候，一个职责发生变化可能会影响到其他职责的实现，造成意想不到的破坏，这种耦合性得到的是低内聚和脆弱的设计。\n\n因此，srp原则体现为: 一个对象(方法)只做一件事情。\n\n\n# 依赖倒置原则\n\n\n# 迪米特原则(即最小知识原则，当前类知道的事儿越少越好)\n\n\n# 2.常见的设计模式列表\n\n * 单例模式\n * 工厂模式\n * 命令模式\n * 代理模式\n * 观察者模式\n * 桥接模式\n * 适配器模式\n * 装饰模式\n * 模板方法模式\n * 策略模式\n * 享元模式\n * 中介者模式',charsets:{cjk:!0}},{title:"代理模式",frontmatter:{},regularPath:"/design-pattern/proxy.html",relativePath:"design-pattern/proxy.md",key:"v-1690bca1",path:"/design-pattern/proxy.html",headers:[{level:2,title:"代理模式",slug:"代理模式",normalizedTitle:"代理模式",charIndex:2},{level:3,title:"1、基本概念",slug:"_1、基本概念",normalizedTitle:"1、基本概念",charIndex:11},{level:3,title:"2、代码示例",slug:"_2、代码示例",normalizedTitle:"2、代码示例",charIndex:185},{level:3,title:"3、前端开发中的实践",slug:"_3、前端开发中的实践",normalizedTitle:"3、前端开发中的实践",charIndex:971}],headersStr:"代理模式 1、基本概念 2、代码示例 3、前端开发中的实践",content:'# 代理模式\n\n\n# 1、基本概念\n\n代理模式是为其他对象提供一种代理以控制对这个对象的访问\n\n就拿前端经常简单的场景举例，比如有些操作并不想频繁的触发它，需要有人限制它的触发频率；就比如有些时候我们在操作数据的时候想做一些额外的事儿，比如Vue的双向数据绑定。\n\n什么时候适合使用代理模式呢？——想在访问一个对象时做一些控制。\n\n代理模式的UML图如下：\n\n\n\n\n# 2、代码示例\n\ninterface Subject {\n  profit(number: number): void;\n}\n\nclass RealSubject implements Subject {\n  profit(number: number): void {\n    console.log("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");\n    console.log(`you can earn money ${number} every day`);\n    console.log("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");\n  }\n}\n\nclass ProxySubject implements Subject {\n  private readSubject = new RealSubject();\n\n  profit(number: number): void {\n    if (number <= 0) {\n      console.warn("salary must bigger than zero");\n      return;\n    }\n    this.readSubject.profit(number);\n  }\n}\n\n(function bootstrap() {\n  const sub = new ProxySubject();\n  for (let i = 0; i < 10; i++) {\n    const rnd = Math.random();\n    sub.profit(rnd > 0.5 ? Number.parseInt((rnd * 1000).toFixed(0)) : 0);\n  }\n})();\n\n\n\n# 3、前端开发中的实践\n\n频繁触发的操作，出于性能考虑，我们会降低它触发的频率，这就是节流和防抖。\n\n节流：规定的时间内重复触发，函数只会执行一次。\n\n节流的应用场景：主要是按钮的点击，屏幕缩放等操作，需要处理一些计算等。\n\n防抖：规定的时间内重复触发，每次触发都会重新计算时间，最后再触发一次真正的操作。比如你设置了一个1S的防抖，如果第1S内连续触发了10次，则第一秒内函数一次都不会执行，在第一秒末开始计算触发时间，第2S真正触发。\n\n防抖的应用场景：搜索框搜索\n\n另外，ES6新增了Proxy，我们可以直接使用语法糖实现代理模式。就比如Vue3数据的双向绑定就使用的是Proxy，还可以用Proxy来实现具有负数索引的数组.\n\n# 3.1、实现数组负数的索引\n\nfunction SafetyArray(arr) {\n  return new Proxy(arr, {\n    get(target, propKey, receiver) {\n      console.log(target, propKey, receiver)\n      // 如果数组为空，\n      const digitProp = Number.parseInt(propKey);\n      if (target.length === 0 && digitProp < 0) {\n        digitProp = Math.abs(digitProp);\n      }\n      if (propKey < 0) {\n        propKey = target.length + digitProp;\n      }\n      return target[propKey];\n    },\n    set(target, propKey, value, receiver) {\n      const digitProp = Number.parseInt(propKey);\n      // 不允许给数组设置除了数字以外的键\n      if (Number.isNaN(digitProp) && propKey !== "length") {\n        return false;\n      }\n      if (target.length === 0 && digitProp < 0) {\n        digitProp = Math.abs(digitProp);\n      }\n      if (propKey < 0) {\n        propKey = target.length + digitProp;\n      }\n      target[propKey] = value;\n      return true;\n    },\n  });\n}\n\n\n# 3.2、节流\n\n由于JS语法特性比较灵活，在前端开发中，节流和防抖这两个代理模式的应用场景，你可能并没有发觉。这是因为JS的函数可以作为参数传递，和闭包搭配使用，避免了我们去编写上述那么多的代码。\n\n下述代码中，callback函数就相当于UML图中的RealSubject类，返回的函数fn就相当于是图中的Proxy类，当我们调用fn的时候，它会根据间隔的时间是否执行真正的callback而改变了函数的行为。\n\nfunction throttle(callback, ms) {\n  let pre = Date.now();\n  return function fn(...args) {\n    let now = Date.now();\n    // 如果超过了时间段，执行函数\n    if (now - pre >= ms) {\n      callback.apply(this, args);\n      // 开启下一个阶段可用\n      pre = now;\n    }\n  };\n}\n\n\n以上节流是不使用定时器的简单实现，此外，节流还可以使用定时器实现。\n\nfunction throttle(callback, ms) {\n  let timer = null;\n  return function fn(...args) {\n    if (!timer) {\n      timer = setTimeout(() => {\n        callback.apply(this, args);\n        timer = null;\n      }, ms);\n    }\n  };\n}\n\n\n# 3.3、防抖\n\nfunction debounce(callback, ms) {\n  let timer = null;\n  return function fn(...args) {\n    // 如果timer存在，说明还没有到执行的时间，需要清理定时器\n    if (timer) {\n      clearTimeout(timer);\n      return;\n    }\n    // 设置一个定时器，在规定的时间内触发即可。\n    timer = setTimeout(() => {\n      callback.apply(this, args);\n    }, ms);\n  };\n}\n',normalizedContent:'# 代理模式\n\n\n# 1、基本概念\n\n代理模式是为其他对象提供一种代理以控制对这个对象的访问\n\n就拿前端经常简单的场景举例，比如有些操作并不想频繁的触发它，需要有人限制它的触发频率；就比如有些时候我们在操作数据的时候想做一些额外的事儿，比如vue的双向数据绑定。\n\n什么时候适合使用代理模式呢？——想在访问一个对象时做一些控制。\n\n代理模式的uml图如下：\n\n\n\n\n# 2、代码示例\n\ninterface subject {\n  profit(number: number): void;\n}\n\nclass realsubject implements subject {\n  profit(number: number): void {\n    console.log("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");\n    console.log(`you can earn money ${number} every day`);\n    console.log("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");\n  }\n}\n\nclass proxysubject implements subject {\n  private readsubject = new realsubject();\n\n  profit(number: number): void {\n    if (number <= 0) {\n      console.warn("salary must bigger than zero");\n      return;\n    }\n    this.readsubject.profit(number);\n  }\n}\n\n(function bootstrap() {\n  const sub = new proxysubject();\n  for (let i = 0; i < 10; i++) {\n    const rnd = math.random();\n    sub.profit(rnd > 0.5 ? number.parseint((rnd * 1000).tofixed(0)) : 0);\n  }\n})();\n\n\n\n# 3、前端开发中的实践\n\n频繁触发的操作，出于性能考虑，我们会降低它触发的频率，这就是节流和防抖。\n\n节流：规定的时间内重复触发，函数只会执行一次。\n\n节流的应用场景：主要是按钮的点击，屏幕缩放等操作，需要处理一些计算等。\n\n防抖：规定的时间内重复触发，每次触发都会重新计算时间，最后再触发一次真正的操作。比如你设置了一个1s的防抖，如果第1s内连续触发了10次，则第一秒内函数一次都不会执行，在第一秒末开始计算触发时间，第2s真正触发。\n\n防抖的应用场景：搜索框搜索\n\n另外，es6新增了proxy，我们可以直接使用语法糖实现代理模式。就比如vue3数据的双向绑定就使用的是proxy，还可以用proxy来实现具有负数索引的数组.\n\n# 3.1、实现数组负数的索引\n\nfunction safetyarray(arr) {\n  return new proxy(arr, {\n    get(target, propkey, receiver) {\n      console.log(target, propkey, receiver)\n      // 如果数组为空，\n      const digitprop = number.parseint(propkey);\n      if (target.length === 0 && digitprop < 0) {\n        digitprop = math.abs(digitprop);\n      }\n      if (propkey < 0) {\n        propkey = target.length + digitprop;\n      }\n      return target[propkey];\n    },\n    set(target, propkey, value, receiver) {\n      const digitprop = number.parseint(propkey);\n      // 不允许给数组设置除了数字以外的键\n      if (number.isnan(digitprop) && propkey !== "length") {\n        return false;\n      }\n      if (target.length === 0 && digitprop < 0) {\n        digitprop = math.abs(digitprop);\n      }\n      if (propkey < 0) {\n        propkey = target.length + digitprop;\n      }\n      target[propkey] = value;\n      return true;\n    },\n  });\n}\n\n\n# 3.2、节流\n\n由于js语法特性比较灵活，在前端开发中，节流和防抖这两个代理模式的应用场景，你可能并没有发觉。这是因为js的函数可以作为参数传递，和闭包搭配使用，避免了我们去编写上述那么多的代码。\n\n下述代码中，callback函数就相当于uml图中的realsubject类，返回的函数fn就相当于是图中的proxy类，当我们调用fn的时候，它会根据间隔的时间是否执行真正的callback而改变了函数的行为。\n\nfunction throttle(callback, ms) {\n  let pre = date.now();\n  return function fn(...args) {\n    let now = date.now();\n    // 如果超过了时间段，执行函数\n    if (now - pre >= ms) {\n      callback.apply(this, args);\n      // 开启下一个阶段可用\n      pre = now;\n    }\n  };\n}\n\n\n以上节流是不使用定时器的简单实现，此外，节流还可以使用定时器实现。\n\nfunction throttle(callback, ms) {\n  let timer = null;\n  return function fn(...args) {\n    if (!timer) {\n      timer = settimeout(() => {\n        callback.apply(this, args);\n        timer = null;\n      }, ms);\n    }\n  };\n}\n\n\n# 3.3、防抖\n\nfunction debounce(callback, ms) {\n  let timer = null;\n  return function fn(...args) {\n    // 如果timer存在，说明还没有到执行的时间，需要清理定时器\n    if (timer) {\n      cleartimeout(timer);\n      return;\n    }\n    // 设置一个定时器，在规定的时间内触发即可。\n    timer = settimeout(() => {\n      callback.apply(this, args);\n    }, ms);\n  };\n}\n',charsets:{cjk:!0}},{title:"职责链模式",frontmatter:{},regularPath:"/design-pattern/responsibility-chain.html",relativePath:"design-pattern/responsibility-chain.md",key:"v-5659b1b5",path:"/design-pattern/responsibility-chain.html",headers:[{level:2,title:"职责链模式",slug:"职责链模式",normalizedTitle:"职责链模式",charIndex:2},{level:3,title:"1、基本概念",slug:"_1、基本概念",normalizedTitle:"1、基本概念",charIndex:12},{level:3,title:"2、代码范式",slug:"_2、代码范式",normalizedTitle:"2、代码范式",charIndex:537},{level:3,title:"3、在前端开发中的实践",slug:"_3、在前端开发中的实践",normalizedTitle:"3、在前端开发中的实践",charIndex:2120}],headersStr:"职责链模式 1、基本概念 2、代码范式 3、在前端开发中的实践",content:'# 职责链模式\n\n\n# 1、基本概念\n\n职责链模式可以说是前端中几乎最常见的设计模式了，但是可能大家并没有注意到这就是职责链模式，像日常开发中的Promise链式调用（异步请求神器axios的请求或响应拦截器就是基于Promise链实现的。），像Rx.js.\n\n职责链模式：使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这个对象连成一条链，直到有一个对象处理它为止。\n\n当客户提交一个请求时，请求是沿着一个业务处理链进行传递。\n\n另外，如果业务代码足够复杂，并且每个if-else分支都有大量的逻辑需要处理，此时使用职责链模式对代码进行重构就比较划算了。因为它可以抹平if-else分支，从而可以使得代码的业务逻辑看起来比较直观（每个处理节点只关心对应的逻辑，无法处理则向后传递，代码单一化职责），但是如果业务逻辑简单的if-else经过这么一个大动干戈的重构，有点儿得不偿失。\n\n职责链模式的UML图如下所示：\n\n\n\n其含义是：具体的业务逻辑处理节点实现接口，每个业务逻辑节点有一个后继节点，在当前节点处理完成之后（或不能处理），委托给它的后继节点处理。\n\n如果职责链构建的太长，那处理效率必然会下降，在实际开发中，我们需要注意取舍。\n\n\n# 2、代码范式\n\nabstract class Component {\n  successor?: Component;\n\n  setSuccessor(next: Component) {\n    this.successor = next;\n  }\n\n  abstract exec(target: Map<string, string>): void;\n}\n\nclass ComputerComponent extends Component {\n  exec(target: Map<string, string>): void {\n    target.set("computer", "Windows 98");\n    console.log("计算机行业处理");\n    this.successor?.exec(target);\n  }\n}\n\nclass FinanceComponent extends Component {\n  exec(target: Map<string, string>): void {\n    target.set("finance", "招商银行600036");\n    console.log("金融行业处理");\n    this.successor?.exec(target);\n  }\n}\n\nclass MedicalComponent extends Component {\n  exec(target: Map<string, string>): void {\n    target.set("medical", "APTX 4869");\n    console.log("医药行业处理");\n    this.successor?.exec(target);\n  }\n}\n\nclass AgricultureComponent extends Component {\n  exec(target: Map<string, string>): void {\n    target.set("agriculture", "杂交水稻");\n    console.log("农业行业处理");\n    this.successor?.exec(target);\n  }\n}\n\nclass Invoker {\n  chian: Component;\n\n  constructor(component: Component) {\n    this.chian = component;\n  }\n\n  doWork() {\n    const map = new Map();\n    this.chian.exec(map);\n    console.log(map);\n  }\n}\n\nconst computer = new ComputerComponent();\nconst finance = new FinanceComponent();\nconst medical = new MedicalComponent();\nconst agriculture = new AgricultureComponent();\n\ncomputer.setSuccessor(finance);\nfinance.setSuccessor(medical);\nmedical.setSuccessor(agriculture);\n\nconst invoker = new Invoker(computer);\n\ninvoker.doWork();\n\n\n每个处理节点可以根据自己的业务需求选择处理当前任务再将其委托给下一个处理节点，也可以根据业务直接忽略当前处理委托给一下处理节点（示例是需要处理的方式）\n\n\n# 3、在前端开发中的实践\n\n在前端中，我们可能每天都在使用Promise，如果你研究过Promise，你会发现，Promise就是基于职责链模式设计的，而我们给then方法中部署回调函数则就是每个职责节点的处理器，因为then方法返回一个新的Promise可以为其委托新的业务处理节点。\n\naxios的拦截器管道就是基于Promise进行设计的，具体源码节选如下：\n\n// 文件位置: axios>lib>core>Axios.js 版本——>0.21.1\n// 以省略无关代码\nfunction Axios(instanceConfig) {\n  this.defaults = instanceConfig;\n  // 注册两个拦截器的管理器\n  this.interceptors = {\n    request: new InterceptorManager(),\n    response: new InterceptorManager(),\n  };\n}\n\nAxios.prototype.request = function request(config) {\n  // Hook up interceptors middleware\n  var chain = [dispatchRequest, undefined];\n  var promise = Promise.resolve(config);\n\n  // 处理请求拦截器\n  this.interceptors.request.forEach(function unshiftRequestInterceptors(\n    interceptor\n  ) {\n    chain.unshift(interceptor.fulfilled, interceptor.rejected);\n  });\n  // 处理响应拦截器\n  this.interceptors.response.forEach(function pushResponseInterceptors(\n    interceptor\n  ) {\n    chain.push(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  // 部署一个Promise链，类似链表的头插法操作，像多米罗骨牌那样的链式反应，是反向部署的\n  while (chain.length) {\n    promise = promise.then(chain.shift(), chain.shift());\n  }\n  // 返回最开头的那个Promise给外界，到时候就可以起到导火索的作用\n  return promise;\n};\n\n\n但是Promise构建的职责链有一个缺点，就是一旦部署好了，就不再从中删除或增加节点，并且Promise链就像鞭炮一样，如果你将其点燃了（因为Promise的状态只会从pending到resolved或rejected），它就会从头到尾噼里啪啦的炸到结束，关键就是炸到结束这串鞭炮就没了，我想再点一串，就得从新再买一串鞭炮。\n\n比如：\n\nlet trigger = null;\n\nfunction demo() {\n  return new Promise((resolve) => {\n    trigger = resolve;\n  });\n}\n\nconst d = demo();\n\nd.then(() => {\n  console.log(1);\n}).then(() => {\n  console.log(2);\n});\n\ntrigger(); // 只会触发一次输出1， 2\ntrigger();\ntrigger();\n\n\n在有些时候，如果业务处理链可能有变动的时候，用Promise可能就不太符合我们的需求了，这个时候，真的就要自己写一下职责链模式的范式了。\n\n实现方式和装饰模式的AOP范式几乎差不多，根据返回结果决定是否将业务逻辑抛给下一个处理节点。\n\nFunction.prototype.after = function (fn) {\n  let self = this;\n  return function () {\n    let ret = self.apply(this, arguments);\n    // 根据上一个职责处理的返回决定是否将其向后抛\n    if (ret === "nextSuccessor") {\n      return fn.apply(this, arguments);\n    }\n    return ret;\n  };\n};\n\n\n基于AOP实现模拟的一个业务场景：\n\nfunction Computer() {\n  console.log("计算机行业处理");\n  return "nextSuccessor";\n}\n\nfunction Finance() {\n  console.log("金融行业处理");\n  return "nextSuccessor";\n}\n\nfunction Medical() {\n  console.log("医药行业处理");\n  return "nextSuccessor";\n}\n\nfunction Agriculture() {\n  console.log("农业行业处理");\n}\n// 构建职责链\nlet chain = Computer.after(Finance).after(Medical).after(Agriculture);\nchain();\n\n\n上述这个职责链可以触发多次，不存在像Promise链那样的问题，而且可以随时应对业务的修改。\n\n所以实际开发中可以根据自己的需求选择是直接使用Promise链还是自己实现职责链模式。',normalizedContent:'# 职责链模式\n\n\n# 1、基本概念\n\n职责链模式可以说是前端中几乎最常见的设计模式了，但是可能大家并没有注意到这就是职责链模式，像日常开发中的promise链式调用（异步请求神器axios的请求或响应拦截器就是基于promise链实现的。），像rx.js.\n\n职责链模式：使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这个对象连成一条链，直到有一个对象处理它为止。\n\n当客户提交一个请求时，请求是沿着一个业务处理链进行传递。\n\n另外，如果业务代码足够复杂，并且每个if-else分支都有大量的逻辑需要处理，此时使用职责链模式对代码进行重构就比较划算了。因为它可以抹平if-else分支，从而可以使得代码的业务逻辑看起来比较直观（每个处理节点只关心对应的逻辑，无法处理则向后传递，代码单一化职责），但是如果业务逻辑简单的if-else经过这么一个大动干戈的重构，有点儿得不偿失。\n\n职责链模式的uml图如下所示：\n\n\n\n其含义是：具体的业务逻辑处理节点实现接口，每个业务逻辑节点有一个后继节点，在当前节点处理完成之后（或不能处理），委托给它的后继节点处理。\n\n如果职责链构建的太长，那处理效率必然会下降，在实际开发中，我们需要注意取舍。\n\n\n# 2、代码范式\n\nabstract class component {\n  successor?: component;\n\n  setsuccessor(next: component) {\n    this.successor = next;\n  }\n\n  abstract exec(target: map<string, string>): void;\n}\n\nclass computercomponent extends component {\n  exec(target: map<string, string>): void {\n    target.set("computer", "windows 98");\n    console.log("计算机行业处理");\n    this.successor?.exec(target);\n  }\n}\n\nclass financecomponent extends component {\n  exec(target: map<string, string>): void {\n    target.set("finance", "招商银行600036");\n    console.log("金融行业处理");\n    this.successor?.exec(target);\n  }\n}\n\nclass medicalcomponent extends component {\n  exec(target: map<string, string>): void {\n    target.set("medical", "aptx 4869");\n    console.log("医药行业处理");\n    this.successor?.exec(target);\n  }\n}\n\nclass agriculturecomponent extends component {\n  exec(target: map<string, string>): void {\n    target.set("agriculture", "杂交水稻");\n    console.log("农业行业处理");\n    this.successor?.exec(target);\n  }\n}\n\nclass invoker {\n  chian: component;\n\n  constructor(component: component) {\n    this.chian = component;\n  }\n\n  dowork() {\n    const map = new map();\n    this.chian.exec(map);\n    console.log(map);\n  }\n}\n\nconst computer = new computercomponent();\nconst finance = new financecomponent();\nconst medical = new medicalcomponent();\nconst agriculture = new agriculturecomponent();\n\ncomputer.setsuccessor(finance);\nfinance.setsuccessor(medical);\nmedical.setsuccessor(agriculture);\n\nconst invoker = new invoker(computer);\n\ninvoker.dowork();\n\n\n每个处理节点可以根据自己的业务需求选择处理当前任务再将其委托给下一个处理节点，也可以根据业务直接忽略当前处理委托给一下处理节点（示例是需要处理的方式）\n\n\n# 3、在前端开发中的实践\n\n在前端中，我们可能每天都在使用promise，如果你研究过promise，你会发现，promise就是基于职责链模式设计的，而我们给then方法中部署回调函数则就是每个职责节点的处理器，因为then方法返回一个新的promise可以为其委托新的业务处理节点。\n\naxios的拦截器管道就是基于promise进行设计的，具体源码节选如下：\n\n// 文件位置: axios>lib>core>axios.js 版本——>0.21.1\n// 以省略无关代码\nfunction axios(instanceconfig) {\n  this.defaults = instanceconfig;\n  // 注册两个拦截器的管理器\n  this.interceptors = {\n    request: new interceptormanager(),\n    response: new interceptormanager(),\n  };\n}\n\naxios.prototype.request = function request(config) {\n  // hook up interceptors middleware\n  var chain = [dispatchrequest, undefined];\n  var promise = promise.resolve(config);\n\n  // 处理请求拦截器\n  this.interceptors.request.foreach(function unshiftrequestinterceptors(\n    interceptor\n  ) {\n    chain.unshift(interceptor.fulfilled, interceptor.rejected);\n  });\n  // 处理响应拦截器\n  this.interceptors.response.foreach(function pushresponseinterceptors(\n    interceptor\n  ) {\n    chain.push(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  // 部署一个promise链，类似链表的头插法操作，像多米罗骨牌那样的链式反应，是反向部署的\n  while (chain.length) {\n    promise = promise.then(chain.shift(), chain.shift());\n  }\n  // 返回最开头的那个promise给外界，到时候就可以起到导火索的作用\n  return promise;\n};\n\n\n但是promise构建的职责链有一个缺点，就是一旦部署好了，就不再从中删除或增加节点，并且promise链就像鞭炮一样，如果你将其点燃了（因为promise的状态只会从pending到resolved或rejected），它就会从头到尾噼里啪啦的炸到结束，关键就是炸到结束这串鞭炮就没了，我想再点一串，就得从新再买一串鞭炮。\n\n比如：\n\nlet trigger = null;\n\nfunction demo() {\n  return new promise((resolve) => {\n    trigger = resolve;\n  });\n}\n\nconst d = demo();\n\nd.then(() => {\n  console.log(1);\n}).then(() => {\n  console.log(2);\n});\n\ntrigger(); // 只会触发一次输出1， 2\ntrigger();\ntrigger();\n\n\n在有些时候，如果业务处理链可能有变动的时候，用promise可能就不太符合我们的需求了，这个时候，真的就要自己写一下职责链模式的范式了。\n\n实现方式和装饰模式的aop范式几乎差不多，根据返回结果决定是否将业务逻辑抛给下一个处理节点。\n\nfunction.prototype.after = function (fn) {\n  let self = this;\n  return function () {\n    let ret = self.apply(this, arguments);\n    // 根据上一个职责处理的返回决定是否将其向后抛\n    if (ret === "nextsuccessor") {\n      return fn.apply(this, arguments);\n    }\n    return ret;\n  };\n};\n\n\n基于aop实现模拟的一个业务场景：\n\nfunction computer() {\n  console.log("计算机行业处理");\n  return "nextsuccessor";\n}\n\nfunction finance() {\n  console.log("金融行业处理");\n  return "nextsuccessor";\n}\n\nfunction medical() {\n  console.log("医药行业处理");\n  return "nextsuccessor";\n}\n\nfunction agriculture() {\n  console.log("农业行业处理");\n}\n// 构建职责链\nlet chain = computer.after(finance).after(medical).after(agriculture);\nchain();\n\n\n上述这个职责链可以触发多次，不存在像promise链那样的问题，而且可以随时应对业务的修改。\n\n所以实际开发中可以根据自己的需求选择是直接使用promise链还是自己实现职责链模式。',charsets:{cjk:!0}},{title:"单例模式",frontmatter:{},regularPath:"/design-pattern/singleton.html",relativePath:"design-pattern/singleton.md",key:"v-2b5eefb2",path:"/design-pattern/singleton.html",headers:[{level:2,title:"单例模式",slug:"单例模式",normalizedTitle:"单例模式",charIndex:2},{level:3,title:"1、基本概念",slug:"_1、基本概念",normalizedTitle:"1、基本概念",charIndex:11},{level:3,title:"2、代码示例",slug:"_2、代码示例",normalizedTitle:"2、代码示例",charIndex:208},{level:3,title:"3、前端开发中的实践",slug:"_3、前端开发中的实践",normalizedTitle:"3、前端开发中的实践",charIndex:509}],headersStr:"单例模式 1、基本概念 2、代码示例 3、前端开发中的实践",content:'# 单例模式\n\n\n# 1、基本概念\n\n单例模式，保证一个类仅有一个实例，并提供一个访问它的全局节点。\n\n通常我们可以让一个全局变量使得一个对象被访问，但它不能被防止你实例化多个对象，一个最好的方式就是，让类自身负责保存它的唯一实例。\n\n这个类可以保证没有其它实例可以被创建。\n\n它的UML图如下:\n\n\n\n从上图中可以看出，将其构造方法私有化，这样外界就无法实例化它了，并且暴露出了一个访问它唯一实例的方法。\n\n\n# 2、代码示例\n\nclass Singleton {\n  /**\n   * 内部持有全局唯一的实例\n   */\n  private instance: Singleton | null = null;\n  /**\n   * 私有化构造函数\n   */\n  private constructor() {}\n  /**\n   * 暴露访问其唯一实例的访问方法\n   * @returns\n   */\n  getInstance(): Singleton {\n    return this.instance || (this.instance = new Singleton());\n  }\n}\n\n\n\n# 3、前端开发中的实践\n\n这个场景已经不能说是在前端开发中的场景了。\n\n我们在使用Nest.JS这类框架开发BFF服务时，通常操作数据库的上下文就会应用单例模式来设计。\n\n另外一个大家比较熟悉的场景就是前端的Notice组件了，比如Element UI的Message组件，如果频繁的执行（用户点击的过快的话）， 就会出现以下这种场景：\n\n\n\n我个人觉得这种交互是比较糟糕的，但是Element UI的设计团队为了把最大的灵活度交给开发者，它并没有在实现的时候就保证其单例，因此，我们可以使用单例模式对Message组件进行封装。\n\n因此，我们需要使用单例模式对Message组件进行封装：\n\nimport Vue from "vue";\n/**\n * 单例的Message组件\n */\nclass SingletonMessage {\n  static instance = null;\n\n  constructor() {\n    // 不允许当前类实例化\n    throw new Error("this class can not called by new");\n  }\n\n  static show(options) {\n    // 如果当前实例存在则什么事儿都可以不做了\n    if (this.instance) {\n      return;\n    }\n    let config;\n    if (typeof options === "string") {\n      config = {\n        message: options,\n        onClose: () => {\n          // 做一些清理工作\n          this.instance = null;\n        },\n      };\n    } else {\n      const { onClose, ...others } = options;\n      config = {\n        ...others,\n        onClose: (...args) => {\n          // 处理额外的清理工作\n          this.instance = null;\n          // 处理默认的参数\n          typeof onClose === "function" && onClose.apply(this, args);\n        },\n      };\n    }\n    this.instance = Message(config);\n  }\n\n  static close() {\n    if (!this.instance) {\n      return;\n    }\n    this.instance.close();\n  }\n}\n\nVue.prototype.$singletonMessage = SingletonMessage;\n\n\n看得仔细的同学可能会觉得上面的代码跟单例模式的UML的表示还是有一些差别的，切记学设计模式不要死板（很多时候，我们都在借鉴其设计思想），使用设计模式最大的动机在于将我们的代码写的易于维护，如果应用了设计模式反而使得我们的代码维护成本更高了，那就应该反思是不是做错了。\n\n此例受制于Element UI的限制，Message组件每次关闭的时候都会移除DOM，所以看起来好像并不是那么“纯”，因此仅借鉴了单例模式的思想，达到了业务预期。\n\n除此之外，还有个对象也是全局单例的，可能你每天都在用到，但你并没有在意，它就是->Math对象',normalizedContent:'# 单例模式\n\n\n# 1、基本概念\n\n单例模式，保证一个类仅有一个实例，并提供一个访问它的全局节点。\n\n通常我们可以让一个全局变量使得一个对象被访问，但它不能被防止你实例化多个对象，一个最好的方式就是，让类自身负责保存它的唯一实例。\n\n这个类可以保证没有其它实例可以被创建。\n\n它的uml图如下:\n\n\n\n从上图中可以看出，将其构造方法私有化，这样外界就无法实例化它了，并且暴露出了一个访问它唯一实例的方法。\n\n\n# 2、代码示例\n\nclass singleton {\n  /**\n   * 内部持有全局唯一的实例\n   */\n  private instance: singleton | null = null;\n  /**\n   * 私有化构造函数\n   */\n  private constructor() {}\n  /**\n   * 暴露访问其唯一实例的访问方法\n   * @returns\n   */\n  getinstance(): singleton {\n    return this.instance || (this.instance = new singleton());\n  }\n}\n\n\n\n# 3、前端开发中的实践\n\n这个场景已经不能说是在前端开发中的场景了。\n\n我们在使用nest.js这类框架开发bff服务时，通常操作数据库的上下文就会应用单例模式来设计。\n\n另外一个大家比较熟悉的场景就是前端的notice组件了，比如element ui的message组件，如果频繁的执行（用户点击的过快的话）， 就会出现以下这种场景：\n\n\n\n我个人觉得这种交互是比较糟糕的，但是element ui的设计团队为了把最大的灵活度交给开发者，它并没有在实现的时候就保证其单例，因此，我们可以使用单例模式对message组件进行封装。\n\n因此，我们需要使用单例模式对message组件进行封装：\n\nimport vue from "vue";\n/**\n * 单例的message组件\n */\nclass singletonmessage {\n  static instance = null;\n\n  constructor() {\n    // 不允许当前类实例化\n    throw new error("this class can not called by new");\n  }\n\n  static show(options) {\n    // 如果当前实例存在则什么事儿都可以不做了\n    if (this.instance) {\n      return;\n    }\n    let config;\n    if (typeof options === "string") {\n      config = {\n        message: options,\n        onclose: () => {\n          // 做一些清理工作\n          this.instance = null;\n        },\n      };\n    } else {\n      const { onclose, ...others } = options;\n      config = {\n        ...others,\n        onclose: (...args) => {\n          // 处理额外的清理工作\n          this.instance = null;\n          // 处理默认的参数\n          typeof onclose === "function" && onclose.apply(this, args);\n        },\n      };\n    }\n    this.instance = message(config);\n  }\n\n  static close() {\n    if (!this.instance) {\n      return;\n    }\n    this.instance.close();\n  }\n}\n\nvue.prototype.$singletonmessage = singletonmessage;\n\n\n看得仔细的同学可能会觉得上面的代码跟单例模式的uml的表示还是有一些差别的，切记学设计模式不要死板（很多时候，我们都在借鉴其设计思想），使用设计模式最大的动机在于将我们的代码写的易于维护，如果应用了设计模式反而使得我们的代码维护成本更高了，那就应该反思是不是做错了。\n\n此例受制于element ui的限制，message组件每次关闭的时候都会移除dom，所以看起来好像并不是那么“纯”，因此仅借鉴了单例模式的思想，达到了业务预期。\n\n除此之外，还有个对象也是全局单例的，可能你每天都在用到，但你并没有在意，它就是->math对象',charsets:{cjk:!0}},{title:"中介者模式",frontmatter:{},regularPath:"/design-pattern/mediator.html",relativePath:"design-pattern/mediator.md",key:"v-04c70155",path:"/design-pattern/mediator.html",headers:[{level:2,title:"中介者模式",slug:"中介者模式",normalizedTitle:"中介者模式",charIndex:2},{level:3,title:"1、基本概念",slug:"_1、基本概念",normalizedTitle:"1、基本概念",charIndex:12},{level:3,title:"2、代码示例",slug:"_2、代码示例",normalizedTitle:"2、代码示例",charIndex:23},{level:3,title:"3、在前端开发中的实践",slug:"_3、在前端开发中的实践",normalizedTitle:"3、在前端开发中的实践",charIndex:34}],headersStr:"中介者模式 1、基本概念 2、代码示例 3、在前端开发中的实践",content:"# 中介者模式\n\n\n# 1、基本概念\n\n\n# 2、代码示例\n\n\n# 3、在前端开发中的实践",normalizedContent:"# 中介者模式\n\n\n# 1、基本概念\n\n\n# 2、代码示例\n\n\n# 3、在前端开发中的实践",charsets:{cjk:!0}},{title:"状态模式",frontmatter:{},regularPath:"/design-pattern/state.html",relativePath:"design-pattern/state.md",key:"v-57365d1b",path:"/design-pattern/state.html",headers:[{level:2,title:"状态模式",slug:"状态模式",normalizedTitle:"状态模式",charIndex:2},{level:3,title:"1、基本概念",slug:"_1、基本概念",normalizedTitle:"1、基本概念",charIndex:11},{level:3,title:"2、代码示例",slug:"_2、代码示例",normalizedTitle:"2、代码示例",charIndex:158},{level:3,title:"3、前端开发中的实践",slug:"_3、前端开发中的实践",normalizedTitle:"3、前端开发中的实践",charIndex:2070}],headersStr:"状态模式 1、基本概念 2、代码示例 3、前端开发中的实践",content:'# 状态模式\n\n\n# 1、基本概念\n\n状态模式：当一个对象内在的状态改变时允许改变其行为，这个对象看起来像是改变了其类。\n\n状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况。把状态的判断逻辑转移到了表示不同状态的一系列类当中，可以把复杂的逻辑简单化。\n\n以下是状态模式的UML图：\n\n\n\n\n# 2、代码示例\n\n定义一个抽象类State表示状态。\n\nabstract class State {\n  /**\n   * 当前状态的名称\n   */\n  abstract stateName: string;\n  /**\n   * 在当前状态上处理的业务逻辑，将Context传递给当前业务状态，使之可以改变Context的状态\n   */\n  public abstract handler(ctx: Context): void;\n}\n\n\n定义一些具象化的业务类，继承State，负责各自的业务逻辑。\n\n/**\n * 起床业务类\n */\nclass GetUpState extends State {\n  stateName: string = "起床状态";\n\n  public handler(ctx: Context): void {\n    console.log("起床啦~~~~~~~~~~~");\n    ctx.setState(new EatState());\n  }\n}\n\n/**\n * 吃饭类\n */\nclass EatState extends State {\n  stateName: string = "吃饭状态";\n\n  public handler(ctx: Context): void {\n    console.log("吃饭啦~~~~~~~~~~~");\n    ctx.setState(new WorkState());\n  }\n}\n\n/**\n * 工作类\n */\nclass WorkState extends State {\n  stateName: string = "工作状态";\n\n  public handler(ctx: Context): void {\n    console.log("工作啦~~~~~~~~~~~~~");\n    ctx.setState(new SleepState());\n  }\n}\n/**\n * 睡觉类\n */\nclass SleepState extends State {\n  stateName: string = "睡觉状态";\n\n  public handler(ctx: Context): void {\n    console.log("睡觉啦~~~~~~~~~~~~~~");\n  }\n}\n\n\n定义一个上下文Context类，其类中的行为由当前持有的业务逻辑状态子类决定。\n\n/**\n * 上下文类\n */\nclass Context {\n  private _state: State;\n\n  get state(): State {\n    return this._state;\n  }\n\n  private set state(nextState: State) {\n    console.log(\n      `当前状态：${this._state.stateName}, 下一个状态：${nextState.stateName}`\n    );\n    this._state = nextState;\n  }\n\n  constructor(initState: State) {\n    this._state = initState;\n  }\n\n  /**\n   * 改变Context的行为\n   */\n  setState(state: State) {\n    this.state = state;\n  }\n  /**\n   * 触发当前上下文状态的业务行为\n   */\n  request() {\n    this.state.handler(this);\n  }\n}\n\n\n调用方：\n\nfunction bootstrap() {\n  const ctx = new Context(new GetUpState());\n  // 起床啦~~~~~~~~~~~\n  // 当前状态：起床状态, 下一个状态：吃饭状态\n  ctx.request();\n  // 吃饭啦~~~~~~~~~~~\n  // 当前状态：吃饭状态, 下一个状态：工作状态\n  ctx.request();\n  // 工作啦~~~~~~~~~~~~~\n  // 当前状态：工作状态, 下一个状态：睡觉状态\n  ctx.request();\n  // 睡觉啦~~~~~~~~~~~~~~\n  ctx.request();\n  // 睡觉啦~~~~~~~~~~~~~~\n  ctx.request();\n}\n\n\n\n# 3、前端开发中的实践\n\n其实我们每天都在使用这个东西，如果你还不知道，那说明你对async-await函数的理解度还是相当欠缺的（如果2023年了，你还没有使用过async-await函数的话，那请你赶紧补补吧~）。\n\n以下是我模拟的一段业务代码：\n\nasync function func() {\n  const val1 = await 1;\n  const val2 = await (2 + val1);\n  const val3 = await (3 + val2);\n  const val4 = await (4 + val3);\n  return val4;\n}\n\n\n这段代码，会被babel编译成以下代码：\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    // 如果执行出错，提前结束\n    reject(error);\n    return;\n  }\n  // 如果Generator已经迭代完成，直接把最终的返回值报告给外部的Promise，作为它的fulfilled值，结束递归\n  if (info.done) {\n    resolve(value);\n  } else {\n    // 没有完成，把本轮的值包裹，最为入参传递给下一个next或者throw的调用\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  // fn就是一个Generator，执行它可以得到一个迭代器\n  return function () {\n    var self = this,\n      args = arguments;\n    return new Promise(function (resolve, reject) {\n      // 得到一个由Generator执行得到的迭代器\n      var gen = fn.apply(self, args);\n      // 定义next函数\n      function _next(value) {\n        // 递归的调用next，以使得Generator执行得到的迭代器可以一直向后迭代\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);\n      }\n      // 定义错误处理函数\n      function _throw(err) {\n        // 递归的调用throw，以使得Generator执行得到的迭代器可以一直向后迭代\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);\n      }\n      // 开始迭代，因为第一个next不能有参数，所以就传递了一个undefined\n      _next(undefined);\n    });\n  };\n}\n\nfunction func() {\n  return _func.apply(this, arguments);\n}\n\nfunction _func() {\n  _func = _asyncToGenerator(\n    // 得到一个Generator，这个Generator执行就可以得到一个迭代器\n    /*#__PURE__*/ _regeneratorRuntime().mark(function _callee() {\n      var val1, val2, val3, val4;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) {\n          switch ((_context.prev = _context.next)) {\n            case 0:\n              _context.next = 2;\n              return 1;\n\n            case 2:\n              val1 = _context.sent;\n              _context.next = 5;\n              return 2 + val1;\n\n            case 5:\n              val2 = _context.sent;\n              _context.next = 8;\n              return 3 + val2;\n\n            case 8:\n              val3 = _context.sent;\n              _context.next = 11;\n              return 4 + val3;\n\n            case 11:\n              val4 = _context.sent;\n              return _context.abrupt("return", val4);\n\n            case 13:\n            case "end":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    })\n  );\n  // 向外界返回一个Promise\n  return _func.apply(this, arguments);\n}\n\n\n如果你对Generator函数还不太清楚的话，请先移步Generator函数的介绍，否则后文的阐述，您将无法理解。\n\n在这一节，我们把注意力放在_regeneratorRuntime().mark(...)这个位置，此刻的回调函数，其中的_context参数正是我们状态模式的这个Context类。\n\n首先Generator函数执行得到一个迭代器，我们每次调用迭代器的next，这个回调函数都知道去修改Context的状态，只不过上面的业务实现类被其写成了switch-case(不要怪babel编译的代码违背了什么开闭原则，babel不是在写业务，它是不知道你的业务逻辑的，它只能根据Generator函数的yield语句得到这样的分支流程，不可能为你去生成那一系列的业务实现类)，因此，我们每次调用迭代器，其行为就不一样（体现在你执行的不同的异步逻辑）\n\n以下是一个使用Generator函数和不使用Generator函数实现状态模式的例子：\n\n不使用Generator：\n\nclass GreenLight {\n  next = new YellowLight();\n\n  turnon(ctx) {\n    console.log("绿灯亮起");\n    ctx.state = this.next;\n  }\n}\n\nclass YellowLight {\n  next = new RedLight();\n\n  turnon(ctx) {\n    console.log("黄灯闪烁，红灯即将亮起");\n    ctx.state = this.next;\n  }\n}\n\nclass RedLight {\n  next = new GreenLight();\n  turnon(ctx) {\n    console.log("红灯亮起");\n    ctx.state = this.next;\n  }\n}\n\nclass SignalLight {\n  state = new GreenLight();\n\n  loop() {\n    this.state.turnon(this);\n  }\n}\n\nconst light = new SignalLight();\n\nfunction start(immediate) {\n  setTimeout(() => {\n    light.loop();\n    start();\n  }, 1000);\n  immediate && light.loop();\n}\n\n\n使用Generator：\n\nfunction* func() {\n  while (1) {\n    yield console.log("红灯亮起");\n    yield console.log("绿灯亮起");\n    yield console.log("黄灯闪烁，红灯即将亮起");\n  }\n}\n\nconst light = func();\n\nfunction start(immediate) {\n  setTimeout(() => {\n    light.next();\n    start();\n  }, 1000);\n  immediate && light.next();\n}\n\n\n因此，可以利用Generator的这个语法在实际开发中代替手写原生的状态模式的代码。',normalizedContent:'# 状态模式\n\n\n# 1、基本概念\n\n状态模式：当一个对象内在的状态改变时允许改变其行为，这个对象看起来像是改变了其类。\n\n状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况。把状态的判断逻辑转移到了表示不同状态的一系列类当中，可以把复杂的逻辑简单化。\n\n以下是状态模式的uml图：\n\n\n\n\n# 2、代码示例\n\n定义一个抽象类state表示状态。\n\nabstract class state {\n  /**\n   * 当前状态的名称\n   */\n  abstract statename: string;\n  /**\n   * 在当前状态上处理的业务逻辑，将context传递给当前业务状态，使之可以改变context的状态\n   */\n  public abstract handler(ctx: context): void;\n}\n\n\n定义一些具象化的业务类，继承state，负责各自的业务逻辑。\n\n/**\n * 起床业务类\n */\nclass getupstate extends state {\n  statename: string = "起床状态";\n\n  public handler(ctx: context): void {\n    console.log("起床啦~~~~~~~~~~~");\n    ctx.setstate(new eatstate());\n  }\n}\n\n/**\n * 吃饭类\n */\nclass eatstate extends state {\n  statename: string = "吃饭状态";\n\n  public handler(ctx: context): void {\n    console.log("吃饭啦~~~~~~~~~~~");\n    ctx.setstate(new workstate());\n  }\n}\n\n/**\n * 工作类\n */\nclass workstate extends state {\n  statename: string = "工作状态";\n\n  public handler(ctx: context): void {\n    console.log("工作啦~~~~~~~~~~~~~");\n    ctx.setstate(new sleepstate());\n  }\n}\n/**\n * 睡觉类\n */\nclass sleepstate extends state {\n  statename: string = "睡觉状态";\n\n  public handler(ctx: context): void {\n    console.log("睡觉啦~~~~~~~~~~~~~~");\n  }\n}\n\n\n定义一个上下文context类，其类中的行为由当前持有的业务逻辑状态子类决定。\n\n/**\n * 上下文类\n */\nclass context {\n  private _state: state;\n\n  get state(): state {\n    return this._state;\n  }\n\n  private set state(nextstate: state) {\n    console.log(\n      `当前状态：${this._state.statename}, 下一个状态：${nextstate.statename}`\n    );\n    this._state = nextstate;\n  }\n\n  constructor(initstate: state) {\n    this._state = initstate;\n  }\n\n  /**\n   * 改变context的行为\n   */\n  setstate(state: state) {\n    this.state = state;\n  }\n  /**\n   * 触发当前上下文状态的业务行为\n   */\n  request() {\n    this.state.handler(this);\n  }\n}\n\n\n调用方：\n\nfunction bootstrap() {\n  const ctx = new context(new getupstate());\n  // 起床啦~~~~~~~~~~~\n  // 当前状态：起床状态, 下一个状态：吃饭状态\n  ctx.request();\n  // 吃饭啦~~~~~~~~~~~\n  // 当前状态：吃饭状态, 下一个状态：工作状态\n  ctx.request();\n  // 工作啦~~~~~~~~~~~~~\n  // 当前状态：工作状态, 下一个状态：睡觉状态\n  ctx.request();\n  // 睡觉啦~~~~~~~~~~~~~~\n  ctx.request();\n  // 睡觉啦~~~~~~~~~~~~~~\n  ctx.request();\n}\n\n\n\n# 3、前端开发中的实践\n\n其实我们每天都在使用这个东西，如果你还不知道，那说明你对async-await函数的理解度还是相当欠缺的（如果2023年了，你还没有使用过async-await函数的话，那请你赶紧补补吧~）。\n\n以下是我模拟的一段业务代码：\n\nasync function func() {\n  const val1 = await 1;\n  const val2 = await (2 + val1);\n  const val3 = await (3 + val2);\n  const val4 = await (4 + val3);\n  return val4;\n}\n\n\n这段代码，会被babel编译成以下代码：\n\nfunction asyncgeneratorstep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    // 如果执行出错，提前结束\n    reject(error);\n    return;\n  }\n  // 如果generator已经迭代完成，直接把最终的返回值报告给外部的promise，作为它的fulfilled值，结束递归\n  if (info.done) {\n    resolve(value);\n  } else {\n    // 没有完成，把本轮的值包裹，最为入参传递给下一个next或者throw的调用\n    promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asynctogenerator(fn) {\n  // fn就是一个generator，执行它可以得到一个迭代器\n  return function () {\n    var self = this,\n      args = arguments;\n    return new promise(function (resolve, reject) {\n      // 得到一个由generator执行得到的迭代器\n      var gen = fn.apply(self, args);\n      // 定义next函数\n      function _next(value) {\n        // 递归的调用next，以使得generator执行得到的迭代器可以一直向后迭代\n        asyncgeneratorstep(gen, resolve, reject, _next, _throw, "next", value);\n      }\n      // 定义错误处理函数\n      function _throw(err) {\n        // 递归的调用throw，以使得generator执行得到的迭代器可以一直向后迭代\n        asyncgeneratorstep(gen, resolve, reject, _next, _throw, "throw", err);\n      }\n      // 开始迭代，因为第一个next不能有参数，所以就传递了一个undefined\n      _next(undefined);\n    });\n  };\n}\n\nfunction func() {\n  return _func.apply(this, arguments);\n}\n\nfunction _func() {\n  _func = _asynctogenerator(\n    // 得到一个generator，这个generator执行就可以得到一个迭代器\n    /*#__pure__*/ _regeneratorruntime().mark(function _callee() {\n      var val1, val2, val3, val4;\n      return _regeneratorruntime().wrap(function _callee$(_context) {\n        while (1) {\n          switch ((_context.prev = _context.next)) {\n            case 0:\n              _context.next = 2;\n              return 1;\n\n            case 2:\n              val1 = _context.sent;\n              _context.next = 5;\n              return 2 + val1;\n\n            case 5:\n              val2 = _context.sent;\n              _context.next = 8;\n              return 3 + val2;\n\n            case 8:\n              val3 = _context.sent;\n              _context.next = 11;\n              return 4 + val3;\n\n            case 11:\n              val4 = _context.sent;\n              return _context.abrupt("return", val4);\n\n            case 13:\n            case "end":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    })\n  );\n  // 向外界返回一个promise\n  return _func.apply(this, arguments);\n}\n\n\n如果你对generator函数还不太清楚的话，请先移步generator函数的介绍，否则后文的阐述，您将无法理解。\n\n在这一节，我们把注意力放在_regeneratorruntime().mark(...)这个位置，此刻的回调函数，其中的_context参数正是我们状态模式的这个context类。\n\n首先generator函数执行得到一个迭代器，我们每次调用迭代器的next，这个回调函数都知道去修改context的状态，只不过上面的业务实现类被其写成了switch-case(不要怪babel编译的代码违背了什么开闭原则，babel不是在写业务，它是不知道你的业务逻辑的，它只能根据generator函数的yield语句得到这样的分支流程，不可能为你去生成那一系列的业务实现类)，因此，我们每次调用迭代器，其行为就不一样（体现在你执行的不同的异步逻辑）\n\n以下是一个使用generator函数和不使用generator函数实现状态模式的例子：\n\n不使用generator：\n\nclass greenlight {\n  next = new yellowlight();\n\n  turnon(ctx) {\n    console.log("绿灯亮起");\n    ctx.state = this.next;\n  }\n}\n\nclass yellowlight {\n  next = new redlight();\n\n  turnon(ctx) {\n    console.log("黄灯闪烁，红灯即将亮起");\n    ctx.state = this.next;\n  }\n}\n\nclass redlight {\n  next = new greenlight();\n  turnon(ctx) {\n    console.log("红灯亮起");\n    ctx.state = this.next;\n  }\n}\n\nclass signallight {\n  state = new greenlight();\n\n  loop() {\n    this.state.turnon(this);\n  }\n}\n\nconst light = new signallight();\n\nfunction start(immediate) {\n  settimeout(() => {\n    light.loop();\n    start();\n  }, 1000);\n  immediate && light.loop();\n}\n\n\n使用generator：\n\nfunction* func() {\n  while (1) {\n    yield console.log("红灯亮起");\n    yield console.log("绿灯亮起");\n    yield console.log("黄灯闪烁，红灯即将亮起");\n  }\n}\n\nconst light = func();\n\nfunction start(immediate) {\n  settimeout(() => {\n    light.next();\n    start();\n  }, 1000);\n  immediate && light.next();\n}\n\n\n因此，可以利用generator的这个语法在实际开发中代替手写原生的状态模式的代码。',charsets:{cjk:!0}},{title:"策略模式",frontmatter:{},regularPath:"/design-pattern/strategy.html",relativePath:"design-pattern/strategy.md",key:"v-ebee5d56",path:"/design-pattern/strategy.html",headers:[{level:2,title:"策略模式",slug:"策略模式",normalizedTitle:"策略模式",charIndex:2},{level:3,title:"1、基本概念",slug:"_1、基本概念",normalizedTitle:"1、基本概念",charIndex:11},{level:3,title:"2、代码示例",slug:"_2、代码示例",normalizedTitle:"2、代码示例",charIndex:538},{level:3,title:"3、在前端开发中的实践",slug:"_3、在前端开发中的实践",normalizedTitle:"3、在前端开发中的实践",charIndex:2625}],headersStr:"策略模式 1、基本概念 2、代码示例 3、在前端开发中的实践",content:'# 策略模式\n\n\n# 1、基本概念\n\n策略模式：定义了一系列的算法家族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化，不会影响到使用算法的客户。\n\n举个实际的例子，大点儿的公司员工很多，每次到了要发工资的时候，总是会让财务焦头烂额的，但是员工基本上也就几大类，能通过进行抽象得到他们发工资的计算方法。\n\n比如客服，客服的工资跟他的接待客诉的数量有关系；销售，销售的工资跟他卖出的产品有关系；研发，研发就比较简单了，基本上就是死工资。那对于公司的会计来说，在统计员工的工资的时候就可以根据员工的工种选择相应的计薪方式，这样就可以方便的得到结果发薪，如果有新的工种，增加相应的计薪方式即可。\n\n策略模式所封装的算法都是在完成相同的工作，只是实现方式不同，它可以以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合。策略模式的优点是简化了单元测试，每个算法都有自己的类，因此可以单独编写接口测试，比较方便。\n\n\n\n以上是策略模式的UML图，Strategy抽象类（或接口），定义一套标准的范式，业务逻辑根据自身的业务实现这套范式，Context根据外部传入的Strategy进行计算。\n\n另外在实际的开发中，策略模式可能常常会和工厂模式结合使用。\n\n\n# 2、代码示例\n\n我们就拿第一节提到的公司发工资的这个场景举例，用策略模式来解决这个问题。\n\nabstract class SalaryStrategy {\n  abstract calc(): void;\n}\n\nclass CustomerServiceSalaryStrategy extends SalaryStrategy {\n  calc(): void {\n    console.log("客服的工资跟他接待的客诉量有一定的关系，基础工资+绩效奖金");\n  }\n}\n\nclass MarketingSpecialistSalaryStrategy extends SalaryStrategy {\n  calc(): void {\n    console.log(\n      "销售的工资跟他卖出的产品有一定的关系，除此之外，卖出一件东西，公司还会给予他额外的提成，基础工资+绩效奖金+销售提成"\n    );\n  }\n}\n\nclass DeveloperSalaryStrategy extends SalaryStrategy {\n  calc(): void {\n    console.log(\n      "研发人员的工资是固定的工资，如果本月研发绩效不达标，会有扣款，固定工资-本月扣款"\n    );\n  }\n}\n\nclass NormalSalaryStrategy extends SalaryStrategy {\n  calc(): void {\n    console.log("没有额外的要求，正常发薪即可");\n  }\n}\n\n/**\n * 根据员工角色获取计薪方式\n * @param role 员工角色\n * @returns\n */\nfunction getSalaryCalculator(role: string): SalaryStrategy {\n  let stg: CustomerServiceSalaryStrategy;\n  switch (role) {\n    case "客服":\n      stg = new CustomerServiceSalaryStrategy();\n      break;\n    case "销售":\n      stg = new MarketingSpecialistSalaryStrategy();\n      break;\n    case "研发":\n      stg = new DeveloperSalaryStrategy();\n      break;\n    default:\n      stg = new NormalSalaryStrategy();\n      break;\n  }\n  return stg;\n}\n\nclass Employee {\n  role: string;\n\n  constructor(role: string) {\n    this.role = role;\n  }\n}\n\nclass Accountant extends Employee {\n  employeeList: Employee[] = [];\n\n  constructor() {\n    super("财务");\n    this.addEmployee(this);\n  }\n\n  addEmployee(employee: Employee) {\n    this.employeeList.push(employee);\n  }\n\n  distributeSalary() {\n    console.log("~~~~~~~~~~~~~~~~开始发薪~~~~~~~~~~~~~~~");\n    this.employeeList.forEach((em) => {\n      const salaryStrategy = getSalaryCalculator(em.role);\n      salaryStrategy.calc();\n    });\n    console.log(\n      "~~~~~~~~~~~~~~本月工资已全数发放，如有问题请联系公司财务~~~~~~~~~~~"\n    );\n  }\n}\n\nfunction bootstrap() {\n  const xiaoming = new Employee("研发");\n  const xiaohong = new Employee("销售");\n  const xiaogang = new Employee("客服");\n  const andi = new Accountant();\n\n  andi.addEmployee(xiaogang);\n  andi.addEmployee(xiaohong);\n  andi.addEmployee(xiaoming);\n\n  andi.distributeSalary();\n}\n\n\n\n# 3、在前端开发中的实践\n\n策略模式在前端开发中是非常常见的设计模式之一，也是比较容易掌握的设计模式之一。\n\n本文就拿vue-router的源码举例。\n\nvue-router支持两种模式：哈希模式和history模式\n\n在vue-router/src/index.js中，会根据用户选择的模式匹配相应的路由替换规则。（以版本3.5.4为例）\n\n// 节选\nimport { HashHistory } from "./history/hash";\nimport { HTML5History } from "./history/html5";\nimport { AbstractHistory } from "./history/abstract";\n\nexport default class VueRouter {\n  constructor(options: RouterOptions = {}) {\n    let mode = options.mode || "hash";\n    this.fallback =\n      mode === "history" && !supportsPushState && options.fallback !== false;\n    if (this.fallback) {\n      mode = "hash";\n    }\n    if (!inBrowser) {\n      mode = "abstract";\n    }\n    this.mode = mode;\n\n    switch (mode) {\n      case "history":\n        this.history = new HTML5History(this, options.base);\n        break;\n      case "hash":\n        this.history = new HashHistory(this, options.base, this.fallback);\n        break;\n      case "abstract":\n        this.history = new AbstractHistory(this, options.base);\n        break;\n      default:\n        if (process.env.NODE_ENV !== "production") {\n          assert(false, `invalid mode: ${mode}`);\n        }\n    }\n  }\n}\n\n\n在vue-router/src/history目录下，History类定义了一些基础的约束，面向不同API的实现策略，继承自History。\n\n// 节选自vue-router/src/history/base.js\nexport class History {\n  // implemented by sub-classes\n  +setupListeners: Function;\n}\n// 节选自vue-router/src/history/hash.js\nexport class HashHistory extends History {\n  /**\n   * 哈希模式用hashchange事件进行监听\n   */\n  setupListeners() {\n    const eventType = supportsPushState ? "popstate" : "hashchange";\n    window.addEventListener(eventType, handleRoutingEvent);\n    this.listeners.push(() => {\n      window.removeEventListener(eventType, handleRoutingEvent);\n    });\n  }\n}\n// 节选自vue-router/src/history/history.js\nexport class HTML5History extends History {\n  /**\n   * Html5 History模式用popstate事件进行监听\n   */\n  setupListeners() {\n    window.addEventListener("popstate", handleRoutingEvent);\n    this.listeners.push(() => {\n      window.removeEventListener("popstate", handleRoutingEvent);\n    });\n  }\n}\n',normalizedContent:'# 策略模式\n\n\n# 1、基本概念\n\n策略模式：定义了一系列的算法家族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化，不会影响到使用算法的客户。\n\n举个实际的例子，大点儿的公司员工很多，每次到了要发工资的时候，总是会让财务焦头烂额的，但是员工基本上也就几大类，能通过进行抽象得到他们发工资的计算方法。\n\n比如客服，客服的工资跟他的接待客诉的数量有关系；销售，销售的工资跟他卖出的产品有关系；研发，研发就比较简单了，基本上就是死工资。那对于公司的会计来说，在统计员工的工资的时候就可以根据员工的工种选择相应的计薪方式，这样就可以方便的得到结果发薪，如果有新的工种，增加相应的计薪方式即可。\n\n策略模式所封装的算法都是在完成相同的工作，只是实现方式不同，它可以以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合。策略模式的优点是简化了单元测试，每个算法都有自己的类，因此可以单独编写接口测试，比较方便。\n\n\n\n以上是策略模式的uml图，strategy抽象类（或接口），定义一套标准的范式，业务逻辑根据自身的业务实现这套范式，context根据外部传入的strategy进行计算。\n\n另外在实际的开发中，策略模式可能常常会和工厂模式结合使用。\n\n\n# 2、代码示例\n\n我们就拿第一节提到的公司发工资的这个场景举例，用策略模式来解决这个问题。\n\nabstract class salarystrategy {\n  abstract calc(): void;\n}\n\nclass customerservicesalarystrategy extends salarystrategy {\n  calc(): void {\n    console.log("客服的工资跟他接待的客诉量有一定的关系，基础工资+绩效奖金");\n  }\n}\n\nclass marketingspecialistsalarystrategy extends salarystrategy {\n  calc(): void {\n    console.log(\n      "销售的工资跟他卖出的产品有一定的关系，除此之外，卖出一件东西，公司还会给予他额外的提成，基础工资+绩效奖金+销售提成"\n    );\n  }\n}\n\nclass developersalarystrategy extends salarystrategy {\n  calc(): void {\n    console.log(\n      "研发人员的工资是固定的工资，如果本月研发绩效不达标，会有扣款，固定工资-本月扣款"\n    );\n  }\n}\n\nclass normalsalarystrategy extends salarystrategy {\n  calc(): void {\n    console.log("没有额外的要求，正常发薪即可");\n  }\n}\n\n/**\n * 根据员工角色获取计薪方式\n * @param role 员工角色\n * @returns\n */\nfunction getsalarycalculator(role: string): salarystrategy {\n  let stg: customerservicesalarystrategy;\n  switch (role) {\n    case "客服":\n      stg = new customerservicesalarystrategy();\n      break;\n    case "销售":\n      stg = new marketingspecialistsalarystrategy();\n      break;\n    case "研发":\n      stg = new developersalarystrategy();\n      break;\n    default:\n      stg = new normalsalarystrategy();\n      break;\n  }\n  return stg;\n}\n\nclass employee {\n  role: string;\n\n  constructor(role: string) {\n    this.role = role;\n  }\n}\n\nclass accountant extends employee {\n  employeelist: employee[] = [];\n\n  constructor() {\n    super("财务");\n    this.addemployee(this);\n  }\n\n  addemployee(employee: employee) {\n    this.employeelist.push(employee);\n  }\n\n  distributesalary() {\n    console.log("~~~~~~~~~~~~~~~~开始发薪~~~~~~~~~~~~~~~");\n    this.employeelist.foreach((em) => {\n      const salarystrategy = getsalarycalculator(em.role);\n      salarystrategy.calc();\n    });\n    console.log(\n      "~~~~~~~~~~~~~~本月工资已全数发放，如有问题请联系公司财务~~~~~~~~~~~"\n    );\n  }\n}\n\nfunction bootstrap() {\n  const xiaoming = new employee("研发");\n  const xiaohong = new employee("销售");\n  const xiaogang = new employee("客服");\n  const andi = new accountant();\n\n  andi.addemployee(xiaogang);\n  andi.addemployee(xiaohong);\n  andi.addemployee(xiaoming);\n\n  andi.distributesalary();\n}\n\n\n\n# 3、在前端开发中的实践\n\n策略模式在前端开发中是非常常见的设计模式之一，也是比较容易掌握的设计模式之一。\n\n本文就拿vue-router的源码举例。\n\nvue-router支持两种模式：哈希模式和history模式\n\n在vue-router/src/index.js中，会根据用户选择的模式匹配相应的路由替换规则。（以版本3.5.4为例）\n\n// 节选\nimport { hashhistory } from "./history/hash";\nimport { html5history } from "./history/html5";\nimport { abstracthistory } from "./history/abstract";\n\nexport default class vuerouter {\n  constructor(options: routeroptions = {}) {\n    let mode = options.mode || "hash";\n    this.fallback =\n      mode === "history" && !supportspushstate && options.fallback !== false;\n    if (this.fallback) {\n      mode = "hash";\n    }\n    if (!inbrowser) {\n      mode = "abstract";\n    }\n    this.mode = mode;\n\n    switch (mode) {\n      case "history":\n        this.history = new html5history(this, options.base);\n        break;\n      case "hash":\n        this.history = new hashhistory(this, options.base, this.fallback);\n        break;\n      case "abstract":\n        this.history = new abstracthistory(this, options.base);\n        break;\n      default:\n        if (process.env.node_env !== "production") {\n          assert(false, `invalid mode: ${mode}`);\n        }\n    }\n  }\n}\n\n\n在vue-router/src/history目录下，history类定义了一些基础的约束，面向不同api的实现策略，继承自history。\n\n// 节选自vue-router/src/history/base.js\nexport class history {\n  // implemented by sub-classes\n  +setuplisteners: function;\n}\n// 节选自vue-router/src/history/hash.js\nexport class hashhistory extends history {\n  /**\n   * 哈希模式用hashchange事件进行监听\n   */\n  setuplisteners() {\n    const eventtype = supportspushstate ? "popstate" : "hashchange";\n    window.addeventlistener(eventtype, handleroutingevent);\n    this.listeners.push(() => {\n      window.removeeventlistener(eventtype, handleroutingevent);\n    });\n  }\n}\n// 节选自vue-router/src/history/history.js\nexport class html5history extends history {\n  /**\n   * html5 history模式用popstate事件进行监听\n   */\n  setuplisteners() {\n    window.addeventlistener("popstate", handleroutingevent);\n    this.listeners.push(() => {\n      window.removeeventlistener("popstate", handleroutingevent);\n    });\n  }\n}\n',charsets:{cjk:!0}},{title:"模板方法模式",frontmatter:{},regularPath:"/design-pattern/template-method.html",relativePath:"design-pattern/template-method.md",key:"v-475cd856",path:"/design-pattern/template-method.html",headers:[{level:2,title:"模板方法模式",slug:"模板方法模式",normalizedTitle:"模板方法模式",charIndex:2},{level:3,title:"1、基本概念",slug:"_1、基本概念",normalizedTitle:"1、基本概念",charIndex:13},{level:3,title:"2、代码范式",slug:"_2、代码范式",normalizedTitle:"2、代码范式",charIndex:544},{level:3,title:"3、在前端开发中的实践",slug:"_3、在前端开发中的实践",normalizedTitle:"3、在前端开发中的实践",charIndex:2893}],headersStr:"模板方法模式 1、基本概念 2、代码范式 3、在前端开发中的实践",content:'# 模板方法模式\n\n\n# 1、基本概念\n\n模板方法模式是一个十分简单且容易掌握的设计模式，如果你在之前没有看过设计模式相关的知识点，但是在大学的课程中，面向对象编程的基本功非常扎实，你可能不由自主的就掌握了这个设计模式。\n\n模板方法模式是一个基于继承的设计模式，它的核心思路很简单，将一些抽象化的操作抽离到基类中，将一些不太容易抽象的操作交给子类根据对应的业务实现，利用了多态的特性，从而实现代码复用。\n\n尤其是在前几年React Hook没出现的时候，当时还需要用class编写类组件，使用模板方法模式将一些抽象的渲染内容（或公共的内容）父类渲染，子类继承父类，然后根据对应的业务重写父类的某些方法（又有点儿像Vue的插槽），开发效率相当高。\n\n虽然模板方法模式是基于继承的设计模式，在ES6的class出现之前，仍然在实际开发中常用，而且，模板方法模式往往可以和很多设计模式结合使用（如：工厂模式，命令模式，状态模式，职责链模式，策略模式等）。\n\n现如今的JavaScript已经拥抱了函数式编程，模板方法模式在使用框架编写业务代码时可能应用的场景会相对较少一些了，但是如果你开发一些库的话，这个设计模式是一个你不得不掌握的设计模式。\n\n模板方法模式的UML结构图如下：\n\n\n\n\n# 2、代码范式\n\n以下是基于一个股票交易场景给出的一个实现方式，由于科创板和创业板有资产的限制，因此，将验证方法抽离到子类\n\nabstract class ContractTransaction {\n  validVolume(num: number) {\n    return num % 100 === 0;\n  }\n\n  validTransactionTime(time: Date) {\n    const am = [9.5 * 3600 * 1000, 11.5 * 3600 * 1000];\n    const pm = [13 * 3600 * 1000, 15 * 3600 * 1000];\n    const tick =\n      (time.getHours() * 3600 + time.getMinutes() * 60 + time.getSeconds()) *\n        1000 +\n      time.getMilliseconds();\n    return (tick >= am[0] && tick <= am[1]) || (tick >= pm[0] && tick <= pm[1]);\n  }\n\n  abstract validContractRestrict(stockCode: string, assets: number): boolean;\n\n  buy(stockCode: string, volume: number, assets: number): void {\n    if (!this.validTransactionTime(new Date("2023/04/07 10:00:00"))) {\n      console.log("非交易时间，无法交易");\n      return;\n    }\n    if (!this.validVolume(volume)) {\n      console.log("买卖数量必须是100的整数");\n      return;\n    }\n    if (!this.validContractRestrict(stockCode, assets)) {\n      console.log("因您的资产限制，无法买卖当前合约");\n      return;\n    }\n    console.log(`您已成功买入合约：${stockCode}，数量：${volume}`);\n  }\n}\n\nclass ShangHaiContractTransaction extends ContractTransaction {\n  validContractRestrict(stockCode: string, assets: number): boolean {\n    if (!/^(SHSE)?688/i.test(stockCode)) {\n      return true;\n    }\n    return /^(SHSE)?688/i.test(stockCode) && assets >= 500000;\n  }\n}\n\nclass ShenzhenContractTansaction extends ContractTransaction {\n  validContractRestrict(stockCode: string, assets: number): boolean {\n    if (!/^(SZSE)?30/i.test(stockCode)) {\n      return true;\n    }\n    return /^(SZSE)?30/i.test(stockCode) && assets >= 100000;\n  }\n}\n\nfunction getTransactionStrategy(stockCode): ContractTransaction {\n  let stg: ContractTransaction;\n  if (/^(SHSE)?6/i.test(stockCode)) {\n    stg = new ShangHaiContractTransaction();\n  } else {\n    stg = new ShenzhenContractTansaction();\n  }\n  return stg;\n}\n\n(function bootstrap() {\n  const stocks = ["6000036", "688688", "002230", "300059"];\n  stocks.forEach((code) => {\n    const stg = getTransactionStrategy(code);\n    stg.buy(code, 100 * Math.floor(Math.random() * 10), 30000);\n  });\n  // 您已成功买入合约：6000036，数量：200\n  // 因您的资产限制，无法买卖当前合约\n  // 您已成功买入合约：002230，数量：800\n  // 因您的资产限制，无法买卖当前合约\n})();\n\n\n对于JS中，如果需要抽象类，可以使用如下形式：\n\nclass SomeClass {\n  someMethod() {\n    throw new Error("this method must be implemented by sub-class");\n  }\n}\n\n\n\n# 3、在前端开发中的实践\n\n在前端开发中，模板方法模式应用场景太多了，凡是在业务中有某些业务具有一定的通用性，某些场景下又具有一些特殊性，这类场景都可以用模板方法模式。\n\n因此，就给大家看一下开源库中的模板方法模式的应用吧。\n\n# 在vue-router中的应用\n\n它可以根据用户选择的模式决定应用特定模式的实现。\n\n在vue-router/src/index.js中，会根据用户选择的模式匹配相应的路由替换规则。（以版本3.5.4为例）\n\n// 节选\nimport { HashHistory } from "./history/hash";\nimport { HTML5History } from "./history/html5";\nimport { AbstractHistory } from "./history/abstract";\n\nexport default class VueRouter {\n  constructor(options: RouterOptions = {}) {\n    let mode = options.mode || "hash";\n    this.fallback =\n      mode === "history" && !supportsPushState && options.fallback !== false;\n    if (this.fallback) {\n      mode = "hash";\n    }\n    if (!inBrowser) {\n      mode = "abstract";\n    }\n    this.mode = mode;\n\n    switch (mode) {\n      case "history":\n        this.history = new HTML5History(this, options.base);\n        break;\n      case "hash":\n        this.history = new HashHistory(this, options.base, this.fallback);\n        break;\n      case "abstract":\n        this.history = new AbstractHistory(this, options.base);\n        break;\n      default:\n        if (process.env.NODE_ENV !== "production") {\n          assert(false, `invalid mode: ${mode}`);\n        }\n    }\n  }\n}\n\n\n在vue-router/src/history目录下，History类定义了一些基础的约束，面向不同API的实现策略，继承自History。\n\n// 节选自vue-router/src/history/base.js\nexport class History {\n  // 已省略无关代码\n  // implemented by sub-classes\n  +setupListeners: Function;\n}\n\n// 节选自vue-router/src/history/hash.js\nexport class HashHistory extends History {\n  // 已省略无关代码\n  /**\n   * 哈希模式用hashchange事件进行监听\n   */\n  setupListeners() {\n    const eventType = supportsPushState ? "popstate" : "hashchange";\n    window.addEventListener(eventType, handleRoutingEvent);\n    this.listeners.push(() => {\n      window.removeEventListener(eventType, handleRoutingEvent);\n    });\n  }\n}\n\n// 节选自vue-router/src/history/history.js\nexport class HTML5History extends History {\n  // 已省略无关代码\n  /**\n   * Html5 History模式用popstate事件进行监听\n   */\n  setupListeners() {\n    window.addEventListener("popstate", handleRoutingEvent);\n    this.listeners.push(() => {\n      window.removeEventListener("popstate", handleRoutingEvent);\n    });\n  }\n}\n\n\n# 在typeorm中的应用\n\n在typeorm中（nodejs生态中大名鼎鼎的一个ORM库），它可以根据用户连接数据库，决定生成对应数据库的SQL方言（这个词能够确切的阐述不同的数据库SQL语句的差异，所以就像我们普通话和四川话、湖南话的差异一样，所以叫做方言特别的贴切）：\n\nBaseQueryRunner\n\nexport abstract class BaseQueryRunner {\n  // 省略代码，有兴趣的读者可以直接在github查看\n}\n\n\nMySQLQueryRunner\n\nexport class MysqlQueryRunner extends BaseQueryRunner implements QueryRunner {\n  // 省略无关代码，有兴趣的读者可以直接在github查看\n}\n\n\nSqlServerRunner\n\nexport class SqlServerQueryRunner extends BaseQueryRunner implements QueryRunner {\n  // 省略代码，有兴趣的读者可以直接在github查看\n}\n\n\n其余数据库的 runner，有兴趣的同学可以自行查看。\n\n以下是两个Driver的示例：\n\nMysqlDriver\n\n/**\n * Organizes communication with MySQL DBMS.\n */\nexport class MysqlDriver implements Driver {\n  // 省略其他无关方法\n  /**\n   * Creates a query runner used to execute database queries.\n   */\n  createQueryRunner(mode: ReplicationMode) {\n    return new MysqlQueryRunner(this, mode);\n  }\n}\n\n\nSqlServerDriver\n\n/**\n * Organizes communication with SQL Server DBMS.\n */\nexport class SqlServerDriver implements Driver {\n  // 省略其他无关方法\n  /**\n   * Creates a query runner used to execute database queries.\n   */\n  createQueryRunner(mode: ReplicationMode) {\n    return new SqlServerQueryRunner(this, mode);\n  }\n}\n\n\n然后在调用侧，根据数据库的环境，选择对应的Runner就可以了（typeorm是选择跟对应的Driver绑定，这个无关紧要，因为最终还是会根据数据库类型选择对应的Driver），而且日后将来需要新增新的数据库支持，再编写一套对应的QueryRunner实现即可，这样的设计是符合开闭原则的。\n\n以下是typeorm的Driver工厂：\n\n/**\n * Helps to create drivers.\n */\nexport class DriverFactory {\n  /**\n   * Creates a new driver depend on a given connection\'s driver type.\n   */\n  create(connection: DataSource): Driver {\n    const { type } = connection.options;\n    switch (type) {\n      case "mysql":\n        return new MysqlDriver(connection);\n      case "postgres":\n        return new PostgresDriver(connection);\n      case "cockroachdb":\n        return new CockroachDriver(connection);\n      case "sap":\n        return new SapDriver(connection);\n      case "mariadb":\n        return new MysqlDriver(connection);\n      case "sqlite":\n        return new SqliteDriver(connection);\n      case "better-sqlite3":\n        return new BetterSqlite3Driver(connection);\n      case "cordova":\n        return new CordovaDriver(connection);\n      case "nativescript":\n        return new NativescriptDriver(connection);\n      case "react-native":\n        return new ReactNativeDriver(connection);\n      case "sqljs":\n        return new SqljsDriver(connection);\n      case "oracle":\n        return new OracleDriver(connection);\n      case "mssql":\n        return new SqlServerDriver(connection);\n      case "mongodb":\n        return new MongoDriver(connection);\n      case "expo":\n        return new ExpoDriver(connection);\n      case "aurora-mysql":\n        return new AuroraMysqlDriver(connection);\n      case "aurora-postgres":\n        return new AuroraPostgresDriver(connection);\n      case "capacitor":\n        return new CapacitorDriver(connection);\n      case "spanner":\n        return new SpannerDriver(connection);\n      default:\n        throw new MissingDriverError(type, [\n          "aurora-mysql",\n          "aurora-postgres",\n          "better-sqlite3",\n          "capacitor",\n          "cockroachdb",\n          "cordova",\n          "expo",\n          "mariadb",\n          "mongodb",\n          "mssql",\n          "mysql",\n          "nativescript",\n          "oracle",\n          "postgres",\n          "react-native",\n          "sap",\n          "sqlite",\n          "sqljs",\n          "spanner",\n        ]);\n    }\n  }\n}\n',normalizedContent:'# 模板方法模式\n\n\n# 1、基本概念\n\n模板方法模式是一个十分简单且容易掌握的设计模式，如果你在之前没有看过设计模式相关的知识点，但是在大学的课程中，面向对象编程的基本功非常扎实，你可能不由自主的就掌握了这个设计模式。\n\n模板方法模式是一个基于继承的设计模式，它的核心思路很简单，将一些抽象化的操作抽离到基类中，将一些不太容易抽象的操作交给子类根据对应的业务实现，利用了多态的特性，从而实现代码复用。\n\n尤其是在前几年react hook没出现的时候，当时还需要用class编写类组件，使用模板方法模式将一些抽象的渲染内容（或公共的内容）父类渲染，子类继承父类，然后根据对应的业务重写父类的某些方法（又有点儿像vue的插槽），开发效率相当高。\n\n虽然模板方法模式是基于继承的设计模式，在es6的class出现之前，仍然在实际开发中常用，而且，模板方法模式往往可以和很多设计模式结合使用（如：工厂模式，命令模式，状态模式，职责链模式，策略模式等）。\n\n现如今的javascript已经拥抱了函数式编程，模板方法模式在使用框架编写业务代码时可能应用的场景会相对较少一些了，但是如果你开发一些库的话，这个设计模式是一个你不得不掌握的设计模式。\n\n模板方法模式的uml结构图如下：\n\n\n\n\n# 2、代码范式\n\n以下是基于一个股票交易场景给出的一个实现方式，由于科创板和创业板有资产的限制，因此，将验证方法抽离到子类\n\nabstract class contracttransaction {\n  validvolume(num: number) {\n    return num % 100 === 0;\n  }\n\n  validtransactiontime(time: date) {\n    const am = [9.5 * 3600 * 1000, 11.5 * 3600 * 1000];\n    const pm = [13 * 3600 * 1000, 15 * 3600 * 1000];\n    const tick =\n      (time.gethours() * 3600 + time.getminutes() * 60 + time.getseconds()) *\n        1000 +\n      time.getmilliseconds();\n    return (tick >= am[0] && tick <= am[1]) || (tick >= pm[0] && tick <= pm[1]);\n  }\n\n  abstract validcontractrestrict(stockcode: string, assets: number): boolean;\n\n  buy(stockcode: string, volume: number, assets: number): void {\n    if (!this.validtransactiontime(new date("2023/04/07 10:00:00"))) {\n      console.log("非交易时间，无法交易");\n      return;\n    }\n    if (!this.validvolume(volume)) {\n      console.log("买卖数量必须是100的整数");\n      return;\n    }\n    if (!this.validcontractrestrict(stockcode, assets)) {\n      console.log("因您的资产限制，无法买卖当前合约");\n      return;\n    }\n    console.log(`您已成功买入合约：${stockcode}，数量：${volume}`);\n  }\n}\n\nclass shanghaicontracttransaction extends contracttransaction {\n  validcontractrestrict(stockcode: string, assets: number): boolean {\n    if (!/^(shse)?688/i.test(stockcode)) {\n      return true;\n    }\n    return /^(shse)?688/i.test(stockcode) && assets >= 500000;\n  }\n}\n\nclass shenzhencontracttansaction extends contracttransaction {\n  validcontractrestrict(stockcode: string, assets: number): boolean {\n    if (!/^(szse)?30/i.test(stockcode)) {\n      return true;\n    }\n    return /^(szse)?30/i.test(stockcode) && assets >= 100000;\n  }\n}\n\nfunction gettransactionstrategy(stockcode): contracttransaction {\n  let stg: contracttransaction;\n  if (/^(shse)?6/i.test(stockcode)) {\n    stg = new shanghaicontracttransaction();\n  } else {\n    stg = new shenzhencontracttansaction();\n  }\n  return stg;\n}\n\n(function bootstrap() {\n  const stocks = ["6000036", "688688", "002230", "300059"];\n  stocks.foreach((code) => {\n    const stg = gettransactionstrategy(code);\n    stg.buy(code, 100 * math.floor(math.random() * 10), 30000);\n  });\n  // 您已成功买入合约：6000036，数量：200\n  // 因您的资产限制，无法买卖当前合约\n  // 您已成功买入合约：002230，数量：800\n  // 因您的资产限制，无法买卖当前合约\n})();\n\n\n对于js中，如果需要抽象类，可以使用如下形式：\n\nclass someclass {\n  somemethod() {\n    throw new error("this method must be implemented by sub-class");\n  }\n}\n\n\n\n# 3、在前端开发中的实践\n\n在前端开发中，模板方法模式应用场景太多了，凡是在业务中有某些业务具有一定的通用性，某些场景下又具有一些特殊性，这类场景都可以用模板方法模式。\n\n因此，就给大家看一下开源库中的模板方法模式的应用吧。\n\n# 在vue-router中的应用\n\n它可以根据用户选择的模式决定应用特定模式的实现。\n\n在vue-router/src/index.js中，会根据用户选择的模式匹配相应的路由替换规则。（以版本3.5.4为例）\n\n// 节选\nimport { hashhistory } from "./history/hash";\nimport { html5history } from "./history/html5";\nimport { abstracthistory } from "./history/abstract";\n\nexport default class vuerouter {\n  constructor(options: routeroptions = {}) {\n    let mode = options.mode || "hash";\n    this.fallback =\n      mode === "history" && !supportspushstate && options.fallback !== false;\n    if (this.fallback) {\n      mode = "hash";\n    }\n    if (!inbrowser) {\n      mode = "abstract";\n    }\n    this.mode = mode;\n\n    switch (mode) {\n      case "history":\n        this.history = new html5history(this, options.base);\n        break;\n      case "hash":\n        this.history = new hashhistory(this, options.base, this.fallback);\n        break;\n      case "abstract":\n        this.history = new abstracthistory(this, options.base);\n        break;\n      default:\n        if (process.env.node_env !== "production") {\n          assert(false, `invalid mode: ${mode}`);\n        }\n    }\n  }\n}\n\n\n在vue-router/src/history目录下，history类定义了一些基础的约束，面向不同api的实现策略，继承自history。\n\n// 节选自vue-router/src/history/base.js\nexport class history {\n  // 已省略无关代码\n  // implemented by sub-classes\n  +setuplisteners: function;\n}\n\n// 节选自vue-router/src/history/hash.js\nexport class hashhistory extends history {\n  // 已省略无关代码\n  /**\n   * 哈希模式用hashchange事件进行监听\n   */\n  setuplisteners() {\n    const eventtype = supportspushstate ? "popstate" : "hashchange";\n    window.addeventlistener(eventtype, handleroutingevent);\n    this.listeners.push(() => {\n      window.removeeventlistener(eventtype, handleroutingevent);\n    });\n  }\n}\n\n// 节选自vue-router/src/history/history.js\nexport class html5history extends history {\n  // 已省略无关代码\n  /**\n   * html5 history模式用popstate事件进行监听\n   */\n  setuplisteners() {\n    window.addeventlistener("popstate", handleroutingevent);\n    this.listeners.push(() => {\n      window.removeeventlistener("popstate", handleroutingevent);\n    });\n  }\n}\n\n\n# 在typeorm中的应用\n\n在typeorm中（nodejs生态中大名鼎鼎的一个orm库），它可以根据用户连接数据库，决定生成对应数据库的sql方言（这个词能够确切的阐述不同的数据库sql语句的差异，所以就像我们普通话和四川话、湖南话的差异一样，所以叫做方言特别的贴切）：\n\nbasequeryrunner\n\nexport abstract class basequeryrunner {\n  // 省略代码，有兴趣的读者可以直接在github查看\n}\n\n\nmysqlqueryrunner\n\nexport class mysqlqueryrunner extends basequeryrunner implements queryrunner {\n  // 省略无关代码，有兴趣的读者可以直接在github查看\n}\n\n\nsqlserverrunner\n\nexport class sqlserverqueryrunner extends basequeryrunner implements queryrunner {\n  // 省略代码，有兴趣的读者可以直接在github查看\n}\n\n\n其余数据库的 runner，有兴趣的同学可以自行查看。\n\n以下是两个driver的示例：\n\nmysqldriver\n\n/**\n * organizes communication with mysql dbms.\n */\nexport class mysqldriver implements driver {\n  // 省略其他无关方法\n  /**\n   * creates a query runner used to execute database queries.\n   */\n  createqueryrunner(mode: replicationmode) {\n    return new mysqlqueryrunner(this, mode);\n  }\n}\n\n\nsqlserverdriver\n\n/**\n * organizes communication with sql server dbms.\n */\nexport class sqlserverdriver implements driver {\n  // 省略其他无关方法\n  /**\n   * creates a query runner used to execute database queries.\n   */\n  createqueryrunner(mode: replicationmode) {\n    return new sqlserverqueryrunner(this, mode);\n  }\n}\n\n\n然后在调用侧，根据数据库的环境，选择对应的runner就可以了（typeorm是选择跟对应的driver绑定，这个无关紧要，因为最终还是会根据数据库类型选择对应的driver），而且日后将来需要新增新的数据库支持，再编写一套对应的queryrunner实现即可，这样的设计是符合开闭原则的。\n\n以下是typeorm的driver工厂：\n\n/**\n * helps to create drivers.\n */\nexport class driverfactory {\n  /**\n   * creates a new driver depend on a given connection\'s driver type.\n   */\n  create(connection: datasource): driver {\n    const { type } = connection.options;\n    switch (type) {\n      case "mysql":\n        return new mysqldriver(connection);\n      case "postgres":\n        return new postgresdriver(connection);\n      case "cockroachdb":\n        return new cockroachdriver(connection);\n      case "sap":\n        return new sapdriver(connection);\n      case "mariadb":\n        return new mysqldriver(connection);\n      case "sqlite":\n        return new sqlitedriver(connection);\n      case "better-sqlite3":\n        return new bettersqlite3driver(connection);\n      case "cordova":\n        return new cordovadriver(connection);\n      case "nativescript":\n        return new nativescriptdriver(connection);\n      case "react-native":\n        return new reactnativedriver(connection);\n      case "sqljs":\n        return new sqljsdriver(connection);\n      case "oracle":\n        return new oracledriver(connection);\n      case "mssql":\n        return new sqlserverdriver(connection);\n      case "mongodb":\n        return new mongodriver(connection);\n      case "expo":\n        return new expodriver(connection);\n      case "aurora-mysql":\n        return new auroramysqldriver(connection);\n      case "aurora-postgres":\n        return new aurorapostgresdriver(connection);\n      case "capacitor":\n        return new capacitordriver(connection);\n      case "spanner":\n        return new spannerdriver(connection);\n      default:\n        throw new missingdrivererror(type, [\n          "aurora-mysql",\n          "aurora-postgres",\n          "better-sqlite3",\n          "capacitor",\n          "cockroachdb",\n          "cordova",\n          "expo",\n          "mariadb",\n          "mongodb",\n          "mssql",\n          "mysql",\n          "nativescript",\n          "oracle",\n          "postgres",\n          "react-native",\n          "sap",\n          "sqlite",\n          "sqljs",\n          "spanner",\n        ]);\n    }\n  }\n}\n',charsets:{cjk:!0}},{title:"观察者模式",frontmatter:{},regularPath:"/design-pattern/watcher.html",relativePath:"design-pattern/watcher.md",key:"v-2264f0f6",path:"/design-pattern/watcher.html",headers:[{level:2,title:"观察者模式",slug:"观察者模式",normalizedTitle:"观察者模式",charIndex:2},{level:3,title:"1、基本概念",slug:"_1、基本概念",normalizedTitle:"1、基本概念",charIndex:12},{level:3,title:"2、代码示例",slug:"_2、代码示例",normalizedTitle:"2、代码示例",charIndex:499},{level:3,title:"3、前端开发中的实践",slug:"_3、前端开发中的实践",normalizedTitle:"3、前端开发中的实践",charIndex:4460}],headersStr:"观察者模式 1、基本概念 2、代码示例 3、前端开发中的实践",content:'# 观察者模式\n\n\n# 1、基本概念\n\n观察者模式（又叫发布-订阅模式）定义了一种一对多的依赖关系，让多个观察对象同时监听某一个主题对象，这个主题对象的状态发生变化时，会通知所有观察者对象，是他们能够主动更新自己。\n\n上述是比较官方的话术解释，举个实际生活中的例子：\n\n比如在实际开发中，前端开发的工作需要依赖其他同事，在其他同事完成工作这个期间，我们是无法进行开发的，但是我们又想在这个期间做一些准备工作，但是又不想一会儿又去打扰同事问：好了没有呀？此刻我们就会跟同事交代，你如果开发完成了的话，给我说一下吧。然后同事就会给你说，知道了，我的工作做完我就告诉你，你现在就放心的去干别的吧~。\n\n这个过程中，给同事交代他完成之后要通知我们，这其实就是订阅，当同事的工作开发完成之后，他就会告诉我们他的工作已经完成了，这其实就是发布。\n\n观察者模式的UML图如下：\n\n\n\n订阅者需要持有观察者，并且把自己加到（也支持移除）它订阅者中，正是因为这样，观察者模式有一个致命的缺点就是如果订阅者还没有持有观察者，那么观察者就会错过订阅者之前的通知，所以，在有些场景下就对业务代码的执行顺序由要求。\n\n\n# 2、代码示例\n\nabstract class Observer {\n  abstract update(): void;\n}\n\nabstract class Subject {\n  private observers: Observer[] = [];\n\n  attach(observer: Observer) {\n    this.observers.push(observer);\n  }\n\n  detach(observer: Observer) {\n    const idx = this.observers.findIndex((ob) => ob === observer);\n    idx >= 0 && this.observers.splice(idx, 1);\n  }\n\n  notify() {\n    this.observers.forEach((ob) => {\n      ob.update();\n    });\n  }\n}\n\nclass ConcreteObserver extends Observer {\n  name: string;\n\n  observeState: string;\n\n  subject: ConcreteSubject;\n\n  setSubject(subject: ConcreteSubject) {\n    this.subject = subject;\n  }\n\n  update(): void {\n    this.observeState = this.subject.subjectState;\n    console.log(`观察者${name}的新状态是${this.observeState}`);\n  }\n}\n\nclass ConcreteSubject extends Subject {\n  private _subjectState: string;\n\n  get subjectState() {\n    return this._subjectState;\n  }\n\n  set subjectState(val: string) {\n    this._subjectState = val;\n  }\n}\n\nconst sub = new ConcreteSubject();\nconst obTom = new ConcreteObserver();\nconst obJohn = new ConcreteObserver();\nobTom.setSubject(sub);\nobJohn.setSubject(sub);\nsub.attach(obTom);\nsub.attach(obJohn);\nsub.subjectState = "happy";\nsub.notify();\nsub.subjectState = "blue";\nsub.notify();\n\n\n以上是基于UML图给出的一种比较标准的范式。\n\n但是上述代码还存在一些考量\n\n * 第一个考量是，有些时候观察者不需要关心订阅者的状态，观察者就可以不必在内部持有订阅者。\n * 第二个考量是，没有频道隔离，不是所有人每次都想接收到相应的通知。比如我是一个房产中介，我手底下有很多客户都订阅了我所管辖的区域的小区房价信息，但是如果别墅的价格变化了的话，我没有必要通知给普通的人（别墅降价对于他来说就是叨扰了，反正他也买不起），我只需要通知高端人群，毕竟他们才有可能消费的起。\n\n对于第一个考量，稍稍的调整一下上述代码就可以了。\n\nabstract class Observer {\n  abstract update(): void;\n}\n\nabstract class Subject {\n  private observers: Observer[] = [];\n\n  attach(observer: Observer) {\n    this.observers.push(observer);\n  }\n\n  detach(observer: Observer) {\n    const idx = this.observers.findIndex((ob) => ob === observer);\n    idx >= 0 && this.observers.splice(idx, 1);\n  }\n\n  notify() {\n    this.observers.forEach((ob) => {\n      ob.update();\n    });\n  }\n}\n\nclass ConcreteObserver extends Observer {\n  name: string;\n\n  observeState: string;\n\n  /*\n   移除了观察者内部持有的订阅者\n   */\n\n  update(): void {\n    console.log("您有新的订单，请及时处理");\n  }\n}\n\nclass ConcreteSubject extends Subject {\n  private _subjectState: string;\n\n  get subjectState() {\n    return this._subjectState;\n  }\n\n  set subjectState(val: string) {\n    this._subjectState = val;\n  }\n}\n\nconst sub = new ConcreteSubject();\nconst obTom = new ConcreteObserver();\nconst obJohn = new ConcreteObserver();\nsub.attach(obTom);\nsub.attach(obJohn);\nsub.notify();\n\n\n如何引入频道呢，可以继续在上述代码进行修改。\n\nabstract class Observer {\n  name: string;\n  abstract update(msg: string): void;\n}\n\nabstract class Subject {\n  private observers: Map<string, Set<Observer>> = new Map();\n\n  attach(channel: string, observer: Observer) {\n    // 在订阅的时候增加频道\n    let obs = this.observers.get(channel);\n    if (!obs) {\n      obs = new Set();\n    }\n    obs.add(observer);\n    this.observers.set(channel, obs);\n  }\n\n  detach(channel: string, observer: Observer) {\n    let obs = this.observers.get(channel);\n    if (!obs) {\n      return;\n    }\n    obs.delete(observer);\n  }\n\n  notify(channel: string, msg: string) {\n    // 只对订阅了这个频道的人进行通知\n    const obSet = this.observers.get(channel);\n    if (obSet) {\n      obSet.forEach((ob) => {\n        ob.update(msg);\n      });\n    }\n  }\n}\n\nclass ConcreteObserver extends Observer {\n  name: string;\n\n  observeState: string;\n\n  update(msg: string): void {\n    console.log(msg, this.name);\n  }\n}\n\nclass ConcreteSubject extends Subject {\n  private _subjectState: string;\n\n  get subjectState() {\n    return this._subjectState;\n  }\n\n  set subjectState(val: string) {\n    this._subjectState = val;\n  }\n}\n\nconst sub = new ConcreteSubject();\nconst obTom = new ConcreteObserver();\nobTom.name = "tom";\nconst obJohn = new ConcreteObserver();\nobJohn.name = "john";\nsub.attach("villa", obTom);\nsub.attach("department", obJohn);\nsub.notify("villa", "别墅降价了");\nsub.notify("villa", "别墅又降价了");\nsub.notify("department", "公寓涨价了，再不买，买不到了");\n\n\n所以，你必须根据实际的业务需要采取相应的设计才行。\n\n\n# 3、前端开发中的实践\n\n对于观察者模式可以说没有一个前端不熟悉它的身影了，因为Vue的双向绑定正是应用了这个设计模式，所以大家迫于面试就会去了解它。\n\n除此之外，还有别的应用，比如EventEmitter，可以用它进行远距离通信（如Vue的事件管道，可以实现任何两个组件之间的通信），理解了观察者模式的设计思想，其实这个EventEmitter实现起来也就相当容易了，以下是我实现的一个EventEmitter。\n\nclass EventEmitter {\n  private _map: Map<string, ((...args: any[]) => void)[]> = new Map();\n\n  /**\n   * 触发一个事件\n   */\n  $emit(channel: string, ...args: any[]) {\n    const eventSets = this._map.get(channel);\n    if (!Array.isArray(eventSets)) {\n      return;\n    }\n    eventSets.forEach((f) => {\n      f.apply(this, args);\n    });\n  }\n\n  /**\n   * 单次监听事件\n   * @param {String} channel 监听事件的频道\n   * @param {Function} handler 监听事件的处理器\n   */\n  $once(channel: string, handler: (...args: any[]) => void) {\n    this.$on(channel, handler, true);\n  }\n\n  /**\n   * 监听事件\n   * @param {String} channel 监听事件的频道\n   * @param {Function} handler 监听事件的处理器\n   * @param {boolean} once 是否仅监听一次\n   */\n  $on(channel: string, handler: (...args: any[]) => void, once?: boolean) {\n    let eventSets = this._map.get(channel);\n    if (!Array.isArray(eventSets)) {\n      eventSets = [];\n    }\n    if (!once) {\n      eventSets.push(handler);\n    } else {\n      const wrapperFunc = function (...args: any[]) {\n        handler.apply(this, args);\n        this.$off(channel, wrapperFunc);\n      };\n      eventSets.push(wrapperFunc);\n    }\n    this._map.set(channel, eventSets);\n  }\n\n  /**\n   * 移除事件监听\n   * @param {String} channel 移除监听事件的频道\n   * @param {Function} handler 移除监听事件的处理器\n   */\n  $off(channel: string, handler: (...args: any[]) => void) {\n    const eventSets = this._map.get(channel);\n    if (!Array.isArray(eventSets)) {\n      console.warn("移除的事件频道不存在");\n      return;\n    }\n    // 如果不传递handler则移除该管道的所有监听\n    if (typeof handler !== "function") {\n      this._map.delete(channel);\n    } else {\n      // 否则只删除一个事件监听器\n      const delIdx = eventSets.findIndex((f) => f === handler);\n      if (delIdx < 0) {\n        console.warn("当前尚未设置此handler的监听");\n        return;\n      } else {\n        eventSets.splice(delIdx, 1);\n        this._map.set(channel, eventSets);\n      }\n    }\n  }\n}\n\n\n另外，在有些场景，观察者模式可以用来控制异步操作，它和Promise结合起来能够达到一个化腐朽为神奇的效果。\n\n在以前的团队使用的Ajax请求库是自己在HTML5提供的fetch API的一层封装（后文简称sdk），其中包裹了许多业务参数，直接调用这个sdk可以省时省力避免因其他因素而产生不确定的bug。但是sdk有个很不方便的特点就是只能当它调用了业务初始化接口获得响应内容结果之后才能正常工作。假设我们在页面中有个接口必须要等到sdk初始化执行，sdk初始化接口一定可以请求成功。\n\n以下是利用观察者模式在SDK上的改造：\n\nclass Request {\n  request = null;\n  constructor() {\n    this.timeout = 3000;\n    this.requestQueues = [];\n  }\n  initialize() {\n    this.request = axios.create({\n      baseURL: "/",\n      timeout: this.timeout,\n    });\n    console.log("this request lib has been initialized!");\n    // timeout error\n    while (this.requestQueues.length > 0) {\n      let execute = this.requestQueues.pop();\n      let call = execute.dowork;\n      // 如果执行到当前时刻的时候，已经超时，将不在执行了。\n      if (execute.timeout) {\n        return;\n      }\n      try {\n        const result = typeof call === "function" && call();\n        if (result && typeof result.then === "function") {\n          result\n            .then((response) => {\n              execute.trigger("success", response);\n            })\n            .catch((err) => {\n              execute.trigger("error", err);\n            });\n        } else {\n          execute.trigger("success", result);\n        }\n      } catch (exp) {\n        execute.trigger("error", exp);\n      }\n    }\n  }\n\n  post() {\n    var args = arguments;\n\n    if (!this.request) {\n      const callback = {\n        dowork: () => {\n          return this.request.post.apply(this, args);\n        },\n        timeout: false,\n      };\n\n      callback.channels = {};\n\n      callback.on = function (channel, func, once = false) {\n        callback.channels[channel] = { func, once };\n      };\n\n      callback.off = function (channel) {\n        delete callback.channels[channel];\n      };\n\n      callback.once = function (channel, callback) {\n        callback.on(channel, callback, true);\n      };\n\n      callback.trigger = function (channel, args) {\n        var action = callback.channels[channel];\n        if (!action) {\n          console.warn("this channel has been off");\n          return;\n        }\n        const { func, once } = action;\n        if (typeof func === "function") {\n          func(args);\n          once && delete callback.channels[channel];\n        }\n      };\n      // 5S内SDK没有初始化成功，则认为SDK初始化超时\n      setTimeout(() => {\n        callback.off("success");\n        callback.off("error");\n        callback.timeout = true;\n        callback.trigger("timeout");\n        console.log("the request lib initialization timeout");\n      }, 5000);\n\n      this.requestQueues.push(callback);\n\n      return new Promise((resolve, reject) => {\n        callback.on("timeout", function () {\n          resolve({ errno: 1, errmsg: "接口请求超时" });\n        });\n\n        callback.on("success", function (response) {\n          clearInterval(timer);\n          resolve(response);\n        });\n\n        callback.on("error", function (response) {\n          clearInterval(timer);\n          reject(response);\n        });\n      });\n    }\n    return this.request.post.apply(this, arguments);\n  }\n}\n\n\n经过这番改造后，我们就可以无痛执行业务代码了，不需要关心SDK什么时候初始化完成。\n\n实际开发中，这类应用场景还很多，请大家注意体会以灵活运用。',normalizedContent:'# 观察者模式\n\n\n# 1、基本概念\n\n观察者模式（又叫发布-订阅模式）定义了一种一对多的依赖关系，让多个观察对象同时监听某一个主题对象，这个主题对象的状态发生变化时，会通知所有观察者对象，是他们能够主动更新自己。\n\n上述是比较官方的话术解释，举个实际生活中的例子：\n\n比如在实际开发中，前端开发的工作需要依赖其他同事，在其他同事完成工作这个期间，我们是无法进行开发的，但是我们又想在这个期间做一些准备工作，但是又不想一会儿又去打扰同事问：好了没有呀？此刻我们就会跟同事交代，你如果开发完成了的话，给我说一下吧。然后同事就会给你说，知道了，我的工作做完我就告诉你，你现在就放心的去干别的吧~。\n\n这个过程中，给同事交代他完成之后要通知我们，这其实就是订阅，当同事的工作开发完成之后，他就会告诉我们他的工作已经完成了，这其实就是发布。\n\n观察者模式的uml图如下：\n\n\n\n订阅者需要持有观察者，并且把自己加到（也支持移除）它订阅者中，正是因为这样，观察者模式有一个致命的缺点就是如果订阅者还没有持有观察者，那么观察者就会错过订阅者之前的通知，所以，在有些场景下就对业务代码的执行顺序由要求。\n\n\n# 2、代码示例\n\nabstract class observer {\n  abstract update(): void;\n}\n\nabstract class subject {\n  private observers: observer[] = [];\n\n  attach(observer: observer) {\n    this.observers.push(observer);\n  }\n\n  detach(observer: observer) {\n    const idx = this.observers.findindex((ob) => ob === observer);\n    idx >= 0 && this.observers.splice(idx, 1);\n  }\n\n  notify() {\n    this.observers.foreach((ob) => {\n      ob.update();\n    });\n  }\n}\n\nclass concreteobserver extends observer {\n  name: string;\n\n  observestate: string;\n\n  subject: concretesubject;\n\n  setsubject(subject: concretesubject) {\n    this.subject = subject;\n  }\n\n  update(): void {\n    this.observestate = this.subject.subjectstate;\n    console.log(`观察者${name}的新状态是${this.observestate}`);\n  }\n}\n\nclass concretesubject extends subject {\n  private _subjectstate: string;\n\n  get subjectstate() {\n    return this._subjectstate;\n  }\n\n  set subjectstate(val: string) {\n    this._subjectstate = val;\n  }\n}\n\nconst sub = new concretesubject();\nconst obtom = new concreteobserver();\nconst objohn = new concreteobserver();\nobtom.setsubject(sub);\nobjohn.setsubject(sub);\nsub.attach(obtom);\nsub.attach(objohn);\nsub.subjectstate = "happy";\nsub.notify();\nsub.subjectstate = "blue";\nsub.notify();\n\n\n以上是基于uml图给出的一种比较标准的范式。\n\n但是上述代码还存在一些考量\n\n * 第一个考量是，有些时候观察者不需要关心订阅者的状态，观察者就可以不必在内部持有订阅者。\n * 第二个考量是，没有频道隔离，不是所有人每次都想接收到相应的通知。比如我是一个房产中介，我手底下有很多客户都订阅了我所管辖的区域的小区房价信息，但是如果别墅的价格变化了的话，我没有必要通知给普通的人（别墅降价对于他来说就是叨扰了，反正他也买不起），我只需要通知高端人群，毕竟他们才有可能消费的起。\n\n对于第一个考量，稍稍的调整一下上述代码就可以了。\n\nabstract class observer {\n  abstract update(): void;\n}\n\nabstract class subject {\n  private observers: observer[] = [];\n\n  attach(observer: observer) {\n    this.observers.push(observer);\n  }\n\n  detach(observer: observer) {\n    const idx = this.observers.findindex((ob) => ob === observer);\n    idx >= 0 && this.observers.splice(idx, 1);\n  }\n\n  notify() {\n    this.observers.foreach((ob) => {\n      ob.update();\n    });\n  }\n}\n\nclass concreteobserver extends observer {\n  name: string;\n\n  observestate: string;\n\n  /*\n   移除了观察者内部持有的订阅者\n   */\n\n  update(): void {\n    console.log("您有新的订单，请及时处理");\n  }\n}\n\nclass concretesubject extends subject {\n  private _subjectstate: string;\n\n  get subjectstate() {\n    return this._subjectstate;\n  }\n\n  set subjectstate(val: string) {\n    this._subjectstate = val;\n  }\n}\n\nconst sub = new concretesubject();\nconst obtom = new concreteobserver();\nconst objohn = new concreteobserver();\nsub.attach(obtom);\nsub.attach(objohn);\nsub.notify();\n\n\n如何引入频道呢，可以继续在上述代码进行修改。\n\nabstract class observer {\n  name: string;\n  abstract update(msg: string): void;\n}\n\nabstract class subject {\n  private observers: map<string, set<observer>> = new map();\n\n  attach(channel: string, observer: observer) {\n    // 在订阅的时候增加频道\n    let obs = this.observers.get(channel);\n    if (!obs) {\n      obs = new set();\n    }\n    obs.add(observer);\n    this.observers.set(channel, obs);\n  }\n\n  detach(channel: string, observer: observer) {\n    let obs = this.observers.get(channel);\n    if (!obs) {\n      return;\n    }\n    obs.delete(observer);\n  }\n\n  notify(channel: string, msg: string) {\n    // 只对订阅了这个频道的人进行通知\n    const obset = this.observers.get(channel);\n    if (obset) {\n      obset.foreach((ob) => {\n        ob.update(msg);\n      });\n    }\n  }\n}\n\nclass concreteobserver extends observer {\n  name: string;\n\n  observestate: string;\n\n  update(msg: string): void {\n    console.log(msg, this.name);\n  }\n}\n\nclass concretesubject extends subject {\n  private _subjectstate: string;\n\n  get subjectstate() {\n    return this._subjectstate;\n  }\n\n  set subjectstate(val: string) {\n    this._subjectstate = val;\n  }\n}\n\nconst sub = new concretesubject();\nconst obtom = new concreteobserver();\nobtom.name = "tom";\nconst objohn = new concreteobserver();\nobjohn.name = "john";\nsub.attach("villa", obtom);\nsub.attach("department", objohn);\nsub.notify("villa", "别墅降价了");\nsub.notify("villa", "别墅又降价了");\nsub.notify("department", "公寓涨价了，再不买，买不到了");\n\n\n所以，你必须根据实际的业务需要采取相应的设计才行。\n\n\n# 3、前端开发中的实践\n\n对于观察者模式可以说没有一个前端不熟悉它的身影了，因为vue的双向绑定正是应用了这个设计模式，所以大家迫于面试就会去了解它。\n\n除此之外，还有别的应用，比如eventemitter，可以用它进行远距离通信（如vue的事件管道，可以实现任何两个组件之间的通信），理解了观察者模式的设计思想，其实这个eventemitter实现起来也就相当容易了，以下是我实现的一个eventemitter。\n\nclass eventemitter {\n  private _map: map<string, ((...args: any[]) => void)[]> = new map();\n\n  /**\n   * 触发一个事件\n   */\n  $emit(channel: string, ...args: any[]) {\n    const eventsets = this._map.get(channel);\n    if (!array.isarray(eventsets)) {\n      return;\n    }\n    eventsets.foreach((f) => {\n      f.apply(this, args);\n    });\n  }\n\n  /**\n   * 单次监听事件\n   * @param {string} channel 监听事件的频道\n   * @param {function} handler 监听事件的处理器\n   */\n  $once(channel: string, handler: (...args: any[]) => void) {\n    this.$on(channel, handler, true);\n  }\n\n  /**\n   * 监听事件\n   * @param {string} channel 监听事件的频道\n   * @param {function} handler 监听事件的处理器\n   * @param {boolean} once 是否仅监听一次\n   */\n  $on(channel: string, handler: (...args: any[]) => void, once?: boolean) {\n    let eventsets = this._map.get(channel);\n    if (!array.isarray(eventsets)) {\n      eventsets = [];\n    }\n    if (!once) {\n      eventsets.push(handler);\n    } else {\n      const wrapperfunc = function (...args: any[]) {\n        handler.apply(this, args);\n        this.$off(channel, wrapperfunc);\n      };\n      eventsets.push(wrapperfunc);\n    }\n    this._map.set(channel, eventsets);\n  }\n\n  /**\n   * 移除事件监听\n   * @param {string} channel 移除监听事件的频道\n   * @param {function} handler 移除监听事件的处理器\n   */\n  $off(channel: string, handler: (...args: any[]) => void) {\n    const eventsets = this._map.get(channel);\n    if (!array.isarray(eventsets)) {\n      console.warn("移除的事件频道不存在");\n      return;\n    }\n    // 如果不传递handler则移除该管道的所有监听\n    if (typeof handler !== "function") {\n      this._map.delete(channel);\n    } else {\n      // 否则只删除一个事件监听器\n      const delidx = eventsets.findindex((f) => f === handler);\n      if (delidx < 0) {\n        console.warn("当前尚未设置此handler的监听");\n        return;\n      } else {\n        eventsets.splice(delidx, 1);\n        this._map.set(channel, eventsets);\n      }\n    }\n  }\n}\n\n\n另外，在有些场景，观察者模式可以用来控制异步操作，它和promise结合起来能够达到一个化腐朽为神奇的效果。\n\n在以前的团队使用的ajax请求库是自己在html5提供的fetch api的一层封装（后文简称sdk），其中包裹了许多业务参数，直接调用这个sdk可以省时省力避免因其他因素而产生不确定的bug。但是sdk有个很不方便的特点就是只能当它调用了业务初始化接口获得响应内容结果之后才能正常工作。假设我们在页面中有个接口必须要等到sdk初始化执行，sdk初始化接口一定可以请求成功。\n\n以下是利用观察者模式在sdk上的改造：\n\nclass request {\n  request = null;\n  constructor() {\n    this.timeout = 3000;\n    this.requestqueues = [];\n  }\n  initialize() {\n    this.request = axios.create({\n      baseurl: "/",\n      timeout: this.timeout,\n    });\n    console.log("this request lib has been initialized!");\n    // timeout error\n    while (this.requestqueues.length > 0) {\n      let execute = this.requestqueues.pop();\n      let call = execute.dowork;\n      // 如果执行到当前时刻的时候，已经超时，将不在执行了。\n      if (execute.timeout) {\n        return;\n      }\n      try {\n        const result = typeof call === "function" && call();\n        if (result && typeof result.then === "function") {\n          result\n            .then((response) => {\n              execute.trigger("success", response);\n            })\n            .catch((err) => {\n              execute.trigger("error", err);\n            });\n        } else {\n          execute.trigger("success", result);\n        }\n      } catch (exp) {\n        execute.trigger("error", exp);\n      }\n    }\n  }\n\n  post() {\n    var args = arguments;\n\n    if (!this.request) {\n      const callback = {\n        dowork: () => {\n          return this.request.post.apply(this, args);\n        },\n        timeout: false,\n      };\n\n      callback.channels = {};\n\n      callback.on = function (channel, func, once = false) {\n        callback.channels[channel] = { func, once };\n      };\n\n      callback.off = function (channel) {\n        delete callback.channels[channel];\n      };\n\n      callback.once = function (channel, callback) {\n        callback.on(channel, callback, true);\n      };\n\n      callback.trigger = function (channel, args) {\n        var action = callback.channels[channel];\n        if (!action) {\n          console.warn("this channel has been off");\n          return;\n        }\n        const { func, once } = action;\n        if (typeof func === "function") {\n          func(args);\n          once && delete callback.channels[channel];\n        }\n      };\n      // 5s内sdk没有初始化成功，则认为sdk初始化超时\n      settimeout(() => {\n        callback.off("success");\n        callback.off("error");\n        callback.timeout = true;\n        callback.trigger("timeout");\n        console.log("the request lib initialization timeout");\n      }, 5000);\n\n      this.requestqueues.push(callback);\n\n      return new promise((resolve, reject) => {\n        callback.on("timeout", function () {\n          resolve({ errno: 1, errmsg: "接口请求超时" });\n        });\n\n        callback.on("success", function (response) {\n          clearinterval(timer);\n          resolve(response);\n        });\n\n        callback.on("error", function (response) {\n          clearinterval(timer);\n          reject(response);\n        });\n      });\n    }\n    return this.request.post.apply(this, arguments);\n  }\n}\n\n\n经过这番改造后，我们就可以无痛执行业务代码了，不需要关心sdk什么时候初始化完成。\n\n实际开发中，这类应用场景还很多，请大家注意体会以灵活运用。',charsets:{cjk:!0}},{frontmatter:{},regularPath:"/design-pattern/%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99.html",relativePath:"design-pattern/依赖倒置原则.md",key:"v-404f375b",path:"/design-pattern/%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99.html",headersStr:null,content:'依赖倒置原则（Dependence Inversion Principle，简称 DIP）是指高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖细节，细节应该依赖抽象。这个原则可以帮助我们实现高内聚、低耦合的代码。\n\n在前端开发中，依赖倒置原则可以通过依赖注入（Dependency Injection，简称 DI）来实现。依赖注入是指通过将依赖关系在运行时动态地注入到对象中，从而达到解耦的目的。\n\n下面是一个前端开发中的应用场景和代码实现示例：\n\n假设我们有一个搜索组件，该组件需要调用后端接口进行搜索操作，我们可以将搜索组件和后端接口实现解耦，通过依赖注入的方式将后端接口实现传递给搜索组件，从而达到依赖倒置的效果。\n\n// 后端接口实现\nclass BackendService {\n  search(query: string): Promise<any> {\n    // 发送搜索请求并返回搜索结果\n  }\n}\n\n// 搜索组件\nclass SearchComponent {\n  private backendService: BackendService;\n\n  constructor(backendService: BackendService) {\n    this.backendService = backendService;\n  }\n\n  async search(query: string) {\n    const result = await this.backendService.search(query);\n    // 处理搜索结果并显示在界面上\n  }\n}\n\n// 创建后端接口实例\nconst backendService = new BackendService();\n\n// 创建搜索组件实例，并将后端接口实例传递给搜索组件\nconst searchComponent = new SearchComponent(backendService);\n\n// 在需要搜索的时候调用搜索组件的search方法即可\nsearchComponent.search("关键词");\n\n\n在上面的示例中，搜索组件 SearchComponent 依赖于抽象的 BackendService 接口而不是具体的实现，通过将具体的实现传递给 SearchComponent 实例，我们实现了依赖注入，并且达到了依赖倒置的效果。这样，在将来如果我们需要更换后端接口实现，只需要创建新的实现，并将其传递给 SearchComponent 实例即可，而不需要修改 SearchComponent 的代码。',normalizedContent:'依赖倒置原则（dependence inversion principle，简称 dip）是指高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖细节，细节应该依赖抽象。这个原则可以帮助我们实现高内聚、低耦合的代码。\n\n在前端开发中，依赖倒置原则可以通过依赖注入（dependency injection，简称 di）来实现。依赖注入是指通过将依赖关系在运行时动态地注入到对象中，从而达到解耦的目的。\n\n下面是一个前端开发中的应用场景和代码实现示例：\n\n假设我们有一个搜索组件，该组件需要调用后端接口进行搜索操作，我们可以将搜索组件和后端接口实现解耦，通过依赖注入的方式将后端接口实现传递给搜索组件，从而达到依赖倒置的效果。\n\n// 后端接口实现\nclass backendservice {\n  search(query: string): promise<any> {\n    // 发送搜索请求并返回搜索结果\n  }\n}\n\n// 搜索组件\nclass searchcomponent {\n  private backendservice: backendservice;\n\n  constructor(backendservice: backendservice) {\n    this.backendservice = backendservice;\n  }\n\n  async search(query: string) {\n    const result = await this.backendservice.search(query);\n    // 处理搜索结果并显示在界面上\n  }\n}\n\n// 创建后端接口实例\nconst backendservice = new backendservice();\n\n// 创建搜索组件实例，并将后端接口实例传递给搜索组件\nconst searchcomponent = new searchcomponent(backendservice);\n\n// 在需要搜索的时候调用搜索组件的search方法即可\nsearchcomponent.search("关键词");\n\n\n在上面的示例中，搜索组件 searchcomponent 依赖于抽象的 backendservice 接口而不是具体的实现，通过将具体的实现传递给 searchcomponent 实例，我们实现了依赖注入，并且达到了依赖倒置的效果。这样，在将来如果我们需要更换后端接口实现，只需要创建新的实现，并将其传递给 searchcomponent 实例即可，而不需要修改 searchcomponent 的代码。',charsets:{cjk:!0}},{frontmatter:{},regularPath:"/design-pattern/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99.html",relativePath:"design-pattern/开闭原则.md",key:"v-6ed9ba4a",path:"/design-pattern/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99.html",headersStr:null,content:'开闭原则指的是软件实体（模块、类、函数等）应该对扩展开放，对修改关闭。也就是说，在不修改现有代码的情况下，能够通过扩展代码来实现新的功能。这样做的好处是可以减少修改已有代码的风险，提高代码的可维护性和可扩展性。\n\n在前端开发中，开闭原则的应用非常广泛，比如说，在一个应用中添加新的功能，应该通过增加新的组件、模块、类等来实现，而不是直接修改现有的代码。这样做不仅可以避免因为修改而带来的不确定性和风险，还可以保证现有的代码功能的稳定性和可靠性。下面是一个前端开发中应用开闭原则的例子：\n\n假设我们有一个管理用户信息的页面，页面上展示了用户的基本信息和一些操作按钮（比如编辑、删除等）。现在我们需要在页面上增加一个“重置密码”的按钮，该按钮可以用来给用户重置密码。\n\n按照开闭原则的思想，我们应该在不修改现有代码的情况下实现这个功能。我们可以新增一个“重置密码”按钮组件，并将其与页面上已有的用户信息组件进行关联。在组件内部实现重置密码的逻辑，并通过回调函数将重置后的密码传递给父组件，由父组件更新用户信息。这样，我们就实现了在不修改现有代码的情况下增加一个新功能的需求。\n\n在策略模式中，我们定义了一组算法，将它们封装在一个对象中，并通过更改这个对象来更改算法的行为。这种方法的好处是，我们可以在不更改现有代码的情况下添加新的算法。\n\ninterface SortingStrategy {\n  sort(array: number[]): number[];\n}\n\nclass QuickSortStrategy implements SortingStrategy {\n  sort(array: number[]): number[] {\n    // sort the array using quick sort algorithm\n    return array;\n  }\n}\n\nclass BubbleSortStrategy implements SortingStrategy {\n  sort(array: number[]): number[] {\n    // sort the array using bubble sort algorithm\n    return array;\n  }\n}\n\nclass Sorter {\n  private sortingStrategy: SortingStrategy;\n\n  constructor(sortingStrategy: SortingStrategy) {\n    this.sortingStrategy = sortingStrategy;\n  }\n\n  setSortingStrategy(sortingStrategy: SortingStrategy) {\n    this.sortingStrategy = sortingStrategy;\n  }\n\n  sort(array: number[]): number[] {\n    return this.sortingStrategy.sort(array);\n  }\n}\n\nconst sorter = new Sorter(new QuickSortStrategy());\nconst sortedArray = sorter.sort([3, 2, 1]); // [1, 2, 3]\n\nsorter.setSortingStrategy(new BubbleSortStrategy());\nconst sortedArray2 = sorter.sort([3, 2, 1]); // [1, 2, 3]\n\n\n\n在模板方法模式中，我们定义了一个模板方法，它定义了一个算法的基本结构，并使用一些抽象方法来延迟实现细节。这种方法的好处是，我们可以在不更改现有代码的情况下更改算法的行为。\n\nabstract class Validator {\n  validate(input: string): boolean {\n    const cleanedInput = this.cleanInput(input);\n    return this.validateInput(cleanedInput);\n  }\n\n  abstract cleanInput(input: string): string;\n  abstract validateInput(input: string): boolean;\n}\n\nclass EmailValidator extends Validator {\n  cleanInput(input: string): string {\n    return input.trim().toLowerCase();\n  }\n\n  validateInput(input: string): boolean {\n    // validate the email address\n    return true;\n  }\n}\n\nclass PhoneNumberValidator extends Validator {\n  cleanInput(input: string): string {\n    return input.replace(/\\D/g, "");\n  }\n\n  validateInput(input: string): boolean {\n    // validate the phone number\n    return true;\n  }\n}\n\nconst emailValidator = new EmailValidator();\nemailValidator.validate("  john@example.com  "); // true\n\nconst phoneNumberValidator = new PhoneNumberValidator();\nphoneNumberValidator.validate("(123) 456-7890"); // true\n',normalizedContent:'开闭原则指的是软件实体（模块、类、函数等）应该对扩展开放，对修改关闭。也就是说，在不修改现有代码的情况下，能够通过扩展代码来实现新的功能。这样做的好处是可以减少修改已有代码的风险，提高代码的可维护性和可扩展性。\n\n在前端开发中，开闭原则的应用非常广泛，比如说，在一个应用中添加新的功能，应该通过增加新的组件、模块、类等来实现，而不是直接修改现有的代码。这样做不仅可以避免因为修改而带来的不确定性和风险，还可以保证现有的代码功能的稳定性和可靠性。下面是一个前端开发中应用开闭原则的例子：\n\n假设我们有一个管理用户信息的页面，页面上展示了用户的基本信息和一些操作按钮（比如编辑、删除等）。现在我们需要在页面上增加一个“重置密码”的按钮，该按钮可以用来给用户重置密码。\n\n按照开闭原则的思想，我们应该在不修改现有代码的情况下实现这个功能。我们可以新增一个“重置密码”按钮组件，并将其与页面上已有的用户信息组件进行关联。在组件内部实现重置密码的逻辑，并通过回调函数将重置后的密码传递给父组件，由父组件更新用户信息。这样，我们就实现了在不修改现有代码的情况下增加一个新功能的需求。\n\n在策略模式中，我们定义了一组算法，将它们封装在一个对象中，并通过更改这个对象来更改算法的行为。这种方法的好处是，我们可以在不更改现有代码的情况下添加新的算法。\n\ninterface sortingstrategy {\n  sort(array: number[]): number[];\n}\n\nclass quicksortstrategy implements sortingstrategy {\n  sort(array: number[]): number[] {\n    // sort the array using quick sort algorithm\n    return array;\n  }\n}\n\nclass bubblesortstrategy implements sortingstrategy {\n  sort(array: number[]): number[] {\n    // sort the array using bubble sort algorithm\n    return array;\n  }\n}\n\nclass sorter {\n  private sortingstrategy: sortingstrategy;\n\n  constructor(sortingstrategy: sortingstrategy) {\n    this.sortingstrategy = sortingstrategy;\n  }\n\n  setsortingstrategy(sortingstrategy: sortingstrategy) {\n    this.sortingstrategy = sortingstrategy;\n  }\n\n  sort(array: number[]): number[] {\n    return this.sortingstrategy.sort(array);\n  }\n}\n\nconst sorter = new sorter(new quicksortstrategy());\nconst sortedarray = sorter.sort([3, 2, 1]); // [1, 2, 3]\n\nsorter.setsortingstrategy(new bubblesortstrategy());\nconst sortedarray2 = sorter.sort([3, 2, 1]); // [1, 2, 3]\n\n\n\n在模板方法模式中，我们定义了一个模板方法，它定义了一个算法的基本结构，并使用一些抽象方法来延迟实现细节。这种方法的好处是，我们可以在不更改现有代码的情况下更改算法的行为。\n\nabstract class validator {\n  validate(input: string): boolean {\n    const cleanedinput = this.cleaninput(input);\n    return this.validateinput(cleanedinput);\n  }\n\n  abstract cleaninput(input: string): string;\n  abstract validateinput(input: string): boolean;\n}\n\nclass emailvalidator extends validator {\n  cleaninput(input: string): string {\n    return input.trim().tolowercase();\n  }\n\n  validateinput(input: string): boolean {\n    // validate the email address\n    return true;\n  }\n}\n\nclass phonenumbervalidator extends validator {\n  cleaninput(input: string): string {\n    return input.replace(/\\d/g, "");\n  }\n\n  validateinput(input: string): boolean {\n    // validate the phone number\n    return true;\n  }\n}\n\nconst emailvalidator = new emailvalidator();\nemailvalidator.validate("  john@example.com  "); // true\n\nconst phonenumbervalidator = new phonenumbervalidator();\nphonenumbervalidator.validate("(123) 456-7890"); // true\n',charsets:{cjk:!0}},{frontmatter:{},regularPath:"/frameworks/",relativePath:"frameworks/index.md",key:"v-19a2deaa",path:"/frameworks/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{},regularPath:"/design-pattern/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99.html",relativePath:"design-pattern/接口隔离原则.md",key:"v-f4d886fc",path:"/design-pattern/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99.html",headersStr:null,content:'接口隔离原则（Interface Segregation Principle，简称 ISP）是指在设计接口时，应该避免设计大而全的接口，而应该设计多个专门的接口，让实现类只实现自己需要的接口，从而减少对实现类的依赖关系。接口隔离原则主要是为了避免接口的“胖接口”问题，即一个接口定义了很多方法，但实现类只需要用到其中的一部分，从而造成代码冗余和浪费。\n\n在前端开发中，接口隔离原则同样适用。例如，在设计一个组件时，如果将所有可能用到的方法都定义在一个接口中，会导致实现类不得不实现所有这些方法，即使实际上只有一小部分方法被用到。这样会增加代码量和维护难度，影响代码的可读性和可维护性。因此，可以采用接口隔离原则来解决这个问题。\n\n以下是一个前端开发中应用接口隔离原则的代码示例：\n\n// 定义一个接口，包含多个方法\ninterface Component {\n  render(): void;\n  handleClick(): void;\n  handleMouseOver(): void;\n  handleMouseOut(): void;\n}\n\n// 实现类A只需要实现render方法\nclass ComponentA implements Component {\n  render() {\n    console.log("ComponentA is rendered");\n  }\n\n  handleClick() {\n    // do nothing\n  }\n\n  handleMouseOver() {\n    // do nothing\n  }\n\n  handleMouseOut() {\n    // do nothing\n  }\n}\n\n// 实现类B只需要实现handleClick方法和handleMouseOver方法\nclass ComponentB implements Component {\n  render() {\n    // do nothing\n  }\n\n  handleClick() {\n    console.log("ComponentB is clicked");\n  }\n\n  handleMouseOver() {\n    console.log("Mouse is over ComponentB");\n  }\n\n  handleMouseOut() {\n    // do nothing\n  }\n}\n\n\n在上面的代码中，我们定义了一个包含多个方法的接口 Component，但是实现类 ComponentA 只需要实现 render 方法，而实现类 ComponentB 只需要实现 handleClick 方法和 handleMouseOver 方法。这样，我们就避免了实现类不必要地实现所有方法的问题，提高了代码的可读性和可维护性。\n\nfunction quickSelect(arr, k) {\n  const n = arr.length;\n  let left = 0;\n  let right = n - 1;\n  while (left <= right) {\n    const pivotIndex = partition(arr, left, right);\n    if (pivotIndex === n - k) {\n      return arr.slice(pivotIndex);\n    } else if (pivotIndex < n - k) {\n      left = pivotIndex + 1;\n    } else {\n      right = pivotIndex - 1;\n    }\n  }\n}\n\nfunction partition(arr, left, right) {\n  const pivotIndex = Math.floor((left + right) / 2);\n  const pivotValue = arr[pivotIndex];\n  swap(arr, pivotIndex, right);\n  let storeIndex = left;\n  for (let i = left; i < right; i++) {\n    if (arr[i] < pivotValue) {\n      swap(arr, i, storeIndex);\n      storeIndex++;\n    }\n  }\n  swap(arr, storeIndex, right);\n  return storeIndex;\n}\n\nfunction swap(arr, i, j) {\n  const temp = arr[i];\n  arr[i] = arr[j];\n  arr[j] = temp;\n}\n',normalizedContent:'接口隔离原则（interface segregation principle，简称 isp）是指在设计接口时，应该避免设计大而全的接口，而应该设计多个专门的接口，让实现类只实现自己需要的接口，从而减少对实现类的依赖关系。接口隔离原则主要是为了避免接口的“胖接口”问题，即一个接口定义了很多方法，但实现类只需要用到其中的一部分，从而造成代码冗余和浪费。\n\n在前端开发中，接口隔离原则同样适用。例如，在设计一个组件时，如果将所有可能用到的方法都定义在一个接口中，会导致实现类不得不实现所有这些方法，即使实际上只有一小部分方法被用到。这样会增加代码量和维护难度，影响代码的可读性和可维护性。因此，可以采用接口隔离原则来解决这个问题。\n\n以下是一个前端开发中应用接口隔离原则的代码示例：\n\n// 定义一个接口，包含多个方法\ninterface component {\n  render(): void;\n  handleclick(): void;\n  handlemouseover(): void;\n  handlemouseout(): void;\n}\n\n// 实现类a只需要实现render方法\nclass componenta implements component {\n  render() {\n    console.log("componenta is rendered");\n  }\n\n  handleclick() {\n    // do nothing\n  }\n\n  handlemouseover() {\n    // do nothing\n  }\n\n  handlemouseout() {\n    // do nothing\n  }\n}\n\n// 实现类b只需要实现handleclick方法和handlemouseover方法\nclass componentb implements component {\n  render() {\n    // do nothing\n  }\n\n  handleclick() {\n    console.log("componentb is clicked");\n  }\n\n  handlemouseover() {\n    console.log("mouse is over componentb");\n  }\n\n  handlemouseout() {\n    // do nothing\n  }\n}\n\n\n在上面的代码中，我们定义了一个包含多个方法的接口 component，但是实现类 componenta 只需要实现 render 方法，而实现类 componentb 只需要实现 handleclick 方法和 handlemouseover 方法。这样，我们就避免了实现类不必要地实现所有方法的问题，提高了代码的可读性和可维护性。\n\nfunction quickselect(arr, k) {\n  const n = arr.length;\n  let left = 0;\n  let right = n - 1;\n  while (left <= right) {\n    const pivotindex = partition(arr, left, right);\n    if (pivotindex === n - k) {\n      return arr.slice(pivotindex);\n    } else if (pivotindex < n - k) {\n      left = pivotindex + 1;\n    } else {\n      right = pivotindex - 1;\n    }\n  }\n}\n\nfunction partition(arr, left, right) {\n  const pivotindex = math.floor((left + right) / 2);\n  const pivotvalue = arr[pivotindex];\n  swap(arr, pivotindex, right);\n  let storeindex = left;\n  for (let i = left; i < right; i++) {\n    if (arr[i] < pivotvalue) {\n      swap(arr, i, storeindex);\n      storeindex++;\n    }\n  }\n  swap(arr, storeindex, right);\n  return storeindex;\n}\n\nfunction swap(arr, i, j) {\n  const temp = arr[i];\n  arr[i] = arr[j];\n  arr[j] = temp;\n}\n',charsets:{cjk:!0}},{frontmatter:{},regularPath:"/design-pattern/%E9%87%8C%E6%B0%8F%E4%BB%A3%E6%8D%A2%E5%8E%9F%E5%88%99.html",relativePath:"design-pattern/里氏代换原则.md",key:"v-c218caaa",path:"/design-pattern/%E9%87%8C%E6%B0%8F%E4%BB%A3%E6%8D%A2%E5%8E%9F%E5%88%99.html",headersStr:null,content:'里氏代换原则（Liskov Substitution Principle）指的是，所有引用基类（父类）的地方必须能透明地使用其子类的对象。\n\n在前端开发中，可以举出一个例子来说明里氏代换原则的应用：\n\n假设我们有一个基类（父类）Animal，它有一个 run 方法用于移动。我们再创建两个子类 Cat 和 Dog，它们都继承自 Animal，并且各自实现了自己的 run 方法。\n\nclass Animal {\n  run() {\n    console.log("Animal is running");\n  }\n}\n\nclass Cat extends Animal {\n  run() {\n    console.log("Cat is running");\n  }\n}\n\nclass Dog extends Animal {\n  run() {\n    console.log("Dog is running");\n  }\n}\n\n\n现在，我们在程序中使用这些类的实例。按照里氏代换原则，我们可以在不改变程序行为的前提下，用子类的实例代替基类的实例。例如，我们可以创建一个 Animal 类型的变量，然后将 Cat 或 Dog 的实例赋值给它。\n\nlet animal: Animal = new Cat();\nanimal.run(); // 输出 "Cat is running"\n\n\n因为 Cat 是 Animal 的子类，所以我们可以将 Cat 的实例赋值给 Animal 类型的变量，并且调用 run 方法时会调用 Cat 的 run 方法，而不是 Animal 的 run 方法。这个例子就说明了里氏代换原则的应用。\n\n在实际开发中，里氏代换原则的应用非常广泛。例如，如果我们要编写一个通用的表格组件，可以先定义一个基类 Table，然后编写各种子类，如 SortableTable、FilterableTable 等，这些子类都可以透明地替换基类的对象，从而实现组件的灵活性和可复用性。',normalizedContent:'里氏代换原则（liskov substitution principle）指的是，所有引用基类（父类）的地方必须能透明地使用其子类的对象。\n\n在前端开发中，可以举出一个例子来说明里氏代换原则的应用：\n\n假设我们有一个基类（父类）animal，它有一个 run 方法用于移动。我们再创建两个子类 cat 和 dog，它们都继承自 animal，并且各自实现了自己的 run 方法。\n\nclass animal {\n  run() {\n    console.log("animal is running");\n  }\n}\n\nclass cat extends animal {\n  run() {\n    console.log("cat is running");\n  }\n}\n\nclass dog extends animal {\n  run() {\n    console.log("dog is running");\n  }\n}\n\n\n现在，我们在程序中使用这些类的实例。按照里氏代换原则，我们可以在不改变程序行为的前提下，用子类的实例代替基类的实例。例如，我们可以创建一个 animal 类型的变量，然后将 cat 或 dog 的实例赋值给它。\n\nlet animal: animal = new cat();\nanimal.run(); // 输出 "cat is running"\n\n\n因为 cat 是 animal 的子类，所以我们可以将 cat 的实例赋值给 animal 类型的变量，并且调用 run 方法时会调用 cat 的 run 方法，而不是 animal 的 run 方法。这个例子就说明了里氏代换原则的应用。\n\n在实际开发中，里氏代换原则的应用非常广泛。例如，如果我们要编写一个通用的表格组件，可以先定义一个基类 table，然后编写各种子类，如 sortabletable、filterabletable 等，这些子类都可以透明地替换基类的对象，从而实现组件的灵活性和可复用性。',charsets:{cjk:!0}},{frontmatter:{},regularPath:"/design-pattern/%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99.html",relativePath:"design-pattern/迪米特法则.md",key:"v-3e081066",path:"/design-pattern/%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99.html",headersStr:null,content:"迪米特法则，也称为最少知道原则（Least Knowledge Principle），它是面向对象设计原则之一，指的是一个对象应该对其他对象保持最少的了解，即一个类应该对自己需要耦合或调用的类知道得最少，从而降低对象之间的耦合性。\n\n在前端开发中，迪米特法则的应用主要体现在以下两个方面：\n\n将复杂的业务逻辑拆分成多个小模块，每个模块只依赖自己需要的数据和其他必要的模块，避免不必要的耦合。\n\n将数据获取和展示分离，通过中间的服务层来传递数据，前端只需要关心数据的展示和交互逻辑，而不需要了解数据是如何获取的。\n\n以下是一个前端开发中应用迪米特法则的代码示例：\n\nclass Cart {\n  private itemList: Item[] = [];\n\n  // 添加商品到购物车\n  addItem(item: Item) {\n    this.itemList.push(item);\n  }\n\n  // 获取购物车商品列表\n  getItemList(): Item[] {\n    return this.itemList;\n  }\n}\n\nclass Item {\n  private name: string;\n  private price: number;\n\n  constructor(name: string, price: number) {\n    this.name = name;\n    this.price = price;\n  }\n\n  getName(): string {\n    return this.name;\n  }\n\n  getPrice(): number {\n    return this.price;\n  }\n}\n\nclass CartService {\n  // 获取购物车中的商品列表\n  getCartItemList(): Item[] {\n    const cart = new Cart();\n    return cart.getItemList();\n  }\n\n  // 向购物车中添加商品\n  addCartItem(item: Item) {\n    const cart = new Cart();\n    cart.addItem(item);\n  }\n}\n\nclass CartView {\n  private cartService: CartService;\n\n  constructor() {\n    this.cartService = new CartService();\n  }\n\n  // 渲染购物车中的商品列表\n  renderCartItemList() {\n    const itemList = this.cartService.getCartItemList();\n    // 渲染商品列表\n  }\n\n  // 添加商品到购物车\n  addItemToCart(item: Item) {\n    this.cartService.addCartItem(item);\n    // 渲染购物车中的商品列表\n    this.renderCartItemList();\n  }\n}\n\n\n在上面的示例中，我们通过将购物车的业务逻辑拆分成三个模块：Cart、CartService 和 CartView 来避免耦合。其中，Cart 类只关注购物车的添加和获取商品列表，CartService 类用于与后端交互获取商品列表和添加商品到购物车中，CartView 类则专注于购物车的展示和交互逻辑。这样，当业务需求变化时，只需要修改对应的模块而不会影响其他模块的代码。",normalizedContent:"迪米特法则，也称为最少知道原则（least knowledge principle），它是面向对象设计原则之一，指的是一个对象应该对其他对象保持最少的了解，即一个类应该对自己需要耦合或调用的类知道得最少，从而降低对象之间的耦合性。\n\n在前端开发中，迪米特法则的应用主要体现在以下两个方面：\n\n将复杂的业务逻辑拆分成多个小模块，每个模块只依赖自己需要的数据和其他必要的模块，避免不必要的耦合。\n\n将数据获取和展示分离，通过中间的服务层来传递数据，前端只需要关心数据的展示和交互逻辑，而不需要了解数据是如何获取的。\n\n以下是一个前端开发中应用迪米特法则的代码示例：\n\nclass cart {\n  private itemlist: item[] = [];\n\n  // 添加商品到购物车\n  additem(item: item) {\n    this.itemlist.push(item);\n  }\n\n  // 获取购物车商品列表\n  getitemlist(): item[] {\n    return this.itemlist;\n  }\n}\n\nclass item {\n  private name: string;\n  private price: number;\n\n  constructor(name: string, price: number) {\n    this.name = name;\n    this.price = price;\n  }\n\n  getname(): string {\n    return this.name;\n  }\n\n  getprice(): number {\n    return this.price;\n  }\n}\n\nclass cartservice {\n  // 获取购物车中的商品列表\n  getcartitemlist(): item[] {\n    const cart = new cart();\n    return cart.getitemlist();\n  }\n\n  // 向购物车中添加商品\n  addcartitem(item: item) {\n    const cart = new cart();\n    cart.additem(item);\n  }\n}\n\nclass cartview {\n  private cartservice: cartservice;\n\n  constructor() {\n    this.cartservice = new cartservice();\n  }\n\n  // 渲染购物车中的商品列表\n  rendercartitemlist() {\n    const itemlist = this.cartservice.getcartitemlist();\n    // 渲染商品列表\n  }\n\n  // 添加商品到购物车\n  additemtocart(item: item) {\n    this.cartservice.addcartitem(item);\n    // 渲染购物车中的商品列表\n    this.rendercartitemlist();\n  }\n}\n\n\n在上面的示例中，我们通过将购物车的业务逻辑拆分成三个模块：cart、cartservice 和 cartview 来避免耦合。其中，cart 类只关注购物车的添加和获取商品列表，cartservice 类用于与后端交互获取商品列表和添加商品到购物车中，cartview 类则专注于购物车的展示和交互逻辑。这样，当业务需求变化时，只需要修改对应的模块而不会影响其他模块的代码。",charsets:{cjk:!0}},{frontmatter:{},regularPath:"/guide/",relativePath:"guide/index.md",key:"v-e18b4c64",path:"/guide/",headersStr:null,content:"数据结构和算法专题\n\n> 常见数据结构和算法（树、图、数组、堆、栈、队列）的基本使用以及典型题目分析。\n\n----------------------------------------\n\n设计模式\n\n> 常见设计模式在 JavaScript 中的实现。\n\n----------------------------------------\n\nJavaScript 专题\n\n> JavaScript常见的一些核心概念以及部分API的手写实现，如节流防抖等。",normalizedContent:"数据结构和算法专题\n\n> 常见数据结构和算法（树、图、数组、堆、栈、队列）的基本使用以及典型题目分析。\n\n----------------------------------------\n\n设计模式\n\n> 常见设计模式在 javascript 中的实现。\n\n----------------------------------------\n\njavascript 专题\n\n> javascript常见的一些核心概念以及部分api的手写实现，如节流防抖等。",charsets:{cjk:!0}},{title:"RegExp对象",frontmatter:{},regularPath:"/javascript/RegExp.html",relativePath:"javascript/RegExp.md",key:"v-c0792b56",path:"/javascript/RegExp.html",headers:[{level:2,title:"RegExp对象",slug:"regexp对象",normalizedTitle:"regexp对象",charIndex:2},{level:3,title:"组",slug:"组",normalizedTitle:"组",charIndex:1346},{level:3,title:"序列化",slug:"序列化",normalizedTitle:"序列化",charIndex:1818},{level:3,title:"全局匹配与lastIndex",slug:"全局匹配与lastindex",normalizedTitle:"全局匹配与lastindex",charIndex:1851}],headersStr:"RegExp对象 组 序列化 全局匹配与lastIndex",content:'# RegExp对象\n\n本文不着重阐述正则表达式本身，主要是阐述RegExp一些应用以及实际开发中的坑。\n\n对于想详细理解RegExp对象的朋友，可以查看MDN原文\n\n在JS中，一般我们喜欢写RegExp对象的字面量形式，如：\n\nconst regExp = /^(\\+86)?1[3456789]\\d{9}$/;\nregExp.test("14730909030");\n\n\n而如果写构造函数的形式，还需要对特殊字符进行转义，相对来说就比较复杂了，比如，实现同等功能，代码要这样写：\n\nconst regExp = new RegExp("^(\\\\+86)?1[3456789]\\\\d{9}$")\n\n\n有些时候，难免会把一些转义字符写错，所以为了避免问题，还是尽量避免写构造函数的形式。\n\n不过凡事不是绝对的，有的情况是不得不写构造函数形式的，比如：\n\nconst obj = { name: "yangxu", age: 28, vocation: "web-frontend developer" };\n\nconst html = `<div class="person">\n                <span class=\'name\'>{{name}}</span>\n                <span class=\'age\'>{{age}}</span>\n                <span class=\'vocation\'>{{vocation}}</span>\n              </div>\n            `;\n/*\n  希望得到如下结果\n  <div class="person">\n    <span class=\'name\'>yangxu</span>\n    <span class=\'age\'>28</span>\n    <span class=\'vocation\'>web-frontend developer</span>\n  </div>\n*/\n\n\nconst compile = (str, targetObj) => {\n  let distStr = str;\n  Object.entries(targetObj).forEach(([prop, val]) => {\n    distStr = distStr.replace(new RegExp("{{(" + prop + ")}}"), val);\n  });\n  return distStr;\n};\n/* 这个例子举的不是特别恰当，但是主要想说明RegExp构造器初始化正则表达式一般都是在动态生成正则表达式的场景下 */\n/**\n  const compile = (str, targetObj) => {\n    let distStr = str.replace(/{{([a-zA-Z0-9]+)}}/g, function (...args) {\n      return args.length > 1 && targetObj[args[1]];\n    });\n    return distStr;\n  };\n*/\n\n\n\n# 组\n\n关于正则的组的概念，请先查阅相关资料，本文主要阐述实际的应用。\n\nRegExp对象上存在$1-$9对象用来表示组，比如：\n\nconst regExp = /^(\\d)[\\u4e00-\\u9fa5]+/\nregExp.test(\'1生一世写前端\');\nRegExp.$1 // 匹配成功之后，RegExp.$1 的值就是 \'1\'，不标准，不建议使用\n\n\n如果使用exec：\n\nconst regExp = /^(\\d)[\\u4e00-\\u9fa5]+/;\nregExp.exec("1生一世写前端"); // 匹配成功得到的是一个数组，如[\'1生一世写前端\', \'1\', index: 0, input: \'1生一世写前端\', groups: undefined]，否则null\n\n\n在字符串的替换中，可以用到这些匹配的结果，如：\n\nconst regExp = /^(\\d)[\\u4e00-\\u9fa5]+/;\nlet str = "1生一世写前端";\nstr = str.replace(regExp, "$1起写代码");\n\n\n\n# 序列化\n\nRegExp的实例只能被序列化成为一个普通对象\n\n\n# 全局匹配与lastIndex\n\n这个问题可能是绝大部分前端都没有搞清楚的问题，并且我也被这个问题坑过。\n\n下面就来看一个例子：\n\nconst regExp = /^(\\+86)?1[3456789]\\d{9}$/g;\n\nregExp.test("14730909030"); // true\nregExp.test("14730909030"); // false\nregExp.test("14730909030"); // true\n\n/^(\\+86)?1[3456789]\\d{9}$/g.test("14730909030") // true\n/^(\\+86)?1[3456789]\\d{9}$/g.test("14730909030") // true\n/^(\\+86)?1[3456789]\\d{9}$/g.test("14730909030") // true\n\n\n为什么中间的这个语句得到的结果是false，超出自己的认知了？？？\n\nno no no！！！，这是你还没有理解到 RegExp.lastIndex 是什么意思。\n\nlastIndex只有正则表达式使用了表示全局检索的 "g" 或者粘性检索的 "y" 标志时，该属性才会起作用。\n\n * 如果 regexp.test 和 regexp.exec 匹配成功，lastIndex 会被设置为紧随最近一次成功匹配的下一个位置。\n * 如果 regexp.test 和 regexp.exec 匹配失败，lastIndex 会被设置为 0\n\n上述第一个情况，三个test，有一个是false的原因是，第一次成功匹配，lastIndex 走到最后一个位置，下次匹配的时候，相当于是从\'\'匹配 \'14730909030\'，那当然是匹配不到了，匹配不到，lastIndex就要归零，所以下次再匹配的时候，就能匹配了。而第二个情况每次都申明一个新的正则对象来进行匹配，其实也就丢失了全局匹配的意义，所以，每次都能匹配上。\n\n明确了这个问题，其实你也明确了什么时候该用全局匹配和什么时候不该用全局匹配了，简言之就是：如果你想在上次的搜索结果上继续向后匹配，那么你就需要使用全局匹配。',normalizedContent:'# regexp对象\n\n本文不着重阐述正则表达式本身，主要是阐述regexp一些应用以及实际开发中的坑。\n\n对于想详细理解regexp对象的朋友，可以查看mdn原文\n\n在js中，一般我们喜欢写regexp对象的字面量形式，如：\n\nconst regexp = /^(\\+86)?1[3456789]\\d{9}$/;\nregexp.test("14730909030");\n\n\n而如果写构造函数的形式，还需要对特殊字符进行转义，相对来说就比较复杂了，比如，实现同等功能，代码要这样写：\n\nconst regexp = new regexp("^(\\\\+86)?1[3456789]\\\\d{9}$")\n\n\n有些时候，难免会把一些转义字符写错，所以为了避免问题，还是尽量避免写构造函数的形式。\n\n不过凡事不是绝对的，有的情况是不得不写构造函数形式的，比如：\n\nconst obj = { name: "yangxu", age: 28, vocation: "web-frontend developer" };\n\nconst html = `<div class="person">\n                <span class=\'name\'>{{name}}</span>\n                <span class=\'age\'>{{age}}</span>\n                <span class=\'vocation\'>{{vocation}}</span>\n              </div>\n            `;\n/*\n  希望得到如下结果\n  <div class="person">\n    <span class=\'name\'>yangxu</span>\n    <span class=\'age\'>28</span>\n    <span class=\'vocation\'>web-frontend developer</span>\n  </div>\n*/\n\n\nconst compile = (str, targetobj) => {\n  let diststr = str;\n  object.entries(targetobj).foreach(([prop, val]) => {\n    diststr = diststr.replace(new regexp("{{(" + prop + ")}}"), val);\n  });\n  return diststr;\n};\n/* 这个例子举的不是特别恰当，但是主要想说明regexp构造器初始化正则表达式一般都是在动态生成正则表达式的场景下 */\n/**\n  const compile = (str, targetobj) => {\n    let diststr = str.replace(/{{([a-za-z0-9]+)}}/g, function (...args) {\n      return args.length > 1 && targetobj[args[1]];\n    });\n    return diststr;\n  };\n*/\n\n\n\n# 组\n\n关于正则的组的概念，请先查阅相关资料，本文主要阐述实际的应用。\n\nregexp对象上存在$1-$9对象用来表示组，比如：\n\nconst regexp = /^(\\d)[\\u4e00-\\u9fa5]+/\nregexp.test(\'1生一世写前端\');\nregexp.$1 // 匹配成功之后，regexp.$1 的值就是 \'1\'，不标准，不建议使用\n\n\n如果使用exec：\n\nconst regexp = /^(\\d)[\\u4e00-\\u9fa5]+/;\nregexp.exec("1生一世写前端"); // 匹配成功得到的是一个数组，如[\'1生一世写前端\', \'1\', index: 0, input: \'1生一世写前端\', groups: undefined]，否则null\n\n\n在字符串的替换中，可以用到这些匹配的结果，如：\n\nconst regexp = /^(\\d)[\\u4e00-\\u9fa5]+/;\nlet str = "1生一世写前端";\nstr = str.replace(regexp, "$1起写代码");\n\n\n\n# 序列化\n\nregexp的实例只能被序列化成为一个普通对象\n\n\n# 全局匹配与lastindex\n\n这个问题可能是绝大部分前端都没有搞清楚的问题，并且我也被这个问题坑过。\n\n下面就来看一个例子：\n\nconst regexp = /^(\\+86)?1[3456789]\\d{9}$/g;\n\nregexp.test("14730909030"); // true\nregexp.test("14730909030"); // false\nregexp.test("14730909030"); // true\n\n/^(\\+86)?1[3456789]\\d{9}$/g.test("14730909030") // true\n/^(\\+86)?1[3456789]\\d{9}$/g.test("14730909030") // true\n/^(\\+86)?1[3456789]\\d{9}$/g.test("14730909030") // true\n\n\n为什么中间的这个语句得到的结果是false，超出自己的认知了？？？\n\nno no no！！！，这是你还没有理解到 regexp.lastindex 是什么意思。\n\nlastindex只有正则表达式使用了表示全局检索的 "g" 或者粘性检索的 "y" 标志时，该属性才会起作用。\n\n * 如果 regexp.test 和 regexp.exec 匹配成功，lastindex 会被设置为紧随最近一次成功匹配的下一个位置。\n * 如果 regexp.test 和 regexp.exec 匹配失败，lastindex 会被设置为 0\n\n上述第一个情况，三个test，有一个是false的原因是，第一次成功匹配，lastindex 走到最后一个位置，下次匹配的时候，相当于是从\'\'匹配 \'14730909030\'，那当然是匹配不到了，匹配不到，lastindex就要归零，所以下次再匹配的时候，就能匹配了。而第二个情况每次都申明一个新的正则对象来进行匹配，其实也就丢失了全局匹配的意义，所以，每次都能匹配上。\n\n明确了这个问题，其实你也明确了什么时候该用全局匹配和什么时候不该用全局匹配了，简言之就是：如果你想在上次的搜索结果上继续向后匹配，那么你就需要使用全局匹配。',charsets:{cjk:!0}},{title:"Ajax",frontmatter:{},regularPath:"/javascript/ajax.html",relativePath:"javascript/ajax.md",key:"v-fa7f0416",path:"/javascript/ajax.html",headers:[{level:2,title:"Ajax",slug:"ajax",normalizedTitle:"ajax",charIndex:2},{level:3,title:"1、Ajax 的前世今生",slug:"_1、ajax-的前世今生",normalizedTitle:"1、ajax 的前世今生",charIndex:42},{level:3,title:"2、原生 Ajax 的实现",slug:"_2、原生-ajax-的实现",normalizedTitle:"2、原生 ajax 的实现",charIndex:842},{level:3,title:"3、选择与服务器的约定通信方式",slug:"_3、选择与服务器的约定通信方式",normalizedTitle:"3、选择与服务器的约定通信方式",charIndex:3971},{level:3,title:"4、跨域 Ajax",slug:"_4、跨域-ajax",normalizedTitle:"4、跨域 ajax",charIndex:4740}],headersStr:"Ajax 1、Ajax 的前世今生 2、原生 Ajax 的实现 3、选择与服务器的约定通信方式 4、跨域 Ajax",content:'# Ajax\n\nAjax在某种程度上来说，改变了现代Web技术的发展走向。\n\n\n# 1、Ajax 的前世今生\n\nAjax 即 Asynchronous Javascript And XML在 2005 年被Jesse James Garrett提出的新术语，用来描述一种使用现有技术集合的‘新’方法，包括: HTML 或 XHTML（已被HTML5取代）, CSS, JavaScript, DOM, XML, XSLT（已过时）, 以及最重要的XMLHttpRequest（后文简称xhr）。 使用Ajax技术网页应用能够快速地将增量更新呈现在用户界面上，而不需要重载（刷新）整个页面，这使得程序能够更快地回应用户的操作。\n\n在没有Ajax技术的时候，前端想要向后端交互数据必须整页的提交，给用户的感觉就是整个页面刷一下，有了这项技术以后便可以局部更新页面，随着后来前端技术的发展（Angular、React、Vue等框架的出现），服务端不再负责页面的渲染，逐渐发展成为了现在的前后端分离的开发模式，即前端负责渲染页面，通过 Ajax技术和后端进行数据的交互，因为不再需要需要整页的向服务器提交数据了，所以我们的页面不再发生跳转，所以看起来就像一个客户端应用一样，即单页面应用程序(SPA)。\n\n在实际的开发中，我们已经不再需要自己手写Ajax的实现，几乎都是用成熟的库，比如大名鼎鼎的axios，后面各大浏览器厂商甚至直接支持了一个类似axios这样的请求API，fetch。\n\n另外，虽然说A代表的含义是异步，但是并不是说Ajax只能异步处理，也可以同步处理，但是几乎不用，因为如果是同步的Ajax，在服务端没有返回的这个过程中，浏览器是无法响应用户的操作的，造成界面的假死，这是非常影响用户体验的；早期和服务端的通信采用XML语言，但是XML是比较笨重的，因此现在普遍的方式都是采用轻量的JSON（JavaScript Object Notation）格式进行通信。\n\n\n# 2、原生 Ajax 的实现\n\n我们模拟实现一个能满足80%日常工作的Ajax函数，实现如下：\n\nfunction MyAjax(params) {\n  params = params || {};\n  params.data = params.data || {};\n  // ajax请求\n  function json(params) {\n    // 请求方式，默认是GET\n    params.type = (params.type || "GET").toUpperCase();\n    // 避免有特殊字符，必须格式化传输数据\n    params.data = formatParams(params.data);\n    var xhr = null;\n    // 实例化XMLHttpRequest对象\n    if (window.XMLHttpRequest) {\n      xhr = new XMLHttpRequest();\n    } else {\n      // IE6及其以下版本\n      xhr = new ActiveXObjcet("Microsoft.XMLHTTP");\n    }\n    // 监听事件，只要 readyState 的值变化，就会调用 readystatechange 事件\n    xhr.onreadystatechange = function () {\n      // readyState属性表示请求/响应过程的当前活动阶段，4为完成，已经接收到全部响应数据\n      if (xhr.readyState == 4) {\n        var status = xhr.status;\n        // status：响应的HTTP状态码，以2开头的都是成功\n        if (status >= 200 && status < 300) {\n          var response = "";\n          // 判断接受数据的内容类型\n          var type = xhr.getResponseHeader("Content-type");\n          if (type.indexOf("xml") !== -1 && xhr.responseXML) {\n            response = xhr.responseXML; //Document对象响应\n          } else if (type === "application/json") {\n            response = JSON.parse(xhr.responseText); //JSON响应\n          } else {\n            response = xhr.responseText; //字符串响应\n          }\n          // 成功回调函数\n          params.success && params.success(response);\n        } else {\n          params.error && params.error(status);\n        }\n      }\n    };\n    // 连接和传输数据\n    if (params.type == "GET") {\n      // 三个参数：请求方式、请求地址(get方式时，传输数据是加在地址后的)、是否异步请求(同步请求的情况极少)；\n      xhr.open(params.type, params.url + "?" + params.data, true);\n      xhr.send(null);\n    } else {\n      xhr.open(params.type, params.url, true);\n      //必须，设置提交时的内容类型\n      xhr.setRequestHeader(\n        "Content-Type",\n        "application/x-www-form-urlencoded; charset=UTF-8"\n      );\n      // 传输数据\n      xhr.send(params.data);\n    }\n  }\n\n  //格式化参数\n  function formatParams(data) {\n    var arr = [];\n    for (var name in data) {\n      // encodeURIComponent() ：用于对 URI 中的某一部分进行编码\n      arr.push(encodeURIComponent(name) + "=" + encodeURIComponent(data[name]));\n    }\n    // 添加一个随机数参数，防止缓存\n    arr.push("v=" + random());\n    return arr.join("&");\n  }\n\n  // 获取随机数\n  function random() {\n    return Math.floor(Math.random() * 10000 + 500);\n  }\n}\n\n\n上述代码中，有很多个关键点，我们逐一进行解释。\n\n首先，在很久很久以前，IE6还在的时候，它还不支持XMLHttpRequest(即XHR)对象，只能用ActiveXObjcet插件。\n\n接着，XMLHttpRequest对象有很多属性，比如常用的readyState，responseType, 也有很多事件是可以监听的，只不过这些事件或属性我们几乎很少用到，比如onabort在取消请求的时候会触发，ononprogress，在上传文件的时候，如果是大文件，会需要有进度条，因为需要用到它，如果你有兴趣还可以了解一下它的其他属性和事件。最重要的是它的onreadystatechange事件（注意：是全小写）\n\nreadyState 有这些值，每个值都表示有特定的含义\n\n值   状态                 描述\n0   UNSET              代理被创建，但尚未调用 open() 方法。\n1   OPENED             open() 方法已经被调用。\n2   HEADERS_RECEIVED   send() 方法已经被调用，并且头部和状态已经可获得。\n3   LOADING            下载中；responseText 属性已经包含部分数据。\n4   DONE               下载操作已完成。\n\n所以这就是为什么在onstatechange监听处理函数里面需要判断readyState的状态为4\n\nHTTP的状态码200附近的状态码都代表成功相关，300附近的状态都代表重定向相关，因此，如果服务器返回这类状态码就表明已经请求成功了，否则代表请求失败。\n\n最后，可以看到，我们通常在地址上会追加一个变动的参数，这是因为浏览器的缓存机制，当浏览器发现两个请求方式一样，请求地址一样，此时浏览器就会认为它是一致的请求，从而得不到我们预期的结果（幂等性（最主要的特点就是相同情况下，不管执行多少次API，返回的作用效果都是一致的））\n\n\n# 3、选择与服务器的约定通信方式\n\n在Ajax通信过程中，最容易和服务端发生不愉快的场景就是传输格式的约定了。\n\n对于GET， HEAD， DELETE这类不随请求报文发送数据的请求还好，反正只能通过查询字符串的形式向服务端传递数据。\n\n但是对于POST、PUT这类复杂请求，数据会随请求报文一并发送，如果产生跨域的话还会发送OPTIONS预检请求。\n\n这类请求数据传输格式有三种，分别对应的编码格式为application/x-www-form-urlencoded（即设置请求头Content-Type:application/x-www-form-urlencoded，后续两种方式也是，不赘述），这种格式传输的时候，要求服务端以key-value的形式接收数据（跟查询字符串其实差不多），另外一种就是使用application/json的形式发送给服务端，这种形式就是告诉服务端，我给你传递的是一个JSON，你可以直接拿着这个数据进行反序列化就能得到你想要的业务实体类的实例。最后一种就是能够发送二进制的方式，主要是在上传文件这类业务场景才会遇到，使用的编码格式为multipart/form-data。使用这种编码格式传递数据，前端不能使用普通的数据对象，必须使用一个专门的接口，叫做FormData，FormData提供了以key-value设置数据的能力，value可以是二进制数据流，另外对于FormData这个API需要注意的是，如果指定的键已经存在，set会新值覆盖原来的值，而append不会，因此，我们在多文件上传的时候，就可以使用其append方法。\n\n\napplication/json\n\n\napplication/x-www-form-urlencoded\n\n\nmultipart/form-data\n\n\n# 4、跨域 Ajax\n\n跨域Ajax是因为浏览器的安全机制拦截了XHR而导致的，解决跨域Ajax即要从不同的方面来破解浏览器的限制。\n\n# 4.1、同源策略\n\n如果两个URL的protocol（协议）、port（端口）(如果有指定的话)和host（主机）都相同的话，则这两个URL是同源。\n\n下表给出了与URL http://store.company.com/dir/page.html 的源进行对比的示例：\n\nURL                                        结果    原因\nhttp://store.company.com/dir2/other.html   同源    只有路径不同\nhttps://store.company.com/secure.html      不同源   协议不同\nhttp://store.company.com:81/dir/etc.html   不同源   端口不同\nhttp://news.company.com/dir/other.html     不同源   主机不同\n\n# 4.2、跨域 Ajax 的实现方式\n\n跨域Ajax的实现，主流的大概有一下几种方式: jsonp，CORS，代理。\n\n1、jsonp\n\njsonp从原来上来说跟我们的XHR是没有任何关系的，它的原理就是利用像script，img这类可以不受同源策略限制标签，设置其src指向我们想要请求的地址，然后得到服务器返回的内容，然后把它注入到客户端，从而实现的通信方式。这种方式从它的实现方式出发，我们就很容易的知道它只能支持GET这种请求方式。\n\n模拟实现大致如下：\n\n(function (window, document) {\n  "use strict";\n  var jsonp = function (url, data, callback) {\n    // 1.将传入的data数据转化为url字符串形式\n    var dataString = url.indexOf("?") == -1 ? "?" : "&";\n    for (var key in data) {\n      dataString += key + "=" + data[key] + "&";\n    }\n    // 2 处理url中的回调函数\n    // cbFuncName回调函数的名字 ：my_json_cb_名字的前缀 + 随机数（把小数点去掉）\n    var cbFuncName = "my_json_cb_" + Math.random().toString().replace(".", "");\n    dataString += "callback=" + cbFuncName;\n    // 3.创建一个script标签并插入到页面中\n    var scriptEle = document.createElement("script");\n    scriptEle.src = url + dataString;\n    // 4.挂载回调函数\n    window[cbFuncName] = function (data) {\n      callback(data);\n      // 处理完回调函数的数据之后，删除jsonp的script标签\n      document.body.removeChild(scriptEle);\n    };\n    document.body.appendChild(scriptEle);\n  };\n  window.$jsonp = jsonp;\n})(window, document);\n\n\n如果你看不懂上面的代码，我们先来脑补一下，浏览器加载script标签，script文件里面返回的就是一串文本，然后这串文本被解析成JS脚本。现在这个地址被指向到了一个可动态生成文本的地址难道你就不会了吗，那当然是万万不能啦。\n\n简单理解，比如一个接口地址https://www.baidu.com/getProfile，明确要求当你以GET形式访问这个地址的时候，你需要在查询字符串上拼接name，age，callback，然后它向你返回一段文本内容(假设我们传递的callback的值为func)，如下：\n\nfunc({ name: \'yangxu\', age: 28 });\n\n\n那，如果把这个内容写到<script>内部则不就成了一个有效的JS代码了吗？那哪儿来的func可以执行呢，我们事先在访问这个地址之前在window对象上挂载好这个方法不就行了吗。\n\n到现在你应该完全明白JSONP的原理了吧。\n\n2、CORS\n\nCORS（Cross-Origin Resource Sharing，跨源资源共享）是一个系统，它由一系列传输的HTTP标头组成，这些HTTP标头决定浏览器是否阻止前端JS代码获取跨源请求的响应。\n\n我们前面提到的同源安全策略默认阻止“跨源”获取资源。但是CORS给了web服务器这样的权限，即服务器可以选择，允许跨源请求访问到它们的资源。\n\n在我们发送HTTP请求时，会带上一个叫Origin的请求头，如果服务器认为这个请求可以接受，就在Access-Allow-Control-Origin返回它允许的域（*表示任何域来源的请求都允许请求当前服务器），如果没有这个响应头的话，浏览器就会报跨域错误了。\n\n如果是复杂请求（POST、PUT这类带请求数据体的请求）的话，浏览器还会发送一个叫做OPTIONS的预检请求到服务器，服务器经过校验，会根据校验结果，若成功则返回一个200，并且服务器通过Access-Allow-Control-Origin，Access-Allow-Control-Headers，Access-Allow-Control-Methods，Access-Allow-Max-Age等影响头和和浏览器沟通，约定可以允许跨域访问的Origin、Methods，Headers，Max-Age。如果沟通成功，紧接着浏览器就会发送真正的请求。因此，如果在实际的开发中，如果服务端开启了CORS，但是仍然出现跨域错误，先不要慌，看看是否是我们传递的Header是否有不在Access-Allow-Control-Headers范围里面的，如果有，让服务端的同事加上即可。\n\n\nOPTIONS请求\n\n上图中，第二个login请求就是真正的请求。\n\n最后，默认情况下，跨域请求默认不发送凭据，如果需要发送cookie，http认证及客户端SSL的话，客户端需要设置XHR的withCredentials属性为true，而服务器能够接受带凭据的请求的话，会返回一个响应头Access-Control-Allow-Credentials值为true\n\n3、代理\n\n通过代理解决跨域的本质就是绕过浏览器的安全限制，直接把我们需要跨域访问的资源代理到自己的域下，浏览器发现是自己域下的资源，就会放行。实际开发中，我们可以通过配置Nginx实现反向代理可以解决跨域的问题，在Vue或者React等项目的开发中，我们的devServer会内置一个代理中间件，叫做http-proxy-middleware，有兴趣的朋友可以在github上看一看。',normalizedContent:'# ajax\n\najax在某种程度上来说，改变了现代web技术的发展走向。\n\n\n# 1、ajax 的前世今生\n\najax 即 asynchronous javascript and xml在 2005 年被jesse james garrett提出的新术语，用来描述一种使用现有技术集合的‘新’方法，包括: html 或 xhtml（已被html5取代）, css, javascript, dom, xml, xslt（已过时）, 以及最重要的xmlhttprequest（后文简称xhr）。 使用ajax技术网页应用能够快速地将增量更新呈现在用户界面上，而不需要重载（刷新）整个页面，这使得程序能够更快地回应用户的操作。\n\n在没有ajax技术的时候，前端想要向后端交互数据必须整页的提交，给用户的感觉就是整个页面刷一下，有了这项技术以后便可以局部更新页面，随着后来前端技术的发展（angular、react、vue等框架的出现），服务端不再负责页面的渲染，逐渐发展成为了现在的前后端分离的开发模式，即前端负责渲染页面，通过 ajax技术和后端进行数据的交互，因为不再需要需要整页的向服务器提交数据了，所以我们的页面不再发生跳转，所以看起来就像一个客户端应用一样，即单页面应用程序(spa)。\n\n在实际的开发中，我们已经不再需要自己手写ajax的实现，几乎都是用成熟的库，比如大名鼎鼎的axios，后面各大浏览器厂商甚至直接支持了一个类似axios这样的请求api，fetch。\n\n另外，虽然说a代表的含义是异步，但是并不是说ajax只能异步处理，也可以同步处理，但是几乎不用，因为如果是同步的ajax，在服务端没有返回的这个过程中，浏览器是无法响应用户的操作的，造成界面的假死，这是非常影响用户体验的；早期和服务端的通信采用xml语言，但是xml是比较笨重的，因此现在普遍的方式都是采用轻量的json（javascript object notation）格式进行通信。\n\n\n# 2、原生 ajax 的实现\n\n我们模拟实现一个能满足80%日常工作的ajax函数，实现如下：\n\nfunction myajax(params) {\n  params = params || {};\n  params.data = params.data || {};\n  // ajax请求\n  function json(params) {\n    // 请求方式，默认是get\n    params.type = (params.type || "get").touppercase();\n    // 避免有特殊字符，必须格式化传输数据\n    params.data = formatparams(params.data);\n    var xhr = null;\n    // 实例化xmlhttprequest对象\n    if (window.xmlhttprequest) {\n      xhr = new xmlhttprequest();\n    } else {\n      // ie6及其以下版本\n      xhr = new activexobjcet("microsoft.xmlhttp");\n    }\n    // 监听事件，只要 readystate 的值变化，就会调用 readystatechange 事件\n    xhr.onreadystatechange = function () {\n      // readystate属性表示请求/响应过程的当前活动阶段，4为完成，已经接收到全部响应数据\n      if (xhr.readystate == 4) {\n        var status = xhr.status;\n        // status：响应的http状态码，以2开头的都是成功\n        if (status >= 200 && status < 300) {\n          var response = "";\n          // 判断接受数据的内容类型\n          var type = xhr.getresponseheader("content-type");\n          if (type.indexof("xml") !== -1 && xhr.responsexml) {\n            response = xhr.responsexml; //document对象响应\n          } else if (type === "application/json") {\n            response = json.parse(xhr.responsetext); //json响应\n          } else {\n            response = xhr.responsetext; //字符串响应\n          }\n          // 成功回调函数\n          params.success && params.success(response);\n        } else {\n          params.error && params.error(status);\n        }\n      }\n    };\n    // 连接和传输数据\n    if (params.type == "get") {\n      // 三个参数：请求方式、请求地址(get方式时，传输数据是加在地址后的)、是否异步请求(同步请求的情况极少)；\n      xhr.open(params.type, params.url + "?" + params.data, true);\n      xhr.send(null);\n    } else {\n      xhr.open(params.type, params.url, true);\n      //必须，设置提交时的内容类型\n      xhr.setrequestheader(\n        "content-type",\n        "application/x-www-form-urlencoded; charset=utf-8"\n      );\n      // 传输数据\n      xhr.send(params.data);\n    }\n  }\n\n  //格式化参数\n  function formatparams(data) {\n    var arr = [];\n    for (var name in data) {\n      // encodeuricomponent() ：用于对 uri 中的某一部分进行编码\n      arr.push(encodeuricomponent(name) + "=" + encodeuricomponent(data[name]));\n    }\n    // 添加一个随机数参数，防止缓存\n    arr.push("v=" + random());\n    return arr.join("&");\n  }\n\n  // 获取随机数\n  function random() {\n    return math.floor(math.random() * 10000 + 500);\n  }\n}\n\n\n上述代码中，有很多个关键点，我们逐一进行解释。\n\n首先，在很久很久以前，ie6还在的时候，它还不支持xmlhttprequest(即xhr)对象，只能用activexobjcet插件。\n\n接着，xmlhttprequest对象有很多属性，比如常用的readystate，responsetype, 也有很多事件是可以监听的，只不过这些事件或属性我们几乎很少用到，比如onabort在取消请求的时候会触发，ononprogress，在上传文件的时候，如果是大文件，会需要有进度条，因为需要用到它，如果你有兴趣还可以了解一下它的其他属性和事件。最重要的是它的onreadystatechange事件（注意：是全小写）\n\nreadystate 有这些值，每个值都表示有特定的含义\n\n值   状态                 描述\n0   unset              代理被创建，但尚未调用 open() 方法。\n1   opened             open() 方法已经被调用。\n2   headers_received   send() 方法已经被调用，并且头部和状态已经可获得。\n3   loading            下载中；responsetext 属性已经包含部分数据。\n4   done               下载操作已完成。\n\n所以这就是为什么在onstatechange监听处理函数里面需要判断readystate的状态为4\n\nhttp的状态码200附近的状态码都代表成功相关，300附近的状态都代表重定向相关，因此，如果服务器返回这类状态码就表明已经请求成功了，否则代表请求失败。\n\n最后，可以看到，我们通常在地址上会追加一个变动的参数，这是因为浏览器的缓存机制，当浏览器发现两个请求方式一样，请求地址一样，此时浏览器就会认为它是一致的请求，从而得不到我们预期的结果（幂等性（最主要的特点就是相同情况下，不管执行多少次api，返回的作用效果都是一致的））\n\n\n# 3、选择与服务器的约定通信方式\n\n在ajax通信过程中，最容易和服务端发生不愉快的场景就是传输格式的约定了。\n\n对于get， head， delete这类不随请求报文发送数据的请求还好，反正只能通过查询字符串的形式向服务端传递数据。\n\n但是对于post、put这类复杂请求，数据会随请求报文一并发送，如果产生跨域的话还会发送options预检请求。\n\n这类请求数据传输格式有三种，分别对应的编码格式为application/x-www-form-urlencoded（即设置请求头content-type:application/x-www-form-urlencoded，后续两种方式也是，不赘述），这种格式传输的时候，要求服务端以key-value的形式接收数据（跟查询字符串其实差不多），另外一种就是使用application/json的形式发送给服务端，这种形式就是告诉服务端，我给你传递的是一个json，你可以直接拿着这个数据进行反序列化就能得到你想要的业务实体类的实例。最后一种就是能够发送二进制的方式，主要是在上传文件这类业务场景才会遇到，使用的编码格式为multipart/form-data。使用这种编码格式传递数据，前端不能使用普通的数据对象，必须使用一个专门的接口，叫做formdata，formdata提供了以key-value设置数据的能力，value可以是二进制数据流，另外对于formdata这个api需要注意的是，如果指定的键已经存在，set会新值覆盖原来的值，而append不会，因此，我们在多文件上传的时候，就可以使用其append方法。\n\n\napplication/json\n\n\napplication/x-www-form-urlencoded\n\n\nmultipart/form-data\n\n\n# 4、跨域 ajax\n\n跨域ajax是因为浏览器的安全机制拦截了xhr而导致的，解决跨域ajax即要从不同的方面来破解浏览器的限制。\n\n# 4.1、同源策略\n\n如果两个url的protocol（协议）、port（端口）(如果有指定的话)和host（主机）都相同的话，则这两个url是同源。\n\n下表给出了与url http://store.company.com/dir/page.html 的源进行对比的示例：\n\nurl                                        结果    原因\nhttp://store.company.com/dir2/other.html   同源    只有路径不同\nhttps://store.company.com/secure.html      不同源   协议不同\nhttp://store.company.com:81/dir/etc.html   不同源   端口不同\nhttp://news.company.com/dir/other.html     不同源   主机不同\n\n# 4.2、跨域 ajax 的实现方式\n\n跨域ajax的实现，主流的大概有一下几种方式: jsonp，cors，代理。\n\n1、jsonp\n\njsonp从原来上来说跟我们的xhr是没有任何关系的，它的原理就是利用像script，img这类可以不受同源策略限制标签，设置其src指向我们想要请求的地址，然后得到服务器返回的内容，然后把它注入到客户端，从而实现的通信方式。这种方式从它的实现方式出发，我们就很容易的知道它只能支持get这种请求方式。\n\n模拟实现大致如下：\n\n(function (window, document) {\n  "use strict";\n  var jsonp = function (url, data, callback) {\n    // 1.将传入的data数据转化为url字符串形式\n    var datastring = url.indexof("?") == -1 ? "?" : "&";\n    for (var key in data) {\n      datastring += key + "=" + data[key] + "&";\n    }\n    // 2 处理url中的回调函数\n    // cbfuncname回调函数的名字 ：my_json_cb_名字的前缀 + 随机数（把小数点去掉）\n    var cbfuncname = "my_json_cb_" + math.random().tostring().replace(".", "");\n    datastring += "callback=" + cbfuncname;\n    // 3.创建一个script标签并插入到页面中\n    var scriptele = document.createelement("script");\n    scriptele.src = url + datastring;\n    // 4.挂载回调函数\n    window[cbfuncname] = function (data) {\n      callback(data);\n      // 处理完回调函数的数据之后，删除jsonp的script标签\n      document.body.removechild(scriptele);\n    };\n    document.body.appendchild(scriptele);\n  };\n  window.$jsonp = jsonp;\n})(window, document);\n\n\n如果你看不懂上面的代码，我们先来脑补一下，浏览器加载script标签，script文件里面返回的就是一串文本，然后这串文本被解析成js脚本。现在这个地址被指向到了一个可动态生成文本的地址难道你就不会了吗，那当然是万万不能啦。\n\n简单理解，比如一个接口地址https://www.baidu.com/getprofile，明确要求当你以get形式访问这个地址的时候，你需要在查询字符串上拼接name，age，callback，然后它向你返回一段文本内容(假设我们传递的callback的值为func)，如下：\n\nfunc({ name: \'yangxu\', age: 28 });\n\n\n那，如果把这个内容写到<script>内部则不就成了一个有效的js代码了吗？那哪儿来的func可以执行呢，我们事先在访问这个地址之前在window对象上挂载好这个方法不就行了吗。\n\n到现在你应该完全明白jsonp的原理了吧。\n\n2、cors\n\ncors（cross-origin resource sharing，跨源资源共享）是一个系统，它由一系列传输的http标头组成，这些http标头决定浏览器是否阻止前端js代码获取跨源请求的响应。\n\n我们前面提到的同源安全策略默认阻止“跨源”获取资源。但是cors给了web服务器这样的权限，即服务器可以选择，允许跨源请求访问到它们的资源。\n\n在我们发送http请求时，会带上一个叫origin的请求头，如果服务器认为这个请求可以接受，就在access-allow-control-origin返回它允许的域（*表示任何域来源的请求都允许请求当前服务器），如果没有这个响应头的话，浏览器就会报跨域错误了。\n\n如果是复杂请求（post、put这类带请求数据体的请求）的话，浏览器还会发送一个叫做options的预检请求到服务器，服务器经过校验，会根据校验结果，若成功则返回一个200，并且服务器通过access-allow-control-origin，access-allow-control-headers，access-allow-control-methods，access-allow-max-age等影响头和和浏览器沟通，约定可以允许跨域访问的origin、methods，headers，max-age。如果沟通成功，紧接着浏览器就会发送真正的请求。因此，如果在实际的开发中，如果服务端开启了cors，但是仍然出现跨域错误，先不要慌，看看是否是我们传递的header是否有不在access-allow-control-headers范围里面的，如果有，让服务端的同事加上即可。\n\n\noptions请求\n\n上图中，第二个login请求就是真正的请求。\n\n最后，默认情况下，跨域请求默认不发送凭据，如果需要发送cookie，http认证及客户端ssl的话，客户端需要设置xhr的withcredentials属性为true，而服务器能够接受带凭据的请求的话，会返回一个响应头access-control-allow-credentials值为true\n\n3、代理\n\n通过代理解决跨域的本质就是绕过浏览器的安全限制，直接把我们需要跨域访问的资源代理到自己的域下，浏览器发现是自己域下的资源，就会放行。实际开发中，我们可以通过配置nginx实现反向代理可以解决跨域的问题，在vue或者react等项目的开发中，我们的devserver会内置一个代理中间件，叫做http-proxy-middleware，有兴趣的朋友可以在github上看一看。',charsets:{cjk:!0}},{title:"JavaScript异步技术的发展进程",frontmatter:{},regularPath:"/javascript/async-development-history.html",relativePath:"javascript/async-development-history.md",key:"v-03ef4303",path:"/javascript/async-development-history.html",headers:[{level:2,title:"JavaScript异步技术的发展进程",slug:"javascript异步技术的发展进程",normalizedTitle:"javascript异步技术的发展进程",charIndex:2},{level:3,title:"1、回调函数",slug:"_1、回调函数",normalizedTitle:"1、回调函数",charIndex:1511},{level:3,title:"2、Promise",slug:"_2、promise",normalizedTitle:"2、promise",charIndex:2168},{level:3,title:"3、async函数",slug:"_3、async函数",normalizedTitle:"3、async函数",charIndex:3395}],headersStr:"JavaScript异步技术的发展进程 1、回调函数 2、Promise 3、async函数",content:'# JavaScript异步技术的发展进程\n\n一直流传着一个说法是JavaScript是一门单线程的语言，其实这个说法是不科学的，准确的说是因为我们写的JS代码运行在一个浏览器的JS执行线程 中。因为受宿主环境的限制，所以JS无法像其它语言一样，在主线程上再开启其它的工作线程（本文不讨论Web Worker）。\n\n因为浏览器只有一个线程在执行JS代码，如何利用这个线程高效的完成各式各样的操作就成了一个复杂的问题。\n\n于是，就有了一个叫做事件轮循的处理机制，具体事件轮循的做法是这样的，JS执行线程会开启一个无限循环，有一个任务队列用来存储任务，每次JS执行线程从任务队列里面取出一个任务进行处理，这个任务又有可能将新的JS代码包裹成任务加入到任务队列中（比如setTimeout），如果任务队列中已经没有任务了，那么JS执行线程休眠，待到有新的任务加入到任务队列，JS执行线程取消休眠并重新开始工作。随着浏览器越来越复杂，单单一个任务队列已经无法满足需求，于是又多了新的微任务队列，这个微任务队列的优先级比较高，当每个任务完成之后，总是需要将微任务队列里面的所有任务执行完成之后才能继续取出任务队列里面的任务开始执行。\n\n由于JS的这套任务处理机制，所以时间的准确性就不能得到保证了，就比如某个任务超级复杂，一直在执行，那么后面等待的任务将会推迟，这就解释了为什么setTimeout，setInterval这类操作时间执行时机不准的原因（比如setTimeout，表示的是告诉JS，在多长时间之后将这个任务加到任务队列去）。\n\n之前我们一直在说异步，什么是同步呢？就是除开setTimeout，setInterval，Promise.then, MutationObserver，process.nextTick这类能够将代码块包装成新的任务或者微任务的代码。\n\n比如：\n\nfunction demo() {\n  let d1 = new Date();\n  while (Date.now() - d1.getTime() <= 2000) {}\n  console.log("模拟耗时操作完成");\n}\n\n\n简言之，一个任务里面的所有代码和异步任务无关的就是同步代码。（有点儿听君一席话，如听君一席话的感觉哈）\n\n紧接着，我们还可以看一下这样的代码：\n\nfunction callFnDemo() {\n  console.log("函数调用");\n  callFnDemo();\n}\n\n\n毫无疑问，这个操作肯定会出现Uncaught RangeError: Maximum call stack size exceeded at callFnDemo。为什么呢？因为在一个任务内，JS执行栈的长度是有限的，无限的递归调用肯定会出现把栈占用完的情况的。\n\n但是，以下代码并不会出现爆栈的情况\n\nfunction callTask() {\n  console.log("函数调用");\n  setTimeout(callTask, 0);\n}\n\n\n区别在哪儿？回到最开始我们提到的任务队列相关的知识点，这个操作相当于是无限的在往JS执行程任务的队列里面加任务，每做完一个，新的任务又来了，没完没了。\n\n所以，一个是在无限的往执行栈加内容，一个是无限的在跟任务队列加任务，前者会导致爆栈，后者会导致浏览器一直都在处理任务。并且，凡是和异步操作相关的for、while、递归这些都不是我们所写的代码那样的运行流程，并且try-catch捕获不到这些操作的错误。\n\nDANGER\n\n耗时的同步操作会导致浏览器假死\n\n\n# 1、回调函数\n\n在解释清楚了JS的事件轮循之后，再来看回调函数。\n\n某些操作它并不是马上就能够得到结果的，比如给一个元素加上点击事件，而用户什么时候点击，取决于用户的操作。回调函数的方案解决了JS中某些操作执行时间不准确的问题（使得用户不再关心什么时间执行了，反正到了那个触发条件它就会执行，别的咱什么都不管，什么也不说）\n\n比如:\n\nfunction addEventDemo() {\n  const divElements = [...document.querySelectorAll("div")];\n  divElements.addEventListeners("click", function (ev) {\n    console.log(ev, "我被点击了");\n  });\n}\n\n\n但是，随着应用程序的越来越庞大与复杂，就会出现在回调函数中再套回调函数的场景，尤其是nodejs很多API都是异步的(nodejs异步 API 的设计标准：最后一个参数是回调函数，回调函数的第一个参数是err，null则代表操作无错，否则代表是操作产生的错误信息)，这种代码的设计对于后期的维护将是一种灾难。\n\na.on("click", function () {\n  b.on("ready", function () {\n    c.on("write", function () {\n      d.on("send", function () {});\n    });\n  });\n});\n\n\n\n# 2、Promise\n\n本文不做Promise的API介绍，在这个位置可以看一下我自行实现的所有Promise的方法，也可以查看阮一峰老师关于Promise知识点的阐述。\n\n因为回调函数的问题，Promise产生了，Promise将嵌套的回调操作打平了成了一个Promise链。\n\n比如上述回调地狱的问题，用Promise改写，可以写成如下形式：\n\nfunction optA() {\n  return new Promise((resolve, reject) => {\n    a.on("click", function () {\n      resolve();\n    });\n  });\n}\n\nfunction optB() {\n  return new Promise((resolve, reject) => {\n    b.on("ready", function () {\n      resolve();\n    });\n  });\n}\n\nfunction optC() {\n  return new Promise((resolve, reject) => {\n    c.on("write", function () {\n      resolve();\n    });\n  });\n}\n\nfunction optD() {\n  return new Promise((resolve, reject) => {\n    d.on("send", function () {\n      resolve();\n    });\n  });\n}\n\noptA()\n  .then(() => {\n    return optB();\n  })\n  .then(() => {\n    return optC();\n  })\n  .then(() => {\n    return optD();\n  })\n  .then(() => {\n    // do something\n  });\n\n\n谁要是能够用Promise把代码写成如下形式，我恳请您早点儿转行\n\noptA().then(() => {\n  optB().then(() => {\n    optC().then(() => {\n      optD().then(() => {\n        // do something\n      });\n    });\n  });\n});\n\n\n但是Promise只解决了一时的问题，它解决不了所有的问题。\n\nPromise的包裹，使得我们代码复杂化了，业务开发者并不能专注于其业务本身，多了一堆的then包裹。\n\n还有一个问题，就比如，我们想要某个异步操作执行成功之后再执行的操作，只能写到then里面去，逻辑上不直观。\n\n不过技术的进步不是一下子就演化成那样子的，这相对于回调函数的编码方式还是算一个很大的进步了。\n\n\n# 3、async函数\n\n因为Promise的问题，所以才有了async函数的出现，async函数中的代码让你在逻辑上看起来跟代码的执行过程接近，没有了Promise的包裹，开发者可以聚焦于业务代码。',normalizedContent:'# javascript异步技术的发展进程\n\n一直流传着一个说法是javascript是一门单线程的语言，其实这个说法是不科学的，准确的说是因为我们写的js代码运行在一个浏览器的js执行线程 中。因为受宿主环境的限制，所以js无法像其它语言一样，在主线程上再开启其它的工作线程（本文不讨论web worker）。\n\n因为浏览器只有一个线程在执行js代码，如何利用这个线程高效的完成各式各样的操作就成了一个复杂的问题。\n\n于是，就有了一个叫做事件轮循的处理机制，具体事件轮循的做法是这样的，js执行线程会开启一个无限循环，有一个任务队列用来存储任务，每次js执行线程从任务队列里面取出一个任务进行处理，这个任务又有可能将新的js代码包裹成任务加入到任务队列中（比如settimeout），如果任务队列中已经没有任务了，那么js执行线程休眠，待到有新的任务加入到任务队列，js执行线程取消休眠并重新开始工作。随着浏览器越来越复杂，单单一个任务队列已经无法满足需求，于是又多了新的微任务队列，这个微任务队列的优先级比较高，当每个任务完成之后，总是需要将微任务队列里面的所有任务执行完成之后才能继续取出任务队列里面的任务开始执行。\n\n由于js的这套任务处理机制，所以时间的准确性就不能得到保证了，就比如某个任务超级复杂，一直在执行，那么后面等待的任务将会推迟，这就解释了为什么settimeout，setinterval这类操作时间执行时机不准的原因（比如settimeout，表示的是告诉js，在多长时间之后将这个任务加到任务队列去）。\n\n之前我们一直在说异步，什么是同步呢？就是除开settimeout，setinterval，promise.then, mutationobserver，process.nexttick这类能够将代码块包装成新的任务或者微任务的代码。\n\n比如：\n\nfunction demo() {\n  let d1 = new date();\n  while (date.now() - d1.gettime() <= 2000) {}\n  console.log("模拟耗时操作完成");\n}\n\n\n简言之，一个任务里面的所有代码和异步任务无关的就是同步代码。（有点儿听君一席话，如听君一席话的感觉哈）\n\n紧接着，我们还可以看一下这样的代码：\n\nfunction callfndemo() {\n  console.log("函数调用");\n  callfndemo();\n}\n\n\n毫无疑问，这个操作肯定会出现uncaught rangeerror: maximum call stack size exceeded at callfndemo。为什么呢？因为在一个任务内，js执行栈的长度是有限的，无限的递归调用肯定会出现把栈占用完的情况的。\n\n但是，以下代码并不会出现爆栈的情况\n\nfunction calltask() {\n  console.log("函数调用");\n  settimeout(calltask, 0);\n}\n\n\n区别在哪儿？回到最开始我们提到的任务队列相关的知识点，这个操作相当于是无限的在往js执行程任务的队列里面加任务，每做完一个，新的任务又来了，没完没了。\n\n所以，一个是在无限的往执行栈加内容，一个是无限的在跟任务队列加任务，前者会导致爆栈，后者会导致浏览器一直都在处理任务。并且，凡是和异步操作相关的for、while、递归这些都不是我们所写的代码那样的运行流程，并且try-catch捕获不到这些操作的错误。\n\ndanger\n\n耗时的同步操作会导致浏览器假死\n\n\n# 1、回调函数\n\n在解释清楚了js的事件轮循之后，再来看回调函数。\n\n某些操作它并不是马上就能够得到结果的，比如给一个元素加上点击事件，而用户什么时候点击，取决于用户的操作。回调函数的方案解决了js中某些操作执行时间不准确的问题（使得用户不再关心什么时间执行了，反正到了那个触发条件它就会执行，别的咱什么都不管，什么也不说）\n\n比如:\n\nfunction addeventdemo() {\n  const divelements = [...document.queryselectorall("div")];\n  divelements.addeventlisteners("click", function (ev) {\n    console.log(ev, "我被点击了");\n  });\n}\n\n\n但是，随着应用程序的越来越庞大与复杂，就会出现在回调函数中再套回调函数的场景，尤其是nodejs很多api都是异步的(nodejs异步 api 的设计标准：最后一个参数是回调函数，回调函数的第一个参数是err，null则代表操作无错，否则代表是操作产生的错误信息)，这种代码的设计对于后期的维护将是一种灾难。\n\na.on("click", function () {\n  b.on("ready", function () {\n    c.on("write", function () {\n      d.on("send", function () {});\n    });\n  });\n});\n\n\n\n# 2、promise\n\n本文不做promise的api介绍，在这个位置可以看一下我自行实现的所有promise的方法，也可以查看阮一峰老师关于promise知识点的阐述。\n\n因为回调函数的问题，promise产生了，promise将嵌套的回调操作打平了成了一个promise链。\n\n比如上述回调地狱的问题，用promise改写，可以写成如下形式：\n\nfunction opta() {\n  return new promise((resolve, reject) => {\n    a.on("click", function () {\n      resolve();\n    });\n  });\n}\n\nfunction optb() {\n  return new promise((resolve, reject) => {\n    b.on("ready", function () {\n      resolve();\n    });\n  });\n}\n\nfunction optc() {\n  return new promise((resolve, reject) => {\n    c.on("write", function () {\n      resolve();\n    });\n  });\n}\n\nfunction optd() {\n  return new promise((resolve, reject) => {\n    d.on("send", function () {\n      resolve();\n    });\n  });\n}\n\nopta()\n  .then(() => {\n    return optb();\n  })\n  .then(() => {\n    return optc();\n  })\n  .then(() => {\n    return optd();\n  })\n  .then(() => {\n    // do something\n  });\n\n\n谁要是能够用promise把代码写成如下形式，我恳请您早点儿转行\n\nopta().then(() => {\n  optb().then(() => {\n    optc().then(() => {\n      optd().then(() => {\n        // do something\n      });\n    });\n  });\n});\n\n\n但是promise只解决了一时的问题，它解决不了所有的问题。\n\npromise的包裹，使得我们代码复杂化了，业务开发者并不能专注于其业务本身，多了一堆的then包裹。\n\n还有一个问题，就比如，我们想要某个异步操作执行成功之后再执行的操作，只能写到then里面去，逻辑上不直观。\n\n不过技术的进步不是一下子就演化成那样子的，这相对于回调函数的编码方式还是算一个很大的进步了。\n\n\n# 3、async函数\n\n因为promise的问题，所以才有了async函数的出现，async函数中的代码让你在逻辑上看起来跟代码的执行过程接近，没有了promise的包裹，开发者可以聚焦于业务代码。',charsets:{cjk:!0}},{title:"闭包",frontmatter:{},regularPath:"/javascript/closure.html",relativePath:"javascript/closure.md",key:"v-5ed5b2a2",path:"/javascript/closure.html",headers:[{level:2,title:"闭包",slug:"闭包",normalizedTitle:"闭包",charIndex:2}],headersStr:"闭包",content:'# 闭包\n\nconst test = 2;\nconst o = (function () {\n  const obj = {\n    a: 1,\n    b: 2,\n  };\n  return {\n    get(prop) {\n      return obj[prop];\n    },\n  };\n})();\n\n// Object.defineProperty(Object.prototype, "abc", {\n//   get() {\n//     return this;\n//   },\n// });\n\n// const obj = o.get("abc");\n\n// delete obj.a;\n\n// delete obj.b;\n\n// console.log(o.get("a"));\n',normalizedContent:'# 闭包\n\nconst test = 2;\nconst o = (function () {\n  const obj = {\n    a: 1,\n    b: 2,\n  };\n  return {\n    get(prop) {\n      return obj[prop];\n    },\n  };\n})();\n\n// object.defineproperty(object.prototype, "abc", {\n//   get() {\n//     return this;\n//   },\n// });\n\n// const obj = o.get("abc");\n\n// delete obj.a;\n\n// delete obj.b;\n\n// console.log(o.get("a"));\n',charsets:{cjk:!0}},{title:"async 函数",frontmatter:{},regularPath:"/javascript/es6/async.html",relativePath:"javascript/es6/async.md",key:"v-a865930a",path:"/javascript/es6/async.html",headers:[{level:2,title:"async 函数",slug:"async-函数",normalizedTitle:"async 函数",charIndex:2},{level:3,title:"1、基本使用",slug:"_1、基本使用",normalizedTitle:"1、基本使用",charIndex:230},{level:3,title:"2、使用的注意点",slug:"_2、使用的注意点",normalizedTitle:"2、使用的注意点",charIndex:1579},{level:3,title:"3、async 函数的实现原理",slug:"_3、async-函数的实现原理",normalizedTitle:"3、async 函数的实现原理",charIndex:2779}],headersStr:"async 函数 1、基本使用 2、使用的注意点 3、async 函数的实现原理",content:'# async 函数\n\nJS是一门单线程的语言，但是JS中的异步编程的场景太常见了，async函数作为JS异步编程解决方案的王炸，对于async函数大家都想必都比较熟悉。\n\n而async函数是Generator的语法糖，但是Generator又是ES6中最难的语法，本文重点不在于阐述async函数的使用，而专注于其底层的运行原理，我们将从babel编译的结果来研究async函数的原理，希望您在阅读本文之前，已掌握Generator底层的运行原理。\n\n\n# 1、基本使用\n\nasync函数的返回结果是一个Promise，也就是说，不管你包不包装这个对象为Promise，它都将给你包装成Promise，比如：\n\nasync function func() {\n  await 1;\n  return Promise.resolve(true);\n}\n\n\n和以下代码是等价的:\n\nasync function func() {\n  await 1;\n  return true;\n}\n\n\n比如，我们可以使用async函数实现一个sleep函数。\n\nfunction sleep(ms) {\n  return new Promise((resolve, reject) => {\n    setTimeout(resolve, ms);\n  });\n}\n\nasync function eventHandler() {\n  // 等待1S，继续后续的业务逻辑\n  await sleep(1000);\n  console.log("执行一些逻辑");\n}\n\n\nawait后面的代码是微任务执行的，而await之前的代码是在同步任务执行的(包括这行)。\n\n比如有以下代码：\n\nasync function func() {\n  console.log(1);\n  await something();\n  console.log(2);\n}\n\n\n等价于:\n\nfunction func() {\n  new Promise(() => {\n    console.log(1);\n    return something();\n  }).then(() => {\n    console.log(2);\n  });\n}\n\n\n下面是一道JS事件循环常考的面试题：\n\n//请写出输出内容\nasync function async1() {\n  console.log("async1 start");\n  await async2();\n  console.log("async1 end");\n}\nasync function async2() {\n  console.log("async2");\n}\n\nconsole.log("script start");\n\nsetTimeout(function () {\n  console.log("setTimeout");\n}, 0);\n\nasync1();\n\nnew Promise(function (resolve) {\n  console.log("promise1");\n  resolve();\n}).then(function () {\n  console.log("promise2");\n});\nconsole.log("script end");\n\n/*\nscript start\nasync1 start\nasync2\npromise1\nscript end\nasync1 end\npromise2\nsetTimeout\n*/\n\n\n另外，对于await表达式，其实表示的含义就是如果await后面跟随的表达式的如果是一个Promise的话，则取出Promise的值，否则直接取其原值。\n\n\n# 2、使用的注意点\n\n最好把await命令放在try...catch代码块中，因为一旦一个await表达式发生错误，后续的流程就不会再执行了，这点我们一会儿可以在babel编译的结果中看到为什么。\n\n然后，async函数是不能够使用new调用的，为什么呢？从现象上来说，因为async函数没有prototype属性，从原理上来讲的话，async函数是基于Generator的，Generator函数是不能被用作new调用的，因为async函数当然也不能被用作new调用了。\n\n另外一个比较重要的注意点是，多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。\n\n比如下述代码：\n\nasync function func() {\n  let foo = await getFoo();\n  let bar = await getBar();\n}\n\n\n需要首先执行getFoo等getFoo变成fulfilled之后，才会再执行getBar。在有些时候，两个操作流程并没有先后顺序的要求，对于用户而已，更快的数据到达是较好的选择，因此，这种场景下，需要写成以下形式：\n\n// 写法一\nlet [foo, bar] = await Promise.all([getFoo(), getBar()]);\n\n// 写法二\nlet fooPromise = getFoo();\nlet barPromise = getBar();\nlet foo = await fooPromise;\nlet bar = await barPromise;\n\n\n上述的写法1大家可能比较好理解，但是写法2可能就会比较迷惑了，这样理解就行了，首先，我们没有通过用await关键字来调用getFoo和getBar，也就是说，在同一时刻，这两个操作就已经执行了，但是，只不过要必须fooPromise的状态为fulfilled才能执行取barPromise状态的逻辑，而实际上两者并没有先后顺序，请读者体会其中的区别。\n\n如何判断一个函数是否是async函数呢，其实方法非常简单：\n\n// 方法一\nconst isAsyncFunc = (val) => {\n  return val && val[Symbol.toStringTag] === "AsyncFunction";\n};\n\n// 方法二\nconst isAsyncFunc = (func) => {\n  return (\n    typeof func === "function" &&\n    Object.prototype.toString.call(func) === "[object AsyncFunction]"\n  );\n};\n\n\n明显感觉方法一要优雅很多，对于这个用法不太清楚的同学可以参考Symbol相关的知识点。\n\n\n# 3、async 函数的实现原理\n\n对于以下代码，我们看看babel将会把它编译成什么样子\n\nasync function func() {\n  const val1 = await 1;\n  const val2 = await (2 + val1);\n  const val3 = await (3 + val2);\n  const val4 = await (4 + val3);\n  return val4;\n}\n\n\nbabel编译之后的结果(为了篇幅，已经省略了generator-runtime的部分):\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    // 如果执行出错，提前结束\n    reject(error);\n    return;\n  }\n  // 如果Generator已经迭代完成，直接把最终的返回值报告给外部的Promise，作为它的fulfilled值，结束递归\n  if (info.done) {\n    resolve(value);\n  } else {\n    // 没有完成，把本轮的值包裹，最为入参传递给下一个next或者throw的调用\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  // fn就是一个Generator，执行它可以得到一个迭代器\n  return function () {\n    var self = this,\n      args = arguments;\n    return new Promise(function (resolve, reject) {\n      // 得到一个由Generator执行得到的迭代器\n      var gen = fn.apply(self, args);\n      // 定义next函数\n      function _next(value) {\n        // 递归的调用next，以使得Generator执行得到的迭代器可以一直向后迭代\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);\n      }\n      // 定义错误处理函数\n      function _throw(err) {\n        // 递归的调用throw，以使得Generator执行得到的迭代器可以一直向后迭代\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);\n      }\n      // 开始迭代，因为第一个next不能有参数，所以就传递了一个undefined\n      _next(undefined);\n    });\n  };\n}\n\nfunction func() {\n  return _func.apply(this, arguments);\n}\n\nfunction _func() {\n  _func = _asyncToGenerator(\n    // 得到一个Generator，这个Generator执行就可以得到一个迭代器\n    /*#__PURE__*/ _regeneratorRuntime().mark(function _callee() {\n      var val1, val2, val3, val4;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) {\n          switch ((_context.prev = _context.next)) {\n            case 0:\n              _context.next = 2;\n              return 1;\n\n            case 2:\n              val1 = _context.sent;\n              _context.next = 5;\n              return 2 + val1;\n\n            case 5:\n              val2 = _context.sent;\n              _context.next = 8;\n              return 3 + val2;\n\n            case 8:\n              val3 = _context.sent;\n              _context.next = 11;\n              return 4 + val3;\n\n            case 11:\n              val4 = _context.sent;\n              return _context.abrupt("return", val4);\n\n            case 13:\n            case "end":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    })\n  );\n  // 向外界返回一个Promise\n  return _func.apply(this, arguments);\n}\n\n\nasync函数的本质是Generator，但是Generator的使用是相当麻烦的，你得运行它，然后不断的调用next直到迭代完成，而async函数直接就在内部帮我们把这个事儿做了，你就只需要专注于业务代码就好了。\n\n首先分析asyncGeneratorStep这个函数，当所有的await语句都走完了之后，返回状态为fulfilled结果，如果中途产生错误则提前终止了，这就是为什么前文提到因为一旦await后面的表达式发生错误，后续的流程就不会再执行了的原因。如果还没有将当前的迭代器迭代完成，则继续向后迭代，为什么是这样的呢？\n\nfunction _next(value) {\n  asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);\n}\n\n\n因为在这个位置，_next函数被用作了参数传递到asyncGeneratorStep，这儿是一个递归调用，而递归的退出条件呢？要么执行完，要么出现错误。\n\n然后，可以看到_asyncToGenerator这个函数返回值是个匿名函数，并且这个匿名函数的返回值是一个Promise，这也就应证了前文所说的，在async函数中没有必要刻意的对返回值进行Promise.resolve这样的操作。\n\n最后，为什么在第一次调用_next函数的时候传递的是undefined，因为Generator节，我们讲过，其在第一个next方法的时候是无法传递参数的。\n\n另外，这个是在阮一峰老师ES6入门书籍里面他给出的spawn函数的实现。\n\nfunction spawn(genF) {\n  return new Promise(function (resolve, reject) {\n    const gen = genF();\n    function step(nextF) {\n      let next;\n      try {\n        next = nextF();\n      } catch (e) {\n        return reject(e);\n      }\n      if (next.done) {\n        return resolve(next.value);\n      }\n      Promise.resolve(next.value).then(\n        function (v) {\n          step(function () {\n            return gen.next(v);\n          });\n        },\n        function (e) {\n          step(function () {\n            return gen.throw(e);\n          });\n        }\n      );\n    }\n    step(function () {\n      return gen.next(undefined);\n    });\n  });\n}\n\n\n上述实现嵌套的层级较多，意思都是一个，但是从可读性来说，我个人感觉不如babel编译之后的代码，不喜勿喷。',normalizedContent:'# async 函数\n\njs是一门单线程的语言，但是js中的异步编程的场景太常见了，async函数作为js异步编程解决方案的王炸，对于async函数大家都想必都比较熟悉。\n\n而async函数是generator的语法糖，但是generator又是es6中最难的语法，本文重点不在于阐述async函数的使用，而专注于其底层的运行原理，我们将从babel编译的结果来研究async函数的原理，希望您在阅读本文之前，已掌握generator底层的运行原理。\n\n\n# 1、基本使用\n\nasync函数的返回结果是一个promise，也就是说，不管你包不包装这个对象为promise，它都将给你包装成promise，比如：\n\nasync function func() {\n  await 1;\n  return promise.resolve(true);\n}\n\n\n和以下代码是等价的:\n\nasync function func() {\n  await 1;\n  return true;\n}\n\n\n比如，我们可以使用async函数实现一个sleep函数。\n\nfunction sleep(ms) {\n  return new promise((resolve, reject) => {\n    settimeout(resolve, ms);\n  });\n}\n\nasync function eventhandler() {\n  // 等待1s，继续后续的业务逻辑\n  await sleep(1000);\n  console.log("执行一些逻辑");\n}\n\n\nawait后面的代码是微任务执行的，而await之前的代码是在同步任务执行的(包括这行)。\n\n比如有以下代码：\n\nasync function func() {\n  console.log(1);\n  await something();\n  console.log(2);\n}\n\n\n等价于:\n\nfunction func() {\n  new promise(() => {\n    console.log(1);\n    return something();\n  }).then(() => {\n    console.log(2);\n  });\n}\n\n\n下面是一道js事件循环常考的面试题：\n\n//请写出输出内容\nasync function async1() {\n  console.log("async1 start");\n  await async2();\n  console.log("async1 end");\n}\nasync function async2() {\n  console.log("async2");\n}\n\nconsole.log("script start");\n\nsettimeout(function () {\n  console.log("settimeout");\n}, 0);\n\nasync1();\n\nnew promise(function (resolve) {\n  console.log("promise1");\n  resolve();\n}).then(function () {\n  console.log("promise2");\n});\nconsole.log("script end");\n\n/*\nscript start\nasync1 start\nasync2\npromise1\nscript end\nasync1 end\npromise2\nsettimeout\n*/\n\n\n另外，对于await表达式，其实表示的含义就是如果await后面跟随的表达式的如果是一个promise的话，则取出promise的值，否则直接取其原值。\n\n\n# 2、使用的注意点\n\n最好把await命令放在try...catch代码块中，因为一旦一个await表达式发生错误，后续的流程就不会再执行了，这点我们一会儿可以在babel编译的结果中看到为什么。\n\n然后，async函数是不能够使用new调用的，为什么呢？从现象上来说，因为async函数没有prototype属性，从原理上来讲的话，async函数是基于generator的，generator函数是不能被用作new调用的，因为async函数当然也不能被用作new调用了。\n\n另外一个比较重要的注意点是，多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。\n\n比如下述代码：\n\nasync function func() {\n  let foo = await getfoo();\n  let bar = await getbar();\n}\n\n\n需要首先执行getfoo等getfoo变成fulfilled之后，才会再执行getbar。在有些时候，两个操作流程并没有先后顺序的要求，对于用户而已，更快的数据到达是较好的选择，因此，这种场景下，需要写成以下形式：\n\n// 写法一\nlet [foo, bar] = await promise.all([getfoo(), getbar()]);\n\n// 写法二\nlet foopromise = getfoo();\nlet barpromise = getbar();\nlet foo = await foopromise;\nlet bar = await barpromise;\n\n\n上述的写法1大家可能比较好理解，但是写法2可能就会比较迷惑了，这样理解就行了，首先，我们没有通过用await关键字来调用getfoo和getbar，也就是说，在同一时刻，这两个操作就已经执行了，但是，只不过要必须foopromise的状态为fulfilled才能执行取barpromise状态的逻辑，而实际上两者并没有先后顺序，请读者体会其中的区别。\n\n如何判断一个函数是否是async函数呢，其实方法非常简单：\n\n// 方法一\nconst isasyncfunc = (val) => {\n  return val && val[symbol.tostringtag] === "asyncfunction";\n};\n\n// 方法二\nconst isasyncfunc = (func) => {\n  return (\n    typeof func === "function" &&\n    object.prototype.tostring.call(func) === "[object asyncfunction]"\n  );\n};\n\n\n明显感觉方法一要优雅很多，对于这个用法不太清楚的同学可以参考symbol相关的知识点。\n\n\n# 3、async 函数的实现原理\n\n对于以下代码，我们看看babel将会把它编译成什么样子\n\nasync function func() {\n  const val1 = await 1;\n  const val2 = await (2 + val1);\n  const val3 = await (3 + val2);\n  const val4 = await (4 + val3);\n  return val4;\n}\n\n\nbabel编译之后的结果(为了篇幅，已经省略了generator-runtime的部分):\n\nfunction asyncgeneratorstep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    // 如果执行出错，提前结束\n    reject(error);\n    return;\n  }\n  // 如果generator已经迭代完成，直接把最终的返回值报告给外部的promise，作为它的fulfilled值，结束递归\n  if (info.done) {\n    resolve(value);\n  } else {\n    // 没有完成，把本轮的值包裹，最为入参传递给下一个next或者throw的调用\n    promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asynctogenerator(fn) {\n  // fn就是一个generator，执行它可以得到一个迭代器\n  return function () {\n    var self = this,\n      args = arguments;\n    return new promise(function (resolve, reject) {\n      // 得到一个由generator执行得到的迭代器\n      var gen = fn.apply(self, args);\n      // 定义next函数\n      function _next(value) {\n        // 递归的调用next，以使得generator执行得到的迭代器可以一直向后迭代\n        asyncgeneratorstep(gen, resolve, reject, _next, _throw, "next", value);\n      }\n      // 定义错误处理函数\n      function _throw(err) {\n        // 递归的调用throw，以使得generator执行得到的迭代器可以一直向后迭代\n        asyncgeneratorstep(gen, resolve, reject, _next, _throw, "throw", err);\n      }\n      // 开始迭代，因为第一个next不能有参数，所以就传递了一个undefined\n      _next(undefined);\n    });\n  };\n}\n\nfunction func() {\n  return _func.apply(this, arguments);\n}\n\nfunction _func() {\n  _func = _asynctogenerator(\n    // 得到一个generator，这个generator执行就可以得到一个迭代器\n    /*#__pure__*/ _regeneratorruntime().mark(function _callee() {\n      var val1, val2, val3, val4;\n      return _regeneratorruntime().wrap(function _callee$(_context) {\n        while (1) {\n          switch ((_context.prev = _context.next)) {\n            case 0:\n              _context.next = 2;\n              return 1;\n\n            case 2:\n              val1 = _context.sent;\n              _context.next = 5;\n              return 2 + val1;\n\n            case 5:\n              val2 = _context.sent;\n              _context.next = 8;\n              return 3 + val2;\n\n            case 8:\n              val3 = _context.sent;\n              _context.next = 11;\n              return 4 + val3;\n\n            case 11:\n              val4 = _context.sent;\n              return _context.abrupt("return", val4);\n\n            case 13:\n            case "end":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    })\n  );\n  // 向外界返回一个promise\n  return _func.apply(this, arguments);\n}\n\n\nasync函数的本质是generator，但是generator的使用是相当麻烦的，你得运行它，然后不断的调用next直到迭代完成，而async函数直接就在内部帮我们把这个事儿做了，你就只需要专注于业务代码就好了。\n\n首先分析asyncgeneratorstep这个函数，当所有的await语句都走完了之后，返回状态为fulfilled结果，如果中途产生错误则提前终止了，这就是为什么前文提到因为一旦await后面的表达式发生错误，后续的流程就不会再执行了的原因。如果还没有将当前的迭代器迭代完成，则继续向后迭代，为什么是这样的呢？\n\nfunction _next(value) {\n  asyncgeneratorstep(gen, resolve, reject, _next, _throw, "next", value);\n}\n\n\n因为在这个位置，_next函数被用作了参数传递到asyncgeneratorstep，这儿是一个递归调用，而递归的退出条件呢？要么执行完，要么出现错误。\n\n然后，可以看到_asynctogenerator这个函数返回值是个匿名函数，并且这个匿名函数的返回值是一个promise，这也就应证了前文所说的，在async函数中没有必要刻意的对返回值进行promise.resolve这样的操作。\n\n最后，为什么在第一次调用_next函数的时候传递的是undefined，因为generator节，我们讲过，其在第一个next方法的时候是无法传递参数的。\n\n另外，这个是在阮一峰老师es6入门书籍里面他给出的spawn函数的实现。\n\nfunction spawn(genf) {\n  return new promise(function (resolve, reject) {\n    const gen = genf();\n    function step(nextf) {\n      let next;\n      try {\n        next = nextf();\n      } catch (e) {\n        return reject(e);\n      }\n      if (next.done) {\n        return resolve(next.value);\n      }\n      promise.resolve(next.value).then(\n        function (v) {\n          step(function () {\n            return gen.next(v);\n          });\n        },\n        function (e) {\n          step(function () {\n            return gen.throw(e);\n          });\n        }\n      );\n    }\n    step(function () {\n      return gen.next(undefined);\n    });\n  });\n}\n\n\n上述实现嵌套的层级较多，意思都是一个，但是从可读性来说，我个人感觉不如babel编译之后的代码，不喜勿喷。',charsets:{cjk:!0}},{frontmatter:{},regularPath:"/javascript/es6/promise.html",relativePath:"javascript/es6/promise.md",key:"v-1ec4367d",path:"/javascript/es6/promise.html",headersStr:null,content:"",normalizedContent:"",charsets:{}},{title:"Generator",frontmatter:{},regularPath:"/javascript/es6/generator.html",relativePath:"javascript/es6/generator.md",key:"v-f49eb2e6",path:"/javascript/es6/generator.html",headers:[{level:2,title:"Generator",slug:"generator",normalizedTitle:"generator",charIndex:2},{level:3,title:"1、基本概念",slug:"_1、基本概念",normalizedTitle:"1、基本概念",charIndex:370},{level:3,title:"2、yield 表达式",slug:"_2、yield-表达式",normalizedTitle:"2、yield 表达式",charIndex:1083},{level:3,title:"3、next 函数",slug:"_3、next-函数",normalizedTitle:"3、next 函数",charIndex:2207},{level:3,title:"4、for-of 循环",slug:"_4、for-of-循环",normalizedTitle:"4、for-of 循环",charIndex:2622},{level:3,title:"5、yeild*表达式",slug:"_5、yeild-表达式",normalizedTitle:"5、yeild*表达式",charIndex:3252},{level:3,title:"6、Generator 运行原理分析",slug:"_6、generator-运行原理分析",normalizedTitle:"6、generator 运行原理分析",charIndex:5244}],headersStr:"Generator 1、基本概念 2、yield 表达式 3、next 函数 4、for-of 循环 5、yeild*表达式 6、Generator 运行原理分析",content:'# Generator\n\n对于绝大多数前端来说，对于Generator可能都是一个比较陌生的概念。在实际开发中，由于我们都直接编写基于async-await的代码，所以基本上不怎么用它，但是Generator却又是一个值得掌握的语法，async-await底层也是基于generator，大名鼎鼎的redux-saga就是使用的generator的语法，明白它的运行原理，能够帮住我们快速的在实际开发中定位bug，并且可以帮助我们掌握async-await函数的原理。\n\n在阅读本文之前，请确保你已经掌握ES6的Iterator的应用。\n\n本文关于Generator基础概念内容大致引用阮一峰老师的Generator节，如果你已经掌握了Generator的概念的话，可以直接跳过，直接查看关于Generator内部运行原理的分析。\n\n\n# 1、基本概念\n\nGenerator函数是ES6提供的一种异步编程解决方案，语法行为与传统函数完全不同。\n\n其写法如下:\n\n// 在function后面紧跟一个*是表示当前函数是一个Generator的语法\nfunction* gen1() {\n  yield 1;\n  yield 2;\n  return 3;\n}\n// *挨着函数名字也是可以的\n/*\nfunction *gen2() {\n  yield 1;\n  yield 2;\n  return 3;\n}\n*/\n\n// 以下是Generator作为属性时的写法\nconst obj = {\n  a: function* () {\n    yield 1;\n    yield 2;\n    return 3;\n  },\n};\n\nconst obj2 = {\n  *b() {\n    yield 1;\n    yield 2;\n    return 3;\n  },\n};\n\n\nGenerator执行结果会得到一个Iterator的实例，我们通过不断的调用这个迭代器的next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。换言之，Generator函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。\n\n如何判断一个函数是Generator还是普通函数呢？\n\nconst isGenerator = (func) => {\n  return func && func[Symbol.toStringTag] === "GeneratorFunction";\n};\n\n\n\n# 2、yield 表达式\n\n由于Generator函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。\n\nyield表达式后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为JavaScript提供了手动的“惰性求值”的语法功能。\n\nyield表达式与return语句既有相似之处，也有区别。相似之处在于，都能返回紧跟在语句后面的那个表达式的值。区别在于每次遇到yield，函数暂停执行，下一次再从该位置继续向后执行，而return语句不具备位置记忆的功能。一个函数里面，只能执行一次（或者说一个）return语句。\n\nGenerator函数可以不用yield表达式，这时就变成了一个单纯的暂缓执行函数。当执行这个函数得到一个迭代器，只有调用这个迭代器的next之后才会执行。\n\n为什么会是这样呢？因为babel编译的时候，把Generator第一个yield之前的代码视为了一个流程。\n\n阮一峰老师的原例如下：\n\nfunction* f() {\n  console.log("执行了！");\n}\n\nvar generator = f();\n\nsetTimeout(function () {\n  generator.next();\n}, 2000);\n\n\n被babel编译之后如下：\n\nvar _marked = /*#__PURE__*/ _regeneratorRuntime().mark(f);\n\nfunction f() {\n  return _regeneratorRuntime().wrap(function f$(_context) {\n    while (1) {\n      switch ((_context.prev = _context.next)) {\n        case 0:\n          console.log("执行了！");\n        case 2:\n        case "end":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n}\n\nvar generator = f();\nsetTimeout(function () {\n  generator.next();\n}, 2000);\n\n\n所以就可以理解为，一个Generator函数有多少个yield语句，它创建的迭代器就可以有效的调用N+1次next方法。\n\nyield关键字必须出现在Generator函数体内，否则会报错。\n\n\n# 3、next 函数\n\nnext函数的入参决定了上一次yield表达式的返回值，第一次调用next传递参数是无效的（因为第一次调用next的上一次没有yield表达式）\n\nfunction* func(b) {\n  const next = yield b;\n  const next2 = yield next + 3;\n  return next2 + 10;\n}\n\nconst ge = func(22);\n// 第一次调用next无法传递参数，因此此刻得到{ value: 22, done: false }\nge.next();\n// next得到上一次yield表达式的返回值，因此此刻得到{value: 36, done: false}\nge.next(33);\n// next2得到上一次yield表达式的返回值，因此此刻得到的{value: 340, done: true}\nge.next(330);\n\n\n\n# 4、for-of 循环\n\nfor-of可以遍历Iterator，那么Generator的执行结果为一个Iterator的实例，那当然就可以用for-of遍历了。 需要注意的是，for-of一旦遇到 { value: xxx, done: true } 就停止了，并且不包括这个值。\n\nconst arr = [1, 2, 3, 4, 5];\nconst ite = arr[Symbol.iterator]();\n// {value: 1, done: false}\nite.next();\n// {value: 2, done: false}\nite.next();\n// {value: 3, done: false}\nite.next();\n// {value: 4, done: false}\nite.next();\n// {value: 5, done: false}\nite.next();\n// {value: undefined, done: true}\nite.next();\n\n\n因此，对于下面的代码，并不会输出return表达式的值\n\nfunction* foo() {\n  yield 1;\n  yield 2;\n  yield 3;\n  yield 4;\n  yield 5;\n  return 6;\n}\n\nfor (let v of foo()) {\n  // 1,2,3,4,5\n  console.log(v);\n}\n\n\n\n# 5、yeild*表达式\n\n如果在Generator函数内部，调用另一个Generator函数。需要在前者的函数体内部，自己手动完成遍历。\n\nES6 提供了yield*表达式，作为解决办法，用来在一个Generator函数里面执行另一个Generator函数。\n\nfunction* foo() {\n  yield "a";\n  yield "b";\n  return 1000;\n}\n\nfunction* bar() {\n  yield "x";\n  // 手动遍历 foo()\n  for (let i of foo()) {\n    console.log(i);\n  }\n  yield "y";\n}\n\n// 等价于\nfunction* bar() {\n  yield "x";\n  // 手动遍历 foo()\n  const b = yield* foo();\n  console.log(b);\n  yield "y";\n}\n// 等价于\nfunction* bar() {\n  yield "x";\n  yield "a";\n  yield "b";\n  yield "y";\n}\n\n\n需要注意的是，由于for-of循环不会包含Generator函数的return值，所以实际上相当于在这期间又插入了N个yield表达式，需要注意的是，yield*表达式跟我们传递的next方法的入参没有任何关系，而是上一个函数的返回值，上述代码中yield* foo()的值为1000，这个结论怎么来的呢，我们看一下上述代码经过babel转码的结果。\n\n以下代码需要注意的是b = _context2.t0;，这是从当前 Generator 的上下文读取内部Generator设置的返回值。\n\nvar _marked = /*#__PURE__*/ _regeneratorRuntime().mark(foo),\n  _marked2 = /*#__PURE__*/ _regeneratorRuntime().mark(bar);\n\nfunction foo() {\n  return _regeneratorRuntime().wrap(function foo$(_context) {\n    while (1) {\n      switch ((_context.prev = _context.next)) {\n        case 0:\n          _context.next = 2;\n          return "a";\n\n        case 2:\n          _context.next = 4;\n          return "b";\n\n        case 4:\n          return _context.abrupt("return", 1000);\n\n        case 5:\n        case "end":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n} // 等价于\n\nfunction bar() {\n  var b;\n  return _regeneratorRuntime().wrap(function bar$(_context2) {\n    while (1) {\n      switch ((_context2.prev = _context2.next)) {\n        case 0:\n          _context2.next = 2;\n          return "x";\n\n        case 2:\n          return _context2.delegateYield(foo(), "t0", 3);\n\n        case 3:\n          b = _context2.t0;\n          console.log(b);\n          _context2.next = 7;\n          return "y";\n\n        case 7:\n        case "end":\n          return _context2.stop();\n      }\n    }\n  }, _marked2);\n}\n\n\n源码在384行将内部Generator的返回值，设置到外层Generator的Context上，然后做了一些清理工作，然后将流程流转到下一个过程，所以在Context就可以拿到内部Generator的返回值了。如果觉得不太清楚的同学可以尝试断点看一下程序的执行过程即可。\n\n\n# 6、Generator 运行原理分析\n\nGenerator通过babel编译之后，底层引入的是一个名叫generator-runtime的库，这个库来源于Facebook。\n\n对于以下代码：\n\nfunction* func() {\n  const b = yield 1;\n  yield 2 + b;\n  if (typeof globalThis !== "window") {\n    throw `this environment is not in browser`;\n  }\n  return 3;\n}\n\nconst gen = func();\ngen.next(10);\ngen.next(12);\ngen.next();\n\n\n通过babel编译之后的结果如下：\n\nvar _marked = /*#__PURE__*/ _regeneratorRuntime().mark(func);\n\nfunction func() {\n  var b;\n  return _regeneratorRuntime().wrap(function func$(_context) {\n    while (1) {\n      switch ((_context.prev = _context.next)) {\n        case 0:\n          _context.next = 2;\n          return 1;\n\n        case 2:\n          b = _context.sent;\n          _context.next = 5;\n          return 2 + b;\n\n        case 5:\n          if (!(typeof globalThis !== "window")) {\n            _context.next = 7;\n            break;\n          }\n\n          throw "this environment is not in browser";\n\n        case 7:\n          return _context.abrupt("return", 3);\n\n        case 8:\n        case "end":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n}\n\nvar gen = func();\ngen.next(10);\ngen.next(12);\ngen.next();\n\n\n其中，上述代码引用的_regeneratorRuntime函数就是引入的generator-runtime库的实例对象。（babel是将其打到了编译的结果中，为了篇幅，上述代码进行了删减）\n\ngenerator-runtime在github的地址，（后文提到的代码行数均以这个源码文件为准）读源代码要方便一些，在阅读本文的时候，如果您一边打开源码一边阅读理解起来会更加方便。\n\n上述代码，我们用到了其提供的两个方法，一个是wrap，一个是mark。\n\nmark函数在 139 行。\n\nexports.mark = function (genFun) {\n  if (Object.setPrototypeOf) {\n    Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n  } else {\n    genFun.__proto__ = GeneratorFunctionPrototype;\n    define(genFun, toStringTagSymbol, "GeneratorFunction");\n  }\n  genFun.prototype = Object.create(Gp);\n  return genFun;\n};\n\n\n在读源码的时候，我们就不要考虑那么多polyfill的操作了，直接假设当前环境有Object.setPrototypeOf方法（后续也将按着这种方式分析），所以mark函数仅仅做了一个很简单的事儿，把我们写的普通函数变成Generator的实例，能够识别与普通函数的区别。\n\n在121行定义了一个defineIteratorMethods方法，这个方法使得所有的Generator实例都拥有next，return，throw方法。\n\n// Helper for defining the .next, .throw, and .return methods of the\n// Iterator interface in terms of a single ._invoke method.\nfunction defineIteratorMethods(prototype) {\n  ["next", "throw", "return"].forEach(function (method) {\n    define(prototype, method, function (arg) {\n      return this._invoke(method, arg);\n    });\n  });\n}\n// 在225行将Generator挂载上述方法集。\n\n\nwrap函数在38行开始，这个方法是Generator的主流程，我们根据其调用的函数分析。\n\nfunction wrap(innerFn, outerFn, self, tryLocsList) {\n  // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n  var protoGenerator =\n    outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n  var generator = Object.create(protoGenerator.prototype);\n  var context = new Context(tryLocsList || []);\n\n  // The ._invoke method unifies the implementations of the .next,\n  // .throw, and .return methods.\n  defineProperty(generator, "_invoke", {\n    value: makeInvokeMethod(innerFn, self, context),\n  });\n\n  return generator;\n}\n\n\n在我们编写的函数调用wrap函数时，明显的看的出来outerFn是Generator的实例，就是为了保证原型必须是Generator。这里面引入了一个Context类，然后在Generator的实例上挂载了一个叫做_invoke的方法，返回了这个Generator的实例。\n\n难点就是Context和makeInvokeMethod。(在源码中还有一个maybeInvokeDelegate函数占有较大的篇幅，它会在使用yield*表达式的时候用到，因次我们仅分析主流程的话这个方法就可以省略了)\n\n首先分析Context类，Context的声明在452行，关键的定义在529行。这里面我们需要知道的是Context用于流程控制（源码里面有个重要的变量ContinueSentinel，凡是在循环里遇到它的都重新进行下一次循环了，读者可以留意一下），其中很大一部分代码跟Generator函数中的try-catch语句有关（取决于babel编译的结果，可读性交差），也有一部分跟Generator函数的嵌套执行有关（yield *），不理解它们并不妨碍我们理解其运行原理，因此本文也不详细分析。\n\n在babel编译之后的wrap方法里面，_context就是Context类的实例，从接下来要讨论的makeInvokeMethod方法就可以看出来，另外babel编译结果的wrap函数的参数就是下述代码tryCatch所执行fn。\n\n在第249行是makeInvokeMethod的定义，这是整个Generator的核心\n\n/* 这部分代码是为了方便读者理解，将其贴到此处 */\n// fn就是wrap方法的innerFn，执行它得到结果，返回给调用者\nfunction tryCatch(fn, obj, arg) {\n  try {\n    return { type: "normal", arg: fn.call(obj, arg) };\n  } catch (err) {\n    return { type: "throw", arg: err };\n  }\n}\n// 以下是 generator 每次调用next、throw、return的流转过程。\nfunction makeInvokeMethod(innerFn, self, context) {\n  var state = GenStateSuspendedStart;\n\n  return function invoke(method, arg) {\n    if (state === GenStateExecuting) {\n      throw new Error("Generator is already running");\n    }\n    // 如果迭代器已经遍历完成的话，直接返回{ value: undefined, done: true }\n    if (state === GenStateCompleted) {\n      if (method === "throw") {\n        throw arg;\n      }\n\n      // Be forgiving, per 25.3.3.3.3 of the spec:\n      // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n      return doneResult();\n    }\n    // 设置当前的操作以及参数到状态上下文上，以知道后续的流转逻辑。\n    context.method = method;\n    context.arg = arg;\n\n    while (true) {\n      // 与Generator函数内嵌yield*表达式相关的逻辑，可以不用具体关注\n      var delegate = context.delegate;\n      if (delegate) {\n        var delegateResult = maybeInvokeDelegate(delegate, context);\n        if (delegateResult) {\n          if (delegateResult === ContinueSentinel) continue;\n          return delegateResult;\n        }\n      }\n      // 把next方法传递的参数设置到Context上去，为的是能够通过next参数的入参控制yield语句的返回值。\n      if (context.method === "next") {\n        // Setting context._sent for legacy support of Babel\'s\n        // function.sent implementation.\n        context.sent = context._sent = context.arg;\n      } else if (context.method === "throw") {\n        // 如果Generator返回的迭代器还没有调用过一次next方法，直接对外抛出错误\n        if (state === GenStateSuspendedStart) {\n          state = GenStateCompleted;\n          throw context.arg;\n        }\n        // 否则，交给context去处理异常，dispatchException会根据用户有没有try-catch执行一些逻辑，如果没有则抛出全局的错误，后续的流程就终止了\n        context.dispatchException(context.arg);\n      } else if (context.method === "return") {\n        // 迭代器执行完成，将Context的流转状态设置为end，然后将值设置在COntext上，返回哨兵对象，流转执行\n        context.abrupt("return", context.arg);\n      }\n      // 将Generator的状态变成执行中\n      state = GenStateExecuting;\n      // 拿到上一步流程的执行结果，根据类别进行相应的处理。\n      var record = tryCatch(innerFn, self, context);\n      if (record.type === "normal") {\n        // If an exception is thrown from innerFn, we leave state ===\n        // GenStateExecuting and loop back for another invocation.\n        state = context.done ? GenStateCompleted : GenStateSuspendedYield;\n        // 如果遇到了哨兵对象，流转Generator的状态\n        if (record.arg === ContinueSentinel) {\n          continue;\n        }\n\n        return {\n          value: record.arg,\n          done: context.done,\n        };\n      } else if (record.type === "throw") {\n        // 此处case是Generator函数顶层没有被try-catch包裹的代码出现问题，直接可以结束Generator了，如果是被try-catch编译过的代码，babel编译生成wrap函数的入参时候就会为其分配后续的流程。\n        state = GenStateCompleted;\n        // Dispatch the exception by looping back around to the\n        // context.dispatchException(context.arg) call above.\n        context.method = "throw";\n        context.arg = record.arg;\n      }\n    }\n  };\n}\n\n\n在源文件的第299行，就是在执行wrap的第一个参数innerFn，在tryCatch执行的时候，形参arg就是Context的实例。\n\n在上述方法中可以看到，如果Generator生成的迭代器已经迭代完成，将会永远返回{value: undefined, done: true }，怎么证明这个结论呢？来源于源码的257行，Generator在return的时候就已经被设置成完成状态了，因此永远返回{value: undefined, done: true }，完成状态又在哪儿设置的呢？是在abrupt("return")里面，调用complete函数，complete将一些数据挂载在Context，并且标记下一步的走向是end，然后返回ContinueSentinel，继续下轮循环，下轮循环就可以将Generator的状态处理成已结束;\n\n在调用next方法的时候，如果用户有传递参数，可以将其保存在context对象上，下次流转的时候首先获取这个值，这就是next方法传递的参数能够作为yield语句的返回值的实现，因此当我们调用或者触发Generator的next或者throw或者return的时候，是一直在把Generator内部的Iterator向后迭代，并切换状态，这样下一次调用next方法的时候就知道了需要流转的逻辑。\n\n另外，虽然看到babel编译的结果是套在while循环的，但是这并不会造成死循环，因为return语句可以将其打断，而这样实现的理由是为了让Generator反复不断的流转（可以无限的调用next方法），其次，我们yield表达式的结果并不一定存在于wrap函数的switch-case语句中，而是取决于makeInvokeMethod的返回值，因此，如果实际开发中我们的业务代码遇到问题，需要关注的代码并不一定是wrap函数的内容了。\n\n所以，再回过头来看的话，我们仅仅只需要把Context看成一个状态机，而它决定了Generator的处理逻辑，而Generator就像很多条线段组成的线段，每个yield就像是一根子线段，这内部的代码就是我们写的业务逻辑代码，而我们通过调用next不断的把进度往前推，如果遇到未捕获的异常就直接结束了，这还是没有脱离JS是一门单线程语言的设定。（看了这些代码之后也没有一些论坛上说的那么玄乎了，还是比较朴实无华的，只不过流程真的很复杂而已）\n\n在理解了Generator之后，我们还有一个非常重要的知识点需要积累，像Generator这种语法在使用babel编译的时候，它并不是元语法（我个人发明的词汇，即这个语法不能再被babel转换为其它语法），所以在使用Tree-shaking的时候，它并不能按我们预期的想法工作，比如如下代码：\n\nfunction* func() {\n  yield 1;\n  yield 2;\n  yield 3;\n  if (process.env.NODE_ENV !== "production") {\n    yield 1000;\n  }\n  yield 4;\n  return 5;\n}\n\n\n转换之后：\n\nfunction func() {\n  return _regeneratorRuntime().wrap(function func$(_context) {\n    while (1) {\n      switch ((_context.prev = _context.next)) {\n        case 0:\n          _context.next = 2;\n          return 1;\n\n        case 2:\n          _context.next = 4;\n          return 2;\n\n        case 4:\n          _context.next = 6;\n          return 3;\n\n        case 6:\n          if (!(process.env.NODE_ENV !== "production")) {\n            _context.next = 9;\n            break;\n          }\n\n          _context.next = 9;\n          return 1000;\n\n        case 9:\n          _context.next = 11;\n          return 4;\n\n        case 11:\n          return _context.abrupt("return", 5);\n\n        case 12:\n        case "end":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n}\n\n\n结语：可以看到，generator-runtime的实现是典型的状态模式应用场景。',normalizedContent:'# generator\n\n对于绝大多数前端来说，对于generator可能都是一个比较陌生的概念。在实际开发中，由于我们都直接编写基于async-await的代码，所以基本上不怎么用它，但是generator却又是一个值得掌握的语法，async-await底层也是基于generator，大名鼎鼎的redux-saga就是使用的generator的语法，明白它的运行原理，能够帮住我们快速的在实际开发中定位bug，并且可以帮助我们掌握async-await函数的原理。\n\n在阅读本文之前，请确保你已经掌握es6的iterator的应用。\n\n本文关于generator基础概念内容大致引用阮一峰老师的generator节，如果你已经掌握了generator的概念的话，可以直接跳过，直接查看关于generator内部运行原理的分析。\n\n\n# 1、基本概念\n\ngenerator函数是es6提供的一种异步编程解决方案，语法行为与传统函数完全不同。\n\n其写法如下:\n\n// 在function后面紧跟一个*是表示当前函数是一个generator的语法\nfunction* gen1() {\n  yield 1;\n  yield 2;\n  return 3;\n}\n// *挨着函数名字也是可以的\n/*\nfunction *gen2() {\n  yield 1;\n  yield 2;\n  return 3;\n}\n*/\n\n// 以下是generator作为属性时的写法\nconst obj = {\n  a: function* () {\n    yield 1;\n    yield 2;\n    return 3;\n  },\n};\n\nconst obj2 = {\n  *b() {\n    yield 1;\n    yield 2;\n    return 3;\n  },\n};\n\n\ngenerator执行结果会得到一个iterator的实例，我们通过不断的调用这个迭代器的next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。换言之，generator函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。\n\n如何判断一个函数是generator还是普通函数呢？\n\nconst isgenerator = (func) => {\n  return func && func[symbol.tostringtag] === "generatorfunction";\n};\n\n\n\n# 2、yield 表达式\n\n由于generator函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。\n\nyield表达式后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为javascript提供了手动的“惰性求值”的语法功能。\n\nyield表达式与return语句既有相似之处，也有区别。相似之处在于，都能返回紧跟在语句后面的那个表达式的值。区别在于每次遇到yield，函数暂停执行，下一次再从该位置继续向后执行，而return语句不具备位置记忆的功能。一个函数里面，只能执行一次（或者说一个）return语句。\n\ngenerator函数可以不用yield表达式，这时就变成了一个单纯的暂缓执行函数。当执行这个函数得到一个迭代器，只有调用这个迭代器的next之后才会执行。\n\n为什么会是这样呢？因为babel编译的时候，把generator第一个yield之前的代码视为了一个流程。\n\n阮一峰老师的原例如下：\n\nfunction* f() {\n  console.log("执行了！");\n}\n\nvar generator = f();\n\nsettimeout(function () {\n  generator.next();\n}, 2000);\n\n\n被babel编译之后如下：\n\nvar _marked = /*#__pure__*/ _regeneratorruntime().mark(f);\n\nfunction f() {\n  return _regeneratorruntime().wrap(function f$(_context) {\n    while (1) {\n      switch ((_context.prev = _context.next)) {\n        case 0:\n          console.log("执行了！");\n        case 2:\n        case "end":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n}\n\nvar generator = f();\nsettimeout(function () {\n  generator.next();\n}, 2000);\n\n\n所以就可以理解为，一个generator函数有多少个yield语句，它创建的迭代器就可以有效的调用n+1次next方法。\n\nyield关键字必须出现在generator函数体内，否则会报错。\n\n\n# 3、next 函数\n\nnext函数的入参决定了上一次yield表达式的返回值，第一次调用next传递参数是无效的（因为第一次调用next的上一次没有yield表达式）\n\nfunction* func(b) {\n  const next = yield b;\n  const next2 = yield next + 3;\n  return next2 + 10;\n}\n\nconst ge = func(22);\n// 第一次调用next无法传递参数，因此此刻得到{ value: 22, done: false }\nge.next();\n// next得到上一次yield表达式的返回值，因此此刻得到{value: 36, done: false}\nge.next(33);\n// next2得到上一次yield表达式的返回值，因此此刻得到的{value: 340, done: true}\nge.next(330);\n\n\n\n# 4、for-of 循环\n\nfor-of可以遍历iterator，那么generator的执行结果为一个iterator的实例，那当然就可以用for-of遍历了。 需要注意的是，for-of一旦遇到 { value: xxx, done: true } 就停止了，并且不包括这个值。\n\nconst arr = [1, 2, 3, 4, 5];\nconst ite = arr[symbol.iterator]();\n// {value: 1, done: false}\nite.next();\n// {value: 2, done: false}\nite.next();\n// {value: 3, done: false}\nite.next();\n// {value: 4, done: false}\nite.next();\n// {value: 5, done: false}\nite.next();\n// {value: undefined, done: true}\nite.next();\n\n\n因此，对于下面的代码，并不会输出return表达式的值\n\nfunction* foo() {\n  yield 1;\n  yield 2;\n  yield 3;\n  yield 4;\n  yield 5;\n  return 6;\n}\n\nfor (let v of foo()) {\n  // 1,2,3,4,5\n  console.log(v);\n}\n\n\n\n# 5、yeild*表达式\n\n如果在generator函数内部，调用另一个generator函数。需要在前者的函数体内部，自己手动完成遍历。\n\nes6 提供了yield*表达式，作为解决办法，用来在一个generator函数里面执行另一个generator函数。\n\nfunction* foo() {\n  yield "a";\n  yield "b";\n  return 1000;\n}\n\nfunction* bar() {\n  yield "x";\n  // 手动遍历 foo()\n  for (let i of foo()) {\n    console.log(i);\n  }\n  yield "y";\n}\n\n// 等价于\nfunction* bar() {\n  yield "x";\n  // 手动遍历 foo()\n  const b = yield* foo();\n  console.log(b);\n  yield "y";\n}\n// 等价于\nfunction* bar() {\n  yield "x";\n  yield "a";\n  yield "b";\n  yield "y";\n}\n\n\n需要注意的是，由于for-of循环不会包含generator函数的return值，所以实际上相当于在这期间又插入了n个yield表达式，需要注意的是，yield*表达式跟我们传递的next方法的入参没有任何关系，而是上一个函数的返回值，上述代码中yield* foo()的值为1000，这个结论怎么来的呢，我们看一下上述代码经过babel转码的结果。\n\n以下代码需要注意的是b = _context2.t0;，这是从当前 generator 的上下文读取内部generator设置的返回值。\n\nvar _marked = /*#__pure__*/ _regeneratorruntime().mark(foo),\n  _marked2 = /*#__pure__*/ _regeneratorruntime().mark(bar);\n\nfunction foo() {\n  return _regeneratorruntime().wrap(function foo$(_context) {\n    while (1) {\n      switch ((_context.prev = _context.next)) {\n        case 0:\n          _context.next = 2;\n          return "a";\n\n        case 2:\n          _context.next = 4;\n          return "b";\n\n        case 4:\n          return _context.abrupt("return", 1000);\n\n        case 5:\n        case "end":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n} // 等价于\n\nfunction bar() {\n  var b;\n  return _regeneratorruntime().wrap(function bar$(_context2) {\n    while (1) {\n      switch ((_context2.prev = _context2.next)) {\n        case 0:\n          _context2.next = 2;\n          return "x";\n\n        case 2:\n          return _context2.delegateyield(foo(), "t0", 3);\n\n        case 3:\n          b = _context2.t0;\n          console.log(b);\n          _context2.next = 7;\n          return "y";\n\n        case 7:\n        case "end":\n          return _context2.stop();\n      }\n    }\n  }, _marked2);\n}\n\n\n源码在384行将内部generator的返回值，设置到外层generator的context上，然后做了一些清理工作，然后将流程流转到下一个过程，所以在context就可以拿到内部generator的返回值了。如果觉得不太清楚的同学可以尝试断点看一下程序的执行过程即可。\n\n\n# 6、generator 运行原理分析\n\ngenerator通过babel编译之后，底层引入的是一个名叫generator-runtime的库，这个库来源于facebook。\n\n对于以下代码：\n\nfunction* func() {\n  const b = yield 1;\n  yield 2 + b;\n  if (typeof globalthis !== "window") {\n    throw `this environment is not in browser`;\n  }\n  return 3;\n}\n\nconst gen = func();\ngen.next(10);\ngen.next(12);\ngen.next();\n\n\n通过babel编译之后的结果如下：\n\nvar _marked = /*#__pure__*/ _regeneratorruntime().mark(func);\n\nfunction func() {\n  var b;\n  return _regeneratorruntime().wrap(function func$(_context) {\n    while (1) {\n      switch ((_context.prev = _context.next)) {\n        case 0:\n          _context.next = 2;\n          return 1;\n\n        case 2:\n          b = _context.sent;\n          _context.next = 5;\n          return 2 + b;\n\n        case 5:\n          if (!(typeof globalthis !== "window")) {\n            _context.next = 7;\n            break;\n          }\n\n          throw "this environment is not in browser";\n\n        case 7:\n          return _context.abrupt("return", 3);\n\n        case 8:\n        case "end":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n}\n\nvar gen = func();\ngen.next(10);\ngen.next(12);\ngen.next();\n\n\n其中，上述代码引用的_regeneratorruntime函数就是引入的generator-runtime库的实例对象。（babel是将其打到了编译的结果中，为了篇幅，上述代码进行了删减）\n\ngenerator-runtime在github的地址，（后文提到的代码行数均以这个源码文件为准）读源代码要方便一些，在阅读本文的时候，如果您一边打开源码一边阅读理解起来会更加方便。\n\n上述代码，我们用到了其提供的两个方法，一个是wrap，一个是mark。\n\nmark函数在 139 行。\n\nexports.mark = function (genfun) {\n  if (object.setprototypeof) {\n    object.setprototypeof(genfun, generatorfunctionprototype);\n  } else {\n    genfun.__proto__ = generatorfunctionprototype;\n    define(genfun, tostringtagsymbol, "generatorfunction");\n  }\n  genfun.prototype = object.create(gp);\n  return genfun;\n};\n\n\n在读源码的时候，我们就不要考虑那么多polyfill的操作了，直接假设当前环境有object.setprototypeof方法（后续也将按着这种方式分析），所以mark函数仅仅做了一个很简单的事儿，把我们写的普通函数变成generator的实例，能够识别与普通函数的区别。\n\n在121行定义了一个defineiteratormethods方法，这个方法使得所有的generator实例都拥有next，return，throw方法。\n\n// helper for defining the .next, .throw, and .return methods of the\n// iterator interface in terms of a single ._invoke method.\nfunction defineiteratormethods(prototype) {\n  ["next", "throw", "return"].foreach(function (method) {\n    define(prototype, method, function (arg) {\n      return this._invoke(method, arg);\n    });\n  });\n}\n// 在225行将generator挂载上述方法集。\n\n\nwrap函数在38行开始，这个方法是generator的主流程，我们根据其调用的函数分析。\n\nfunction wrap(innerfn, outerfn, self, trylocslist) {\n  // if outerfn provided and outerfn.prototype is a generator, then outerfn.prototype instanceof generator.\n  var protogenerator =\n    outerfn && outerfn.prototype instanceof generator ? outerfn : generator;\n  var generator = object.create(protogenerator.prototype);\n  var context = new context(trylocslist || []);\n\n  // the ._invoke method unifies the implementations of the .next,\n  // .throw, and .return methods.\n  defineproperty(generator, "_invoke", {\n    value: makeinvokemethod(innerfn, self, context),\n  });\n\n  return generator;\n}\n\n\n在我们编写的函数调用wrap函数时，明显的看的出来outerfn是generator的实例，就是为了保证原型必须是generator。这里面引入了一个context类，然后在generator的实例上挂载了一个叫做_invoke的方法，返回了这个generator的实例。\n\n难点就是context和makeinvokemethod。(在源码中还有一个maybeinvokedelegate函数占有较大的篇幅，它会在使用yield*表达式的时候用到，因次我们仅分析主流程的话这个方法就可以省略了)\n\n首先分析context类，context的声明在452行，关键的定义在529行。这里面我们需要知道的是context用于流程控制（源码里面有个重要的变量continuesentinel，凡是在循环里遇到它的都重新进行下一次循环了，读者可以留意一下），其中很大一部分代码跟generator函数中的try-catch语句有关（取决于babel编译的结果，可读性交差），也有一部分跟generator函数的嵌套执行有关（yield *），不理解它们并不妨碍我们理解其运行原理，因此本文也不详细分析。\n\n在babel编译之后的wrap方法里面，_context就是context类的实例，从接下来要讨论的makeinvokemethod方法就可以看出来，另外babel编译结果的wrap函数的参数就是下述代码trycatch所执行fn。\n\n在第249行是makeinvokemethod的定义，这是整个generator的核心\n\n/* 这部分代码是为了方便读者理解，将其贴到此处 */\n// fn就是wrap方法的innerfn，执行它得到结果，返回给调用者\nfunction trycatch(fn, obj, arg) {\n  try {\n    return { type: "normal", arg: fn.call(obj, arg) };\n  } catch (err) {\n    return { type: "throw", arg: err };\n  }\n}\n// 以下是 generator 每次调用next、throw、return的流转过程。\nfunction makeinvokemethod(innerfn, self, context) {\n  var state = genstatesuspendedstart;\n\n  return function invoke(method, arg) {\n    if (state === genstateexecuting) {\n      throw new error("generator is already running");\n    }\n    // 如果迭代器已经遍历完成的话，直接返回{ value: undefined, done: true }\n    if (state === genstatecompleted) {\n      if (method === "throw") {\n        throw arg;\n      }\n\n      // be forgiving, per 25.3.3.3.3 of the spec:\n      // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n      return doneresult();\n    }\n    // 设置当前的操作以及参数到状态上下文上，以知道后续的流转逻辑。\n    context.method = method;\n    context.arg = arg;\n\n    while (true) {\n      // 与generator函数内嵌yield*表达式相关的逻辑，可以不用具体关注\n      var delegate = context.delegate;\n      if (delegate) {\n        var delegateresult = maybeinvokedelegate(delegate, context);\n        if (delegateresult) {\n          if (delegateresult === continuesentinel) continue;\n          return delegateresult;\n        }\n      }\n      // 把next方法传递的参数设置到context上去，为的是能够通过next参数的入参控制yield语句的返回值。\n      if (context.method === "next") {\n        // setting context._sent for legacy support of babel\'s\n        // function.sent implementation.\n        context.sent = context._sent = context.arg;\n      } else if (context.method === "throw") {\n        // 如果generator返回的迭代器还没有调用过一次next方法，直接对外抛出错误\n        if (state === genstatesuspendedstart) {\n          state = genstatecompleted;\n          throw context.arg;\n        }\n        // 否则，交给context去处理异常，dispatchexception会根据用户有没有try-catch执行一些逻辑，如果没有则抛出全局的错误，后续的流程就终止了\n        context.dispatchexception(context.arg);\n      } else if (context.method === "return") {\n        // 迭代器执行完成，将context的流转状态设置为end，然后将值设置在context上，返回哨兵对象，流转执行\n        context.abrupt("return", context.arg);\n      }\n      // 将generator的状态变成执行中\n      state = genstateexecuting;\n      // 拿到上一步流程的执行结果，根据类别进行相应的处理。\n      var record = trycatch(innerfn, self, context);\n      if (record.type === "normal") {\n        // if an exception is thrown from innerfn, we leave state ===\n        // genstateexecuting and loop back for another invocation.\n        state = context.done ? genstatecompleted : genstatesuspendedyield;\n        // 如果遇到了哨兵对象，流转generator的状态\n        if (record.arg === continuesentinel) {\n          continue;\n        }\n\n        return {\n          value: record.arg,\n          done: context.done,\n        };\n      } else if (record.type === "throw") {\n        // 此处case是generator函数顶层没有被try-catch包裹的代码出现问题，直接可以结束generator了，如果是被try-catch编译过的代码，babel编译生成wrap函数的入参时候就会为其分配后续的流程。\n        state = genstatecompleted;\n        // dispatch the exception by looping back around to the\n        // context.dispatchexception(context.arg) call above.\n        context.method = "throw";\n        context.arg = record.arg;\n      }\n    }\n  };\n}\n\n\n在源文件的第299行，就是在执行wrap的第一个参数innerfn，在trycatch执行的时候，形参arg就是context的实例。\n\n在上述方法中可以看到，如果generator生成的迭代器已经迭代完成，将会永远返回{value: undefined, done: true }，怎么证明这个结论呢？来源于源码的257行，generator在return的时候就已经被设置成完成状态了，因此永远返回{value: undefined, done: true }，完成状态又在哪儿设置的呢？是在abrupt("return")里面，调用complete函数，complete将一些数据挂载在context，并且标记下一步的走向是end，然后返回continuesentinel，继续下轮循环，下轮循环就可以将generator的状态处理成已结束;\n\n在调用next方法的时候，如果用户有传递参数，可以将其保存在context对象上，下次流转的时候首先获取这个值，这就是next方法传递的参数能够作为yield语句的返回值的实现，因此当我们调用或者触发generator的next或者throw或者return的时候，是一直在把generator内部的iterator向后迭代，并切换状态，这样下一次调用next方法的时候就知道了需要流转的逻辑。\n\n另外，虽然看到babel编译的结果是套在while循环的，但是这并不会造成死循环，因为return语句可以将其打断，而这样实现的理由是为了让generator反复不断的流转（可以无限的调用next方法），其次，我们yield表达式的结果并不一定存在于wrap函数的switch-case语句中，而是取决于makeinvokemethod的返回值，因此，如果实际开发中我们的业务代码遇到问题，需要关注的代码并不一定是wrap函数的内容了。\n\n所以，再回过头来看的话，我们仅仅只需要把context看成一个状态机，而它决定了generator的处理逻辑，而generator就像很多条线段组成的线段，每个yield就像是一根子线段，这内部的代码就是我们写的业务逻辑代码，而我们通过调用next不断的把进度往前推，如果遇到未捕获的异常就直接结束了，这还是没有脱离js是一门单线程语言的设定。（看了这些代码之后也没有一些论坛上说的那么玄乎了，还是比较朴实无华的，只不过流程真的很复杂而已）\n\n在理解了generator之后，我们还有一个非常重要的知识点需要积累，像generator这种语法在使用babel编译的时候，它并不是元语法（我个人发明的词汇，即这个语法不能再被babel转换为其它语法），所以在使用tree-shaking的时候，它并不能按我们预期的想法工作，比如如下代码：\n\nfunction* func() {\n  yield 1;\n  yield 2;\n  yield 3;\n  if (process.env.node_env !== "production") {\n    yield 1000;\n  }\n  yield 4;\n  return 5;\n}\n\n\n转换之后：\n\nfunction func() {\n  return _regeneratorruntime().wrap(function func$(_context) {\n    while (1) {\n      switch ((_context.prev = _context.next)) {\n        case 0:\n          _context.next = 2;\n          return 1;\n\n        case 2:\n          _context.next = 4;\n          return 2;\n\n        case 4:\n          _context.next = 6;\n          return 3;\n\n        case 6:\n          if (!(process.env.node_env !== "production")) {\n            _context.next = 9;\n            break;\n          }\n\n          _context.next = 9;\n          return 1000;\n\n        case 9:\n          _context.next = 11;\n          return 4;\n\n        case 11:\n          return _context.abrupt("return", 5);\n\n        case 12:\n        case "end":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n}\n\n\n结语：可以看到，generator-runtime的实现是典型的状态模式应用场景。',charsets:{cjk:!0}},{title:"Class 的前世今生",frontmatter:{},regularPath:"/javascript/es6/class.html",relativePath:"javascript/es6/class.md",key:"v-b548d0fa",path:"/javascript/es6/class.html",headers:[{level:2,title:"Class 的前世今生",slug:"class-的前世今生",normalizedTitle:"class 的前世今生",charIndex:2},{level:2,title:"Class 的基础语法",slug:"class-的基础语法",normalizedTitle:"class 的基础语法",charIndex:273},{level:2,title:"Class 的 constructor 方法",slug:"class-的-constructor-方法",normalizedTitle:"class 的 constructor 方法",charIndex:1217},{level:2,title:"Class 的静态属性和方法",slug:"class-的静态属性和方法",normalizedTitle:"class 的静态属性和方法",charIndex:1475},{level:2,title:"Class 的私有属性和私有方法",slug:"class-的私有属性和私有方法",normalizedTitle:"class 的私有属性和私有方法",charIndex:1827},{level:2,title:"Class 的 getter 和 setter",slug:"class-的-getter-和-setter",normalizedTitle:"class 的 getter 和 setter",charIndex:2543},{level:2,title:"Class 的静态块",slug:"class-的静态块",normalizedTitle:"class 的静态块",charIndex:4105},{level:2,title:"Class 的继承",slug:"class-的继承",normalizedTitle:"class 的继承",charIndex:4834},{level:3,title:"super 关键字",slug:"super-关键字",normalizedTitle:"super 关键字",charIndex:7311},{level:2,title:"Class 的一些注意点",slug:"class-的一些注意点",normalizedTitle:"class 的一些注意点",charIndex:8322}],headersStr:"Class 的前世今生 Class 的基础语法 Class 的 constructor 方法 Class 的静态属性和方法 Class 的私有属性和私有方法 Class 的 getter 和 setter Class 的静态块 Class 的继承 super 关键字 Class 的一些注意点",content:'# Class 的前世今生\n\nJS是一门基于原型继承的语言，对于熟悉C#，Java等语言的人来说，理解起来相当费解(我在学习JS的初期几乎是以完全忘记C#语法的姿态去学习的)，随着现代 Web 技术的发展（尤其是nodejs的出现），我们的项目也变得越来越庞大，维护成本也变得越来越高，因此 TC39 委员会也致力于将JS向一门完备的工业化语言迈进，因此就引入了ES的下一代版本，即ES6。\n\n其中相当令人兴奋的一个特性便是引入了Class这一语法糖，使得我们可以不用再费力的去基于原型，控制JS代码的一些行为，对于初学者也更加的友好。\n\n\n# Class 的基础语法\n\nclass Person {\n  name = "awesome boy";\n\n  age = 18;\n\n  constructor(hobby) {\n    this.hobby = hobby;\n  }\n\n  run() {\n    console.log("I can run");\n  }\n\n  say() {\n    if (this.hobby) {\n      console.log("I can say, I like " + this.hobby);\n      return;\n    }\n    console.log("I can say");\n  }\n\n  inspect() {\n    console.log(this);\n  }\n}\n\nconst xiaoming = new Person("Java");\nxiaoming.say();\nxiaoming.run();\n\n\n上述代码我们便定义了一个Person，其中name和age叫做类的属性，run和say叫做类的方法，使用起来和ES5完全一致，如果改写成ES5的代码，大致如下。如果不修改类的方法的this指向的话，方法中this默认指向类的实例对象。\n\nfunction Person(hobby) {\n  this.name = "awesome boy";\n  this.age = 18;\n  this.hobby = hobby;\n}\n\nPerson.prototype.say = function () {\n  if (this.hobby) {\n    console.log("I can say, I like " + this.hobby);\n    return;\n  }\n  console.log("I can say");\n};\n\nPerson.prototype.run = function () {\n  console.log("I can run");\n};\n\n\nWARNING\n\n需要注意的一点儿就是，类中的方法是归属于类的实例对象的原型对象上的，并不在实例本身上，因此增加say和run方法不能直接写在构造函数内部。\n\n\n# Class 的 constructor 方法\n\n用法和 Java 和 C#一样，当我们需要在类初始化的时候传递一些参数就需要用到构造函数，默认构造函数是可以不写的。\n\n如果在使用类实现继承的时候，一旦写了构造函数就必须要在构造函数中首先调用父类的构造函数（仍然默认可以不写）\n\nclass Person {}\n\nclass Male extends Person {\n  constructor() {\n    super();\n    console.log("hello world");\n  }\n}\n\n\n\n# Class 的静态属性和方法\n\n对于静态属性和方法，其实也没有什么好神秘的，其实就是加了一个static关键字，使得这个属性或者方法归属于这个类本身，而不再归属于类的实例对象。\n\nclass Person {\n  static version = "0.0.1";\n\n  static bootstrap() {\n    console.log("I am alive");\n  }\n}\n\n\n上述改写成ES5的代码的话，即:\n\nfunction Person() {}\n\nPerson.version = "0.0.1";\n\nPerson.bootstrap = function () {\n  console.log("I am alive");\n};\n\n\n静态方法中this默认指向类本身。\n\n\n# Class 的私有属性和私有方法\n\n像Java，C# 甚至TS都有私有属性或者私有方法，并且是使用private，不过这个设想最终还是没有落到JS的语法上，JS类的私有属性和方法比较杀马特，需要在前面加入一个#，以表示这是一个私有的字段，如：\n\nclass Person {\n  #salary = 1800;\n\n  #settleSalary() {\n    console.log("月入1800，每天笑哈哈，月入3800，拿命往里搭");\n  }\n}\n\n\n私有字段只有在类的内部才能访问的到，一旦出了类，就无法访问了，你可以简单的理解为在类的这两个{}之前可以访问到，除此之外再也无法访问到了。\n\n至于这个是怎么实现的，就需要更高级的语法了，ES6中引入了一个叫做WeakMap的接口，而class的私有字段便是基于这个实现的。\n\n"use strict";\n\nvar _background = new WeakMap();\n\nvar Point = /*#__PURE__*/ (function () {\n  function Point(x, y) {\n    _background.set(this, {\n      writable: true,\n      value: "red",\n    });\n  }\n\n  return Point;\n})();\n\n\n对于每一个私有字段，都声明一个WeakMap来控制，每个WeakMap挂载的key为当前类，因此，一旦出了类，再也访问不到它，因为WeakMap不会增加对象的引用计数，一旦这个类销毁了，那么这个WeakMap也随之销毁了，不会造成内存泄露。\n\n\n# Class 的 getter 和 setter\n\n因为有私有属性，有些时候，我们仅仅想让外界读取而不能改写(只读)或者只写的时候就需要用到getter或者setter。\n\nclass Person {\n  #_salary = 0;\n\n  get salary() {\n    return this.#_salary;\n  }\n\n  set salary(value) {\n    if (value <= 0) {\n      console.warn("薪资不能是负值");\n      return;\n    }\n    this.#_salary = value;\n  }\n}\n\n\ngetter和setter其实对应的就是ES5提供的Object.defineProperty方法中的get和set\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if ("value" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, "prototype", { writable: false });\n  return Constructor;\n}\n\nvar Person = /*#__PURE__*/ (function () {\n  function Person() {\n    _classCallCheck(this, Person);\n\n    _classPrivateFieldInitSpec(this, _salary, {\n      writable: true,\n      value: 0,\n    });\n  }\n\n  _createClass(Person, [\n    {\n      key: "salary",\n      get: function get() {\n        return _classPrivateFieldGet(this, _salary);\n      },\n      set: function set(value) {\n        if (value <= 0) {\n          console.warn("薪资不能是负值");\n          return;\n        }\n\n        _classPrivateFieldSet(this, _salary, value);\n      },\n    },\n  ]);\n\n  return Person;\n})();\n\n\n\n# Class 的静态块\n\n这是在ES2021中增加的内容，主要目的是对静态属性进行初始化，因为在这之前，静态属性的一个问题是，如果它有初始化逻辑，这个逻辑要么写在类的外部，要么写在constructor()方法里面。后者带来的问题是每次这个类初始化实例的时候都会执行一遍。前者的问题是使得代码的内聚性降低，不利于维护。\n\nclass Position {\n  static x;\n  static y;\n  static z;\n\n  static {\n    // 模拟一些初始化的操作\n    this.x = 1;\n    this.y = 2;\n    this.z = 3;\n  }\n}\n\n\n在类生成时运行且只运行一次，以后，新建类的实例时，这个块就不运行了。\n\n转化为ES5的语法大致如下：\n\nvar Position = /*#__PURE__*/ _createClass(function Position() {\n  _classCallCheck(this, Position);\n});\n\n_defineProperty(Position, "x", void 0);\n\n_defineProperty(Position, "y", void 0);\n\n_defineProperty(Position, "z", void 0);\n\n(function () {\n  // 模拟一些初始化的操作\n  Position.x = 1;\n  Position.y = 2;\n  Position.z = 3;\n})();\n\n\n用一个立即执行函数初始化这些操作，解决了写在构造器执行多次的问题，本质上是初始化逻辑写在类的外部的语法糖。\n\n\n# Class 的继承\n\n使用 Class 继承完美的解决了早期 ES 种继承的问题，而且语法相当简单，就一个extends就搞定了。\n\n我们先以数学定理的形式先记住继承中父类子类之间的属性和方法的关系\n\n * 1、子类可以继承父类中所有的非私有属性和方法\n * 2、子类可以继承父类中所有的非私有静态属性和静态方法\n\n假设有如下继承关系\n\nclass Base {\n  name = "111";\n\n  age = 222;\n\n  say() {\n    console.log("base say");\n  }\n\n  run() {\n    console.log("base run");\n  }\n}\n\nclass Sub extends Base {\n  run() {\n    console.log("sub run");\n  }\n}\n\nconst parent = new Base();\nconst child = new Sub();\nchild.run();\nconsole.log(child.name);\n\n\n我们根据第一条定理来推导第一条原型指向关系：\n\nSub.prototype.__proto__ === Base.prototype;\n\n\n为什么是这样，根据上文阐述，我们知道，所有的类的方法都挂载类的原型对象上的，既然当前类能够访问到父类的所有方法，当前类方法定义的位置在Sub.prototype，既然 JS 引擎取值不会报错，那么自然这个原型对象的原型是父类的原型对象。\n\n那么，属性是怎么继承来的呢？\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, "prototype", { writable: false });\n  return Constructor;\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nvar Base = /*#__PURE__*/ (function () {\n  function Base() {\n    _classCallCheck(this, Base);\n\n    _defineProperty(this, "name", "111");\n\n    _defineProperty(this, "age", 222);\n  }\n\n  _createClass(Base, [\n    {\n      key: "say",\n      value: function say() {\n        console.log("base say");\n      },\n    },\n    {\n      key: "run",\n      value: function run() {\n        console.log("base run");\n      },\n    },\n  ]);\n\n  return Base;\n})();\n\nvar Sub = /*#__PURE__*/ (function (_Base) {\n  _inherits(Sub, _Base);\n\n  var _super = _createSuper(Sub);\n\n  function Sub() {\n    _classCallCheck(this, Sub);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Sub, [\n    {\n      key: "run",\n      value: function run() {\n        console.log("sub run");\n      },\n    },\n  ]);\n\n  return Sub;\n})(Base);\n\n\n关键就是看_createSuper这个辅助函数，其返回一个函数，其直接调用了一次Super，相当于我们得到的是一个把当前类上所有属性完成拷贝的对象，这就避免了多个子类继承同一个父类的时候，共用一个父类的属性的问题\n\n接着，我们根据第二条定理来推导的第二条原型指向关系：\n\nSub.__proto__ = Base;\n\n\n为什么是这样，根据上文阐述，我们知道，所有类的静态属性或者方法都挂载在类本身的，既然 JS 引擎取值不会报错，那么自然这个类的原型是父类。\n\n\n# super 关键字\n\n上述代码中我们可以看到，当子类中方法和父类重名的时候，会出现一种比较奇妙的现象，我们回想一下 JS 对象的属性访问规则，当前对象上有名为 xxx 的方法，便不会向上查找了，子类已经完全修改了父类的行为，专业术语叫做重写或者覆盖，这个语法特性在面向对象程序设计中有相当大的应用，比如常见的设计模式：模板方法模式、策略模式、命令模式等都可以看到这个特性的应用。\n\nclass Strategy {\n  run() {\n    console.log("base run");\n  }\n}\n\nclass SimpleStrategy extends Strategy {\n  run() {\n    console.log("sub run");\n  }\n}\n\nclass ComplexStrategy extends Strategy() {\n  run() {\n    console.log("sub run");\n  }\n}\n\nfunction selectStrategy(mode) {\n  let stg = null;\n  switch (mode) {\n    case "simple":\n      stg = new SimleStrategy();\n      break;\n    case "multi":\n      stg = new ComplexStrategy();\n      break;\n  }\n  return stg;\n}\n\nclass Bootstrap {\n  runner() {\n    const stg = selectStrategy(import.meta.env.STRATEGY);\n    stg.run();\n  }\n}\n\n\n若我们又不想完全覆盖父类的行为呢，比如某些时候，我们得到的一个 SDK 已经提供了某些功能，但是这个功能又不完全满足我们的业务，我们需要针对我们的业务定制化，此刻就可以使得super关键字派上用场了。\n\nclass Base {\n  run() {\n    console.log("base run");\n  }\n}\n\nclass Sub extends Base {\n  run() {\n    super.run();\n    console.log("sub run");\n  }\n}\n\n\n\n# Class 的一些注意点\n\n * 类和模块的内部，默认就是严格模式\n * 类的方法内部如果含有this，它默认指向类的实例，但是并不意味着就是绝对安全的，比如有些老六\n\nclass Person {\n  name = "yx";\n\n  say() {\n    console.log(this.name);\n  }\n}\nconst p = new Person();\nconst say = p.say;\n// Uncaught TypeError: Cannot read properties of undefined\nsay();\n\n\n * 类不存在提升\n * 类中有一个名为new.target的属性，这个属性在初始化的时候指向的是类本身，因此可以用这个属性判断类是否使用new调用，即便子类继承了父类，在父类中，new.target仍然指向子类。',normalizedContent:'# class 的前世今生\n\njs是一门基于原型继承的语言，对于熟悉c#，java等语言的人来说，理解起来相当费解(我在学习js的初期几乎是以完全忘记c#语法的姿态去学习的)，随着现代 web 技术的发展（尤其是nodejs的出现），我们的项目也变得越来越庞大，维护成本也变得越来越高，因此 tc39 委员会也致力于将js向一门完备的工业化语言迈进，因此就引入了es的下一代版本，即es6。\n\n其中相当令人兴奋的一个特性便是引入了class这一语法糖，使得我们可以不用再费力的去基于原型，控制js代码的一些行为，对于初学者也更加的友好。\n\n\n# class 的基础语法\n\nclass person {\n  name = "awesome boy";\n\n  age = 18;\n\n  constructor(hobby) {\n    this.hobby = hobby;\n  }\n\n  run() {\n    console.log("i can run");\n  }\n\n  say() {\n    if (this.hobby) {\n      console.log("i can say, i like " + this.hobby);\n      return;\n    }\n    console.log("i can say");\n  }\n\n  inspect() {\n    console.log(this);\n  }\n}\n\nconst xiaoming = new person("java");\nxiaoming.say();\nxiaoming.run();\n\n\n上述代码我们便定义了一个person，其中name和age叫做类的属性，run和say叫做类的方法，使用起来和es5完全一致，如果改写成es5的代码，大致如下。如果不修改类的方法的this指向的话，方法中this默认指向类的实例对象。\n\nfunction person(hobby) {\n  this.name = "awesome boy";\n  this.age = 18;\n  this.hobby = hobby;\n}\n\nperson.prototype.say = function () {\n  if (this.hobby) {\n    console.log("i can say, i like " + this.hobby);\n    return;\n  }\n  console.log("i can say");\n};\n\nperson.prototype.run = function () {\n  console.log("i can run");\n};\n\n\nwarning\n\n需要注意的一点儿就是，类中的方法是归属于类的实例对象的原型对象上的，并不在实例本身上，因此增加say和run方法不能直接写在构造函数内部。\n\n\n# class 的 constructor 方法\n\n用法和 java 和 c#一样，当我们需要在类初始化的时候传递一些参数就需要用到构造函数，默认构造函数是可以不写的。\n\n如果在使用类实现继承的时候，一旦写了构造函数就必须要在构造函数中首先调用父类的构造函数（仍然默认可以不写）\n\nclass person {}\n\nclass male extends person {\n  constructor() {\n    super();\n    console.log("hello world");\n  }\n}\n\n\n\n# class 的静态属性和方法\n\n对于静态属性和方法，其实也没有什么好神秘的，其实就是加了一个static关键字，使得这个属性或者方法归属于这个类本身，而不再归属于类的实例对象。\n\nclass person {\n  static version = "0.0.1";\n\n  static bootstrap() {\n    console.log("i am alive");\n  }\n}\n\n\n上述改写成es5的代码的话，即:\n\nfunction person() {}\n\nperson.version = "0.0.1";\n\nperson.bootstrap = function () {\n  console.log("i am alive");\n};\n\n\n静态方法中this默认指向类本身。\n\n\n# class 的私有属性和私有方法\n\n像java，c# 甚至ts都有私有属性或者私有方法，并且是使用private，不过这个设想最终还是没有落到js的语法上，js类的私有属性和方法比较杀马特，需要在前面加入一个#，以表示这是一个私有的字段，如：\n\nclass person {\n  #salary = 1800;\n\n  #settlesalary() {\n    console.log("月入1800，每天笑哈哈，月入3800，拿命往里搭");\n  }\n}\n\n\n私有字段只有在类的内部才能访问的到，一旦出了类，就无法访问了，你可以简单的理解为在类的这两个{}之前可以访问到，除此之外再也无法访问到了。\n\n至于这个是怎么实现的，就需要更高级的语法了，es6中引入了一个叫做weakmap的接口，而class的私有字段便是基于这个实现的。\n\n"use strict";\n\nvar _background = new weakmap();\n\nvar point = /*#__pure__*/ (function () {\n  function point(x, y) {\n    _background.set(this, {\n      writable: true,\n      value: "red",\n    });\n  }\n\n  return point;\n})();\n\n\n对于每一个私有字段，都声明一个weakmap来控制，每个weakmap挂载的key为当前类，因此，一旦出了类，再也访问不到它，因为weakmap不会增加对象的引用计数，一旦这个类销毁了，那么这个weakmap也随之销毁了，不会造成内存泄露。\n\n\n# class 的 getter 和 setter\n\n因为有私有属性，有些时候，我们仅仅想让外界读取而不能改写(只读)或者只写的时候就需要用到getter或者setter。\n\nclass person {\n  #_salary = 0;\n\n  get salary() {\n    return this.#_salary;\n  }\n\n  set salary(value) {\n    if (value <= 0) {\n      console.warn("薪资不能是负值");\n      return;\n    }\n    this.#_salary = value;\n  }\n}\n\n\ngetter和setter其实对应的就是es5提供的object.defineproperty方法中的get和set\n\nfunction _defineproperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if ("value" in descriptor) descriptor.writable = true;\n    object.defineproperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createclass(constructor, protoprops, staticprops) {\n  if (protoprops) _defineproperties(constructor.prototype, protoprops);\n  if (staticprops) _defineproperties(constructor, staticprops);\n  object.defineproperty(constructor, "prototype", { writable: false });\n  return constructor;\n}\n\nvar person = /*#__pure__*/ (function () {\n  function person() {\n    _classcallcheck(this, person);\n\n    _classprivatefieldinitspec(this, _salary, {\n      writable: true,\n      value: 0,\n    });\n  }\n\n  _createclass(person, [\n    {\n      key: "salary",\n      get: function get() {\n        return _classprivatefieldget(this, _salary);\n      },\n      set: function set(value) {\n        if (value <= 0) {\n          console.warn("薪资不能是负值");\n          return;\n        }\n\n        _classprivatefieldset(this, _salary, value);\n      },\n    },\n  ]);\n\n  return person;\n})();\n\n\n\n# class 的静态块\n\n这是在es2021中增加的内容，主要目的是对静态属性进行初始化，因为在这之前，静态属性的一个问题是，如果它有初始化逻辑，这个逻辑要么写在类的外部，要么写在constructor()方法里面。后者带来的问题是每次这个类初始化实例的时候都会执行一遍。前者的问题是使得代码的内聚性降低，不利于维护。\n\nclass position {\n  static x;\n  static y;\n  static z;\n\n  static {\n    // 模拟一些初始化的操作\n    this.x = 1;\n    this.y = 2;\n    this.z = 3;\n  }\n}\n\n\n在类生成时运行且只运行一次，以后，新建类的实例时，这个块就不运行了。\n\n转化为es5的语法大致如下：\n\nvar position = /*#__pure__*/ _createclass(function position() {\n  _classcallcheck(this, position);\n});\n\n_defineproperty(position, "x", void 0);\n\n_defineproperty(position, "y", void 0);\n\n_defineproperty(position, "z", void 0);\n\n(function () {\n  // 模拟一些初始化的操作\n  position.x = 1;\n  position.y = 2;\n  position.z = 3;\n})();\n\n\n用一个立即执行函数初始化这些操作，解决了写在构造器执行多次的问题，本质上是初始化逻辑写在类的外部的语法糖。\n\n\n# class 的继承\n\n使用 class 继承完美的解决了早期 es 种继承的问题，而且语法相当简单，就一个extends就搞定了。\n\n我们先以数学定理的形式先记住继承中父类子类之间的属性和方法的关系\n\n * 1、子类可以继承父类中所有的非私有属性和方法\n * 2、子类可以继承父类中所有的非私有静态属性和静态方法\n\n假设有如下继承关系\n\nclass base {\n  name = "111";\n\n  age = 222;\n\n  say() {\n    console.log("base say");\n  }\n\n  run() {\n    console.log("base run");\n  }\n}\n\nclass sub extends base {\n  run() {\n    console.log("sub run");\n  }\n}\n\nconst parent = new base();\nconst child = new sub();\nchild.run();\nconsole.log(child.name);\n\n\n我们根据第一条定理来推导第一条原型指向关系：\n\nsub.prototype.__proto__ === base.prototype;\n\n\n为什么是这样，根据上文阐述，我们知道，所有的类的方法都挂载类的原型对象上的，既然当前类能够访问到父类的所有方法，当前类方法定义的位置在sub.prototype，既然 js 引擎取值不会报错，那么自然这个原型对象的原型是父类的原型对象。\n\n那么，属性是怎么继承来的呢？\n\nfunction _createclass(constructor, protoprops, staticprops) {\n  if (protoprops) _defineproperties(constructor.prototype, protoprops);\n  if (staticprops) _defineproperties(constructor, staticprops);\n  object.defineproperty(constructor, "prototype", { writable: false });\n  return constructor;\n}\n\nfunction _createsuper(derived) {\n  var hasnativereflectconstruct = _isnativereflectconstruct();\n  return function _createsuperinternal() {\n    var super = _getprototypeof(derived),\n      result;\n    if (hasnativereflectconstruct) {\n      var newtarget = _getprototypeof(this).constructor;\n      result = reflect.construct(super, arguments, newtarget);\n    } else {\n      result = super.apply(this, arguments);\n    }\n    return _possibleconstructorreturn(this, result);\n  };\n}\n\nvar base = /*#__pure__*/ (function () {\n  function base() {\n    _classcallcheck(this, base);\n\n    _defineproperty(this, "name", "111");\n\n    _defineproperty(this, "age", 222);\n  }\n\n  _createclass(base, [\n    {\n      key: "say",\n      value: function say() {\n        console.log("base say");\n      },\n    },\n    {\n      key: "run",\n      value: function run() {\n        console.log("base run");\n      },\n    },\n  ]);\n\n  return base;\n})();\n\nvar sub = /*#__pure__*/ (function (_base) {\n  _inherits(sub, _base);\n\n  var _super = _createsuper(sub);\n\n  function sub() {\n    _classcallcheck(this, sub);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createclass(sub, [\n    {\n      key: "run",\n      value: function run() {\n        console.log("sub run");\n      },\n    },\n  ]);\n\n  return sub;\n})(base);\n\n\n关键就是看_createsuper这个辅助函数，其返回一个函数，其直接调用了一次super，相当于我们得到的是一个把当前类上所有属性完成拷贝的对象，这就避免了多个子类继承同一个父类的时候，共用一个父类的属性的问题\n\n接着，我们根据第二条定理来推导的第二条原型指向关系：\n\nsub.__proto__ = base;\n\n\n为什么是这样，根据上文阐述，我们知道，所有类的静态属性或者方法都挂载在类本身的，既然 js 引擎取值不会报错，那么自然这个类的原型是父类。\n\n\n# super 关键字\n\n上述代码中我们可以看到，当子类中方法和父类重名的时候，会出现一种比较奇妙的现象，我们回想一下 js 对象的属性访问规则，当前对象上有名为 xxx 的方法，便不会向上查找了，子类已经完全修改了父类的行为，专业术语叫做重写或者覆盖，这个语法特性在面向对象程序设计中有相当大的应用，比如常见的设计模式：模板方法模式、策略模式、命令模式等都可以看到这个特性的应用。\n\nclass strategy {\n  run() {\n    console.log("base run");\n  }\n}\n\nclass simplestrategy extends strategy {\n  run() {\n    console.log("sub run");\n  }\n}\n\nclass complexstrategy extends strategy() {\n  run() {\n    console.log("sub run");\n  }\n}\n\nfunction selectstrategy(mode) {\n  let stg = null;\n  switch (mode) {\n    case "simple":\n      stg = new simlestrategy();\n      break;\n    case "multi":\n      stg = new complexstrategy();\n      break;\n  }\n  return stg;\n}\n\nclass bootstrap {\n  runner() {\n    const stg = selectstrategy(import.meta.env.strategy);\n    stg.run();\n  }\n}\n\n\n若我们又不想完全覆盖父类的行为呢，比如某些时候，我们得到的一个 sdk 已经提供了某些功能，但是这个功能又不完全满足我们的业务，我们需要针对我们的业务定制化，此刻就可以使得super关键字派上用场了。\n\nclass base {\n  run() {\n    console.log("base run");\n  }\n}\n\nclass sub extends base {\n  run() {\n    super.run();\n    console.log("sub run");\n  }\n}\n\n\n\n# class 的一些注意点\n\n * 类和模块的内部，默认就是严格模式\n * 类的方法内部如果含有this，它默认指向类的实例，但是并不意味着就是绝对安全的，比如有些老六\n\nclass person {\n  name = "yx";\n\n  say() {\n    console.log(this.name);\n  }\n}\nconst p = new person();\nconst say = p.say;\n// uncaught typeerror: cannot read properties of undefined\nsay();\n\n\n * 类不存在提升\n * 类中有一个名为new.target的属性，这个属性在初始化的时候指向的是类本身，因此可以用这个属性判断类是否使用new调用，即便子类继承了父类，在父类中，new.target仍然指向子类。',charsets:{cjk:!0}},{title:"迭代器",frontmatter:{},regularPath:"/javascript/es6/iterator.html",relativePath:"javascript/es6/iterator.md",key:"v-865a99d6",path:"/javascript/es6/iterator.html",headers:[{level:2,title:"迭代器",slug:"迭代器",normalizedTitle:"迭代器",charIndex:2},{level:3,title:"1、基本概念",slug:"_1、基本概念",normalizedTitle:"1、基本概念",charIndex:245},{level:3,title:"2、调用 Iterator 的场合",slug:"_2、调用-iterator-的场合",normalizedTitle:"2、调用 iterator 的场合",charIndex:2721},{level:3,title:"3、遍历器对象的 return 方法和 throw 方法",slug:"_3、遍历器对象的-return-方法和-throw-方法",normalizedTitle:"3、遍历器对象的 return 方法和 throw 方法",charIndex:4033},{level:2,title:"异步迭代器",slug:"异步迭代器",normalizedTitle:"异步迭代器",charIndex:4748},{level:3,title:"1、基本概念",slug:"_1、基本概念-2",normalizedTitle:"1、基本概念",charIndex:245},{level:3,title:"2、异步Generator函数",slug:"_2、异步generator函数",normalizedTitle:"2、异步generator函数",charIndex:6772}],headersStr:"迭代器 1、基本概念 2、调用 Iterator 的场合 3、遍历器对象的 return 方法和 throw 方法 异步迭代器 1、基本概念 2、异步Generator函数",content:'# 迭代器\n\n在阐述这篇文章之前，首先看一道比较经典的面试题，可能看过之后大家将会为什么技术积累有多么的重要了。（在阅读本文之前，请确保你已经完全掌握Symbol的相关知识点。）\n\n为了使得下面的代码按预期运行，请问在右侧的对象上需要进行什么操作？\n\nconst [a, b] = { a: 1, b: 2 };\n\n\n既然这题放在Iterator这一节，那么肯定是跟Iterator的知识点相关了，如果你一时半会儿还没有任何思路的话，请先接着往下面看，然后你心中自然就会有答案了。\n\n\n# 1、基本概念\n\n遍历器（Iterator），它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。\n\n在ES6之前只有数组和对象这两种表示集合的数据结构，但是ES6增加了很多的数据结构(如Map，Set)，因此Iterator的出现可以使得这些数据结构的遍历有一套标准的方法，ES6创造了一种新的遍历命令for...of循环，Iterator接口主要供for...of消费。\n\n遍历器接口（Iterable）、指针对象（Iterator）和next方法返回值的规格可以描述如下。\n\ninterface Iterable {\n  [Symbol.iterator](): Iterator;\n}\n\ninterface Iterator {\n  next(value?: any): IterationResult;\n}\n\ninterface IterationResult {\n  value: any;\n  done: boolean;\n}\n\n\n原生具备Iterator接口的数据结构如下。\n\n * Array\n * Map\n * Set\n * String\n * TypedArray\n * 函数的arguments对象\n * NodeList对象\n\n也就是说，这些数据结构天生支持for-of遍历，并且我们可以拿上述这些数据结构自带的Iterator进行迭代:\n\n// 手动调用String的Iterator\nconst str = "hello world";\n// 得到string的Iterator\nconst it = str[Symbol.iterator]();\nit.next();\n// {value: \'h\', done: false}\nit.next();\n// {value: \'e\', done: false}\nit.next();\n// {value: \'l\', done: false}\nit.next();\n// {value: \'l\', done: false}\nit.next();\n// {value: \'o\', done: false}\nit.next();\n// {value: \' \', done: false}\nit.next();\n// {value: \'w\', done: false}\nit.next();\n// {value: \'o\', done: false}\nit.next();\n// {value: \'r\', done: false}\nit.next();\n// {value: \'l\', done: false}\nit.next();\n// {value: \'d\', done: false}\nit.next();\n// {value: undefined, done: true}\n\n\nconst str = "hello world";\nfor (const char of str) {\n  console.log(char);\n}\n\n\n可以看到，如果我们自己去调用String的Iterator的话，最后会输出一个{value: undefined, done: true}的结果，可是为什么for-of循环没有输出这个结果呢？\n\nWARNING\n\n这儿有一个重要的结论：for-of循环只会遍历迭代器done的值为false的结果\n\n所以，如果用for-of循环遍历Generator生成的迭代器的话，无法处理到最后Generator函数的return值的(若有)。\n\n另外，还有个易错点，就是有些同学初学时可能会犯这样的错误，为什么我已经明明按照规格定义了，但是采用for-of循环的时候却说这个结果不是可迭代的对象呢？\n\n/**\n * 创建一个迭代器\n * @param {number[]} values\n * @returns\n */\nfunction createIterator(values) {\n  let idx = 0;\n  return {\n    next() {\n      return {\n        value: values[idx++],\n        done: idx > values.length,\n      };\n    },\n  };\n}\n\nfor (const num of createIterator([1, 2, 3, 4, 5, 6])) {\n  console.log(num);\n}\n\n\n代码运行时却得到了这样的一个错误：\n\ncreateIterator is not a function or its return value is not iterable\n\n\n其实你这个情况就是典型的自我感动，因为你知道它是一个迭代器，但是系统并不知道它是一个迭代器。\n\n所以仅仅需要为其添加简单的一行代码即可：\n\n/**\n * 创建一个迭代器\n * @param {number[]} values\n * @returns\n */\nfunction createIterator(values) {\n  let idx = 0;\n  return {\n    // 需要明确的告知系统，迭代时，就调用我自己就好\n    [Symbol.iterator]() {\n      return this;\n    },\n    next() {\n      return {\n        value: values[idx++],\n        done: idx > values.length,\n      };\n    },\n  };\n}\n\nfor (const num of createIterator([1, 2, 3, 4, 5, 6])) {\n  console.log(num);\n}\n\n\n\n# 2、调用 Iterator 的场合\n\n如果你认真的阅读完本节，就可以回答本文开头提到的面试题了。除了for-of循环，主要在这几类场合会默认调用Iterator\n\n * 解构赋值: 对数组和Set结构进行解构赋值时，会默认调用Symbol.iterator方法。\n * 扩展运算符: 扩展运算符...也会调用默认的 Iterator 接口。\n * yield*: yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。\n\nlet generator = function* () {\n  yield 1;\n  yield* [2, 3, 4];\n  yield 5;\n};\n\nvar iterator = generator();\n\niterator.next(); // { value: 1, done: false }\niterator.next(); // { value: 2, done: false }\niterator.next(); // { value: 3, done: false }\niterator.next(); // { value: 4, done: false }\niterator.next(); // { value: 5, done: false }\niterator.next(); // { value: undefined, done: true }\n\n\n * 其它场合:\n * for...of\n * Array.from()\n * Map(), Set(), WeakMap(), WeakSet()（比如 new Map([[\'a\',1],[\'b\',2]])）\n * Promise.all()\n * Promise.race()\n\n因此，对于我们在文章开头提到的那题，我们只能从解构赋值的场景去思考，把右侧的内容当成一个数组，但是因为对象并不原生具备Iterator，因此，我们就可以给他补一个Iterator就可以使得代码正常运行了。\n\nconst [a, b] = {\n  a: 1,\n  b: 2,\n  [Symbol.iterator]() {\n    const keys = Object.keys(this);\n    let idx = 0;\n    const _this = this;\n    return {\n      next() {\n        const i = idx++;\n        return {\n          value: _this[keys[i]],\n          done: i >= keys.length,\n        };\n      },\n    };\n  },\n};\n\n\n需要注意的是，因为这种解构方式并不是原生支持的方式，有可能键取值顺序的关系，a和b变量并不是一定拿到的就是 1 和 2，仅仅是这行代码能够正常工作而已（对象（Object）之所以没有默认部署Iterator接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定）。\n\n\n# 3、遍历器对象的 return 方法和 throw 方法\n\n遍历器对象除了具有next方法，还可以具有return方法和throw方法。如果你自己写遍历器对象生成函数，那么next方法是必须的，return方法和 throw方法是可选的。\n\nreturn是一个无参数或者接受一个参数的函数，并返回符合IteratorResult接口的对象，其参数value通常等价于传递的value，并且done等于true。调用这个方法表明迭代器的调用者不打算调用更多的next方法，并且可以进行清理工作。\n\nthrow方法无参数或者接受一个参数的函数，并返回符合IteratorResult接口的对象，通常done等于true。调用这个方法表明迭代器的调用者监测到错误的状况，并且其参数exception通常是一个Error实例。\n\n其TS定义可以参考如下代码：\n\ninterface Iterator<T, TReturn = any, TNext = undefined> {\n  // NOTE: \'next\' is defined using a tuple to ensure we report the correct assignability errors in all places.\n  next(...args: [] | [TNext]): IteratorResult<T, TReturn>;\n  return?(value?: TReturn): IteratorResult<T, TReturn>;\n  throw?(e?: any): IteratorResult<T, TReturn>;\n}\n\n\n\n# 异步迭代器\n\n\n# 1、基本概念\n\n上述代码都要求我们的代码是同步代码，即调用next函数时其必须立即返回结果。但实际上有些场景下肯定是存在异步情况的(设计模式有个模式叫做迭代器模式，而我们在实际的开发中需要将一些异步操作统一规格进行操作)。\n\nES2018引入了一个异步迭代器的概念，即同步迭代器返回结果是{ value: any; done: boolean }，异步迭代器的返回结果是Promise<{value: any; done: boolean}>\n\n/**\n * 创建一个异步迭代器\n * @param {number[]} values\n * @returns\n */\nfunction createAsyncIterator(values) {\n  let idx = 0;\n  return {\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n    next() {\n      return new Promise((resolve) => {\n        resolve({\n          value: values[idx++],\n          done: idx > values.length,\n        });\n      });\n    },\n  };\n}\n\n\n上述这个代码得到的迭代器，如果自己实现数据结构遍历其实还是不太容易的。因为程序的执行流程是异步的，循环遍历只能处理同步代码，是达不到我们想要的效果的。\n\n如果有看到过async函数的spawn函数实现过程的小伙伴肯定脑袋中一下子就会有解决方案：递归。\n\n以下是我自己写的一个异步迭代器的遍历器：\n\n/**\n * 异步迭代器遍历器\n * @param {AsyncIterator} it 异步迭代器\n */\nfunction run(it) {\n  if (!it || typeof it[Symbol.asyncIterator] !== "function") {\n    console.log("the parameter must be an asynchronous iterator");\n    return;\n  }\n  it.next().then(({ value, done }) => {\n    if (!done) {\n      run(it);\n    }\n    console.log(value);\n  });\n}\n\n\n于是ES6又提供了一个新语法: for await...of，除了多了一个await关键字以外，它消费的接口是Symbol.asyncIterator，其他技术特征跟for-of没有什么区别。\n\nfor await...of 同样可以用于同步迭代器（其实也很好解释，采用Promise.resolve()将一个不是Promise的值包裹成一个Promise，规格就保持一致了嘛）\n\n因为加上了await关键字，所有函数最外层就要套上async关键字（本文不考虑顶层await关键字语法），使用for await-of遍历这个异步迭代器，可以将代码书写成如下：\n\nconst it = createAsyncIterator([1, 2, 3, 4, 5, 6]);\n(async function run() {\n  // 多了一个await关键字\n  for await (const num of it) {\n    console.log(num);\n  }\n})();\n\n\n代码真的是简洁了不少。\n\nfor await...of会等待前一个异步任务完成之后才会继续向后迭代，这个，我们可以在后面用一个异步Generator函数的例子得到证明。\n\n但是：\n\nWARNING\n\n异步迭代器的next方法是可以一直调用的，并不需要等待先前的异步操作完成\n\n其实这个语法特点也比较好理解，我们先调next函数相当于是在部署异步链，但是异步任务什么时候执行到这个位置，这就不得而知了。\n\n用一个简单的例子来理解这个事儿，就比如湖南浏阳的烟花爆竹全国出名，他们在制作花炮时，首先将其一个一个的爆竹绑在一条预设的引线上，而这个引线什么时候点，就取决于最终花炮的所有者，当引线烧到了爆竹的位置，爆竹就爆炸了。\n\n这个例子中，将爆竹绑在引线上，其实就好比我们在调用next函数，然后爆竹爆炸就是好比我们写在其Promise的then方法的回调执行了，而引线什么时候点燃，就取决于这个异步链的上游的Promise的状态改变。\n\n而你用for await...of遍历，就会像是async函数内部的运行原理一样，是递归的一步一步的向后迭代的，每一步都需要等待上一步的异步任务完成，才会到下一个异步任务。\n\n\n# 2、异步Generator函数\n\n在Generator那节，我们讨论了Generator函数的执行结果是一个迭代器，而如果在一个Generator函数前加上关键字async，那么这个函数就变成了异步Generator函数\n\nfunction* bar() {}\nconst b = bar();\nconsole.log(b[Symbol.toStringTag]); // Generator\nconsole.log(b[Symbol.iterator]); // ƒ [Symbol.iterator]() { [native code] }\n\nasync function* foo() {}\nconst a = foo();\nconsole.log(a[Symbol.toStringTag]); // AsyncGenerator\nconsole.log(a[Symbol.asyncIterator]); // ƒ [Symbol.asyncIterator]() { [native code] }\nconsole.log(a[Symbol.iterator]); // undefined\n\n\n其实也没有什么大不了的，函数体内部肯定会出现await关键字罢了，其它的技术特征跟普通的Generator也差不多，不过因为有await关键字的加入，所以await语句后面的逻辑需要等待异步任务执行完成之后才能执行了。\n\n以下是摘自阮一峰老师网络书籍《ES6入门》的一个例子：\n\nasync function* readLines(path) {\n  let file = await fileOpen(path);\n  try {\n    while (!file.EOF) {\n      yield await file.readLine();\n    }\n  } finally {\n    await file.close();\n  }\n}\n\n\n另外，我们继续可以用这个代码来验证，异步Generator函数里面有一个永远pending的Promise，执行这个函数运行的结果，发现除了Promise构造函数里面的内容输出了，其余啥都没有。\n\nasync function* foreverPendingTest() {\n  await new Promise(() => {\n    console.log("我就是啥都不做");\n  });\n  yield 1;\n  yield 2;\n  yield 3;\n}\n\n(async function () {\n  for await (const val of foreverPendingTest()) {\n    console.log(val);\n  }\n  console.log("异步遍历完成");\n})();\n\n\n也就是如果这个迭代器的next函数的then方法里面部署代码，一个都不会执行。这个例子，就是回答之前我们在异步迭代器开始的时候所提到的。\n\n通过babel对for await-of的编译结果来看，确实也可以证明其内部的运行原理和async是一样的。\n\n"use strict";\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n      args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);\n      }\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);\n      }\n      _next(undefined);\n    });\n  };\n}\n\nfunction _asyncIterator(iterable) {\n  var method,\n    async,\n    sync,\n    retry = 2;\n  for (\n    "undefined" != typeof Symbol &&\n    ((async = Symbol.asyncIterator), (sync = Symbol.iterator));\n    retry--;\n\n  ) {\n    if (async && null != (method = iterable[async]))\n      return method.call(iterable);\n    if (sync && null != (method = iterable[sync]))\n      return new AsyncFromSyncIterator(method.call(iterable));\n    (async = "@@asyncIterator"), (sync = "@@iterator");\n  }\n  throw new TypeError("Object is not async iterable");\n}\n\nfunction AsyncFromSyncIterator(s) {\n  function AsyncFromSyncIteratorContinuation(r) {\n    if (Object(r) !== r)\n      return Promise.reject(new TypeError(r + " is not an object."));\n    var done = r.done;\n    return Promise.resolve(r.value).then(function (value) {\n      return { value: value, done: done };\n    });\n  }\n  return (\n    (AsyncFromSyncIterator = function AsyncFromSyncIterator(s) {\n      (this.s = s), (this.n = s.next);\n    }),\n    (AsyncFromSyncIterator.prototype = {\n      s: null,\n      n: null,\n      next: function next() {\n        return AsyncFromSyncIteratorContinuation(\n          this.n.apply(this.s, arguments)\n        );\n      },\n      return: function _return(value) {\n        var ret = this.s["return"];\n        return void 0 === ret\n          ? Promise.resolve({ value: value, done: !0 })\n          : AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments));\n      },\n      throw: function _throw(value) {\n        var thr = this.s["return"];\n        return void 0 === thr\n          ? Promise.reject(value)\n          : AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments));\n      },\n    }),\n    new AsyncFromSyncIterator(s)\n  );\n}\n\n(function () {\n  var _run = _asyncToGenerator(\n    /*#__PURE__*/ _regeneratorRuntime().mark(function _callee() {\n      var _iteratorAbruptCompletion,\n        _didIteratorError,\n        _iteratorError,\n        _iterator,\n        _step,\n        num;\n\n      return _regeneratorRuntime().wrap(\n        function _callee$(_context) {\n          while (1) {\n            switch ((_context.prev = _context.next)) {\n              case 0:\n                _iteratorAbruptCompletion = false;\n                _didIteratorError = false;\n                _context.prev = 2;\n                _iterator = _asyncIterator([1, 2, 3]);\n\n              case 4:\n                _context.next = 6;\n                return _iterator.next();\n\n              case 6:\n                if (\n                  !(_iteratorAbruptCompletion = !(_step = _context.sent).done)\n                ) {\n                  _context.next = 12;\n                  break;\n                }\n\n                num = _step.value;\n                console.log(num);\n\n              case 9:\n                _iteratorAbruptCompletion = false;\n                _context.next = 4;\n                break;\n\n              case 12:\n                _context.next = 18;\n                break;\n\n              case 14:\n                _context.prev = 14;\n                _context.t0 = _context["catch"](2);\n                _didIteratorError = true;\n                _iteratorError = _context.t0;\n\n              case 18:\n                _context.prev = 18;\n                _context.prev = 19;\n\n                if (\n                  !(_iteratorAbruptCompletion && _iterator["return"] != null)\n                ) {\n                  _context.next = 23;\n                  break;\n                }\n\n                _context.next = 23;\n                return _iterator["return"]();\n\n              case 23:\n                _context.prev = 23;\n\n                if (!_didIteratorError) {\n                  _context.next = 26;\n                  break;\n                }\n\n                throw _iteratorError;\n\n              case 26:\n                return _context.finish(23);\n\n              case 27:\n                return _context.finish(18);\n\n              case 28:\n              case "end":\n                return _context.stop();\n            }\n          }\n        },\n        _callee,\n        null,\n        [\n          [2, 14, 18, 28],\n          [19, , 23, 27],\n        ]\n      );\n    })\n  );\n\n  function run() {\n    return _run.apply(this, arguments);\n  }\n\n  return run;\n})()();\n\n\n上述代码没有贴generator-runtime库的代码。另外，while循环中嵌套的switch-case可以不用看，因为这个是generator函数流转流程的代码，我们只需要把它看做一个状态转化的黑盒就行。\n\n如果上述代码你阅读有困难，可以先查阅我关于Generator和Async函数的文章。\n\n重点在_asyncIterator函数上，如果一个迭代器不是异步的迭代器，它会尝试将其转化成异步迭代器，那就可以得出一个结论:\n\nfor await-of既能遍历同步迭代器也能遍历异步迭代器，而for-of只能遍历同步跌代器。',normalizedContent:'# 迭代器\n\n在阐述这篇文章之前，首先看一道比较经典的面试题，可能看过之后大家将会为什么技术积累有多么的重要了。（在阅读本文之前，请确保你已经完全掌握symbol的相关知识点。）\n\n为了使得下面的代码按预期运行，请问在右侧的对象上需要进行什么操作？\n\nconst [a, b] = { a: 1, b: 2 };\n\n\n既然这题放在iterator这一节，那么肯定是跟iterator的知识点相关了，如果你一时半会儿还没有任何思路的话，请先接着往下面看，然后你心中自然就会有答案了。\n\n\n# 1、基本概念\n\n遍历器（iterator），它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署iterator接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。\n\n在es6之前只有数组和对象这两种表示集合的数据结构，但是es6增加了很多的数据结构(如map，set)，因此iterator的出现可以使得这些数据结构的遍历有一套标准的方法，es6创造了一种新的遍历命令for...of循环，iterator接口主要供for...of消费。\n\n遍历器接口（iterable）、指针对象（iterator）和next方法返回值的规格可以描述如下。\n\ninterface iterable {\n  [symbol.iterator](): iterator;\n}\n\ninterface iterator {\n  next(value?: any): iterationresult;\n}\n\ninterface iterationresult {\n  value: any;\n  done: boolean;\n}\n\n\n原生具备iterator接口的数据结构如下。\n\n * array\n * map\n * set\n * string\n * typedarray\n * 函数的arguments对象\n * nodelist对象\n\n也就是说，这些数据结构天生支持for-of遍历，并且我们可以拿上述这些数据结构自带的iterator进行迭代:\n\n// 手动调用string的iterator\nconst str = "hello world";\n// 得到string的iterator\nconst it = str[symbol.iterator]();\nit.next();\n// {value: \'h\', done: false}\nit.next();\n// {value: \'e\', done: false}\nit.next();\n// {value: \'l\', done: false}\nit.next();\n// {value: \'l\', done: false}\nit.next();\n// {value: \'o\', done: false}\nit.next();\n// {value: \' \', done: false}\nit.next();\n// {value: \'w\', done: false}\nit.next();\n// {value: \'o\', done: false}\nit.next();\n// {value: \'r\', done: false}\nit.next();\n// {value: \'l\', done: false}\nit.next();\n// {value: \'d\', done: false}\nit.next();\n// {value: undefined, done: true}\n\n\nconst str = "hello world";\nfor (const char of str) {\n  console.log(char);\n}\n\n\n可以看到，如果我们自己去调用string的iterator的话，最后会输出一个{value: undefined, done: true}的结果，可是为什么for-of循环没有输出这个结果呢？\n\nwarning\n\n这儿有一个重要的结论：for-of循环只会遍历迭代器done的值为false的结果\n\n所以，如果用for-of循环遍历generator生成的迭代器的话，无法处理到最后generator函数的return值的(若有)。\n\n另外，还有个易错点，就是有些同学初学时可能会犯这样的错误，为什么我已经明明按照规格定义了，但是采用for-of循环的时候却说这个结果不是可迭代的对象呢？\n\n/**\n * 创建一个迭代器\n * @param {number[]} values\n * @returns\n */\nfunction createiterator(values) {\n  let idx = 0;\n  return {\n    next() {\n      return {\n        value: values[idx++],\n        done: idx > values.length,\n      };\n    },\n  };\n}\n\nfor (const num of createiterator([1, 2, 3, 4, 5, 6])) {\n  console.log(num);\n}\n\n\n代码运行时却得到了这样的一个错误：\n\ncreateiterator is not a function or its return value is not iterable\n\n\n其实你这个情况就是典型的自我感动，因为你知道它是一个迭代器，但是系统并不知道它是一个迭代器。\n\n所以仅仅需要为其添加简单的一行代码即可：\n\n/**\n * 创建一个迭代器\n * @param {number[]} values\n * @returns\n */\nfunction createiterator(values) {\n  let idx = 0;\n  return {\n    // 需要明确的告知系统，迭代时，就调用我自己就好\n    [symbol.iterator]() {\n      return this;\n    },\n    next() {\n      return {\n        value: values[idx++],\n        done: idx > values.length,\n      };\n    },\n  };\n}\n\nfor (const num of createiterator([1, 2, 3, 4, 5, 6])) {\n  console.log(num);\n}\n\n\n\n# 2、调用 iterator 的场合\n\n如果你认真的阅读完本节，就可以回答本文开头提到的面试题了。除了for-of循环，主要在这几类场合会默认调用iterator\n\n * 解构赋值: 对数组和set结构进行解构赋值时，会默认调用symbol.iterator方法。\n * 扩展运算符: 扩展运算符...也会调用默认的 iterator 接口。\n * yield*: yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。\n\nlet generator = function* () {\n  yield 1;\n  yield* [2, 3, 4];\n  yield 5;\n};\n\nvar iterator = generator();\n\niterator.next(); // { value: 1, done: false }\niterator.next(); // { value: 2, done: false }\niterator.next(); // { value: 3, done: false }\niterator.next(); // { value: 4, done: false }\niterator.next(); // { value: 5, done: false }\niterator.next(); // { value: undefined, done: true }\n\n\n * 其它场合:\n * for...of\n * array.from()\n * map(), set(), weakmap(), weakset()（比如 new map([[\'a\',1],[\'b\',2]])）\n * promise.all()\n * promise.race()\n\n因此，对于我们在文章开头提到的那题，我们只能从解构赋值的场景去思考，把右侧的内容当成一个数组，但是因为对象并不原生具备iterator，因此，我们就可以给他补一个iterator就可以使得代码正常运行了。\n\nconst [a, b] = {\n  a: 1,\n  b: 2,\n  [symbol.iterator]() {\n    const keys = object.keys(this);\n    let idx = 0;\n    const _this = this;\n    return {\n      next() {\n        const i = idx++;\n        return {\n          value: _this[keys[i]],\n          done: i >= keys.length,\n        };\n      },\n    };\n  },\n};\n\n\n需要注意的是，因为这种解构方式并不是原生支持的方式，有可能键取值顺序的关系，a和b变量并不是一定拿到的就是 1 和 2，仅仅是这行代码能够正常工作而已（对象（object）之所以没有默认部署iterator接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定）。\n\n\n# 3、遍历器对象的 return 方法和 throw 方法\n\n遍历器对象除了具有next方法，还可以具有return方法和throw方法。如果你自己写遍历器对象生成函数，那么next方法是必须的，return方法和 throw方法是可选的。\n\nreturn是一个无参数或者接受一个参数的函数，并返回符合iteratorresult接口的对象，其参数value通常等价于传递的value，并且done等于true。调用这个方法表明迭代器的调用者不打算调用更多的next方法，并且可以进行清理工作。\n\nthrow方法无参数或者接受一个参数的函数，并返回符合iteratorresult接口的对象，通常done等于true。调用这个方法表明迭代器的调用者监测到错误的状况，并且其参数exception通常是一个error实例。\n\n其ts定义可以参考如下代码：\n\ninterface iterator<t, treturn = any, tnext = undefined> {\n  // note: \'next\' is defined using a tuple to ensure we report the correct assignability errors in all places.\n  next(...args: [] | [tnext]): iteratorresult<t, treturn>;\n  return?(value?: treturn): iteratorresult<t, treturn>;\n  throw?(e?: any): iteratorresult<t, treturn>;\n}\n\n\n\n# 异步迭代器\n\n\n# 1、基本概念\n\n上述代码都要求我们的代码是同步代码，即调用next函数时其必须立即返回结果。但实际上有些场景下肯定是存在异步情况的(设计模式有个模式叫做迭代器模式，而我们在实际的开发中需要将一些异步操作统一规格进行操作)。\n\nes2018引入了一个异步迭代器的概念，即同步迭代器返回结果是{ value: any; done: boolean }，异步迭代器的返回结果是promise<{value: any; done: boolean}>\n\n/**\n * 创建一个异步迭代器\n * @param {number[]} values\n * @returns\n */\nfunction createasynciterator(values) {\n  let idx = 0;\n  return {\n    [symbol.asynciterator]() {\n      return this;\n    },\n    next() {\n      return new promise((resolve) => {\n        resolve({\n          value: values[idx++],\n          done: idx > values.length,\n        });\n      });\n    },\n  };\n}\n\n\n上述这个代码得到的迭代器，如果自己实现数据结构遍历其实还是不太容易的。因为程序的执行流程是异步的，循环遍历只能处理同步代码，是达不到我们想要的效果的。\n\n如果有看到过async函数的spawn函数实现过程的小伙伴肯定脑袋中一下子就会有解决方案：递归。\n\n以下是我自己写的一个异步迭代器的遍历器：\n\n/**\n * 异步迭代器遍历器\n * @param {asynciterator} it 异步迭代器\n */\nfunction run(it) {\n  if (!it || typeof it[symbol.asynciterator] !== "function") {\n    console.log("the parameter must be an asynchronous iterator");\n    return;\n  }\n  it.next().then(({ value, done }) => {\n    if (!done) {\n      run(it);\n    }\n    console.log(value);\n  });\n}\n\n\n于是es6又提供了一个新语法: for await...of，除了多了一个await关键字以外，它消费的接口是symbol.asynciterator，其他技术特征跟for-of没有什么区别。\n\nfor await...of 同样可以用于同步迭代器（其实也很好解释，采用promise.resolve()将一个不是promise的值包裹成一个promise，规格就保持一致了嘛）\n\n因为加上了await关键字，所有函数最外层就要套上async关键字（本文不考虑顶层await关键字语法），使用for await-of遍历这个异步迭代器，可以将代码书写成如下：\n\nconst it = createasynciterator([1, 2, 3, 4, 5, 6]);\n(async function run() {\n  // 多了一个await关键字\n  for await (const num of it) {\n    console.log(num);\n  }\n})();\n\n\n代码真的是简洁了不少。\n\nfor await...of会等待前一个异步任务完成之后才会继续向后迭代，这个，我们可以在后面用一个异步generator函数的例子得到证明。\n\n但是：\n\nwarning\n\n异步迭代器的next方法是可以一直调用的，并不需要等待先前的异步操作完成\n\n其实这个语法特点也比较好理解，我们先调next函数相当于是在部署异步链，但是异步任务什么时候执行到这个位置，这就不得而知了。\n\n用一个简单的例子来理解这个事儿，就比如湖南浏阳的烟花爆竹全国出名，他们在制作花炮时，首先将其一个一个的爆竹绑在一条预设的引线上，而这个引线什么时候点，就取决于最终花炮的所有者，当引线烧到了爆竹的位置，爆竹就爆炸了。\n\n这个例子中，将爆竹绑在引线上，其实就好比我们在调用next函数，然后爆竹爆炸就是好比我们写在其promise的then方法的回调执行了，而引线什么时候点燃，就取决于这个异步链的上游的promise的状态改变。\n\n而你用for await...of遍历，就会像是async函数内部的运行原理一样，是递归的一步一步的向后迭代的，每一步都需要等待上一步的异步任务完成，才会到下一个异步任务。\n\n\n# 2、异步generator函数\n\n在generator那节，我们讨论了generator函数的执行结果是一个迭代器，而如果在一个generator函数前加上关键字async，那么这个函数就变成了异步generator函数\n\nfunction* bar() {}\nconst b = bar();\nconsole.log(b[symbol.tostringtag]); // generator\nconsole.log(b[symbol.iterator]); // ƒ [symbol.iterator]() { [native code] }\n\nasync function* foo() {}\nconst a = foo();\nconsole.log(a[symbol.tostringtag]); // asyncgenerator\nconsole.log(a[symbol.asynciterator]); // ƒ [symbol.asynciterator]() { [native code] }\nconsole.log(a[symbol.iterator]); // undefined\n\n\n其实也没有什么大不了的，函数体内部肯定会出现await关键字罢了，其它的技术特征跟普通的generator也差不多，不过因为有await关键字的加入，所以await语句后面的逻辑需要等待异步任务执行完成之后才能执行了。\n\n以下是摘自阮一峰老师网络书籍《es6入门》的一个例子：\n\nasync function* readlines(path) {\n  let file = await fileopen(path);\n  try {\n    while (!file.eof) {\n      yield await file.readline();\n    }\n  } finally {\n    await file.close();\n  }\n}\n\n\n另外，我们继续可以用这个代码来验证，异步generator函数里面有一个永远pending的promise，执行这个函数运行的结果，发现除了promise构造函数里面的内容输出了，其余啥都没有。\n\nasync function* foreverpendingtest() {\n  await new promise(() => {\n    console.log("我就是啥都不做");\n  });\n  yield 1;\n  yield 2;\n  yield 3;\n}\n\n(async function () {\n  for await (const val of foreverpendingtest()) {\n    console.log(val);\n  }\n  console.log("异步遍历完成");\n})();\n\n\n也就是如果这个迭代器的next函数的then方法里面部署代码，一个都不会执行。这个例子，就是回答之前我们在异步迭代器开始的时候所提到的。\n\n通过babel对for await-of的编译结果来看，确实也可以证明其内部的运行原理和async是一样的。\n\n"use strict";\n\nfunction asyncgeneratorstep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n  if (info.done) {\n    resolve(value);\n  } else {\n    promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asynctogenerator(fn) {\n  return function () {\n    var self = this,\n      args = arguments;\n    return new promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n      function _next(value) {\n        asyncgeneratorstep(gen, resolve, reject, _next, _throw, "next", value);\n      }\n      function _throw(err) {\n        asyncgeneratorstep(gen, resolve, reject, _next, _throw, "throw", err);\n      }\n      _next(undefined);\n    });\n  };\n}\n\nfunction _asynciterator(iterable) {\n  var method,\n    async,\n    sync,\n    retry = 2;\n  for (\n    "undefined" != typeof symbol &&\n    ((async = symbol.asynciterator), (sync = symbol.iterator));\n    retry--;\n\n  ) {\n    if (async && null != (method = iterable[async]))\n      return method.call(iterable);\n    if (sync && null != (method = iterable[sync]))\n      return new asyncfromsynciterator(method.call(iterable));\n    (async = "@@asynciterator"), (sync = "@@iterator");\n  }\n  throw new typeerror("object is not async iterable");\n}\n\nfunction asyncfromsynciterator(s) {\n  function asyncfromsynciteratorcontinuation(r) {\n    if (object(r) !== r)\n      return promise.reject(new typeerror(r + " is not an object."));\n    var done = r.done;\n    return promise.resolve(r.value).then(function (value) {\n      return { value: value, done: done };\n    });\n  }\n  return (\n    (asyncfromsynciterator = function asyncfromsynciterator(s) {\n      (this.s = s), (this.n = s.next);\n    }),\n    (asyncfromsynciterator.prototype = {\n      s: null,\n      n: null,\n      next: function next() {\n        return asyncfromsynciteratorcontinuation(\n          this.n.apply(this.s, arguments)\n        );\n      },\n      return: function _return(value) {\n        var ret = this.s["return"];\n        return void 0 === ret\n          ? promise.resolve({ value: value, done: !0 })\n          : asyncfromsynciteratorcontinuation(ret.apply(this.s, arguments));\n      },\n      throw: function _throw(value) {\n        var thr = this.s["return"];\n        return void 0 === thr\n          ? promise.reject(value)\n          : asyncfromsynciteratorcontinuation(thr.apply(this.s, arguments));\n      },\n    }),\n    new asyncfromsynciterator(s)\n  );\n}\n\n(function () {\n  var _run = _asynctogenerator(\n    /*#__pure__*/ _regeneratorruntime().mark(function _callee() {\n      var _iteratorabruptcompletion,\n        _diditeratorerror,\n        _iteratorerror,\n        _iterator,\n        _step,\n        num;\n\n      return _regeneratorruntime().wrap(\n        function _callee$(_context) {\n          while (1) {\n            switch ((_context.prev = _context.next)) {\n              case 0:\n                _iteratorabruptcompletion = false;\n                _diditeratorerror = false;\n                _context.prev = 2;\n                _iterator = _asynciterator([1, 2, 3]);\n\n              case 4:\n                _context.next = 6;\n                return _iterator.next();\n\n              case 6:\n                if (\n                  !(_iteratorabruptcompletion = !(_step = _context.sent).done)\n                ) {\n                  _context.next = 12;\n                  break;\n                }\n\n                num = _step.value;\n                console.log(num);\n\n              case 9:\n                _iteratorabruptcompletion = false;\n                _context.next = 4;\n                break;\n\n              case 12:\n                _context.next = 18;\n                break;\n\n              case 14:\n                _context.prev = 14;\n                _context.t0 = _context["catch"](2);\n                _diditeratorerror = true;\n                _iteratorerror = _context.t0;\n\n              case 18:\n                _context.prev = 18;\n                _context.prev = 19;\n\n                if (\n                  !(_iteratorabruptcompletion && _iterator["return"] != null)\n                ) {\n                  _context.next = 23;\n                  break;\n                }\n\n                _context.next = 23;\n                return _iterator["return"]();\n\n              case 23:\n                _context.prev = 23;\n\n                if (!_diditeratorerror) {\n                  _context.next = 26;\n                  break;\n                }\n\n                throw _iteratorerror;\n\n              case 26:\n                return _context.finish(23);\n\n              case 27:\n                return _context.finish(18);\n\n              case 28:\n              case "end":\n                return _context.stop();\n            }\n          }\n        },\n        _callee,\n        null,\n        [\n          [2, 14, 18, 28],\n          [19, , 23, 27],\n        ]\n      );\n    })\n  );\n\n  function run() {\n    return _run.apply(this, arguments);\n  }\n\n  return run;\n})()();\n\n\n上述代码没有贴generator-runtime库的代码。另外，while循环中嵌套的switch-case可以不用看，因为这个是generator函数流转流程的代码，我们只需要把它看做一个状态转化的黑盒就行。\n\n如果上述代码你阅读有困难，可以先查阅我关于generator和async函数的文章。\n\n重点在_asynciterator函数上，如果一个迭代器不是异步的迭代器，它会尝试将其转化成异步迭代器，那就可以得出一个结论:\n\nfor await-of既能遍历同步迭代器也能遍历异步迭代器，而for-of只能遍历同步跌代器。',charsets:{cjk:!0}},{title:"JS 常用的继承方案",frontmatter:{},regularPath:"/javascript/extend.html",relativePath:"javascript/extend.md",key:"v-2006ac96",path:"/javascript/extend.html",headers:[{level:2,title:"JS 常用的继承方案",slug:"js-常用的继承方案",normalizedTitle:"js 常用的继承方案",charIndex:2},{level:3,title:"1、原型链继承",slug:"_1、原型链继承",normalizedTitle:"1、原型链继承",charIndex:102},{level:3,title:"2、借用构造函数继承",slug:"_2、借用构造函数继承",normalizedTitle:"2、借用构造函数继承",charIndex:646},{level:3,title:"3、组合继承",slug:"_3、组合继承",normalizedTitle:"3、组合继承",charIndex:1097},{level:3,title:"4、原型式继承",slug:"_4、原型式继承",normalizedTitle:"4、原型式继承",charIndex:2125},{level:3,title:"5、寄生式继承",slug:"_5、寄生式继承",normalizedTitle:"5、寄生式继承",charIndex:2710},{level:3,title:"6、⭐️ 寄生组合式继承",slug:"_6、⭐️-寄生组合式继承",normalizedTitle:"6、⭐️ 寄生组合式继承",charIndex:3167},{level:3,title:"7、混入方式继承多个对象",slug:"_7、混入方式继承多个对象",normalizedTitle:"7、混入方式继承多个对象",charIndex:4301},{level:3,title:"8、⭐️ ES6 类继承 extends",slug:"_8、⭐️-es6-类继承-extends",normalizedTitle:"8、⭐️ es6 类继承 extends",charIndex:4787}],headersStr:"JS 常用的继承方案 1、原型链继承 2、借用构造函数继承 3、组合继承 4、原型式继承 5、寄生式继承 6、⭐️ 寄生组合式继承 7、混入方式继承多个对象 8、⭐️ ES6 类继承 extends",content:'# JS 常用的继承方案\n\n本文前面的几种继承方式有点儿属于为了面试而准备八股文，如果您作为一个初学者，抱着学习的态度阅读本文的话，最好掌握ES5的组合寄生继承和ES6的继承并且理解其原理最佳。\n\n\n# 1、原型链继承\n\nfunction SuperType() {\n  this.property = true;\n}\n\nSuperType.prototype.getSuperValue = function () {\n  return this.property;\n};\n\nfunction SubType() {\n  this.subproperty = false;\n}\n\n// 这里是关键，创建SuperType的实例，并将该实例赋值给SubType.prototype\nSubType.prototype = new SuperType();\n\nSubType.prototype.getSubValue = function () {\n  return this.subproperty;\n};\n\nvar instance = new SubType();\nconsole.log(instance.getSuperValue()); // true\n\n\n在SubType.prototype = new SuperType()可以看到，子类的原型都引用了同一个对象，因此原型链方案存在的缺点，当多个实例对引用类型的操作会被篡改，这种继承方式在实际开发中几乎不会用到。\n\n\n# 2、借用构造函数继承\n\n使用父类的构造函数来增强子类实例，等同于复制父类的实例给子类\n\nfunction SuperType() {\n  this.color = ["red", "green", "blue"];\n}\nfunction SubType() {\n  //继承自SuperType\n  SuperType.call(this);\n}\nvar instance1 = new SubType();\ninstance1.color.push("black");\nalert(instance1.color); //"red,green,blue,black"\n\nvar instance2 = new SubType();\nalert(instance2.color); //"red,green,blue"\n\n\n该方案就好比是仅仅把父类构造函数捞过来再执行了一遍，对自己的属性或方法形成一种 copy，但是这种继承无法继承父类原型上的属性和方法，这种继承方式在实际开发中也不会用。\n\n\n# 3、组合继承\n\n组合上述两种方法就是组合继承。用原型链实现对原型属性和方法的继承，用借用构造函数技术来实现实例属性的继承。\n\nfunction SuperType(name) {\n  this.name = name;\n  this.colors = ["red", "blue", "green"];\n}\nSuperType.prototype.sayName = function () {\n  alert(this.name);\n};\n\nfunction SubType(name, age) {\n  // 继承属性\n  // 第二次调用SuperType()\n  SuperType.call(this, name);\n  this.age = age;\n}\n\n// 继承方法\n// 构建原型链\n// 第一次调用SuperType()\nSubType.prototype = new SuperType();\n// 重写SubType.prototype的constructor属性，指向自己的构造函数SubType\nSubType.prototype.constructor = SubType;\nSubType.prototype.sayAge = function () {\n  alert(this.age);\n};\n\nvar instance1 = new SubType("Nicholas", 29);\ninstance1.colors.push("black");\nalert(instance1.colors); //"red,blue,green,black"\ninstance1.sayName(); //"Nicholas";\ninstance1.sayAge(); //29\n\nvar instance2 = new SubType("Greg", 27);\nalert(instance2.colors); //"red,blue,green"\ninstance2.sayName(); //"Greg";\ninstance2.sayAge(); //27\n\n\n实例对象 instance1 上的两个属性就屏蔽了其原型对象 SubType.prototype 的两个同名属性。所以，组合模式的缺点就是在使用子类创建实例对象时，其原型中会存在两份相同的属性/方法。\n\n组合继承的缺点就是父类的构造函数会调用两次。\n\n\n# 4、原型式继承\n\n利用一个空对象作为中介，将某个对象直接赋值给空对象构造函数的原型。\n\nfunction inherit(obj) {\n  function F() {}\n  F.prototype = obj;\n  return new F();\n}\n\n\nvar person = {\n  name: "Nicholas",\n  friends: ["Shelby", "Court", "Van"],\n};\n\nvar anotherPerson = inherit(person);\nanotherPerson.name = "Greg";\nanotherPerson.friends.push("Rob");\n\nvar yetAnotherPerson = inherit(person);\nyetAnotherPerson.name = "Linda";\nyetAnotherPerson.friends.push("Barbie");\n\nalert(person.friends); //"Shelby,Court,Van,Rob,Barbie"\n\n\n上述代码可以使用 ES5 提供的Object.create等价实现\n\n同样存在多个实例的引用类型属性指向相同，存在篡改的可能的这个缺点，并且还无法传递参数。在实际开发中有一定的使用场景，但是比较局限\n\n\n# 5、寄生式继承\n\n在原型式继承的基础上，增强对象，返回构造函数\n\nfunction createAnother(original) {\n  // 通过调用 Object.create() 函数创建一个新对象，其原型为original\n  var clone = Object.create(original);\n  clone.sayHi = function () {\n    // 以某种方式来增强对象\n    alert("hi");\n  };\n  return clone; // 返回这个对象\n}\n\n\n函数的主要作用是为构造函数新增属性和方法，以增强函数\n\nvar person = {\n  name: "Nicholas",\n  friends: ["Shelby", "Court", "Van"],\n};\nvar anotherPerson = createAnother(person);\nanotherPerson.sayHi(); //"hi"\n\n\n该方式和寄生继承存在一样的缺点。\n\n\n# 6、⭐️ 寄生组合式继承\n\n结合借用构造函数传递参数和寄生模式实现继承，即上述组合继承和寄生继承的结合体。\n\nfunction inheritPrototype(subType, superType) {\n  var prototype = Object.create(superType.prototype); // 创建对象，创建父类原型的一个副本\n  prototype.constructor = subType; // 增强对象，弥补因重写原型而失去的默认的constructor 属性\n  subType.prototype = prototype; // 指定对象，将新创建的对象赋值给子类的原型\n}\n\n// 父类初始化实例属性和原型属性\nfunction SuperType(name) {\n  this.name = name;\n  this.colors = ["red", "blue", "green"];\n}\nSuperType.prototype.sayName = function () {\n  alert(this.name);\n};\n\n// 借用构造函数传递增强子类实例属性（支持传参和避免篡改）\nfunction SubType(name, age) {\n  SuperType.call(this, name);\n  this.age = age;\n}\n\n// 将父类原型指向子类\ninheritPrototype(SubType, SuperType);\n\n// 新增子类原型属性\nSubType.prototype.sayAge = function () {\n  alert(this.age);\n};\n\nvar instance1 = new SubType("xyc", 23);\nvar instance2 = new SubType("lxy", 23);\n\ninstance1.colors.push("2"); // ["red", "blue", "green", "2"]\ninstance1.colors.push("3"); // ["red", "blue", "green", "3"]\n\n\n这种方式的高效率体现在它只调用了一次SuperType构造函数，并且因此避免了在SubType.prototype上创建不必要的、多余的属性。于此同时，原型链还能保持不变；因此，还能够正常使用instanceof 和Object.isPrototypeOf。\n\n这是最成熟的方法，也是现在库实现的方法，ES6类的继承编译成ES5代码之后就是使用的这种方式。\n\n这种方式是我们必须要掌握的继承方式。\n\n\n# 7、混入方式继承多个对象\n\nfunction MyClass() {\n  SuperClass.call(this);\n  OtherSuperClass.call(this);\n}\n\n// 继承一个类\nMyClass.prototype = Object.create(SuperClass.prototype);\n// 混合其它\nObject.assign(MyClass.prototype, OtherSuperClass.prototype);\n// 重新指定constructor\nMyClass.prototype.constructor = MyClass;\n\nMyClass.prototype.myMethod = function () {\n  // do something\n};\n\n\nObject.assign 会把 OtherSuperClass 原型上的函数拷贝到 MyClass 原型上，使 MyClass 的所有实例都可用 OtherSuperClass 的方法。\n\n实际开发中有类似混入的需求，但一般不会使用此方式来实现继承。\n\n\n# 8、⭐️ ES6 类继承 extends\n\nES6的继承最为简单，语法上跟Java，C#等语言类似，但是其原理是上述多种继承方式的组合。\n\nES6的继承，子类可以继承父类的非私有方法和属性（即使是静态方法或者属性也可以继承），比如：\n\nclass Base {\n  name = "111";\n\n  static age = 222;\n\n  static say() {\n    console.log("base say");\n  }\n\n  run() {\n    console.log("base run");\n  }\n}\n\nclass Sub extends Base {\n  run() {\n    console.log("sub run");\n  }\n}\n\n\n如果对ES6的类的语法及其原理不太清楚的同学请查看本文档阐述ES6的类的语法节。\n\nES6的继承有两条原型指向关系：\n\n * SubType.__proto__ === SuperType\n * SubType.prototype.__proto__ === SuperType.prototype\n\n以下是上述代码经过babel编译之后的节选\n\n"use strict";\n// 节选了相关代码\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== "function" && superClass !== null) {\n    throw new TypeError("Super expression must either be null or a function");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: { value: subClass, writable: true, configurable: true },\n  });\n  Object.defineProperty(subClass, "prototype", { writable: false });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf\n    ? Object.setPrototypeOf.bind()\n    : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n      };\n  return _setPrototypeOf(o, p);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, "prototype", { writable: false });\n  return Constructor;\n}\n\nvar Base = /*#__PURE__*/ (function () {\n  function Base() {\n    _classCallCheck(this, Base);\n\n    _defineProperty(this, "name", "111");\n  }\n\n  _createClass(\n    Base,\n    [\n      {\n        key: "run",\n        value: function run() {\n          console.log("base run");\n        },\n      },\n    ],\n    [\n      {\n        key: "say",\n        value: function say() {\n          console.log("base say");\n        },\n      },\n    ]\n  );\n\n  return Base;\n})();\n\n_defineProperty(Base, "age", 222);\n\nvar Sub = /*#__PURE__*/ (function (_Base) {\n  _inherits(Sub, _Base);\n\n  var _super = _createSuper(Sub);\n\n  function Sub() {\n    _classCallCheck(this, Sub);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Sub, [\n    {\n      key: "run",\n      value: function run() {\n        console.log("sub run");\n      },\n    },\n  ]);\n\n  return Sub;\n})(Base);\n\n\n关键函数_inherits，在这个函数中建立了子类和父类的原型关系（Object.create方法：创建以某个对象为原型对象的对象），自然就推导出了上述所说的第二条关系，即SubType.prototype.__proto__ === SuperType.prototype，(Object.setPrototypeOf方法:设置一个指定的对象的原型 ( 即, 内部[[Prototype]]属性）到另一个对象)，自然就推导出了上述的第一条结论，即：SubType.__proto__ === SuperType，以上便完成了静态属性和方法以及普通方法的继承。\n\n在上述处理完成之后，看看是如何处理普通属性的，关键点在_createSuper，这个函数返回的是一个函数，可以看到，其执行结果就是获取到绑定了父类构造器的函数，在这个构造器中，用反射的形式创建一个父类的实例，Reflect.construct(target, argumentsList[, newTarget])，这样就相当于先构造了一个父类的实例，好处就是可以使得多个子类继承一个父类的话，如果一个子类实例修改父类属性，不至于影响到父类和别的子类。\n\n所以ES6继承的本质还是组合寄生继承。',normalizedContent:'# js 常用的继承方案\n\n本文前面的几种继承方式有点儿属于为了面试而准备八股文，如果您作为一个初学者，抱着学习的态度阅读本文的话，最好掌握es5的组合寄生继承和es6的继承并且理解其原理最佳。\n\n\n# 1、原型链继承\n\nfunction supertype() {\n  this.property = true;\n}\n\nsupertype.prototype.getsupervalue = function () {\n  return this.property;\n};\n\nfunction subtype() {\n  this.subproperty = false;\n}\n\n// 这里是关键，创建supertype的实例，并将该实例赋值给subtype.prototype\nsubtype.prototype = new supertype();\n\nsubtype.prototype.getsubvalue = function () {\n  return this.subproperty;\n};\n\nvar instance = new subtype();\nconsole.log(instance.getsupervalue()); // true\n\n\n在subtype.prototype = new supertype()可以看到，子类的原型都引用了同一个对象，因此原型链方案存在的缺点，当多个实例对引用类型的操作会被篡改，这种继承方式在实际开发中几乎不会用到。\n\n\n# 2、借用构造函数继承\n\n使用父类的构造函数来增强子类实例，等同于复制父类的实例给子类\n\nfunction supertype() {\n  this.color = ["red", "green", "blue"];\n}\nfunction subtype() {\n  //继承自supertype\n  supertype.call(this);\n}\nvar instance1 = new subtype();\ninstance1.color.push("black");\nalert(instance1.color); //"red,green,blue,black"\n\nvar instance2 = new subtype();\nalert(instance2.color); //"red,green,blue"\n\n\n该方案就好比是仅仅把父类构造函数捞过来再执行了一遍，对自己的属性或方法形成一种 copy，但是这种继承无法继承父类原型上的属性和方法，这种继承方式在实际开发中也不会用。\n\n\n# 3、组合继承\n\n组合上述两种方法就是组合继承。用原型链实现对原型属性和方法的继承，用借用构造函数技术来实现实例属性的继承。\n\nfunction supertype(name) {\n  this.name = name;\n  this.colors = ["red", "blue", "green"];\n}\nsupertype.prototype.sayname = function () {\n  alert(this.name);\n};\n\nfunction subtype(name, age) {\n  // 继承属性\n  // 第二次调用supertype()\n  supertype.call(this, name);\n  this.age = age;\n}\n\n// 继承方法\n// 构建原型链\n// 第一次调用supertype()\nsubtype.prototype = new supertype();\n// 重写subtype.prototype的constructor属性，指向自己的构造函数subtype\nsubtype.prototype.constructor = subtype;\nsubtype.prototype.sayage = function () {\n  alert(this.age);\n};\n\nvar instance1 = new subtype("nicholas", 29);\ninstance1.colors.push("black");\nalert(instance1.colors); //"red,blue,green,black"\ninstance1.sayname(); //"nicholas";\ninstance1.sayage(); //29\n\nvar instance2 = new subtype("greg", 27);\nalert(instance2.colors); //"red,blue,green"\ninstance2.sayname(); //"greg";\ninstance2.sayage(); //27\n\n\n实例对象 instance1 上的两个属性就屏蔽了其原型对象 subtype.prototype 的两个同名属性。所以，组合模式的缺点就是在使用子类创建实例对象时，其原型中会存在两份相同的属性/方法。\n\n组合继承的缺点就是父类的构造函数会调用两次。\n\n\n# 4、原型式继承\n\n利用一个空对象作为中介，将某个对象直接赋值给空对象构造函数的原型。\n\nfunction inherit(obj) {\n  function f() {}\n  f.prototype = obj;\n  return new f();\n}\n\n\nvar person = {\n  name: "nicholas",\n  friends: ["shelby", "court", "van"],\n};\n\nvar anotherperson = inherit(person);\nanotherperson.name = "greg";\nanotherperson.friends.push("rob");\n\nvar yetanotherperson = inherit(person);\nyetanotherperson.name = "linda";\nyetanotherperson.friends.push("barbie");\n\nalert(person.friends); //"shelby,court,van,rob,barbie"\n\n\n上述代码可以使用 es5 提供的object.create等价实现\n\n同样存在多个实例的引用类型属性指向相同，存在篡改的可能的这个缺点，并且还无法传递参数。在实际开发中有一定的使用场景，但是比较局限\n\n\n# 5、寄生式继承\n\n在原型式继承的基础上，增强对象，返回构造函数\n\nfunction createanother(original) {\n  // 通过调用 object.create() 函数创建一个新对象，其原型为original\n  var clone = object.create(original);\n  clone.sayhi = function () {\n    // 以某种方式来增强对象\n    alert("hi");\n  };\n  return clone; // 返回这个对象\n}\n\n\n函数的主要作用是为构造函数新增属性和方法，以增强函数\n\nvar person = {\n  name: "nicholas",\n  friends: ["shelby", "court", "van"],\n};\nvar anotherperson = createanother(person);\nanotherperson.sayhi(); //"hi"\n\n\n该方式和寄生继承存在一样的缺点。\n\n\n# 6、⭐️ 寄生组合式继承\n\n结合借用构造函数传递参数和寄生模式实现继承，即上述组合继承和寄生继承的结合体。\n\nfunction inheritprototype(subtype, supertype) {\n  var prototype = object.create(supertype.prototype); // 创建对象，创建父类原型的一个副本\n  prototype.constructor = subtype; // 增强对象，弥补因重写原型而失去的默认的constructor 属性\n  subtype.prototype = prototype; // 指定对象，将新创建的对象赋值给子类的原型\n}\n\n// 父类初始化实例属性和原型属性\nfunction supertype(name) {\n  this.name = name;\n  this.colors = ["red", "blue", "green"];\n}\nsupertype.prototype.sayname = function () {\n  alert(this.name);\n};\n\n// 借用构造函数传递增强子类实例属性（支持传参和避免篡改）\nfunction subtype(name, age) {\n  supertype.call(this, name);\n  this.age = age;\n}\n\n// 将父类原型指向子类\ninheritprototype(subtype, supertype);\n\n// 新增子类原型属性\nsubtype.prototype.sayage = function () {\n  alert(this.age);\n};\n\nvar instance1 = new subtype("xyc", 23);\nvar instance2 = new subtype("lxy", 23);\n\ninstance1.colors.push("2"); // ["red", "blue", "green", "2"]\ninstance1.colors.push("3"); // ["red", "blue", "green", "3"]\n\n\n这种方式的高效率体现在它只调用了一次supertype构造函数，并且因此避免了在subtype.prototype上创建不必要的、多余的属性。于此同时，原型链还能保持不变；因此，还能够正常使用instanceof 和object.isprototypeof。\n\n这是最成熟的方法，也是现在库实现的方法，es6类的继承编译成es5代码之后就是使用的这种方式。\n\n这种方式是我们必须要掌握的继承方式。\n\n\n# 7、混入方式继承多个对象\n\nfunction myclass() {\n  superclass.call(this);\n  othersuperclass.call(this);\n}\n\n// 继承一个类\nmyclass.prototype = object.create(superclass.prototype);\n// 混合其它\nobject.assign(myclass.prototype, othersuperclass.prototype);\n// 重新指定constructor\nmyclass.prototype.constructor = myclass;\n\nmyclass.prototype.mymethod = function () {\n  // do something\n};\n\n\nobject.assign 会把 othersuperclass 原型上的函数拷贝到 myclass 原型上，使 myclass 的所有实例都可用 othersuperclass 的方法。\n\n实际开发中有类似混入的需求，但一般不会使用此方式来实现继承。\n\n\n# 8、⭐️ es6 类继承 extends\n\nes6的继承最为简单，语法上跟java，c#等语言类似，但是其原理是上述多种继承方式的组合。\n\nes6的继承，子类可以继承父类的非私有方法和属性（即使是静态方法或者属性也可以继承），比如：\n\nclass base {\n  name = "111";\n\n  static age = 222;\n\n  static say() {\n    console.log("base say");\n  }\n\n  run() {\n    console.log("base run");\n  }\n}\n\nclass sub extends base {\n  run() {\n    console.log("sub run");\n  }\n}\n\n\n如果对es6的类的语法及其原理不太清楚的同学请查看本文档阐述es6的类的语法节。\n\nes6的继承有两条原型指向关系：\n\n * subtype.__proto__ === supertype\n * subtype.prototype.__proto__ === supertype.prototype\n\n以下是上述代码经过babel编译之后的节选\n\n"use strict";\n// 节选了相关代码\n\nfunction _inherits(subclass, superclass) {\n  if (typeof superclass !== "function" && superclass !== null) {\n    throw new typeerror("super expression must either be null or a function");\n  }\n  subclass.prototype = object.create(superclass && superclass.prototype, {\n    constructor: { value: subclass, writable: true, configurable: true },\n  });\n  object.defineproperty(subclass, "prototype", { writable: false });\n  if (superclass) _setprototypeof(subclass, superclass);\n}\n\nfunction _setprototypeof(o, p) {\n  _setprototypeof = object.setprototypeof\n    ? object.setprototypeof.bind()\n    : function _setprototypeof(o, p) {\n        o.__proto__ = p;\n        return o;\n      };\n  return _setprototypeof(o, p);\n}\n\nfunction _createsuper(derived) {\n  var hasnativereflectconstruct = _isnativereflectconstruct();\n  return function _createsuperinternal() {\n    var super = _getprototypeof(derived),\n      result;\n    if (hasnativereflectconstruct) {\n      var newtarget = _getprototypeof(this).constructor;\n      result = reflect.construct(super, arguments, newtarget);\n    } else {\n      result = super.apply(this, arguments);\n    }\n    return _possibleconstructorreturn(this, result);\n  };\n}\n\nfunction _createclass(constructor, protoprops, staticprops) {\n  if (protoprops) _defineproperties(constructor.prototype, protoprops);\n  if (staticprops) _defineproperties(constructor, staticprops);\n  object.defineproperty(constructor, "prototype", { writable: false });\n  return constructor;\n}\n\nvar base = /*#__pure__*/ (function () {\n  function base() {\n    _classcallcheck(this, base);\n\n    _defineproperty(this, "name", "111");\n  }\n\n  _createclass(\n    base,\n    [\n      {\n        key: "run",\n        value: function run() {\n          console.log("base run");\n        },\n      },\n    ],\n    [\n      {\n        key: "say",\n        value: function say() {\n          console.log("base say");\n        },\n      },\n    ]\n  );\n\n  return base;\n})();\n\n_defineproperty(base, "age", 222);\n\nvar sub = /*#__pure__*/ (function (_base) {\n  _inherits(sub, _base);\n\n  var _super = _createsuper(sub);\n\n  function sub() {\n    _classcallcheck(this, sub);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createclass(sub, [\n    {\n      key: "run",\n      value: function run() {\n        console.log("sub run");\n      },\n    },\n  ]);\n\n  return sub;\n})(base);\n\n\n关键函数_inherits，在这个函数中建立了子类和父类的原型关系（object.create方法：创建以某个对象为原型对象的对象），自然就推导出了上述所说的第二条关系，即subtype.prototype.__proto__ === supertype.prototype，(object.setprototypeof方法:设置一个指定的对象的原型 ( 即, 内部[[prototype]]属性）到另一个对象)，自然就推导出了上述的第一条结论，即：subtype.__proto__ === supertype，以上便完成了静态属性和方法以及普通方法的继承。\n\n在上述处理完成之后，看看是如何处理普通属性的，关键点在_createsuper，这个函数返回的是一个函数，可以看到，其执行结果就是获取到绑定了父类构造器的函数，在这个构造器中，用反射的形式创建一个父类的实例，reflect.construct(target, argumentslist[, newtarget])，这样就相当于先构造了一个父类的实例，好处就是可以使得多个子类继承一个父类的话，如果一个子类实例修改父类属性，不至于影响到父类和别的子类。\n\n所以es6继承的本质还是组合寄生继承。',charsets:{cjk:!0}},{title:"扩展运算符",frontmatter:{},regularPath:"/javascript/es6/spread-symbol.html",relativePath:"javascript/es6/spread-symbol.md",key:"v-900bc0e2",path:"/javascript/es6/spread-symbol.html",headers:[{level:2,title:"扩展运算符",slug:"扩展运算符",normalizedTitle:"扩展运算符",charIndex:2},{level:3,title:"1、对象",slug:"_1、对象",normalizedTitle:"1、对象",charIndex:141},{level:3,title:"2、数组",slug:"_2、数组",normalizedTitle:"2、数组",charIndex:4810},{level:3,title:"3、迭代器",slug:"_3、迭代器",normalizedTitle:"3、迭代器",charIndex:6981},{level:3,title:"4、易错点",slug:"_4、易错点",normalizedTitle:"4、易错点",charIndex:10477}],headersStr:"扩展运算符 1、对象 2、数组 3、迭代器 4、易错点",content:'# 扩展运算符\n\n扩展运算符，...是ES6引入的一个相当实用的语法，它具有收集和展开的功能，本文将会从2个大类的一些实际应用场景（由于迭代器的场景众多，关于迭代器的应用，我将其作为单独的一节来阐述），结合babel的编译结果来学习一下JS引擎底层到底做了什么神奇的事儿。\n\n\n# 1、对象\n\n在对象上的运用主要是解构赋值\n\n# 1.1、对象的拷贝 或者 合并\n\n// 对象的合并\nconst obj1 = {\n  a: 1,\n  b: 2,\n  c: 3,\n};\nconst obj2 = {\n  a: "xxx",\n  d: "ddd",\n  k: 2,\n};\nconst newObj = {\n  ...obj1,\n  ...obj2,\n};\nconsole.log(newObj);\n\n\n这种场景，就好比把一个个对象敲碎，然后再填入到一个新的对象里面去，所以体现的是扩展运算符的展开的作用。\n\n编译后的结果如下：\n\n"use strict";\n/**\n * 获取一个对象上包含Symbol在内的所有key\n * @param {Object} object 目标对象\n * @param {boolean} enumerableOnly 在获取Symbol类型的key时，是否只获取可枚举的\n * @returns\n */\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    // 过滤掉Symbol的key中不可枚举的\n    enumerableOnly &&\n      (symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      })),\n      keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\n/**\n * 对象展开，将除了target以外的所有key全部合并到target中\n * @param {Object} target\n * @returns\n */\nfunction _objectSpread(target) {\n  // 从第一个参数开始，分别对后面的参数进行处理\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    /* 这段是babel编译的结果，但是看起来不是那么直观，也于是决定对其进行改写 */\n    // i % 2\n    //   ? ownKeys(Object(source), !0).forEach(function (key) {\n    //       _defineProperty(target, key, source[key]);\n    //     })\n    //   : Object.getOwnPropertyDescriptors\n    //   ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source))\n    //   : ownKeys(Object(source)).forEach(function (key) {\n    //       Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    //     });\n    /* 为什么对 序号为偶数的key才去单独处理，没看懂这样的意义是什么？ */\n    if (i % 2) {\n      ownKeys(Object(source), !0).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else {\n      if (Object.getOwnPropertyDescriptors) {\n        Object.defineProperties(\n          target,\n          Object.getOwnPropertyDescriptors(source)\n        );\n      } else {\n        ownKeys(Object(source)).forEach(function (key) {\n          Object.defineProperty(\n            target,\n            key,\n            Object.getOwnPropertyDescriptor(source, key)\n          );\n        });\n      }\n    }\n  }\n  return target;\n}\n/**\n * 以兼容的方式定义对象的属性和值\n * @param {object} obj\n * @param {string} key\n * @param {any} value\n * @returns\n */\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true,\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nvar obj1 = {\n  a: 1,\n  b: 2,\n  c: 3,\n};\nvar obj2 = {\n  a: "xxx",\n  d: "ddd",\n  k: 2,\n};\nvar newObj = _objectSpread(_objectSpread({}, obj1), obj2);\nconsole.log(newObj);\n\n\n// 对象的拷贝\nconst obj = {\n  a: 1,\n  b: {},\n};\nconst copy = { ...obj };\n\n\n上述代码原理和对象的合并是一样的，此处就不再贴babel的编译结果了。\n\n对于这种方式拷贝对象，需要注意的问题是，如果obj对象上全部是基础类型的话，相当于是做了一次深拷贝（Symbol类型一样是可以拷贝的），而如果有引用类型的话就不再是深拷贝了，如果明确了这个点，在实际开发中就可以得心应手的处理各种问题了。\n\n综上所述，这种场景的...其实它就是Object.assign的语法糖而已。\n\n# 1.2、提取需要的字段\n\n取出某些键，将剩余的键收集到一个对象中，在实际开发中，可能你不想处理某些键（有点儿类似lodash的omit等操作，在map的时候，如果想刻意的丢弃一些键值，这个可比直接取对象出来然后再使用delete操作符方便的多呀）。或者说，需要对键值，需要分开处理的场景。\n\nconst obj = { a: 1, b: 2, c: 3 };\nconst { a, ...rest } = obj;\nconsole.log(a, rest);\n\n\n这种场景，就好比把obj上的一些键值填到了叫做rest的对象里面，所以体现的是扩展运算符的收集的作用。\n\nbabel的编译结果：\n\n/**\n * 移除source对象中包含exclude的键（包含Symbol）\n * @param {Object} source 源对象\n * @param {Object} excluded 用来匹配需要删除的键的对象\n * @returns {Object}\n */\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  // 如果当前环境支持Symbol，Symbol类型的key也可以拷贝，但是对于不能枚举的Symbol属性则不拷贝\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      // 不处理不可枚举的Symbol\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\n/**\n * 宽松的移除source对象中包含exclude的键\n * @param {Object} source 源对象\n * @param {Object} excluded 用来匹配需要删除的键的对象\n * @returns {Object}\n */\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  // 不对当前对象原型上的属性进行处理\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nvar obj = {\n  a: 1,\n  b: 2,\n  c: 3,\n};\nvar a = obj.a,\n  rest = _objectWithoutProperties(obj, ["a"]);\nconsole.log(a, obj);\n\n\n\n# 2、数组\n\n# 2.1、函数参数聚合\n\n众所周知，箭头函数是没有arguments这个内置对象的，但是有些时候我们又希望箭头函数能够处理不定参数，此时...就是一个应用场景。\n\n// 不定参数的求和函数\nconst sum = (...args) => {\n  // 此时将会把多个参数聚合成一个数组\n  return args.reduce((total, cur) => {\n    return total + cur;\n  }, 0);\n};\n\n\n这种场景也体现的也是扩展运算符的收集作用。\n\nbabel的编译结果为：\n\n"use strict";\n// 不定参数的求和函数\nvar sum = function sum() {\n  for (\n    var _len = arguments.length, args = new Array(_len), _key = 0;\n    _key < _len;\n    _key++\n  ) {\n    args[_key] = arguments[_key];\n  }\n\n  // 此时将会把多个参数聚合成一个数组\n  return args.reduce(function (total, cur) {\n    return total + cur;\n  }, 0);\n};\n\n\n不出意外，借助函数的arguments是最简单的实现了，只是需要额外处理一下this即可（因为求和函数没有用到，所以没有这部分的处理，但是实际上会有）。\n\n还有这种用法:\n\nconst sum = (a, b, ...rest) => {\n  return (\n    a * 100 +\n    b * 10 +\n    rest.reduce((total, cur) => {\n      return total + cur;\n    }, 0)\n  );\n};\n\n\n原理和上面的是一样的，但是这种用法剩余参数只能在最后一个参数，因为这样编译器才知道分配多少个参数到rest变量身上，否则就乱套了。\n\n# 2.2、接受多个参数的函数\n\n这个经常见到，比如常见的JS原生函数的TS定义：\n\ninterface Math {\n  /**\n   * Returns the larger of a set of supplied numeric expressions.\n   * @param values Numeric expressions to be evaluated.\n   */\n  max(...values: number[]): number;\n  /**\n   * Returns the smaller of a set of supplied numeric expressions.\n   * @param values Numeric expressions to be evaluated.\n   */\n  min(...values: number[]): number;\n}\n\ninterface Console {\n  log(message?: any, ...optionalParams: any[]): void;\n}\n\ninterface Array<T> {\n  push(...items: T[]): number;\n}\n\n\n这个操作和上面的操作是相反的。在传递参数的时候，我们可以传递一个数组。\n\n这种场景下，体现的是扩展运算符的展开的作用。\n\n比如:\n\nconst arr = [1, 2, 3];\nconsole.log(...arr);\nMath.max(...arr);\n\n\nbabel编译之后的结果如下：\n\n"use strict";\n\nvar _console;\n\nvar arr = [1, 2, 3];\n\n(_console = console).log.apply(_console, arr);\n\nMath.max.apply(Math, arr);\n\n\n这种情况下，是apply的语法糖。\n\n# 2.3、数组合并 或 拷贝\n\n对于数组合并，这个babel编译的结果有一定的非预期。\n\nconst arr = [1, 2, 3];\nconst b = [3, ...arr];\nconsole.log(b);\n\n\nbabel的编译结果:\n\nvar arr = [1, 2, 3];\nvar b = [3].concat(arr);\nconsole.log(b);\n\n\n上述代码，如果我们在数组上手动部署了迭代器的话，babel编译的时候会忽略，仍然使用concat，但是在支持ES6的环境下体现出来的是迭代器的效果。\n\n对于这种case下的数组拷贝的话，仍然和上文提到的对象拷贝是一样的，如果说数组的元素每一个都是引用类型的话，就相当于深拷贝了一个数组的壳，而里面的元素还是引用的是和原数组相同的内容，但如果数组的元素是基本类型的话，就相当于完完全全的拷贝了一个数组，这种场景等价于：\n\nconst arr = [1, 2, 3];\nconst copiedArr = arr.map((v) => v);\n\n\n\n# 3、迭代器\n\n对于这一节，应用就比较广泛了，上文我们提到过，对于数组的合并也是基于这个操作。\n\n所以回归到本质，ES6哪些结构是部署了Iterator的结构呢？\n\n * String\n * Array (或者 TypedArray，指的是那一大堆跟二进制数据结构相关的类型)\n * Generator函数的执行结果\n * Map和Set\n * 函数的arguments对象\n * NodeList对象\n\n在Array上应用，目前从babel的编译结果看存在一些非预期。\n\nconst arr = [1, 2, 3, 4, 5];\narr[Symbol.iterator] = function () {\n  let idx = 0;\n  return {\n    next() {\n      const val = {\n        value: idx + 1,\n        done: idx >= 10,\n      };\n      idx++;\n      return val;\n    },\n  };\n};\n\nconst b = [...arr]; // [1,2,3,4,5,6,7,8,9,10]\n\n\nbabel的编译结果:\n\nvar arr = [1, 2, 3, 4, 5];\n\narr[Symbol.iterator] = function () {\n  var idx = 0;\n  return {\n    next: function next() {\n      var val = {\n        value: idx + 1,\n        done: idx >= 10,\n      };\n      idx++;\n      return val;\n    },\n  };\n};\n\nvar bbb = [].concat(arr);\n\n\n对于上面的代码，按目前已经支持ES6的浏览器运行结果，b的结果是[1,2,3,4,5,6,7,8,9,10]，但babel的编译结果明显是[1,2,3,4,5]不知道这是babel的bug还是什么其它方面的限制呢，有兴趣的同学可以探究一下。\n\n但是这种场景属于极端的场景，一般业务代码肯定轮不到我们去自定义数组的迭代器的，把Array处理成concat明显要比操作迭代器简单很多。\n\n在String上应用\n\nconst str = "hello world";\nconst arr = [...str];\n\n\nbabel的编译结果如下：\n\nfunction _toConsumableArray(arr) {\n  return (\n    _arrayWithoutHoles(arr) ||\n    _iterableToArray(arr) ||\n    _unsupportedIterableToArray(arr) ||\n    _nonIterableSpread()\n  );\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\n    "Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."\n  );\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === "string") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === "Object" && o.constructor) n = o.constructor.name;\n  if (n === "Map" || n === "Set") return Array.from(o);\n  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n    return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (\n    (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null) ||\n    iter["@@iterator"] != null\n  )\n    return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\n\nvar str = "hello world";\n\nvar arr = _toConsumableArray(str);\n\n\n在Map或Set，Generator函数，NodeList对象上的应用和String类似，有兴趣的读者可以自己试一下（只不过Generator函数babel编译了一个generator-runtime的库，代码比较多而已）。\n\n在arguments上应用：\n\nfunction func() {\n  const args = [...arguments];\n  console.log(args);\n}\n\n\nbabel编译结果:\n\nfunction func() {\n  var args = Array.prototype.slice.call(arguments);\n  console.log(args);\n}\n\n\n说了这么多，其实上述场景我们都只是在做一件事，即Array.from的语法糖，这个方法的TS定义如下。\n\ninterface ArrayLike<T> {\n  readonly length: number;\n  readonly [n: number]: T;\n}\n\ninterface ArrayConstructor {\n  /**\n   * Creates an array from an array-like object.\n   * @param arrayLike An array-like object to convert to an array.\n   */\n  from<T>(arrayLike: ArrayLike<T>): T[];\n\n  /**\n   * Creates an array from an iterable object.\n   * @param arrayLike An array-like object to convert to an array.\n   * @param mapfn A mapping function to call on every element of the array.\n   * @param thisArg Value of \'this\' used to invoke the mapfn.\n   */\n  from<T, U>(\n    arrayLike: ArrayLike<T>,\n    mapfn: (v: T, k: number) => U,\n    thisArg?: any\n  ): U[];\n}\n\n\n在MDN的定义阐述的是对一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。，多了支持可迭代对象这个条件。\n\n\n# 4、易错点\n\n这儿有一个易错点。 在React中，我们很有可能会看到这种代码\n\nclass MyButton extends Component {\n  render() {\n    const props = { ...this.props, name: "我自己封装的Button" };\n    return <Button {...props} />;\n  }\n}\n\n\n这个扩展运算符对对象的props进行批量传递，是React生态自己的支持（相当于是人家多了一个插件去转码这个语法，而原生JS是不支持这种语法的），需要注意一下区别。',normalizedContent:'# 扩展运算符\n\n扩展运算符，...是es6引入的一个相当实用的语法，它具有收集和展开的功能，本文将会从2个大类的一些实际应用场景（由于迭代器的场景众多，关于迭代器的应用，我将其作为单独的一节来阐述），结合babel的编译结果来学习一下js引擎底层到底做了什么神奇的事儿。\n\n\n# 1、对象\n\n在对象上的运用主要是解构赋值\n\n# 1.1、对象的拷贝 或者 合并\n\n// 对象的合并\nconst obj1 = {\n  a: 1,\n  b: 2,\n  c: 3,\n};\nconst obj2 = {\n  a: "xxx",\n  d: "ddd",\n  k: 2,\n};\nconst newobj = {\n  ...obj1,\n  ...obj2,\n};\nconsole.log(newobj);\n\n\n这种场景，就好比把一个个对象敲碎，然后再填入到一个新的对象里面去，所以体现的是扩展运算符的展开的作用。\n\n编译后的结果如下：\n\n"use strict";\n/**\n * 获取一个对象上包含symbol在内的所有key\n * @param {object} object 目标对象\n * @param {boolean} enumerableonly 在获取symbol类型的key时，是否只获取可枚举的\n * @returns\n */\nfunction ownkeys(object, enumerableonly) {\n  var keys = object.keys(object);\n  if (object.getownpropertysymbols) {\n    var symbols = object.getownpropertysymbols(object);\n    // 过滤掉symbol的key中不可枚举的\n    enumerableonly &&\n      (symbols = symbols.filter(function (sym) {\n        return object.getownpropertydescriptor(object, sym).enumerable;\n      })),\n      keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\n/**\n * 对象展开，将除了target以外的所有key全部合并到target中\n * @param {object} target\n * @returns\n */\nfunction _objectspread(target) {\n  // 从第一个参数开始，分别对后面的参数进行处理\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    /* 这段是babel编译的结果，但是看起来不是那么直观，也于是决定对其进行改写 */\n    // i % 2\n    //   ? ownkeys(object(source), !0).foreach(function (key) {\n    //       _defineproperty(target, key, source[key]);\n    //     })\n    //   : object.getownpropertydescriptors\n    //   ? object.defineproperties(target, object.getownpropertydescriptors(source))\n    //   : ownkeys(object(source)).foreach(function (key) {\n    //       object.defineproperty(target, key, object.getownpropertydescriptor(source, key));\n    //     });\n    /* 为什么对 序号为偶数的key才去单独处理，没看懂这样的意义是什么？ */\n    if (i % 2) {\n      ownkeys(object(source), !0).foreach(function (key) {\n        _defineproperty(target, key, source[key]);\n      });\n    } else {\n      if (object.getownpropertydescriptors) {\n        object.defineproperties(\n          target,\n          object.getownpropertydescriptors(source)\n        );\n      } else {\n        ownkeys(object(source)).foreach(function (key) {\n          object.defineproperty(\n            target,\n            key,\n            object.getownpropertydescriptor(source, key)\n          );\n        });\n      }\n    }\n  }\n  return target;\n}\n/**\n * 以兼容的方式定义对象的属性和值\n * @param {object} obj\n * @param {string} key\n * @param {any} value\n * @returns\n */\nfunction _defineproperty(obj, key, value) {\n  if (key in obj) {\n    object.defineproperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true,\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nvar obj1 = {\n  a: 1,\n  b: 2,\n  c: 3,\n};\nvar obj2 = {\n  a: "xxx",\n  d: "ddd",\n  k: 2,\n};\nvar newobj = _objectspread(_objectspread({}, obj1), obj2);\nconsole.log(newobj);\n\n\n// 对象的拷贝\nconst obj = {\n  a: 1,\n  b: {},\n};\nconst copy = { ...obj };\n\n\n上述代码原理和对象的合并是一样的，此处就不再贴babel的编译结果了。\n\n对于这种方式拷贝对象，需要注意的问题是，如果obj对象上全部是基础类型的话，相当于是做了一次深拷贝（symbol类型一样是可以拷贝的），而如果有引用类型的话就不再是深拷贝了，如果明确了这个点，在实际开发中就可以得心应手的处理各种问题了。\n\n综上所述，这种场景的...其实它就是object.assign的语法糖而已。\n\n# 1.2、提取需要的字段\n\n取出某些键，将剩余的键收集到一个对象中，在实际开发中，可能你不想处理某些键（有点儿类似lodash的omit等操作，在map的时候，如果想刻意的丢弃一些键值，这个可比直接取对象出来然后再使用delete操作符方便的多呀）。或者说，需要对键值，需要分开处理的场景。\n\nconst obj = { a: 1, b: 2, c: 3 };\nconst { a, ...rest } = obj;\nconsole.log(a, rest);\n\n\n这种场景，就好比把obj上的一些键值填到了叫做rest的对象里面，所以体现的是扩展运算符的收集的作用。\n\nbabel的编译结果：\n\n/**\n * 移除source对象中包含exclude的键（包含symbol）\n * @param {object} source 源对象\n * @param {object} excluded 用来匹配需要删除的键的对象\n * @returns {object}\n */\nfunction _objectwithoutproperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectwithoutpropertiesloose(source, excluded);\n  var key, i;\n  // 如果当前环境支持symbol，symbol类型的key也可以拷贝，但是对于不能枚举的symbol属性则不拷贝\n  if (object.getownpropertysymbols) {\n    var sourcesymbolkeys = object.getownpropertysymbols(source);\n    for (i = 0; i < sourcesymbolkeys.length; i++) {\n      key = sourcesymbolkeys[i];\n      if (excluded.indexof(key) >= 0) continue;\n      // 不处理不可枚举的symbol\n      if (!object.prototype.propertyisenumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\n/**\n * 宽松的移除source对象中包含exclude的键\n * @param {object} source 源对象\n * @param {object} excluded 用来匹配需要删除的键的对象\n * @returns {object}\n */\nfunction _objectwithoutpropertiesloose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  // 不对当前对象原型上的属性进行处理\n  var sourcekeys = object.keys(source);\n  var key, i;\n  for (i = 0; i < sourcekeys.length; i++) {\n    key = sourcekeys[i];\n    if (excluded.indexof(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nvar obj = {\n  a: 1,\n  b: 2,\n  c: 3,\n};\nvar a = obj.a,\n  rest = _objectwithoutproperties(obj, ["a"]);\nconsole.log(a, obj);\n\n\n\n# 2、数组\n\n# 2.1、函数参数聚合\n\n众所周知，箭头函数是没有arguments这个内置对象的，但是有些时候我们又希望箭头函数能够处理不定参数，此时...就是一个应用场景。\n\n// 不定参数的求和函数\nconst sum = (...args) => {\n  // 此时将会把多个参数聚合成一个数组\n  return args.reduce((total, cur) => {\n    return total + cur;\n  }, 0);\n};\n\n\n这种场景也体现的也是扩展运算符的收集作用。\n\nbabel的编译结果为：\n\n"use strict";\n// 不定参数的求和函数\nvar sum = function sum() {\n  for (\n    var _len = arguments.length, args = new array(_len), _key = 0;\n    _key < _len;\n    _key++\n  ) {\n    args[_key] = arguments[_key];\n  }\n\n  // 此时将会把多个参数聚合成一个数组\n  return args.reduce(function (total, cur) {\n    return total + cur;\n  }, 0);\n};\n\n\n不出意外，借助函数的arguments是最简单的实现了，只是需要额外处理一下this即可（因为求和函数没有用到，所以没有这部分的处理，但是实际上会有）。\n\n还有这种用法:\n\nconst sum = (a, b, ...rest) => {\n  return (\n    a * 100 +\n    b * 10 +\n    rest.reduce((total, cur) => {\n      return total + cur;\n    }, 0)\n  );\n};\n\n\n原理和上面的是一样的，但是这种用法剩余参数只能在最后一个参数，因为这样编译器才知道分配多少个参数到rest变量身上，否则就乱套了。\n\n# 2.2、接受多个参数的函数\n\n这个经常见到，比如常见的js原生函数的ts定义：\n\ninterface math {\n  /**\n   * returns the larger of a set of supplied numeric expressions.\n   * @param values numeric expressions to be evaluated.\n   */\n  max(...values: number[]): number;\n  /**\n   * returns the smaller of a set of supplied numeric expressions.\n   * @param values numeric expressions to be evaluated.\n   */\n  min(...values: number[]): number;\n}\n\ninterface console {\n  log(message?: any, ...optionalparams: any[]): void;\n}\n\ninterface array<t> {\n  push(...items: t[]): number;\n}\n\n\n这个操作和上面的操作是相反的。在传递参数的时候，我们可以传递一个数组。\n\n这种场景下，体现的是扩展运算符的展开的作用。\n\n比如:\n\nconst arr = [1, 2, 3];\nconsole.log(...arr);\nmath.max(...arr);\n\n\nbabel编译之后的结果如下：\n\n"use strict";\n\nvar _console;\n\nvar arr = [1, 2, 3];\n\n(_console = console).log.apply(_console, arr);\n\nmath.max.apply(math, arr);\n\n\n这种情况下，是apply的语法糖。\n\n# 2.3、数组合并 或 拷贝\n\n对于数组合并，这个babel编译的结果有一定的非预期。\n\nconst arr = [1, 2, 3];\nconst b = [3, ...arr];\nconsole.log(b);\n\n\nbabel的编译结果:\n\nvar arr = [1, 2, 3];\nvar b = [3].concat(arr);\nconsole.log(b);\n\n\n上述代码，如果我们在数组上手动部署了迭代器的话，babel编译的时候会忽略，仍然使用concat，但是在支持es6的环境下体现出来的是迭代器的效果。\n\n对于这种case下的数组拷贝的话，仍然和上文提到的对象拷贝是一样的，如果说数组的元素每一个都是引用类型的话，就相当于深拷贝了一个数组的壳，而里面的元素还是引用的是和原数组相同的内容，但如果数组的元素是基本类型的话，就相当于完完全全的拷贝了一个数组，这种场景等价于：\n\nconst arr = [1, 2, 3];\nconst copiedarr = arr.map((v) => v);\n\n\n\n# 3、迭代器\n\n对于这一节，应用就比较广泛了，上文我们提到过，对于数组的合并也是基于这个操作。\n\n所以回归到本质，es6哪些结构是部署了iterator的结构呢？\n\n * string\n * array (或者 typedarray，指的是那一大堆跟二进制数据结构相关的类型)\n * generator函数的执行结果\n * map和set\n * 函数的arguments对象\n * nodelist对象\n\n在array上应用，目前从babel的编译结果看存在一些非预期。\n\nconst arr = [1, 2, 3, 4, 5];\narr[symbol.iterator] = function () {\n  let idx = 0;\n  return {\n    next() {\n      const val = {\n        value: idx + 1,\n        done: idx >= 10,\n      };\n      idx++;\n      return val;\n    },\n  };\n};\n\nconst b = [...arr]; // [1,2,3,4,5,6,7,8,9,10]\n\n\nbabel的编译结果:\n\nvar arr = [1, 2, 3, 4, 5];\n\narr[symbol.iterator] = function () {\n  var idx = 0;\n  return {\n    next: function next() {\n      var val = {\n        value: idx + 1,\n        done: idx >= 10,\n      };\n      idx++;\n      return val;\n    },\n  };\n};\n\nvar bbb = [].concat(arr);\n\n\n对于上面的代码，按目前已经支持es6的浏览器运行结果，b的结果是[1,2,3,4,5,6,7,8,9,10]，但babel的编译结果明显是[1,2,3,4,5]不知道这是babel的bug还是什么其它方面的限制呢，有兴趣的同学可以探究一下。\n\n但是这种场景属于极端的场景，一般业务代码肯定轮不到我们去自定义数组的迭代器的，把array处理成concat明显要比操作迭代器简单很多。\n\n在string上应用\n\nconst str = "hello world";\nconst arr = [...str];\n\n\nbabel的编译结果如下：\n\nfunction _toconsumablearray(arr) {\n  return (\n    _arraywithoutholes(arr) ||\n    _iterabletoarray(arr) ||\n    _unsupportediterabletoarray(arr) ||\n    _noniterablespread()\n  );\n}\n\nfunction _noniterablespread() {\n  throw new typeerror(\n    "invalid attempt to spread non-iterable instance.\\nin order to be iterable, non-array objects must have a [symbol.iterator]() method."\n  );\n}\n\nfunction _unsupportediterabletoarray(o, minlen) {\n  if (!o) return;\n  if (typeof o === "string") return _arrayliketoarray(o, minlen);\n  var n = object.prototype.tostring.call(o).slice(8, -1);\n  if (n === "object" && o.constructor) n = o.constructor.name;\n  if (n === "map" || n === "set") return array.from(o);\n  if (n === "arguments" || /^(?:ui|i)nt(?:8|16|32)(?:clamped)?array$/.test(n))\n    return _arrayliketoarray(o, minlen);\n}\n\nfunction _iterabletoarray(iter) {\n  if (\n    (typeof symbol !== "undefined" && iter[symbol.iterator] != null) ||\n    iter["@@iterator"] != null\n  )\n    return array.from(iter);\n}\n\nfunction _arraywithoutholes(arr) {\n  if (array.isarray(arr)) return _arrayliketoarray(arr);\n}\n\nfunction _arrayliketoarray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\n\nvar str = "hello world";\n\nvar arr = _toconsumablearray(str);\n\n\n在map或set，generator函数，nodelist对象上的应用和string类似，有兴趣的读者可以自己试一下（只不过generator函数babel编译了一个generator-runtime的库，代码比较多而已）。\n\n在arguments上应用：\n\nfunction func() {\n  const args = [...arguments];\n  console.log(args);\n}\n\n\nbabel编译结果:\n\nfunction func() {\n  var args = array.prototype.slice.call(arguments);\n  console.log(args);\n}\n\n\n说了这么多，其实上述场景我们都只是在做一件事，即array.from的语法糖，这个方法的ts定义如下。\n\ninterface arraylike<t> {\n  readonly length: number;\n  readonly [n: number]: t;\n}\n\ninterface arrayconstructor {\n  /**\n   * creates an array from an array-like object.\n   * @param arraylike an array-like object to convert to an array.\n   */\n  from<t>(arraylike: arraylike<t>): t[];\n\n  /**\n   * creates an array from an iterable object.\n   * @param arraylike an array-like object to convert to an array.\n   * @param mapfn a mapping function to call on every element of the array.\n   * @param thisarg value of \'this\' used to invoke the mapfn.\n   */\n  from<t, u>(\n    arraylike: arraylike<t>,\n    mapfn: (v: t, k: number) => u,\n    thisarg?: any\n  ): u[];\n}\n\n\n在mdn的定义阐述的是对一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。，多了支持可迭代对象这个条件。\n\n\n# 4、易错点\n\n这儿有一个易错点。 在react中，我们很有可能会看到这种代码\n\nclass mybutton extends component {\n  render() {\n    const props = { ...this.props, name: "我自己封装的button" };\n    return <button {...props} />;\n  }\n}\n\n\n这个扩展运算符对对象的props进行批量传递，是react生态自己的支持（相当于是人家多了一个插件去转码这个语法，而原生js是不支持这种语法的），需要注意一下区别。',charsets:{cjk:!0}},{frontmatter:{},regularPath:"/javascript/event-loop.html",relativePath:"javascript/event-loop.md",key:"v-099d0615",path:"/javascript/event-loop.html",headersStr:null,content:'const func = () => {\n  console.log(0);\n\n  setTimeout(() => {\n    console.log(1);\n  }, 1);\n\n  setTimeout(() => {\n    console.log(2);\n  }, 0);\n\n  new Promise((res) => {\n    console.log(3);\n    return res();\n  }).then(() => {\n    console.log(4);\n  });\n\n  setTimeout(() => {\n    console.log(5);\n    new Promise((res) => {\n      console.log(6);\n      return res();\n    }).then((res) => {\n      console.log(7);\n    });\n    console.log(8);\n  });\n\n  console.log(9);\n};\n\nfunc();\n\n\nsetTimeout(function () {\n  console.log(1);\n\n  new Promise(function executor(resolve) {\n    console.log(7);\n\n    for (var i = 0; i < 10000; i++) {\n      i === 9999 && resolve();\n    }\n\n    console.log(8);\n  }).then(function () {\n    console.log(9);\n  });\n}, 0);\n\nsetTimeout(function () {\n  console.log(6);\n}, 0);\n\nnew Promise(function executor(resolve) {\n  console.log(2);\n\n  for (var i = 0; i < 10000; i++) {\n    i === 9999 && resolve();\n  }\n\n  console.log(3);\n}).then(function () {\n  console.log(4);\n});\n\nconsole.log(5);\n\n\nasync function async1() {\n  console.log("1");\n  await async2();\n  console.log("AAA");\n}\n\nasync function async2() {\n  console.log("3");\n  return new Promise((resolve, reject) => {\n    resolve();\n    console.log("4");\n  });\n}\n\nconsole.log("5");\n\nsetTimeout(() => {\n  console.log("6");\n}, 0);\n// async1()\n// await async1();\n\nnew Promise((resolve) => {\n  console.log("7");\n  resolve();\n})\n  .then(() => {\n    console.log("8");\n  })\n  .then(() => {\n    console.log("9");\n  })\n  .then(() => {\n    console.log("10");\n  });\nconsole.log("11");\n// 5 1 3 4 7 11 8 9 AAA 10 6\n\n\nPromise.resolve()\n  .then(() => {\n    console.log(0);\n    return Promise.resolve(4);\n  })\n  .then((res) => {\n    console.log(res);\n  });\n\nPromise.resolve()\n  .then(() => {\n    console.log(1);\n  })\n  .then(() => {\n    console.log(2);\n  })\n  .then(() => {\n    console.log(3);\n  })\n  .then(() => {\n    console.log(5);\n  })\n  .then(() => {\n    console.log(6);\n  });\n',normalizedContent:'const func = () => {\n  console.log(0);\n\n  settimeout(() => {\n    console.log(1);\n  }, 1);\n\n  settimeout(() => {\n    console.log(2);\n  }, 0);\n\n  new promise((res) => {\n    console.log(3);\n    return res();\n  }).then(() => {\n    console.log(4);\n  });\n\n  settimeout(() => {\n    console.log(5);\n    new promise((res) => {\n      console.log(6);\n      return res();\n    }).then((res) => {\n      console.log(7);\n    });\n    console.log(8);\n  });\n\n  console.log(9);\n};\n\nfunc();\n\n\nsettimeout(function () {\n  console.log(1);\n\n  new promise(function executor(resolve) {\n    console.log(7);\n\n    for (var i = 0; i < 10000; i++) {\n      i === 9999 && resolve();\n    }\n\n    console.log(8);\n  }).then(function () {\n    console.log(9);\n  });\n}, 0);\n\nsettimeout(function () {\n  console.log(6);\n}, 0);\n\nnew promise(function executor(resolve) {\n  console.log(2);\n\n  for (var i = 0; i < 10000; i++) {\n    i === 9999 && resolve();\n  }\n\n  console.log(3);\n}).then(function () {\n  console.log(4);\n});\n\nconsole.log(5);\n\n\nasync function async1() {\n  console.log("1");\n  await async2();\n  console.log("aaa");\n}\n\nasync function async2() {\n  console.log("3");\n  return new promise((resolve, reject) => {\n    resolve();\n    console.log("4");\n  });\n}\n\nconsole.log("5");\n\nsettimeout(() => {\n  console.log("6");\n}, 0);\n// async1()\n// await async1();\n\nnew promise((resolve) => {\n  console.log("7");\n  resolve();\n})\n  .then(() => {\n    console.log("8");\n  })\n  .then(() => {\n    console.log("9");\n  })\n  .then(() => {\n    console.log("10");\n  });\nconsole.log("11");\n// 5 1 3 4 7 11 8 9 aaa 10 6\n\n\npromise.resolve()\n  .then(() => {\n    console.log(0);\n    return promise.resolve(4);\n  })\n  .then((res) => {\n    console.log(res);\n  });\n\npromise.resolve()\n  .then(() => {\n    console.log(1);\n  })\n  .then(() => {\n    console.log(2);\n  })\n  .then(() => {\n    console.log(3);\n  })\n  .then(() => {\n    console.log(5);\n  })\n  .then(() => {\n    console.log(6);\n  });\n',charsets:{}},{title:"JavaScript专题",frontmatter:{title:"JavaScript专题"},regularPath:"/javascript/",relativePath:"javascript/index.md",key:"v-4b62e23a",path:"/javascript/",headersStr:null,content:" * JavaScript 专题\n * 函数上下文 this\n * 原型链\n * 继承\n * 闭包\n * Ajax\n * ES6\n * 实用代码片段",normalizedContent:" * javascript 专题\n * 函数上下文 this\n * 原型链\n * 继承\n * 闭包\n * ajax\n * es6\n * 实用代码片段",charsets:{cjk:!0}},{title:"原型及原型链",frontmatter:{},regularPath:"/javascript/prototype.html",relativePath:"javascript/prototype.md",key:"v-5da62161",path:"/javascript/prototype.html",headers:[{level:2,title:"原型及原型链",slug:"原型及原型链",normalizedTitle:"原型及原型链",charIndex:2},{level:3,title:"__proto__ 和 prototype",slug:"proto-和-prototype",normalizedTitle:"<strong>proto</strong> 和 prototype",charIndex:null},{level:3,title:"获取或修改原型的指向关系",slug:"获取或修改原型的指向关系",normalizedTitle:"获取或修改原型的指向关系",charIndex:1591},{level:3,title:"函数与构造器",slug:"函数与构造器",normalizedTitle:"函数与构造器",charIndex:1653},{level:3,title:"ES6类继承中的原型链指向关系",slug:"es6类继承中的原型链指向关系",normalizedTitle:"es6类继承中的原型链指向关系",charIndex:3094},{level:3,title:"实际应用",slug:"实际应用",normalizedTitle:"实际应用",charIndex:6089}],headersStr:"原型及原型链 __proto__ 和 prototype 获取或修改原型的指向关系 函数与构造器 ES6类继承中的原型链指向关系 实际应用",content:'# 原型及原型链\n\nJS是一门基于原型继承的语言，并不是传统的Java，C#基于类继承的语言，这是JS较为重要的一个特征之一。\n\n虽然ES6增加了class的语法，然而class的本质还是基于原型及原型链的关系，是个语法糖而已，因此对于任何一个前端来说这个知识点是必须要掌握的。\n\n\n# __proto__ 和 prototype\n\n之前我在论坛上听大家有叫__proto__什么隐式原型对象的，我个人感觉叫什么不重要，只要你理解它能干啥就行了（就好比你说话，如果别人都能听懂了，你还去纠结什么是主语什么是谓语什么是宾语就有点儿孔乙己了），所以我一直从初学到现在任意大中小厂面试只要提到原型链我都是直接念的__proto__。\n\n# __proto__\n\n为什么说JS万物皆对象呢，我想大概就是因为它吧。\n\n已知的除了null，undefined，ø(即Object.create(null))没有这个属性以外，所有的变量都会有__proto__。为什么一个空对象（{}）能够拥有toString方法呢，因为({}).__proto__指向的是Object.prototype。\n\nJS属性的一个读取特征就是，首先它会在当前的对象上找，如果找的到的话，直接就使用，找不到就通过__proto__到它的原型对象上去找，如果还找不到，就到原型对象的原型对象上去找，如果原型对象的原型对象不存在呢？不存在的话就报错了，如：a.demo is not a function。\n\n所以，任意的数据类型的实例都指向它的原型对象，因此有：\n\n(1).__proto__ === Number.prototype;\n// 注意：NaN也是number类型\ntrue.__proto__ === Boolean.prototype;\n({}.__proto__ === Object.prototype);\nSymbol(1).__proto__ === Symbol.prototype;\n"hello world".__proto__ === String.prototype;\n(() => {}).__proto__ === Function.prototype;\n\n\n# prototype\n\n这个属性是找原型对象的钥匙，也就是说，我们要获取到一个原型对象，必须得通过prototype，我的理解就是原型对象它是放在仓库的一个工具箱，要想使用这个工具箱，首先得找仓库（即找对应的构造器），找到仓库之后，拿钥匙开门（即prototype），然后我们就可以打开这个工具箱，发现这里面有好多工具可以用。\n\n\n\n但是问题就是，不是随便一个阿猫阿狗都能拥有prototype这个属性的，想要拥有这个属性，这个对象必须是一个构造器(constructor)\n\n现在我们用一个生活中的例子来捋一捋刚才所讲的知识点之间的关系：\n\n印度尼西亚想向中国订购一列高铁（对象的实例，即instance），那么，中国中车是造高铁的工厂（构造器），高铁不是生产出来就完了，还需要有一系列维护运营的技术（即原型对象上的方法），生产的高铁上贴着标签: 中国中车制造(__proto__)，那么以后这列高铁的维护运营都可以使用中国中车提供的技术了。\n\n\n\n有一个问题就是，虽然这些高铁技术是中国中车的，但是这些技术放在那儿，但我们总感觉会被西方反华势力剽窃走，所以，我们最好希望让这些技术的专业技术人员们知道自己是归属于谁的，因此原型对象上有一个constructor属性是指向构造器的，如：\n\nObject.prototype.constructor === Object; // true\n\n\n有了这个例子之后，我们可以很容易的分清楚构造器和原型对象的关系了，如Object和Object.prototype。\n\n\n# 获取或修改原型的指向关系\n\nObject.setPrototypeOf和Object.getPrototypeOf\n\n\n# 函数与构造器\n\n# 函数\n\n上一节中，我们强调了在JS中万物皆对象，函数也是一类特殊的对象。\n\n我们定义一个函数，就生成了一个函数的实例，如：\n\nfunction Person() {}\n\n\n根据上文阐述的内容得知，函数的实例指向的是函数的原型对象，即：\n\nPerson.__proto__ === Function.prototype; // true\nPerson.prototype.constructor === Person; // true\n\n\nJS的函数除了普通的调用方式以外，还可以通过new调用以生成对象，但是通过new调用是有条件的，这个函数必须拥有prototype属性（从逻辑上讲，这样用当前函数创建对象之后才能知道是哪个工厂生产的呀），有prototype才会有constructor，而这个构造器又指向的是它自己，所以有无prototype就成为了这个函数是否能通过new调用的先决条件了。\n\n# 构造器\n\n刚才我们阐述原型对象的过程中有一个非常关键的概念还没有详细阐述，那就是constructor(基于上文所述，此处阐述的构造器譬如Object.prototype.constructor，简化描述为Object)，通过第一节的分析，它跟原型对象，存在一定的关系，但是肯定不是一个东西，（最开始我们只阐述了3个没有原型对象的类型），那它指向的是谁呢？答案是函数原型对象(Function.prototype)。\n\n任意一个构造器都是函数原型对象的实例，即：\n\nObject.__proto__ === Function.prototype; // true\nNumber.__proto__ === Function.prototype; // true\nBoolean.__proto__ === Function.prototype; // true\nString.__proto__ === Function.prototype; // true\nSymbol.__proto__ === Function.prototype; // true\nArray.__proto__ === Function.prototype; // true\n\n\n上面还有一个关键的指向关系没有阐述,容我卖个关子。\n\n我们已经得出结论，任意一个构造器都是函数原型对象的实例，请问Function是构造器吗？ 毫无疑问必须得是啊，既然是，那就应该符合我们这个结论，即：\n\nFunction.__proto__ === Function.prototype; // true\n\n\n曾经很长一段时间，我都是把这个指向关系当结论给记住的，其实经过上述的一通分析，完全没有必要死记硬背啦。\n\n所以，我们就可以画出一个比较全面的指向关系：\n\n\n\n再来个更复杂一点儿的，加一个自定义的函数试试：\n\nfunction Person() {}\n\nPerson.prototype.getName = function () {\n  return "JohnYang";\n};\n\nlet p = new Person();\n\n\n把Person和p加到我们刚才的图中去，得到的关系如下：\n\n\n\nDANGER\n\n箭头函数是一类特殊的函数，其没有prototype，导致其不存在constructor，因此不能通过new调用。\n\n打个比方，箭头函数就好像是一只做了绝育手术的猫。\n\n\n# ES6类继承中的原型链指向关系\n\n本文不阐述class的语法，如果还不了解的朋友可以先行查阅相关资料。\n\n假设现在有如下两个类，并且有继承关系：\n\nclass Parent {\n  static aaa;\n\n  bbb() {\n    console.log("hello world");\n  }\n}\n\nclass Child extends Parent {\n  bbb() {\n    super.bbb();\n    console.log("hello world 222");\n  }\n}\n\n\n接下来看一下经过babel编译之后的结果，为了节约篇幅，只贴比较关键的部分。\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== "function" && superClass !== null) {\n    throw new TypeError("Super expression must either be null or a function");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });\n  Object.defineProperty(subClass, "prototype", { writable: false });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, "prototype", { writable: false });\n  return Constructor;\n}\n\nvar Parent = /*#__PURE__*/ (function () {\n  function Parent() {\n    _classCallCheck(this, Parent);\n  }\n\n  _createClass(Parent, [\n    {\n      key: "bbb",\n      value: function bbb() {\n        console.log("hello world");\n      },\n    },\n  ]);\n\n  return Parent;\n})();\n\n\n_defineProperty(Parent, "aaa", void 0);\n\nvar Child = /*#__PURE__*/ (function (_Parent) {\n  _inherits(Child, _Parent);\n\n  var _super = _createSuper(Child);\n\n  function Child() {\n    _classCallCheck(this, Child);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Child, [\n    {\n      key: "bbb",\n      value: function bbb() {\n        _get(_getPrototypeOf(Child.prototype), "bbb", this).call(this);\n\n        console.log("hello world 222");\n      },\n    },\n  ]);\n\n  return Child;\n})(Parent);\n\n\n从编译的结果看，凡是带static的关键字的都给添加到了构造器上，没有static关键字的都添加到了原型对象上。\n\n最关键的一个方法是_inherits，其中：\n\nsubClass.prototype = Object.create(superClass && superClass.prototype, {\n  constructor: { value: subClass, writable: true, configurable: true },\n});\n/**\n Object.create: 创建一个以什么对象为原型的对象，即可以理解为：\n subClass.prototype.__proto__ === superClass.prototype // true\n */\n_setPrototypeOf(subClass, superClass);\n\n/**\n  subClass.__proto__ === superClass // true\n */\n\n\nTIP\n\n在ES6中，**子类.__proto__ === 父类， 子类的原型对象.__proto__ === 父类的原型对象 **\n\n其实这个结论从我们的实际开发中也体验的出来，static属性可以被继承，那么必然存在子类.__proto__ === 父类，非 static 属性也可以被继承（均非私有）当我们初始化一个子类的实例的时候，必然存在 ins.__proto__ 指向 Child.prototype，Child.prototype.__proto__指向Parent.prototype\n\n\n# 实际应用\n\n对于应付面试八股文非我们学习的本意，学习的目的还是为了提高生产力\n\n# 1、 实现instanceof\n\ninstanceof的原理就是判断输入参数的__proto__在不断向其原型链上迭代的过程中，最终是否指向构造器关联的原型对象。\n\nfunction MyInstanceOf(child, parent) {\n  if (!parent || !parent.prototype) {\n    throw `the instanceof must apply to compare two object`;\n  }\n  let flag = false;\n  while (child) {\n    if (child.__proto__ === parent.prototype) {\n      flag = true;\n      break;\n    }\n    child = child.__proto__;\n  }\n  return flag;\n}\n\n\n# 2、面向切面编程\n\n这是一个在实际开发中非常有价值的应用。\n\n现在某个团队提供给你了一个包和这个包的API，这个包是被压缩过的，你没有修改包源码的权利，但是某个方法A我们发现它不完全满足我们的业务场景，怎么办呢？其实挺好办的，修改原型链，给它追加一层我们自己的业务逻辑控制，并且不改变它本身的实现，这就是常提到的面向切面编程（或者说是装饰模式也行）。\n\nimport lib from "@xxx/xxx-sdk";\nconst enhancedLib = {\n  /* 注意：不能写成 init: function() {} */\n  init() {\n    // 不侵入库本来的代码\n    typeof super.init === "function" && super.init.apply(this, arguments);\n    // 扩展当前特殊的业务\n    console.log("Initialized");\n  },\n};\n// 让增强的对象的__prototo__指向库\nObject.setPrototypeOf(enhancedLib, Lib);\nexport default enhancedLib;\n\n\nDANGER\n\nsuper关键字必须要在类中或者要将对象的方法写成ES6方法的简写形式才可使用。',normalizedContent:'# 原型及原型链\n\njs是一门基于原型继承的语言，并不是传统的java，c#基于类继承的语言，这是js较为重要的一个特征之一。\n\n虽然es6增加了class的语法，然而class的本质还是基于原型及原型链的关系，是个语法糖而已，因此对于任何一个前端来说这个知识点是必须要掌握的。\n\n\n# __proto__ 和 prototype\n\n之前我在论坛上听大家有叫__proto__什么隐式原型对象的，我个人感觉叫什么不重要，只要你理解它能干啥就行了（就好比你说话，如果别人都能听懂了，你还去纠结什么是主语什么是谓语什么是宾语就有点儿孔乙己了），所以我一直从初学到现在任意大中小厂面试只要提到原型链我都是直接念的__proto__。\n\n# __proto__\n\n为什么说js万物皆对象呢，我想大概就是因为它吧。\n\n已知的除了null，undefined，ø(即object.create(null))没有这个属性以外，所有的变量都会有__proto__。为什么一个空对象（{}）能够拥有tostring方法呢，因为({}).__proto__指向的是object.prototype。\n\njs属性的一个读取特征就是，首先它会在当前的对象上找，如果找的到的话，直接就使用，找不到就通过__proto__到它的原型对象上去找，如果还找不到，就到原型对象的原型对象上去找，如果原型对象的原型对象不存在呢？不存在的话就报错了，如：a.demo is not a function。\n\n所以，任意的数据类型的实例都指向它的原型对象，因此有：\n\n(1).__proto__ === number.prototype;\n// 注意：nan也是number类型\ntrue.__proto__ === boolean.prototype;\n({}.__proto__ === object.prototype);\nsymbol(1).__proto__ === symbol.prototype;\n"hello world".__proto__ === string.prototype;\n(() => {}).__proto__ === function.prototype;\n\n\n# prototype\n\n这个属性是找原型对象的钥匙，也就是说，我们要获取到一个原型对象，必须得通过prototype，我的理解就是原型对象它是放在仓库的一个工具箱，要想使用这个工具箱，首先得找仓库（即找对应的构造器），找到仓库之后，拿钥匙开门（即prototype），然后我们就可以打开这个工具箱，发现这里面有好多工具可以用。\n\n\n\n但是问题就是，不是随便一个阿猫阿狗都能拥有prototype这个属性的，想要拥有这个属性，这个对象必须是一个构造器(constructor)\n\n现在我们用一个生活中的例子来捋一捋刚才所讲的知识点之间的关系：\n\n印度尼西亚想向中国订购一列高铁（对象的实例，即instance），那么，中国中车是造高铁的工厂（构造器），高铁不是生产出来就完了，还需要有一系列维护运营的技术（即原型对象上的方法），生产的高铁上贴着标签: 中国中车制造(__proto__)，那么以后这列高铁的维护运营都可以使用中国中车提供的技术了。\n\n\n\n有一个问题就是，虽然这些高铁技术是中国中车的，但是这些技术放在那儿，但我们总感觉会被西方反华势力剽窃走，所以，我们最好希望让这些技术的专业技术人员们知道自己是归属于谁的，因此原型对象上有一个constructor属性是指向构造器的，如：\n\nobject.prototype.constructor === object; // true\n\n\n有了这个例子之后，我们可以很容易的分清楚构造器和原型对象的关系了，如object和object.prototype。\n\n\n# 获取或修改原型的指向关系\n\nobject.setprototypeof和object.getprototypeof\n\n\n# 函数与构造器\n\n# 函数\n\n上一节中，我们强调了在js中万物皆对象，函数也是一类特殊的对象。\n\n我们定义一个函数，就生成了一个函数的实例，如：\n\nfunction person() {}\n\n\n根据上文阐述的内容得知，函数的实例指向的是函数的原型对象，即：\n\nperson.__proto__ === function.prototype; // true\nperson.prototype.constructor === person; // true\n\n\njs的函数除了普通的调用方式以外，还可以通过new调用以生成对象，但是通过new调用是有条件的，这个函数必须拥有prototype属性（从逻辑上讲，这样用当前函数创建对象之后才能知道是哪个工厂生产的呀），有prototype才会有constructor，而这个构造器又指向的是它自己，所以有无prototype就成为了这个函数是否能通过new调用的先决条件了。\n\n# 构造器\n\n刚才我们阐述原型对象的过程中有一个非常关键的概念还没有详细阐述，那就是constructor(基于上文所述，此处阐述的构造器譬如object.prototype.constructor，简化描述为object)，通过第一节的分析，它跟原型对象，存在一定的关系，但是肯定不是一个东西，（最开始我们只阐述了3个没有原型对象的类型），那它指向的是谁呢？答案是函数原型对象(function.prototype)。\n\n任意一个构造器都是函数原型对象的实例，即：\n\nobject.__proto__ === function.prototype; // true\nnumber.__proto__ === function.prototype; // true\nboolean.__proto__ === function.prototype; // true\nstring.__proto__ === function.prototype; // true\nsymbol.__proto__ === function.prototype; // true\narray.__proto__ === function.prototype; // true\n\n\n上面还有一个关键的指向关系没有阐述,容我卖个关子。\n\n我们已经得出结论，任意一个构造器都是函数原型对象的实例，请问function是构造器吗？ 毫无疑问必须得是啊，既然是，那就应该符合我们这个结论，即：\n\nfunction.__proto__ === function.prototype; // true\n\n\n曾经很长一段时间，我都是把这个指向关系当结论给记住的，其实经过上述的一通分析，完全没有必要死记硬背啦。\n\n所以，我们就可以画出一个比较全面的指向关系：\n\n\n\n再来个更复杂一点儿的，加一个自定义的函数试试：\n\nfunction person() {}\n\nperson.prototype.getname = function () {\n  return "johnyang";\n};\n\nlet p = new person();\n\n\n把person和p加到我们刚才的图中去，得到的关系如下：\n\n\n\ndanger\n\n箭头函数是一类特殊的函数，其没有prototype，导致其不存在constructor，因此不能通过new调用。\n\n打个比方，箭头函数就好像是一只做了绝育手术的猫。\n\n\n# es6类继承中的原型链指向关系\n\n本文不阐述class的语法，如果还不了解的朋友可以先行查阅相关资料。\n\n假设现在有如下两个类，并且有继承关系：\n\nclass parent {\n  static aaa;\n\n  bbb() {\n    console.log("hello world");\n  }\n}\n\nclass child extends parent {\n  bbb() {\n    super.bbb();\n    console.log("hello world 222");\n  }\n}\n\n\n接下来看一下经过babel编译之后的结果，为了节约篇幅，只贴比较关键的部分。\n\nfunction _inherits(subclass, superclass) {\n  if (typeof superclass !== "function" && superclass !== null) {\n    throw new typeerror("super expression must either be null or a function");\n  }\n  subclass.prototype = object.create(superclass && superclass.prototype, { constructor: { value: subclass, writable: true, configurable: true } });\n  object.defineproperty(subclass, "prototype", { writable: false });\n  if (superclass) _setprototypeof(subclass, superclass);\n}\n\nfunction _createsuper(derived) {\n  var hasnativereflectconstruct = _isnativereflectconstruct();\n  return function _createsuperinternal() {\n    var super = _getprototypeof(derived),\n      result;\n    if (hasnativereflectconstruct) {\n      var newtarget = _getprototypeof(this).constructor;\n      result = reflect.construct(super, arguments, newtarget);\n    } else {\n      result = super.apply(this, arguments);\n    }\n    return _possibleconstructorreturn(this, result);\n  };\n}\n\nfunction _createclass(constructor, protoprops, staticprops) {\n  if (protoprops) _defineproperties(constructor.prototype, protoprops);\n  if (staticprops) _defineproperties(constructor, staticprops);\n  object.defineproperty(constructor, "prototype", { writable: false });\n  return constructor;\n}\n\nvar parent = /*#__pure__*/ (function () {\n  function parent() {\n    _classcallcheck(this, parent);\n  }\n\n  _createclass(parent, [\n    {\n      key: "bbb",\n      value: function bbb() {\n        console.log("hello world");\n      },\n    },\n  ]);\n\n  return parent;\n})();\n\n\n_defineproperty(parent, "aaa", void 0);\n\nvar child = /*#__pure__*/ (function (_parent) {\n  _inherits(child, _parent);\n\n  var _super = _createsuper(child);\n\n  function child() {\n    _classcallcheck(this, child);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createclass(child, [\n    {\n      key: "bbb",\n      value: function bbb() {\n        _get(_getprototypeof(child.prototype), "bbb", this).call(this);\n\n        console.log("hello world 222");\n      },\n    },\n  ]);\n\n  return child;\n})(parent);\n\n\n从编译的结果看，凡是带static的关键字的都给添加到了构造器上，没有static关键字的都添加到了原型对象上。\n\n最关键的一个方法是_inherits，其中：\n\nsubclass.prototype = object.create(superclass && superclass.prototype, {\n  constructor: { value: subclass, writable: true, configurable: true },\n});\n/**\n object.create: 创建一个以什么对象为原型的对象，即可以理解为：\n subclass.prototype.__proto__ === superclass.prototype // true\n */\n_setprototypeof(subclass, superclass);\n\n/**\n  subclass.__proto__ === superclass // true\n */\n\n\ntip\n\n在es6中，**子类.__proto__ === 父类， 子类的原型对象.__proto__ === 父类的原型对象 **\n\n其实这个结论从我们的实际开发中也体验的出来，static属性可以被继承，那么必然存在子类.__proto__ === 父类，非 static 属性也可以被继承（均非私有）当我们初始化一个子类的实例的时候，必然存在 ins.__proto__ 指向 child.prototype，child.prototype.__proto__指向parent.prototype\n\n\n# 实际应用\n\n对于应付面试八股文非我们学习的本意，学习的目的还是为了提高生产力\n\n# 1、 实现instanceof\n\ninstanceof的原理就是判断输入参数的__proto__在不断向其原型链上迭代的过程中，最终是否指向构造器关联的原型对象。\n\nfunction myinstanceof(child, parent) {\n  if (!parent || !parent.prototype) {\n    throw `the instanceof must apply to compare two object`;\n  }\n  let flag = false;\n  while (child) {\n    if (child.__proto__ === parent.prototype) {\n      flag = true;\n      break;\n    }\n    child = child.__proto__;\n  }\n  return flag;\n}\n\n\n# 2、面向切面编程\n\n这是一个在实际开发中非常有价值的应用。\n\n现在某个团队提供给你了一个包和这个包的api，这个包是被压缩过的，你没有修改包源码的权利，但是某个方法a我们发现它不完全满足我们的业务场景，怎么办呢？其实挺好办的，修改原型链，给它追加一层我们自己的业务逻辑控制，并且不改变它本身的实现，这就是常提到的面向切面编程（或者说是装饰模式也行）。\n\nimport lib from "@xxx/xxx-sdk";\nconst enhancedlib = {\n  /* 注意：不能写成 init: function() {} */\n  init() {\n    // 不侵入库本来的代码\n    typeof super.init === "function" && super.init.apply(this, arguments);\n    // 扩展当前特殊的业务\n    console.log("initialized");\n  },\n};\n// 让增强的对象的__prototo__指向库\nobject.setprototypeof(enhancedlib, lib);\nexport default enhancedlib;\n\n\ndanger\n\nsuper关键字必须要在类中或者要将对象的方法写成es6方法的简写形式才可使用。',charsets:{cjk:!0}},{title:"复制内容到剪贴板",frontmatter:{},regularPath:"/javascript/snippets/copy-into-clipboard.html",relativePath:"javascript/snippets/copy-into-clipboard.md",key:"v-8d7c3a16",path:"/javascript/snippets/copy-into-clipboard.html",headers:[{level:2,title:"复制内容到剪贴板",slug:"复制内容到剪贴板",normalizedTitle:"复制内容到剪贴板",charIndex:2}],headersStr:"复制内容到剪贴板",content:'# 复制内容到剪贴板\n\n以下是一个不用借助任何第三方库也几乎不用考虑兼容性的复制内容到剪贴板的实现。\n\n/**\n * 向Clipboard写入内容\n * @param {string} content 写入剪贴板的内容\n */\nasync function setClipboardText(content) {\n  try {\n    await navigator.clipboard.writeText(content);\n  } catch (exp) {\n    const tmpInput = document.createElement("input");\n    document.body.appendChild(tmpInput);\n    tmpInput.value = content;\n    /* 需要让这个input是可见的，不能将其设置为visibility为hidden或者display为none */\n    tmpInput.style.left = "absolute";\n    tmpInput.style.left = "10000px";\n    tmpInput.style.top = "10000px";\n    tmpInput.select();\n    typeof document.execCommand === "function" && document.execCommand("copy");\n    document.body.removeChild(tmpInput);\n  }\n}\n\n\nHTML5新增了一个比较有趣的API，叫做ClipboardItem，以下是它的兼容性情况，还不算太好。\n\n\n\n可以使用它复制图片，不过图片只能是png格式的。\n\n以下是一段复制图片到剪贴板的代码片段：（注意，需要在网页里面执行，否则会抛出DOMException: Document is not focused.这个错误）\n\nasync function copyImage() {\n  const resp = await fetch(\n    "https://res.cdn.changbaimg.com/asset/yunying/gold-rabbit-bless/mask-layer.bcc76a5e.png"\n  );\n  const blob = await resp.blob();\n  const copyContent = new ClipboardItem({\n    "image/png": blob,\n  });\n  navigator.clipboard.write([copyContent]);\n}\n',normalizedContent:'# 复制内容到剪贴板\n\n以下是一个不用借助任何第三方库也几乎不用考虑兼容性的复制内容到剪贴板的实现。\n\n/**\n * 向clipboard写入内容\n * @param {string} content 写入剪贴板的内容\n */\nasync function setclipboardtext(content) {\n  try {\n    await navigator.clipboard.writetext(content);\n  } catch (exp) {\n    const tmpinput = document.createelement("input");\n    document.body.appendchild(tmpinput);\n    tmpinput.value = content;\n    /* 需要让这个input是可见的，不能将其设置为visibility为hidden或者display为none */\n    tmpinput.style.left = "absolute";\n    tmpinput.style.left = "10000px";\n    tmpinput.style.top = "10000px";\n    tmpinput.select();\n    typeof document.execcommand === "function" && document.execcommand("copy");\n    document.body.removechild(tmpinput);\n  }\n}\n\n\nhtml5新增了一个比较有趣的api，叫做clipboarditem，以下是它的兼容性情况，还不算太好。\n\n\n\n可以使用它复制图片，不过图片只能是png格式的。\n\n以下是一段复制图片到剪贴板的代码片段：（注意，需要在网页里面执行，否则会抛出domexception: document is not focused.这个错误）\n\nasync function copyimage() {\n  const resp = await fetch(\n    "https://res.cdn.changbaimg.com/asset/yunying/gold-rabbit-bless/mask-layer.bcc76a5e.png"\n  );\n  const blob = await resp.blob();\n  const copycontent = new clipboarditem({\n    "image/png": blob,\n  });\n  navigator.clipboard.write([copycontent]);\n}\n',charsets:{cjk:!0}},{frontmatter:{},regularPath:"/javascript/snippets/money-transfer.html",relativePath:"javascript/snippets/money-transfer.md",key:"v-20439003",path:"/javascript/snippets/money-transfer.html",headersStr:null,content:"",normalizedContent:"",charsets:{}},{title:"日期格式化",frontmatter:{},regularPath:"/javascript/snippets/date-format.html",relativePath:"javascript/snippets/date-format.md",key:"v-0f9649d6",path:"/javascript/snippets/date-format.html",headers:[{level:2,title:"日期格式化",slug:"日期格式化",normalizedTitle:"日期格式化",charIndex:2}],headersStr:"日期格式化",content:'# 日期格式化\n\n日期格式化函数在日常的开发中非常实用，但是如果没有研究过其实现过程的话，还是觉得挺神秘的。\n\n如果对于一个初学者来说，可能不太容易想到。但是对于一个有经验的开发者来说的话，就异常简单了。\n\n因为，这类问题，其实本质上是一个编译的过程，如果这么说的话，您是否感觉有什么东西似曾相识呢？\n\n对，我们写的JSX是怎么转化成React.createElement的？Vue是如何解析template模板语法的？\n\n既然都想到这儿了，问题也就简单了，我们只需要把我们感兴趣的内容识别到，并且转化成相应的结果，是不是就完成啦？\n\n所以，思路非常简单，接下来就考虑如何去编译用户传递的模板字符串。\n\n有两种办法，第一种属于比较简单的做法，可以直接使用正则表达式进行替换，因为字符串替换，第二个参数可以接收一个函数，从而实现灵活的控制替换内容。\n\nfunction paramPredicate(date) {\n  if (!(date instanceof Date) && typeof date != "number") {\n    throw new TypeError("Invalid Date Value");\n  }\n  if (typeof date === "number" && Number.isNaN(date)) {\n    throw new TypeError("Invalid Date Value");\n  }\n}\n\n/**\n * 时间格式化函数\n * @param {Date | Number } date\n * @param {String} formatPattern\n */\nfunction format(date, formatPattern = "YYYY-MM-DD") {\n  paramPredicate(date);\n  if (typeof date === "number") {\n    date = new Date(date);\n  }\n  /**\n   * 格式化年份\n   * @param {Date} time 日期\n   * @param {boolean} simple 是否只取后两位\n   */\n  function formatFullYear(time, simple) {\n    const year = time.getFullYear().toString();\n    return simple ? year.substring(2, 4) : year;\n  }\n  /**\n   * 格式化月份\n   * @param {Date} time 日期\n   * @param {boolean} pad 是否填充\n   */\n  function formatMonth(time, pad) {\n    const month = time.getMonth() + 1;\n    return pad ? String(month).padStart(2, 0) : month.toString();\n  }\n\n  /**\n   * 通用格式化\n   * @param {Date} time\n   * @param {keyof Date} method\n   * @param {boolean} pad\n   */\n  function generalFormat(time, method, pad) {\n    const val = time[method]();\n    return pad ? String(val).padStart(2, 0) : val.toString();\n  }\n\n  /**\n   * 格式化毫秒\n   * @param {Date} time\n   * @param {Number} length\n   */\n  function formatMilliSeconds(time, length) {\n    let ms = time.getMilliseconds();\n    if (length === 3) {\n      return String(ms).padStart(3, 0);\n    } else if (length === 2) {\n      return String(Number.parseInt(ms / 10)).padStart(2, 0);\n    } else {\n      return Number.parseInt(ms / 100);\n    }\n  }\n\n  const formatFlags = {\n    yy: function (val) {\n      return formatFullYear(val, true);\n    },\n    yyyy: function (val) {\n      return formatFullYear(val, false);\n    },\n    YY: function (val) {\n      return formatFullYear(val, true);\n    },\n    YYYY: function (val) {\n      return formatFullYear(val, false);\n    },\n    M: function (val) {\n      return formatMonth(val, false);\n    },\n    MM: function (val) {\n      return formatMonth(val, true);\n    },\n    d: function (val) {\n      return generalFormat(val, "getDate", false);\n    },\n    dd: function (val) {\n      return generalFormat(val, "getDate", true);\n    },\n    D: function (val) {\n      return generalFormat(val, "getDate", false);\n    },\n    DD: function (val) {\n      return generalFormat(val, "getDate", true);\n    },\n    h: function (val) {\n      return generalFormat(val, "getHours", false);\n    },\n    hh: function (val) {\n      return generalFormat(val, "getHours", true);\n    },\n    m: function (val) {\n      return generalFormat(val, "getMinutes", false);\n    },\n    mm: function (val) {\n      return generalFormat(val, "getMinutes", true);\n    },\n    s: function (val) {\n      return generalFormat(val, "getSeconds", false);\n    },\n    ss: function (val) {\n      return generalFormat(val, "getSeconds", true);\n    },\n    S: function (val) {\n      return formatMilliSeconds(val, 1);\n    },\n    SS: function (val) {\n      return formatMilliSeconds(val, 2);\n    },\n    SSS: function (val) {\n      return formatMilliSeconds(val, 3);\n    },\n    W: function (val) {\n      // TODO: 星期几，如Mon， Tus\n    },\n    WW: function (val) {\n      // TODO: 星期几，如星期一，星期二\n    },\n    WWW: function (val) {\n      // TODO: 星期几，如Monday， Mayday\n    },\n  };\n\n  return formatPattern.replace(/[a-zA-Z]+/g, function (matched, index, source) {\n    const formatter = formatFlags[matched];\n    return typeof formatter === "function" ? formatter(date) : matched;\n  });\n}\n\n\n第二种办法就是使用栈，利用词法分析来做替换，但是这种办法不如正则替换来的快，也不如其代码看起来直观。',normalizedContent:'# 日期格式化\n\n日期格式化函数在日常的开发中非常实用，但是如果没有研究过其实现过程的话，还是觉得挺神秘的。\n\n如果对于一个初学者来说，可能不太容易想到。但是对于一个有经验的开发者来说的话，就异常简单了。\n\n因为，这类问题，其实本质上是一个编译的过程，如果这么说的话，您是否感觉有什么东西似曾相识呢？\n\n对，我们写的jsx是怎么转化成react.createelement的？vue是如何解析template模板语法的？\n\n既然都想到这儿了，问题也就简单了，我们只需要把我们感兴趣的内容识别到，并且转化成相应的结果，是不是就完成啦？\n\n所以，思路非常简单，接下来就考虑如何去编译用户传递的模板字符串。\n\n有两种办法，第一种属于比较简单的做法，可以直接使用正则表达式进行替换，因为字符串替换，第二个参数可以接收一个函数，从而实现灵活的控制替换内容。\n\nfunction parampredicate(date) {\n  if (!(date instanceof date) && typeof date != "number") {\n    throw new typeerror("invalid date value");\n  }\n  if (typeof date === "number" && number.isnan(date)) {\n    throw new typeerror("invalid date value");\n  }\n}\n\n/**\n * 时间格式化函数\n * @param {date | number } date\n * @param {string} formatpattern\n */\nfunction format(date, formatpattern = "yyyy-mm-dd") {\n  parampredicate(date);\n  if (typeof date === "number") {\n    date = new date(date);\n  }\n  /**\n   * 格式化年份\n   * @param {date} time 日期\n   * @param {boolean} simple 是否只取后两位\n   */\n  function formatfullyear(time, simple) {\n    const year = time.getfullyear().tostring();\n    return simple ? year.substring(2, 4) : year;\n  }\n  /**\n   * 格式化月份\n   * @param {date} time 日期\n   * @param {boolean} pad 是否填充\n   */\n  function formatmonth(time, pad) {\n    const month = time.getmonth() + 1;\n    return pad ? string(month).padstart(2, 0) : month.tostring();\n  }\n\n  /**\n   * 通用格式化\n   * @param {date} time\n   * @param {keyof date} method\n   * @param {boolean} pad\n   */\n  function generalformat(time, method, pad) {\n    const val = time[method]();\n    return pad ? string(val).padstart(2, 0) : val.tostring();\n  }\n\n  /**\n   * 格式化毫秒\n   * @param {date} time\n   * @param {number} length\n   */\n  function formatmilliseconds(time, length) {\n    let ms = time.getmilliseconds();\n    if (length === 3) {\n      return string(ms).padstart(3, 0);\n    } else if (length === 2) {\n      return string(number.parseint(ms / 10)).padstart(2, 0);\n    } else {\n      return number.parseint(ms / 100);\n    }\n  }\n\n  const formatflags = {\n    yy: function (val) {\n      return formatfullyear(val, true);\n    },\n    yyyy: function (val) {\n      return formatfullyear(val, false);\n    },\n    yy: function (val) {\n      return formatfullyear(val, true);\n    },\n    yyyy: function (val) {\n      return formatfullyear(val, false);\n    },\n    m: function (val) {\n      return formatmonth(val, false);\n    },\n    mm: function (val) {\n      return formatmonth(val, true);\n    },\n    d: function (val) {\n      return generalformat(val, "getdate", false);\n    },\n    dd: function (val) {\n      return generalformat(val, "getdate", true);\n    },\n    d: function (val) {\n      return generalformat(val, "getdate", false);\n    },\n    dd: function (val) {\n      return generalformat(val, "getdate", true);\n    },\n    h: function (val) {\n      return generalformat(val, "gethours", false);\n    },\n    hh: function (val) {\n      return generalformat(val, "gethours", true);\n    },\n    m: function (val) {\n      return generalformat(val, "getminutes", false);\n    },\n    mm: function (val) {\n      return generalformat(val, "getminutes", true);\n    },\n    s: function (val) {\n      return generalformat(val, "getseconds", false);\n    },\n    ss: function (val) {\n      return generalformat(val, "getseconds", true);\n    },\n    s: function (val) {\n      return formatmilliseconds(val, 1);\n    },\n    ss: function (val) {\n      return formatmilliseconds(val, 2);\n    },\n    sss: function (val) {\n      return formatmilliseconds(val, 3);\n    },\n    w: function (val) {\n      // todo: 星期几，如mon， tus\n    },\n    ww: function (val) {\n      // todo: 星期几，如星期一，星期二\n    },\n    www: function (val) {\n      // todo: 星期几，如monday， mayday\n    },\n  };\n\n  return formatpattern.replace(/[a-za-z]+/g, function (matched, index, source) {\n    const formatter = formatflags[matched];\n    return typeof formatter === "function" ? formatter(date) : matched;\n  });\n}\n\n\n第二种办法就是使用栈，利用词法分析来做替换，但是这种办法不如正则替换来的快，也不如其代码看起来直观。',charsets:{cjk:!0}},{title:"图片懒加载",frontmatter:{},regularPath:"/javascript/snippets/lazyload.html",relativePath:"javascript/snippets/lazyload.md",key:"v-26e99c3f",path:"/javascript/snippets/lazyload.html",headers:[{level:2,title:"图片懒加载",slug:"图片懒加载",normalizedTitle:"图片懒加载",charIndex:2},{level:3,title:"方法1: getBoundingClientRect",slug:"方法1-getboundingclientrect",normalizedTitle:"方法1: getboundingclientrect",charIndex:203},{level:3,title:"方法2: IntersectionObserver",slug:"方法2-intersectionobserver",normalizedTitle:"方法2: intersectionobserver",charIndex:4723}],headersStr:"图片懒加载 方法1: getBoundingClientRect 方法2: IntersectionObserver",content:'# 图片懒加载\n\n图片懒加载是一个前端开发中常用的优化手段，主要是优先加载可视区的图片，当用户有操作的时候，有新的图片进入可视区，随即再加载的方式。\n\n图片懒加载有两种实现的方式，比较常用的手段有2种，第一种方式用到的核心API，是getBoundingClientRect，第二种方式用到的核心API是一个比较实用但是可能有些朋友还比较陌生的API，叫做IntersectionObserver\n\n\n# 方法1: getBoundingClientRect\n\ngetBoundingClientRect主要用途是用来判断元素是否可见，这个API可以返回一个元素距离浏览器窗口四角的距离，以及元素的宽高，和元素在屏幕中的位置，其结果的TS定义如下：\n\ninterface DOMRectReadOnly {\n  readonly bottom: number;\n  readonly height: number;\n  readonly left: number;\n  readonly right: number;\n  readonly top: number;\n  readonly width: number;\n  readonly x: number;\n  readonly y: number;\n  toJSON(): any;\n}\n\n\n如果一个元素在视口中可见的话，那么满足如下条件：\n\nfunction isVisible(el) {\n  const position = el.getBoundingClientRect();\n  const windowHeight = document.documentElement.clientHeight;\n  // 顶部边缘可见\n  const topVisible = position.top > 0 && position.top < windowHeight;\n  // 底部边缘可见\n  const bottomVisible = position.bottom < windowHeight && position.bottom > 0;\n  return topVisible || bottomVisible;\n}\n\n\n图片最初的时候，不要直接将地址绑定在src属性上，我们给它设置一个自定义属性data-src，然后当判断到元素进入视口之后，读取这个属性，并且将其设置给src属性。\n\n<img\n  data-src="https://aliimg.changbalive.com/photo/360/9bfe4674fad8e9f7_100_100.jpg"\n/>\n\n\n然后在页面初始化的时候以及页面滚动的时候，根据图片是否在可视区加载图片。由于我们需要绑定window.onload和window.onscroll事件，但是由于这个事件可能别的程序员也有可能处理，因次为了防止丢失别人的处理逻辑，我们需要使用装饰模式为上述连个事件绑定处理器。\n\n另外，由于window.onscroll会触发的比较频繁，出于性能考虑，我们还需要对滑动事件处理器绑定经过节流处理之后的函数。\n\n/**\n * 增加前置执行的函数\n */\nFunction.prototype.beforeExec = function (fn) {\n  const _this = this;\n  return function wrapper() {\n    fn.apply(this, arguments);\n    return _this.apply(this, arguments);\n  };\n};\n/**\n * 增加后置执行的函数\n */\nFunction.prototype.afterExec = function (fn) {\n  const _this = this;\n  return function wrapper() {\n    const response = _this.apply(_this, arguments);\n    _this.apply(_this, arguments);\n    return response;\n  };\n};\n\nfunction lazyLoadImages() {\n  const images = document.querySelectorAll("img");\n  for (let img of images) {\n    const realSrc = img.dataset.src;\n    if (!realSrc) continue;\n    if (isVisible(img)) {\n      img.src = realSrc;\n      img.dataset.src = "";\n    }\n  }\n}\n\n//节流1S\nconst throttledLazyLoadImages = throttle(\n  lazyLoadImages,\n  {\n    trailing: false,\n  },\n  1000\n);\n\nwindow.onload =\n  typeof window.onload === "function"\n    ? window.onload.afterExec(lazyLoadImages)\n    : lazyLoadImages;\n// 防止scroll的触发频率过高\nwindow.onscroll =\n  typeof window.onscroll === "function"\n    ? window.onscroll.afterExec(throttledLazyLoadImages)\n    : throttledLazyLoadImages;\n\n\n虽然上述代码已经能正常运行了，但是在实际开发中，我们一般都是基于框架写代码，以vue框架为例，这样的代码特别适合封装成一个指令，对于使用者来说，只需要采用如下方式调用，毫无学习成本：\n\n<template>\n  <img\n    v-lazyload="https://aliimg.changbalive.com/photo/360/9bfe4674fad8e9f7_100_100.jpg"\n  />\n</template>\n\n\n以下是懒加载指令的完整实现：\n\nimport { throttle } from "lodash-es";\n/**\n * 增加前置执行的函数\n */\ntypeof Function.prototype.beforeExec !== "function" &&\n  (Function.prototype.beforeExec = function (fn) {\n    const _this = this;\n    return function wrapper() {\n      fn.apply(this, arguments);\n      return _this.apply(this, arguments);\n    };\n  });\n/**\n * 增加后置执行的函数\n */\ntypeof Function.prototype.afterExec !== "function" &&\n  (Function.prototype.afterExec = function (fn) {\n    const _this = this;\n    return function wrapper() {\n      const response = _this.apply(_this, arguments);\n      fn.apply(_this, arguments);\n      return response;\n    };\n  });\n/**\n * 定义一个Set，用于存储挂载v-lazyload指令的元素\n */\nconst set = new Set();\n/**\n * 处理图片懒加载逻辑\n */\nfunction lazyLoadImages() {\n  // 从Set中取出所有尚未加载的图片\n  const images = set.values();\n  let readyDelImgs = [];\n  for (const img of images) {\n    const realSrc = img.dataset.src;\n    if (img.src || !realSrc) {\n      continue;\n    }\n    // 已加载的图片要从set中拿掉\n    if (isVisible(img)) {\n      img.src = realSrc;\n      img.dataset.src = "";\n      readyDelImgs.push(img);\n    }\n  }\n  readyDelImgs.forEach((el) => {\n    set.delete(el);\n  });\n  readyDelImgs = null;\n}\n\nconst throttledLazyLoadImages = throttle(\n  lazyLoadImages,\n  {\n    trailing: false,\n  },\n  1000\n);\n\nfunction isVisible(el) {\n  const position = el.getBoundingClientRect();\n  const windowHeight = document.documentElement.clientHeight;\n  // 顶部边缘可见\n  const topVisible = position.top > 0 && position.top < windowHeight;\n  // 底部边缘可见\n  const bottomVisible = position.bottom < windowHeight && position.bottom > 0;\n  return topVisible || bottomVisible;\n}\n\n/**\n * 防止侵入已有逻辑，因此保险起见\n */\nwindow.onload =\n  typeof window.onload === "function"\n    ? window.onload.afterExec(lazyLoadImages)\n    : lazyLoadImages;\n// 防止scroll的触发频率过高\nwindow.onscroll =\n  typeof window.onscroll === "function"\n    ? window.onscroll.afterExec(throttledLazyLoadImages)\n    : throttledLazyLoadImages;\n\nexport default {\n  created(el, binding) {\n    if (!el.dataset.src) {\n      el.dataset.src = binding.value;\n      set.add(el);\n    }\n  },\n};\n\n\n\n# 方法2: IntersectionObserver\n\n使用IntersectionObserver和使用getBoundingClientRect方法差异还算比较大的，因为getBoundingClientRect告诉我们的是元素的位置，并且还需要我们自己判断元素是否在视口，同时我们还需要在window对象特定的事件里面判断这些业务。\n\n而使用IntersectionObserver，这些事儿全部都交给它在做了，我们只需要为其绑定回调函数，然后一旦元素进入视口，回调函数自动就触发了，代码需要处理的业务逻辑变简单了许多。\n\nIntersectionObserver这个API本质是用来判断元素之间是否相交，只是在这个场景下，我们判断的是特定的元素是否和视口相交，希望读者加以体会，不要混淆。\n\n以下是基于IntersectionObserver编写的图片懒加载指令的实现：\n\nconst itObserver = new IntersectionObserver(\n  (entries) => {\n    for (const entry of entries) {\n      // entry.intersectionRatio 如果正在变大(可以用Map来记住某个元素对应的intersectionRatio从而看出变化)，\n      // 说明当前被观察的元素正在进入某个元素（本例是视口），否则是远离\n      if (entry.isIntersecting) {\n        if (entry.target.src || !entry.target.dataset.src) {\n          continue;\n        }\n        const tmpSrc = entry.target.getAttribute("data-src");\n        entry.target.src = tmpSrc;\n        entry.target.removeAttribute("data-src");\n      }\n    }\n  },\n  {\n    // 设置相交的阈值\n    threshold: 0.1,\n  }\n);\n\nexport default {\n  created(el, binding) {\n    if (!el.dataset.src) {\n      el.dataset.src = binding.value;\n    }\n    itObserver.observe(el);\n  },\n  beforeUnmount(el) {\n    itObserver.unobserve(el);\n  },\n};\n',normalizedContent:'# 图片懒加载\n\n图片懒加载是一个前端开发中常用的优化手段，主要是优先加载可视区的图片，当用户有操作的时候，有新的图片进入可视区，随即再加载的方式。\n\n图片懒加载有两种实现的方式，比较常用的手段有2种，第一种方式用到的核心api，是getboundingclientrect，第二种方式用到的核心api是一个比较实用但是可能有些朋友还比较陌生的api，叫做intersectionobserver\n\n\n# 方法1: getboundingclientrect\n\ngetboundingclientrect主要用途是用来判断元素是否可见，这个api可以返回一个元素距离浏览器窗口四角的距离，以及元素的宽高，和元素在屏幕中的位置，其结果的ts定义如下：\n\ninterface domrectreadonly {\n  readonly bottom: number;\n  readonly height: number;\n  readonly left: number;\n  readonly right: number;\n  readonly top: number;\n  readonly width: number;\n  readonly x: number;\n  readonly y: number;\n  tojson(): any;\n}\n\n\n如果一个元素在视口中可见的话，那么满足如下条件：\n\nfunction isvisible(el) {\n  const position = el.getboundingclientrect();\n  const windowheight = document.documentelement.clientheight;\n  // 顶部边缘可见\n  const topvisible = position.top > 0 && position.top < windowheight;\n  // 底部边缘可见\n  const bottomvisible = position.bottom < windowheight && position.bottom > 0;\n  return topvisible || bottomvisible;\n}\n\n\n图片最初的时候，不要直接将地址绑定在src属性上，我们给它设置一个自定义属性data-src，然后当判断到元素进入视口之后，读取这个属性，并且将其设置给src属性。\n\n<img\n  data-src="https://aliimg.changbalive.com/photo/360/9bfe4674fad8e9f7_100_100.jpg"\n/>\n\n\n然后在页面初始化的时候以及页面滚动的时候，根据图片是否在可视区加载图片。由于我们需要绑定window.onload和window.onscroll事件，但是由于这个事件可能别的程序员也有可能处理，因次为了防止丢失别人的处理逻辑，我们需要使用装饰模式为上述连个事件绑定处理器。\n\n另外，由于window.onscroll会触发的比较频繁，出于性能考虑，我们还需要对滑动事件处理器绑定经过节流处理之后的函数。\n\n/**\n * 增加前置执行的函数\n */\nfunction.prototype.beforeexec = function (fn) {\n  const _this = this;\n  return function wrapper() {\n    fn.apply(this, arguments);\n    return _this.apply(this, arguments);\n  };\n};\n/**\n * 增加后置执行的函数\n */\nfunction.prototype.afterexec = function (fn) {\n  const _this = this;\n  return function wrapper() {\n    const response = _this.apply(_this, arguments);\n    _this.apply(_this, arguments);\n    return response;\n  };\n};\n\nfunction lazyloadimages() {\n  const images = document.queryselectorall("img");\n  for (let img of images) {\n    const realsrc = img.dataset.src;\n    if (!realsrc) continue;\n    if (isvisible(img)) {\n      img.src = realsrc;\n      img.dataset.src = "";\n    }\n  }\n}\n\n//节流1s\nconst throttledlazyloadimages = throttle(\n  lazyloadimages,\n  {\n    trailing: false,\n  },\n  1000\n);\n\nwindow.onload =\n  typeof window.onload === "function"\n    ? window.onload.afterexec(lazyloadimages)\n    : lazyloadimages;\n// 防止scroll的触发频率过高\nwindow.onscroll =\n  typeof window.onscroll === "function"\n    ? window.onscroll.afterexec(throttledlazyloadimages)\n    : throttledlazyloadimages;\n\n\n虽然上述代码已经能正常运行了，但是在实际开发中，我们一般都是基于框架写代码，以vue框架为例，这样的代码特别适合封装成一个指令，对于使用者来说，只需要采用如下方式调用，毫无学习成本：\n\n<template>\n  <img\n    v-lazyload="https://aliimg.changbalive.com/photo/360/9bfe4674fad8e9f7_100_100.jpg"\n  />\n</template>\n\n\n以下是懒加载指令的完整实现：\n\nimport { throttle } from "lodash-es";\n/**\n * 增加前置执行的函数\n */\ntypeof function.prototype.beforeexec !== "function" &&\n  (function.prototype.beforeexec = function (fn) {\n    const _this = this;\n    return function wrapper() {\n      fn.apply(this, arguments);\n      return _this.apply(this, arguments);\n    };\n  });\n/**\n * 增加后置执行的函数\n */\ntypeof function.prototype.afterexec !== "function" &&\n  (function.prototype.afterexec = function (fn) {\n    const _this = this;\n    return function wrapper() {\n      const response = _this.apply(_this, arguments);\n      fn.apply(_this, arguments);\n      return response;\n    };\n  });\n/**\n * 定义一个set，用于存储挂载v-lazyload指令的元素\n */\nconst set = new set();\n/**\n * 处理图片懒加载逻辑\n */\nfunction lazyloadimages() {\n  // 从set中取出所有尚未加载的图片\n  const images = set.values();\n  let readydelimgs = [];\n  for (const img of images) {\n    const realsrc = img.dataset.src;\n    if (img.src || !realsrc) {\n      continue;\n    }\n    // 已加载的图片要从set中拿掉\n    if (isvisible(img)) {\n      img.src = realsrc;\n      img.dataset.src = "";\n      readydelimgs.push(img);\n    }\n  }\n  readydelimgs.foreach((el) => {\n    set.delete(el);\n  });\n  readydelimgs = null;\n}\n\nconst throttledlazyloadimages = throttle(\n  lazyloadimages,\n  {\n    trailing: false,\n  },\n  1000\n);\n\nfunction isvisible(el) {\n  const position = el.getboundingclientrect();\n  const windowheight = document.documentelement.clientheight;\n  // 顶部边缘可见\n  const topvisible = position.top > 0 && position.top < windowheight;\n  // 底部边缘可见\n  const bottomvisible = position.bottom < windowheight && position.bottom > 0;\n  return topvisible || bottomvisible;\n}\n\n/**\n * 防止侵入已有逻辑，因此保险起见\n */\nwindow.onload =\n  typeof window.onload === "function"\n    ? window.onload.afterexec(lazyloadimages)\n    : lazyloadimages;\n// 防止scroll的触发频率过高\nwindow.onscroll =\n  typeof window.onscroll === "function"\n    ? window.onscroll.afterexec(throttledlazyloadimages)\n    : throttledlazyloadimages;\n\nexport default {\n  created(el, binding) {\n    if (!el.dataset.src) {\n      el.dataset.src = binding.value;\n      set.add(el);\n    }\n  },\n};\n\n\n\n# 方法2: intersectionobserver\n\n使用intersectionobserver和使用getboundingclientrect方法差异还算比较大的，因为getboundingclientrect告诉我们的是元素的位置，并且还需要我们自己判断元素是否在视口，同时我们还需要在window对象特定的事件里面判断这些业务。\n\n而使用intersectionobserver，这些事儿全部都交给它在做了，我们只需要为其绑定回调函数，然后一旦元素进入视口，回调函数自动就触发了，代码需要处理的业务逻辑变简单了许多。\n\nintersectionobserver这个api本质是用来判断元素之间是否相交，只是在这个场景下，我们判断的是特定的元素是否和视口相交，希望读者加以体会，不要混淆。\n\n以下是基于intersectionobserver编写的图片懒加载指令的实现：\n\nconst itobserver = new intersectionobserver(\n  (entries) => {\n    for (const entry of entries) {\n      // entry.intersectionratio 如果正在变大(可以用map来记住某个元素对应的intersectionratio从而看出变化)，\n      // 说明当前被观察的元素正在进入某个元素（本例是视口），否则是远离\n      if (entry.isintersecting) {\n        if (entry.target.src || !entry.target.dataset.src) {\n          continue;\n        }\n        const tmpsrc = entry.target.getattribute("data-src");\n        entry.target.src = tmpsrc;\n        entry.target.removeattribute("data-src");\n      }\n    }\n  },\n  {\n    // 设置相交的阈值\n    threshold: 0.1,\n  }\n);\n\nexport default {\n  created(el, binding) {\n    if (!el.dataset.src) {\n      el.dataset.src = binding.value;\n    }\n    itobserver.observe(el);\n  },\n  beforeunmount(el) {\n    itobserver.unobserve(el);\n  },\n};\n',charsets:{cjk:!0}},{title:"rgb颜色转hex颜色",frontmatter:{},regularPath:"/javascript/snippets/color-transform.html",relativePath:"javascript/snippets/color-transform.md",key:"v-6852a215",path:"/javascript/snippets/color-transform.html",headers:[{level:2,title:"rgb颜色转hex颜色",slug:"rgb颜色转hex颜色",normalizedTitle:"rgb颜色转hex颜色",charIndex:2},{level:2,title:"hex颜色转rgb颜色",slug:"hex颜色转rgb颜色",normalizedTitle:"hex颜色转rgb颜色",charIndex:43}],headersStr:"rgb颜色转hex颜色 hex颜色转rgb颜色",content:"# rgb颜色转hex颜色\n\nfunction rgbToHex() {}\n\n\n\n# hex颜色转rgb颜色\n\nfunction hexToGgb() {}\n",normalizedContent:"# rgb颜色转hex颜色\n\nfunction rgbtohex() {}\n\n\n\n# hex颜色转rgb颜色\n\nfunction hextoggb() {}\n",charsets:{cjk:!0}},{title:"两数相加（非负数）",frontmatter:{},regularPath:"/javascript/snippets/safety-add.html",relativePath:"javascript/snippets/safety-add.md",key:"v-a3a42c32",path:"/javascript/snippets/safety-add.html",headers:[{level:2,title:"两数相加（非负数）",slug:"两数相加-非负数",normalizedTitle:"两数相加（非负数）",charIndex:2},{level:2,title:"两数相减（非负数）",slug:"两数相减-非负数",normalizedTitle:"两数相减（非负数）",charIndex:16}],headersStr:"两数相加（非负数） 两数相减（非负数）",content:"# 两数相加（非负数）\n\n\n# 两数相减（非负数）",normalizedContent:"# 两数相加（非负数）\n\n\n# 两数相减（非负数）",charsets:{cjk:!0}},{title:"支持重复请求的方法",frontmatter:{},regularPath:"/javascript/snippets/repeatable-request.html",relativePath:"javascript/snippets/repeatable-request.md",key:"v-4cd85745",path:"/javascript/snippets/repeatable-request.html",headers:[{level:2,title:"支持重复请求的方法",slug:"支持重复请求的方法",normalizedTitle:"支持重复请求的方法",charIndex:2}],headersStr:"支持重复请求的方法",content:"# 支持重复请求的方法\n\n这个方法主要是看你对Promise的理解程度了，主要思路就是如果Promise.catch捕获到错误了的话，需要重新发起请求，如果超过了最大的重试次数的话，则不再进行了。\n\n以下是递归的实现：\n\nfunction request(url, maxCount = 5) {\n  return fetch(url).catch((err) => {\n    // 如果超出了最大错误对外返回一个rejected态的Promise，否则根据当前已请求次数决定是否重试\n    return maxCount <= 0 ? Promise.reject(err) : request(url, maxCount - 1);\n  });\n}\n\n\n递归的实现看起来比较简洁，如果有些同学对递归看不顺眼的话，以下是非递归的写法。\n\n非递归的实现思路主要还是在怎么继续进行下一次的请求，首先这个肯定是线性的数据结构，我就会考虑到队列 + 循环来实现了。\n\nasync function request(url, maxCount = 5) {\n  // 包裹的函数，定义成函数的原因，是可能在这里面可以支持额外的操作\n  const func = (url) => fetch(url);\n  const queue = [func];\n  maxCount--;\n  while (queue.length) {\n    const fn = queue.shift();\n    try {\n      const resp = await fn(url);\n      return resp;\n    } catch (exp) {\n      if (maxCount <= 0) {\n        throw new Error(exp);\n      } else {\n        maxCount--;\n        queue.push(func);\n      }\n    }\n  }\n}\n",normalizedContent:"# 支持重复请求的方法\n\n这个方法主要是看你对promise的理解程度了，主要思路就是如果promise.catch捕获到错误了的话，需要重新发起请求，如果超过了最大的重试次数的话，则不再进行了。\n\n以下是递归的实现：\n\nfunction request(url, maxcount = 5) {\n  return fetch(url).catch((err) => {\n    // 如果超出了最大错误对外返回一个rejected态的promise，否则根据当前已请求次数决定是否重试\n    return maxcount <= 0 ? promise.reject(err) : request(url, maxcount - 1);\n  });\n}\n\n\n递归的实现看起来比较简洁，如果有些同学对递归看不顺眼的话，以下是非递归的写法。\n\n非递归的实现思路主要还是在怎么继续进行下一次的请求，首先这个肯定是线性的数据结构，我就会考虑到队列 + 循环来实现了。\n\nasync function request(url, maxcount = 5) {\n  // 包裹的函数，定义成函数的原因，是可能在这里面可以支持额外的操作\n  const func = (url) => fetch(url);\n  const queue = [func];\n  maxcount--;\n  while (queue.length) {\n    const fn = queue.shift();\n    try {\n      const resp = await fn(url);\n      return resp;\n    } catch (exp) {\n      if (maxcount <= 0) {\n        throw new error(exp);\n      } else {\n        maxcount--;\n        queue.push(func);\n      }\n    }\n  }\n}\n",charsets:{cjk:!0}},{title:"安全的取值和赋值方法",frontmatter:{},regularPath:"/javascript/snippets/safety-getandset.html",relativePath:"javascript/snippets/safety-getandset.md",key:"v-654cbf67",path:"/javascript/snippets/safety-getandset.html",headers:[{level:2,title:"安全的取值和赋值方法",slug:"安全的取值和赋值方法",normalizedTitle:"安全的取值和赋值方法",charIndex:2}],headersStr:"安全的取值和赋值方法",content:'# 安全的取值和赋值方法\n\n安全的从对象上取值的方法在ES6的?.运算符出来之前是一个比较常用的方法（如果项目没有这种工具库的话，那还是用?.运算符比较省事儿了）因为JS如果在当前执行任务里遇到未捕获的错误的话，就不再继续向下执行了。所以我们在对象上进行取值操作的时候，基本上都会进行一个非空断言。\n\n比如：\n\no && o.p && typeof o.p.q === "function" && o.p.q();\n\n\n有了 ES6 的?.运算符之后，以下代码可以简写成\n\no?.p?.q?.();\n\n\n我们可以将这段代码编译之后的代码贴出来看看\n\n"use strict";\n\nvar _o$p, _o$p$q;\n\nvar o = {};\no.p = {};\n\no.p.q = function () {\n  console.log("aaa");\n};\n\no === null || o === void 0\n  ? void 0\n  : (_o$p = o.p) === null || _o$p === void 0\n  ? void 0\n  : (_o$p$q = _o$p.q) === null || _o$p$q === void 0\n  ? void 0\n  : _o$p$q.call(_o$p);\n\n\n可以看到，这段代码编译出来的结果是相当的长啊，这就是为什么Vue3没有采用这种语法的原因了。\n\n在对象上设置某个值就会比较有用了，因为你就不用一次一次的去初始化对象，解放双手。\n\n说了这么多废话，回归正题，以下是我实现一个安全的取值方法safetyGetProperty和safetySetProperty\n\n/**\n * 安全的获取对象o上键为p的值(不考虑原型链)\n * @param {Object} o\n * @param {String} p p支持a.b.c或者b.a[o][d].e这样的形式，对于[]这种形式的取值，如果不按预期传递，解析的结果可能就非预期\n */\nexport function safetyGetProperty(o, p) {\n  // 非引用类型直接报错\n  if (!isRef(o)) {\n    throw new Error("o must be a reference type");\n  }\n  p = String(p);\n  // 如果当前对象上不存在这个key，说明用户传递的内容是复杂key，才继续后续的流程，否则可以直接取值\n  if (o && o.hasOwnProperty(p)) {\n    return o[p];\n  }\n  // 解析keys\n  const props = parseProps(p);\n  let prop = props.shift();\n  let target = o[prop];\n  // 如果target不是一个真值，那么继续循环将会报错，如果realKeys的length还存在，说明key值还没有取完，需要继续向下迭代\n  while (target && props.length) {\n    prop = props.shift();\n    target = target[prop];\n  }\n  // 如果keys的值用尽，说明是正常终止，否则就是非正常终止的，则返回null。\n  return props.length === 0 ? target : null;\n}\n\n/**\n * 安全的设置对象o上键为p的值v(不考虑原型链)\n * @param {Object} o\n * @param {String} p\n * @param {any} v\n */\nexport function safetySetProperty(\n  o,\n  p,\n  v,\n  propDesc = {\n    enumerable: true,\n    writable: true,\n    configurable: true,\n  }\n) {\n  // 非引用类型直接报错\n  if (!isRef(o)) {\n    throw new Error("o must be a reference type");\n  }\n  p = String(p);\n  // 解析props\n  const realKeys = parseProps(p);\n  let target = o;\n  let prop = realKeys.shift();\n  while (realKeys.length) {\n    // 是否是纯数字的键\n    let isPureNumProp = /\\d+/.test(prop);\n    // 如果对象不存在\n    if (!target[prop]) {\n      // 如果是纯数字的key，初始化为数组，否则初试化为对象\n      target[prop] = isPureNumProp ? [] : {};\n    }\n    // 向后迭代\n    target = target[prop];\n    prop = realKeys.shift();\n  }\n  Object.defineProperty(target, prop, {\n    ...propDesc,\n    value: v,\n  });\n}\n\n/**\n * 判断是否是引用类型\n * @param {Array | Object} o\n * @returns\n */\nfunction isRef(o) {\n  return ["Object", "Array"].some((key) => {\n    return Object.prototype.toString.call(o, key) === `[object ${key}]`;\n  });\n}\n\nfunction parseProps(prop) {\n  // 先以.形式分割，如果最后一个字符为.则视为最后想要取的键位\'\'，如果第一个是.，则视其为第一个键值的一部分\n  const primaryKeys = prop.split(".");\n  if (/^\\./.test(prop)) {\n    // 弹出空值\n    primaryKeys.shift();\n    // 取出真值，并且将.视为第一个键的一部分\n    const tmp = primaryKeys.shift();\n    primaryKeys.unshift("." + tmp);\n  }\n  const parsedProps = [];\n  for (let i = 0; i < primaryKeys.length; i++) {\n    const key = primaryKeys[i];\n    if (/\\[[\\w]+\\]/.test(key)) {\n      const keyGroup = parseSquareBrackets(key);\n      parsedProps.push(...keyGroup);\n    } else {\n      parsedProps.push(key);\n    }\n  }\n  return parsedProps;\n}\n\n/**\n * 解析方括号中的key值\n * @param {String} prop\n */\nfunction parseSquareBrackets(prop) {\n  let pos = 0;\n  let str = "";\n  let parsedKeys = [];\n  // 定义一个解析中的标记\n  let parsing = false;\n  while (pos < prop.length) {\n    const char = prop[pos++];\n    // 解析到第一个`[`之前的key，当前的[不计入key中\n    if (char === "[") {\n      if (str != "") {\n        parsedKeys.push(str);\n        str = "";\n      }\n      parsing = true;\n      continue;\n    }\n    // 遇到`]`则视为已经解析到了一个key\n    else if (char === "]" && parsing) {\n      parsing = false;\n      parsedKeys.push(str);\n      str = "";\n    } else {\n      // 极端的case 单的`]`，还没有开始就已经遇到]\n      str += char;\n    }\n  }\n  // 极端case 单的`[`\n  if (parsing) {\n    const tmp = parsedKeys.pop();\n    parsedKeys.push(tmp + "[" + str);\n    str = "";\n  }\n  // 极端的case 单的`]`\n  if (str != "") {\n    parsedKeys.push(str);\n    str = "";\n  }\n  return parsedKeys;\n}\n/**\n * 这是parseSquareBrackets的测试用例\n */\n// parseSquareBrackets("a[b][c]")\n// [\'a\', \'b\', \'c\']\n// parseSquareBrackets("a[bc]")\n// [\'a\', \'bc\']\n// parseSquareBrackets("a[bc")\n// [\'a[bc\']\n// parseSquareBrackets("ab]c")\n// [\'ab]c\']\n// parseSquareBrackets("ab]c]")\n// [\'ab]c]\']\n// parseSquareBrackets("[abc]")\n// [\'abc\']\n// parseSquareBrackets("[]")\n// [\'\']\n// parseSquareBrackets("a[[b]]c")\n// [\'a\', \'b\', \'c\']，这是我认为预期的处理结果\n',normalizedContent:'# 安全的取值和赋值方法\n\n安全的从对象上取值的方法在es6的?.运算符出来之前是一个比较常用的方法（如果项目没有这种工具库的话，那还是用?.运算符比较省事儿了）因为js如果在当前执行任务里遇到未捕获的错误的话，就不再继续向下执行了。所以我们在对象上进行取值操作的时候，基本上都会进行一个非空断言。\n\n比如：\n\no && o.p && typeof o.p.q === "function" && o.p.q();\n\n\n有了 es6 的?.运算符之后，以下代码可以简写成\n\no?.p?.q?.();\n\n\n我们可以将这段代码编译之后的代码贴出来看看\n\n"use strict";\n\nvar _o$p, _o$p$q;\n\nvar o = {};\no.p = {};\n\no.p.q = function () {\n  console.log("aaa");\n};\n\no === null || o === void 0\n  ? void 0\n  : (_o$p = o.p) === null || _o$p === void 0\n  ? void 0\n  : (_o$p$q = _o$p.q) === null || _o$p$q === void 0\n  ? void 0\n  : _o$p$q.call(_o$p);\n\n\n可以看到，这段代码编译出来的结果是相当的长啊，这就是为什么vue3没有采用这种语法的原因了。\n\n在对象上设置某个值就会比较有用了，因为你就不用一次一次的去初始化对象，解放双手。\n\n说了这么多废话，回归正题，以下是我实现一个安全的取值方法safetygetproperty和safetysetproperty\n\n/**\n * 安全的获取对象o上键为p的值(不考虑原型链)\n * @param {object} o\n * @param {string} p p支持a.b.c或者b.a[o][d].e这样的形式，对于[]这种形式的取值，如果不按预期传递，解析的结果可能就非预期\n */\nexport function safetygetproperty(o, p) {\n  // 非引用类型直接报错\n  if (!isref(o)) {\n    throw new error("o must be a reference type");\n  }\n  p = string(p);\n  // 如果当前对象上不存在这个key，说明用户传递的内容是复杂key，才继续后续的流程，否则可以直接取值\n  if (o && o.hasownproperty(p)) {\n    return o[p];\n  }\n  // 解析keys\n  const props = parseprops(p);\n  let prop = props.shift();\n  let target = o[prop];\n  // 如果target不是一个真值，那么继续循环将会报错，如果realkeys的length还存在，说明key值还没有取完，需要继续向下迭代\n  while (target && props.length) {\n    prop = props.shift();\n    target = target[prop];\n  }\n  // 如果keys的值用尽，说明是正常终止，否则就是非正常终止的，则返回null。\n  return props.length === 0 ? target : null;\n}\n\n/**\n * 安全的设置对象o上键为p的值v(不考虑原型链)\n * @param {object} o\n * @param {string} p\n * @param {any} v\n */\nexport function safetysetproperty(\n  o,\n  p,\n  v,\n  propdesc = {\n    enumerable: true,\n    writable: true,\n    configurable: true,\n  }\n) {\n  // 非引用类型直接报错\n  if (!isref(o)) {\n    throw new error("o must be a reference type");\n  }\n  p = string(p);\n  // 解析props\n  const realkeys = parseprops(p);\n  let target = o;\n  let prop = realkeys.shift();\n  while (realkeys.length) {\n    // 是否是纯数字的键\n    let ispurenumprop = /\\d+/.test(prop);\n    // 如果对象不存在\n    if (!target[prop]) {\n      // 如果是纯数字的key，初始化为数组，否则初试化为对象\n      target[prop] = ispurenumprop ? [] : {};\n    }\n    // 向后迭代\n    target = target[prop];\n    prop = realkeys.shift();\n  }\n  object.defineproperty(target, prop, {\n    ...propdesc,\n    value: v,\n  });\n}\n\n/**\n * 判断是否是引用类型\n * @param {array | object} o\n * @returns\n */\nfunction isref(o) {\n  return ["object", "array"].some((key) => {\n    return object.prototype.tostring.call(o, key) === `[object ${key}]`;\n  });\n}\n\nfunction parseprops(prop) {\n  // 先以.形式分割，如果最后一个字符为.则视为最后想要取的键位\'\'，如果第一个是.，则视其为第一个键值的一部分\n  const primarykeys = prop.split(".");\n  if (/^\\./.test(prop)) {\n    // 弹出空值\n    primarykeys.shift();\n    // 取出真值，并且将.视为第一个键的一部分\n    const tmp = primarykeys.shift();\n    primarykeys.unshift("." + tmp);\n  }\n  const parsedprops = [];\n  for (let i = 0; i < primarykeys.length; i++) {\n    const key = primarykeys[i];\n    if (/\\[[\\w]+\\]/.test(key)) {\n      const keygroup = parsesquarebrackets(key);\n      parsedprops.push(...keygroup);\n    } else {\n      parsedprops.push(key);\n    }\n  }\n  return parsedprops;\n}\n\n/**\n * 解析方括号中的key值\n * @param {string} prop\n */\nfunction parsesquarebrackets(prop) {\n  let pos = 0;\n  let str = "";\n  let parsedkeys = [];\n  // 定义一个解析中的标记\n  let parsing = false;\n  while (pos < prop.length) {\n    const char = prop[pos++];\n    // 解析到第一个`[`之前的key，当前的[不计入key中\n    if (char === "[") {\n      if (str != "") {\n        parsedkeys.push(str);\n        str = "";\n      }\n      parsing = true;\n      continue;\n    }\n    // 遇到`]`则视为已经解析到了一个key\n    else if (char === "]" && parsing) {\n      parsing = false;\n      parsedkeys.push(str);\n      str = "";\n    } else {\n      // 极端的case 单的`]`，还没有开始就已经遇到]\n      str += char;\n    }\n  }\n  // 极端case 单的`[`\n  if (parsing) {\n    const tmp = parsedkeys.pop();\n    parsedkeys.push(tmp + "[" + str);\n    str = "";\n  }\n  // 极端的case 单的`]`\n  if (str != "") {\n    parsedkeys.push(str);\n    str = "";\n  }\n  return parsedkeys;\n}\n/**\n * 这是parsesquarebrackets的测试用例\n */\n// parsesquarebrackets("a[b][c]")\n// [\'a\', \'b\', \'c\']\n// parsesquarebrackets("a[bc]")\n// [\'a\', \'bc\']\n// parsesquarebrackets("a[bc")\n// [\'a[bc\']\n// parsesquarebrackets("ab]c")\n// [\'ab]c\']\n// parsesquarebrackets("ab]c]")\n// [\'ab]c]\']\n// parsesquarebrackets("[abc]")\n// [\'abc\']\n// parsesquarebrackets("[]")\n// [\'\']\n// parsesquarebrackets("a[[b]]c")\n// [\'a\', \'b\', \'c\']，这是我认为预期的处理结果\n',charsets:{cjk:!0}},{title:"函数上下文——this",frontmatter:{},regularPath:"/javascript/this.html",relativePath:"javascript/this.md",key:"v-397682b5",path:"/javascript/this.html",headers:[{level:2,title:"函数上下文——this",slug:"函数上下文-this",normalizedTitle:"函数上下文——this",charIndex:2},{level:2,title:"this的默认绑定",slug:"this的默认绑定",normalizedTitle:"this的默认绑定",charIndex:252},{level:3,title:"方法中的this",slug:"方法中的this",normalizedTitle:"方法中的this",charIndex:322},{level:3,title:"单独的this",slug:"单独的this",normalizedTitle:"单独的this",charIndex:826},{level:3,title:"函数的this",slug:"函数的this",normalizedTitle:"函数的this",charIndex:1054},{level:3,title:"事件处理中的this",slug:"事件处理中的this",normalizedTitle:"事件处理中的this",charIndex:1209},{level:2,title:"改变this的默认绑定方式",slug:"改变this的默认绑定方式",normalizedTitle:"改变this的默认绑定方式",charIndex:1328},{level:3,title:"new",slug:"new",normalizedTitle:"new",charIndex:1394},{level:3,title:"call，apply，bind",slug:"call-apply-bind",normalizedTitle:"call，apply，bind",charIndex:2213},{level:3,title:"箭头函数",slug:"箭头函数",normalizedTitle:"箭头函数",charIndex:3404},{level:2,title:"this绑定的优先级",slug:"this绑定的优先级",normalizedTitle:"this绑定的优先级",charIndex:4166}],headersStr:"函数上下文——this this的默认绑定 方法中的this 单独的this 函数的this 事件处理中的this 改变this的默认绑定方式 new call，apply，bind 箭头函数 this绑定的优先级",content:'# 函数上下文——this\n\n如果你是一个JS的初学者，this这一定是一个能够让你欲哭无泪的语法。像C#，Java这类语言，如果类的方法是非静态的，那么this指向的就是类的实例，如果是静态方法，那么就指向类本身，而JS的this是可变的，在没有搞懂this之前，不妨忘记之前学过的知识，以利于学习。\n\n它有一个更加贴切的名字，函数上下文，这个名字恰到好处的表达了this的含义。\n\n当函数在不同的环境下执行，this的指向是不同的，简言之就是哪个对象调用的这个函数，this就指向那个对象。\n\n\n# this的默认绑定\n\n默认情况的this调用都是隐式绑定，即谁调用，指向谁。因此，这节所有内容都不考虑方法被强制指定this的情况\n\n\n# 方法中的this\n\nlet person = {\n  firstName: "Bill",\n  lastName: "Gates",\n  id: 123,\n  fullName: function(){\n    return this.firstName + " " + this.lastName;\n  }\n};\n\nperson.fullName() // Bill Gates\n\nlet fullName = person.fullName;\n\nfullName(); // "undefined undefined"\n\n\n如果在 ES6 的class中的话，this的指向分两种情况：\n\nclass App {\n  static run() {\n    console.log(this);\n  }\n\n  log() {\n    console.log(this);\n  }\n}\n\n\n对于静态方法中的this，默认指向的是当前class（如run方法的this指向App），对于非静态方法的this，默认指向的是当前class的原型对象(如log方法的this指向App.prototype)\n\n\n# 单独的this\n\nconsole.log(this); // globalThis\n\n\n在单独使用时，拥有者是全局对象，this指的是全局对象，即globalThis，对于nodejs，globalThis指向的是global对象，而对于浏览器， globalThis指向的是window对象，这就是上小节内容为什么fullName()输出的内容是"undefined undefined"，而对于WebWorker中，this指向self对象。\n\n\n# 函数的this\n\nfunction Person(){\n  return this;\n}\n\n\n非严格模式中，函数的拥有者默认绑定this，因此，在函数中，this指的是全局对象globalThis。\n\n严格模式不允许默认绑定，因此，在函数中使用时，在严格模式下，this是未定义的undefined。\n\n\n# 事件处理中的this\n\n<button onclick="this.style.display=\'none\'">点击来删除我！</button>\n\n\nthis指向的是当前触发事件的元素，如上面例子中，this指向的是button\n\n\n# 改变this的默认绑定方式\n\n由于this的可变性，导致我们的程序可能会变的脆弱，因此，需要在某些时候明确this的指向。\n\n\n# new\n\nfunction Person(){\n  console.log(this instanceof Person)\n  console.log(new.target);\n}\n\nconst people = new Person(); // Person Person\n\n\n这是一个隐式改变this的调用，同时又是this绑定中优先级最高的调用。\n\n有了这个手段，我们可以用来判断函数是否是被用于new的形式调用，下面的代码就是babel转码class的结果的节选。\n\n在ES6中为new引入了一个新的数据target，也可以用来判断是否是通过new调用的。\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError("Cannot call a class as a function");\n  }\n}\n\n\n接下来就是一个比较迷惑也不迷惑的面试题了，如下：\n\nconst obj = {\n  name: \'JohnYang\',\n  age: 28,\n}\nfunction Person(){\n  console.log(this instanceof Person)\n  console.log(new.target);\n  console.log(this.name, this.age);\n}\n// 想强制指定this为obj\nconst MyPerson = Person.bind(obj);\n\nconst p = new MyPerson();\n\n\n因为使用new调用时的this绑定优先级是最高的，所以其实MyPerson就是Person，this上不存在name和age，因此最终输出的是undefined undefined\n\n\n# call，apply，bind\n\n这几个问题是面试题中考场最多的问题之一了，面试官：“请问call，apply，bind三者有什么区别，并说出如何实现”?\n\n本文不讨论它们的实现，只讨论用法。\n\ninterface Function {\n  apply(this: Function, thisArg: any, argArray?: any): any;\n  call(this: Function, thisArg: any, ...argArray: any[]): any;\n  bind(this: Function, thisArg: any, ...argArray: any[]): any;\n}\n\n\n首先，call和apply几乎是差不多的，它们的第一个参数都是this上下文，而call是接受N个参数，一字排开，而apply是接受一个由函数的N个参数组成的数组（类数组对象也可以的），然后这个函数就被立即执行了。\n\n如：\n\nlet firstName = "John";\nlet lastName = "Yang";\nlet person = {\n  firstName: "Bill",\n  lastName: "Gates",\n  id: 123,\n  fullName: function (arg1, arg2) {\n    console.log(arg1, arg2);\n    return this.firstName + " " + this.lastName;\n  },\n};\nperson.fullName.apply(person, ["hello", "world"]); // "hello" "world" 返回 "Bill Gates"\nconst fullName2 = person.fullName.bind(window, "hello", "world"); // "hello" "world" 返回 "John Yang"\n\n\n而bind和它们两者有个最大的不同，bind是返回一个被改变了this指向的函数。\n\nbind在使用的过程中还可以预制一些参数，那么得到的函数在执行的时候就可以省略掉预制的参数，如：\n\nfunction Person(name, age) {\n  this.name = name;\n  this.age = age;\n}\n\nconst MyPerson = Person.bind(window, "Tom");\n\nconst p = new MyPerson("28"); // { name:\'Tom\', age: \'28\' }\nconst yang = new MyPerson("Yang", "28"); // { name:\'Yang\', age: \'28\' }\n\n\n\n# 箭头函数\n\n箭头函数的this其实本质并不是改变了this的默认绑定，但是为了说明改变this指向的手段，就将其暂且的列在这一小节了。\n\nclass MyButton extends React.Component {\n  onClick = () => {\n    console.log(this.name);\n  };\n\n  render() {\n    return <button onClick={this.onClick}>Hello World</button>;\n  }\n}\n\n\nES6中引入的新语法，箭头函数的this永远指向当前的父作用域的this，如在React的组件中可以经常看到上述代码。\n\n接下来看一段转码前与转码后的代码。\n\n转码前：\n\nclass A {\n  name = "A";\n\n  say = () => {\n    console.log(this.name);\n  };\n}\n\nconst D = () => {\n  console.log(this);\n};\n\n\n转码后：\n\nvar _this2 = void 0;\n\nvar A = /*#__PURE__*/ _createClass(function A() {\n  var _this = this;\n\n  _classCallCheck(this, A);\n\n  _defineProperty(this, "name", "A");\n\n  _defineProperty(this, "say", function () {\n    console.log(_this.name);\n  });\n});\n\nvar D = function D() {\n  console.log(_this2);\n};\n\n\n\n# this绑定的优先级\n\n说完了this在实际开发中的场景之后，最后来聊一下this绑定的优先级的问题。\n\n对于隐式绑定（或默认绑定）来说优先级是最低的（谁调用，指向谁），其次是使用call，apply，bind进行的显示绑定，优先级次之，最后是通过new调用的new绑定，优先级最高。\n\n这儿并没有讨论箭头函数的this的优先级，因为箭头函数的this绑定在父级作用域下，是babel通过定义特定作用域下的变量，转化使得函数的最终的this能够符合预期，是语法糖，属于作用域链的范畴，跟this绑定无关。',normalizedContent:'# 函数上下文——this\n\n如果你是一个js的初学者，this这一定是一个能够让你欲哭无泪的语法。像c#，java这类语言，如果类的方法是非静态的，那么this指向的就是类的实例，如果是静态方法，那么就指向类本身，而js的this是可变的，在没有搞懂this之前，不妨忘记之前学过的知识，以利于学习。\n\n它有一个更加贴切的名字，函数上下文，这个名字恰到好处的表达了this的含义。\n\n当函数在不同的环境下执行，this的指向是不同的，简言之就是哪个对象调用的这个函数，this就指向那个对象。\n\n\n# this的默认绑定\n\n默认情况的this调用都是隐式绑定，即谁调用，指向谁。因此，这节所有内容都不考虑方法被强制指定this的情况\n\n\n# 方法中的this\n\nlet person = {\n  firstname: "bill",\n  lastname: "gates",\n  id: 123,\n  fullname: function(){\n    return this.firstname + " " + this.lastname;\n  }\n};\n\nperson.fullname() // bill gates\n\nlet fullname = person.fullname;\n\nfullname(); // "undefined undefined"\n\n\n如果在 es6 的class中的话，this的指向分两种情况：\n\nclass app {\n  static run() {\n    console.log(this);\n  }\n\n  log() {\n    console.log(this);\n  }\n}\n\n\n对于静态方法中的this，默认指向的是当前class（如run方法的this指向app），对于非静态方法的this，默认指向的是当前class的原型对象(如log方法的this指向app.prototype)\n\n\n# 单独的this\n\nconsole.log(this); // globalthis\n\n\n在单独使用时，拥有者是全局对象，this指的是全局对象，即globalthis，对于nodejs，globalthis指向的是global对象，而对于浏览器， globalthis指向的是window对象，这就是上小节内容为什么fullname()输出的内容是"undefined undefined"，而对于webworker中，this指向self对象。\n\n\n# 函数的this\n\nfunction person(){\n  return this;\n}\n\n\n非严格模式中，函数的拥有者默认绑定this，因此，在函数中，this指的是全局对象globalthis。\n\n严格模式不允许默认绑定，因此，在函数中使用时，在严格模式下，this是未定义的undefined。\n\n\n# 事件处理中的this\n\n<button onclick="this.style.display=\'none\'">点击来删除我！</button>\n\n\nthis指向的是当前触发事件的元素，如上面例子中，this指向的是button\n\n\n# 改变this的默认绑定方式\n\n由于this的可变性，导致我们的程序可能会变的脆弱，因此，需要在某些时候明确this的指向。\n\n\n# new\n\nfunction person(){\n  console.log(this instanceof person)\n  console.log(new.target);\n}\n\nconst people = new person(); // person person\n\n\n这是一个隐式改变this的调用，同时又是this绑定中优先级最高的调用。\n\n有了这个手段，我们可以用来判断函数是否是被用于new的形式调用，下面的代码就是babel转码class的结果的节选。\n\n在es6中为new引入了一个新的数据target，也可以用来判断是否是通过new调用的。\n\nfunction _classcallcheck(instance, constructor) {\n  if (!(instance instanceof constructor)) {\n    throw new typeerror("cannot call a class as a function");\n  }\n}\n\n\n接下来就是一个比较迷惑也不迷惑的面试题了，如下：\n\nconst obj = {\n  name: \'johnyang\',\n  age: 28,\n}\nfunction person(){\n  console.log(this instanceof person)\n  console.log(new.target);\n  console.log(this.name, this.age);\n}\n// 想强制指定this为obj\nconst myperson = person.bind(obj);\n\nconst p = new myperson();\n\n\n因为使用new调用时的this绑定优先级是最高的，所以其实myperson就是person，this上不存在name和age，因此最终输出的是undefined undefined\n\n\n# call，apply，bind\n\n这几个问题是面试题中考场最多的问题之一了，面试官：“请问call，apply，bind三者有什么区别，并说出如何实现”?\n\n本文不讨论它们的实现，只讨论用法。\n\ninterface function {\n  apply(this: function, thisarg: any, argarray?: any): any;\n  call(this: function, thisarg: any, ...argarray: any[]): any;\n  bind(this: function, thisarg: any, ...argarray: any[]): any;\n}\n\n\n首先，call和apply几乎是差不多的，它们的第一个参数都是this上下文，而call是接受n个参数，一字排开，而apply是接受一个由函数的n个参数组成的数组（类数组对象也可以的），然后这个函数就被立即执行了。\n\n如：\n\nlet firstname = "john";\nlet lastname = "yang";\nlet person = {\n  firstname: "bill",\n  lastname: "gates",\n  id: 123,\n  fullname: function (arg1, arg2) {\n    console.log(arg1, arg2);\n    return this.firstname + " " + this.lastname;\n  },\n};\nperson.fullname.apply(person, ["hello", "world"]); // "hello" "world" 返回 "bill gates"\nconst fullname2 = person.fullname.bind(window, "hello", "world"); // "hello" "world" 返回 "john yang"\n\n\n而bind和它们两者有个最大的不同，bind是返回一个被改变了this指向的函数。\n\nbind在使用的过程中还可以预制一些参数，那么得到的函数在执行的时候就可以省略掉预制的参数，如：\n\nfunction person(name, age) {\n  this.name = name;\n  this.age = age;\n}\n\nconst myperson = person.bind(window, "tom");\n\nconst p = new myperson("28"); // { name:\'tom\', age: \'28\' }\nconst yang = new myperson("yang", "28"); // { name:\'yang\', age: \'28\' }\n\n\n\n# 箭头函数\n\n箭头函数的this其实本质并不是改变了this的默认绑定，但是为了说明改变this指向的手段，就将其暂且的列在这一小节了。\n\nclass mybutton extends react.component {\n  onclick = () => {\n    console.log(this.name);\n  };\n\n  render() {\n    return <button onclick={this.onclick}>hello world</button>;\n  }\n}\n\n\nes6中引入的新语法，箭头函数的this永远指向当前的父作用域的this，如在react的组件中可以经常看到上述代码。\n\n接下来看一段转码前与转码后的代码。\n\n转码前：\n\nclass a {\n  name = "a";\n\n  say = () => {\n    console.log(this.name);\n  };\n}\n\nconst d = () => {\n  console.log(this);\n};\n\n\n转码后：\n\nvar _this2 = void 0;\n\nvar a = /*#__pure__*/ _createclass(function a() {\n  var _this = this;\n\n  _classcallcheck(this, a);\n\n  _defineproperty(this, "name", "a");\n\n  _defineproperty(this, "say", function () {\n    console.log(_this.name);\n  });\n});\n\nvar d = function d() {\n  console.log(_this2);\n};\n\n\n\n# this绑定的优先级\n\n说完了this在实际开发中的场景之后，最后来聊一下this绑定的优先级的问题。\n\n对于隐式绑定（或默认绑定）来说优先级是最低的（谁调用，指向谁），其次是使用call，apply，bind进行的显示绑定，优先级次之，最后是通过new调用的new绑定，优先级最高。\n\n这儿并没有讨论箭头函数的this的优先级，因为箭头函数的this绑定在父级作用域下，是babel通过定义特定作用域下的变量，转化使得函数的最终的this能够符合预期，是语法糖，属于作用域链的范畴，跟this绑定无关。',charsets:{cjk:!0}},{title:"实现JSON.stringify",frontmatter:{},regularPath:"/javascript/write/JSON.html",relativePath:"javascript/write/JSON.md",key:"v-4cfc62f5",path:"/javascript/write/JSON.html",headers:[{level:2,title:"实现JSON.stringify",slug:"实现json-stringify",normalizedTitle:"实现json.stringify",charIndex:2},{level:2,title:"实现JSON.parse",slug:"实现json-parse",normalizedTitle:"实现json.parse",charIndex:69}],headersStr:"实现JSON.stringify 实现JSON.parse",content:"# 实现JSON.stringify\n\n我觉得能挑战这 2 个问题的程序员绝对是壮士。\n\n首先，对于JSON.stringify\n\n\n# 实现JSON.parse",normalizedContent:"# 实现json.stringify\n\n我觉得能挑战这 2 个问题的程序员绝对是壮士。\n\n首先，对于json.stringify\n\n\n# 实现json.parse",charsets:{cjk:!0}},{title:"数字保留 N 位小数（不四舍五入）",frontmatter:{},regularPath:"/javascript/snippets/reserve.html",relativePath:"javascript/snippets/reserve.md",key:"v-aedfab56",path:"/javascript/snippets/reserve.html",headers:[{level:2,title:"数字保留 N 位小数（不四舍五入）",slug:"数字保留-n-位小数-不四舍五入",normalizedTitle:"数字保留 n 位小数（不四舍五入）",charIndex:2}],headersStr:"数字保留 N 位小数（不四舍五入）",content:"# 数字保留 N 位小数（不四舍五入）\n\n这是一个不常用的需求，正常有两个方法可以使用，如Number.prototype.toFixed(保留多少位小数)，另外一个是Number.prototype.toPrecision(保留多少位有效数字)，这两个方法都有一个共同的特点：四舍五入，但是有些时候产品需求是直接抹去小数位多少位之后的数字，不进行四舍五入。\n\n另外，有些时候可能还有这类场景，比如都需要对一组数据进行转换，但是有些数据是整数，经过Number.prototype.toFixed转化之后都变成小数了，而希望本地来整数的就维持整数。\n\n所以，简单的调用库函数就无法满足要求了，此刻就需要自行实现。\n\nfunction reserve(num, length) {}\n",normalizedContent:"# 数字保留 n 位小数（不四舍五入）\n\n这是一个不常用的需求，正常有两个方法可以使用，如number.prototype.tofixed(保留多少位小数)，另外一个是number.prototype.toprecision(保留多少位有效数字)，这两个方法都有一个共同的特点：四舍五入，但是有些时候产品需求是直接抹去小数位多少位之后的数字，不进行四舍五入。\n\n另外，有些时候可能还有这类场景，比如都需要对一组数据进行转换，但是有些数据是整数，经过number.prototype.tofixed转化之后都变成小数了，而希望本地来整数的就维持整数。\n\n所以，简单的调用库函数就无法满足要求了，此刻就需要自行实现。\n\nfunction reserve(num, length) {}\n",charsets:{cjk:!0}},{title:"异步任务调度器",frontmatter:{},regularPath:"/javascript/write/async-task-scheduler.html",relativePath:"javascript/write/async-task-scheduler.md",key:"v-f1681116",path:"/javascript/write/async-task-scheduler.html",headers:[{level:2,title:"异步任务调度器",slug:"异步任务调度器",normalizedTitle:"异步任务调度器",charIndex:2}],headersStr:"异步任务调度器",content:"# 异步任务调度器\n\n这是一道字节跳动的面试题，我觉得是一道非常有实际意义的题，实际开发中，常常用于加载资源，有了这个设计可以防止请求过多造成浏览器卡顿，对提高页面的性能有非常好的改善。\n\n有以下代码，并且期待如下输出，请实现TaskScheduler类\n\nfunction timeout(time) {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve();\n    }, time);\n  });\n}\n\nconst taskScheduler = new TaskScheduler();\n\nfunction addTask(time, name) {\n  taskScheduler()\n    .add(() => timeout(time))\n    .then(() => {\n      console.log(`任务${name}完成`);\n    });\n}\n\naddTask(10000, 1); // 10000ms后输出 任务1完成\naddTask(5000, 2); // 5000ms后输出 任务2完成\naddTask(3000, 3); // 8000ms后输出 任务3完成\naddTask(4000, 4); // 12000ms后输出 任务4完成\naddTask(5000, 5); // 15000ms后输出 任务5完成\n\n\n先分析一下这个输出流程，前两个异步任务，加进去，正常情况，如果不受限制的话，5S后输出任务2,10S后输出任务1，但是第三个任务加进去的时候，却是8S后输出，说明什么呢，说明这个任务调度器最多只能支持2个异步任务同时进行，第2个异步任务在5S后完成，此时任务3能进来了，过了3S（即8S时刻）, 任务3完成，如果基于我们上述猜测的话，第4个任务已经能进来了，再过2S，任务1已经能够完成了(即第10S)，此刻任务5能够进来了；再过2S（即第12S），任务4完成了，最后任务5在第15S的时候完成。\n\n有了这铺垫之后，我们就知道这个异步任务调度器的实现要点了。\n\n首先做这题需要有一个知识铺垫，如何让Promise停在那儿等待异步任务的完成，我在设计模式-观察者模式那一节有阐述过曾经我改写SDK的一个经历，里面用发布订阅模式实现了Promise的暂停。其关键就是在于你对Promise理解的深度，Promise跟返回内容无关，关键是你需要把它的两个触发器(resolve和reject)记录下来，在你希望的时刻调用。\n\nclass AsyncTaskScheduler {\n  /**\n   * 定义当前正在执行的异步任务\n   */\n  runningTask = 0;\n  /**\n   * 定义任务调度器允许的最大异步并发量\n   */\n  maxTask = 2;\n  /**\n   * 异步任务队列，用于记录暂时无法处理稍候需要处理的内容\n   */\n  asyncTaskQueue = [];\n  /**\n   * 定义方法，供外界任务内容加入到当前的调度器中执行\n   */\n  add(fn) {\n    return new Promise((resolve, reject) => {\n      // 如果当前没有超出最大的任务并发限制，当前任务可以直接执行\n      if (this.runningTask < this.maxTask) {\n        // 标记当前运行中的任务量增加1\n        this.runningTask++;\n        // 将外部函数传入的值包裹成Promise(因为有可能用户传递的不是Promise)\n        Promise.resolve(fn())\n          .then((response) => {\n            // 将来在异步任务完成的时候，让运行中的异步任务减少\n            this.runningTask--;\n            // 返回异步任务的内容\n            resolve(response);\n            // 此刻外部可能已经堆积了很多异步任务待处理了，因此，需要处理pending中的异步任务\n            this.run();\n          })\n          .catch((err) => {\n            // 对外界报告错误，并且继续执行pending中的异步任务\n            this.runningTask--;\n            reject(err);\n            this.run();\n          });\n      } else {\n        // 将任务加入到异步队列中，在将来执行，注意在这儿一定要把resolve和reject一并带上，将来外部作用域才能改变这个Promise的状态\n        this.asyncTaskQueue.push({\n          resolve,\n          reject,\n          fn,\n        });\n      }\n    });\n  }\n  /**\n   * 处理延时等待的异步任务\n   */\n  run() {\n    // while的退出条件大家可以想一下为什么是这样？因为不能超过最大允许的并发量，并且还必须要有那么多pending的任务等待做才行\n    while (this.asyncTaskQueue.length && this.runningTask < this.maxTask) {\n      const task = this.asyncTaskQueue.shift();\n      // 取出延迟执行的异步任务\n      const { fn, resolve, reject } = task;\n      // 标记当前进行中的异步任务量增加\n      this.runningTask++;\n      fn()\n        .then((response) => {\n          // 异步任务完成，运行中的异步任务递减\n          this.runningTask--;\n          resolve(response);\n          // 继续运行还在等待执行中的异步任务\n          this.run();\n        })\n        .catch((err) => {\n          // 异步任务完成，运行中的异步任务递减\n          this.runningTask--;\n          reject(err);\n          // 继续运行还在等待执行中的异步任务\n          this.run();\n        });\n    }\n    // 另外，为什么我没有用Promise.all或者Promise.allSettled，因为这两个API都取决于所有Promise状态的改变，实际上我们并不需要等所有的都执行完，\n    // 要珍惜宝贵的并发资源，完成一个，等待的任务就要去执行一个。\n    // 除此之外，为什么run方法的递归调用为什么写在了then和catch里面而不是写在while后面，因为是异步任务，写在外面，可能上一轮的任务并没有完成，\n    // 然后不断的去调用run，增加了无意义的尝试次数，写在then和catch里面一定能够确定的是再调run方法的时候有了并发的资源可用了。\n  }\n}\n",normalizedContent:"# 异步任务调度器\n\n这是一道字节跳动的面试题，我觉得是一道非常有实际意义的题，实际开发中，常常用于加载资源，有了这个设计可以防止请求过多造成浏览器卡顿，对提高页面的性能有非常好的改善。\n\n有以下代码，并且期待如下输出，请实现taskscheduler类\n\nfunction timeout(time) {\n  return new promise((resolve) => {\n    settimeout(() => {\n      resolve();\n    }, time);\n  });\n}\n\nconst taskscheduler = new taskscheduler();\n\nfunction addtask(time, name) {\n  taskscheduler()\n    .add(() => timeout(time))\n    .then(() => {\n      console.log(`任务${name}完成`);\n    });\n}\n\naddtask(10000, 1); // 10000ms后输出 任务1完成\naddtask(5000, 2); // 5000ms后输出 任务2完成\naddtask(3000, 3); // 8000ms后输出 任务3完成\naddtask(4000, 4); // 12000ms后输出 任务4完成\naddtask(5000, 5); // 15000ms后输出 任务5完成\n\n\n先分析一下这个输出流程，前两个异步任务，加进去，正常情况，如果不受限制的话，5s后输出任务2,10s后输出任务1，但是第三个任务加进去的时候，却是8s后输出，说明什么呢，说明这个任务调度器最多只能支持2个异步任务同时进行，第2个异步任务在5s后完成，此时任务3能进来了，过了3s（即8s时刻）, 任务3完成，如果基于我们上述猜测的话，第4个任务已经能进来了，再过2s，任务1已经能够完成了(即第10s)，此刻任务5能够进来了；再过2s（即第12s），任务4完成了，最后任务5在第15s的时候完成。\n\n有了这铺垫之后，我们就知道这个异步任务调度器的实现要点了。\n\n首先做这题需要有一个知识铺垫，如何让promise停在那儿等待异步任务的完成，我在设计模式-观察者模式那一节有阐述过曾经我改写sdk的一个经历，里面用发布订阅模式实现了promise的暂停。其关键就是在于你对promise理解的深度，promise跟返回内容无关，关键是你需要把它的两个触发器(resolve和reject)记录下来，在你希望的时刻调用。\n\nclass asynctaskscheduler {\n  /**\n   * 定义当前正在执行的异步任务\n   */\n  runningtask = 0;\n  /**\n   * 定义任务调度器允许的最大异步并发量\n   */\n  maxtask = 2;\n  /**\n   * 异步任务队列，用于记录暂时无法处理稍候需要处理的内容\n   */\n  asynctaskqueue = [];\n  /**\n   * 定义方法，供外界任务内容加入到当前的调度器中执行\n   */\n  add(fn) {\n    return new promise((resolve, reject) => {\n      // 如果当前没有超出最大的任务并发限制，当前任务可以直接执行\n      if (this.runningtask < this.maxtask) {\n        // 标记当前运行中的任务量增加1\n        this.runningtask++;\n        // 将外部函数传入的值包裹成promise(因为有可能用户传递的不是promise)\n        promise.resolve(fn())\n          .then((response) => {\n            // 将来在异步任务完成的时候，让运行中的异步任务减少\n            this.runningtask--;\n            // 返回异步任务的内容\n            resolve(response);\n            // 此刻外部可能已经堆积了很多异步任务待处理了，因此，需要处理pending中的异步任务\n            this.run();\n          })\n          .catch((err) => {\n            // 对外界报告错误，并且继续执行pending中的异步任务\n            this.runningtask--;\n            reject(err);\n            this.run();\n          });\n      } else {\n        // 将任务加入到异步队列中，在将来执行，注意在这儿一定要把resolve和reject一并带上，将来外部作用域才能改变这个promise的状态\n        this.asynctaskqueue.push({\n          resolve,\n          reject,\n          fn,\n        });\n      }\n    });\n  }\n  /**\n   * 处理延时等待的异步任务\n   */\n  run() {\n    // while的退出条件大家可以想一下为什么是这样？因为不能超过最大允许的并发量，并且还必须要有那么多pending的任务等待做才行\n    while (this.asynctaskqueue.length && this.runningtask < this.maxtask) {\n      const task = this.asynctaskqueue.shift();\n      // 取出延迟执行的异步任务\n      const { fn, resolve, reject } = task;\n      // 标记当前进行中的异步任务量增加\n      this.runningtask++;\n      fn()\n        .then((response) => {\n          // 异步任务完成，运行中的异步任务递减\n          this.runningtask--;\n          resolve(response);\n          // 继续运行还在等待执行中的异步任务\n          this.run();\n        })\n        .catch((err) => {\n          // 异步任务完成，运行中的异步任务递减\n          this.runningtask--;\n          reject(err);\n          // 继续运行还在等待执行中的异步任务\n          this.run();\n        });\n    }\n    // 另外，为什么我没有用promise.all或者promise.allsettled，因为这两个api都取决于所有promise状态的改变，实际上我们并不需要等所有的都执行完，\n    // 要珍惜宝贵的并发资源，完成一个，等待的任务就要去执行一个。\n    // 除此之外，为什么run方法的递归调用为什么写在了then和catch里面而不是写在while后面，因为是异步任务，写在外面，可能上一轮的任务并没有完成，\n    // 然后不断的去调用run，增加了无意义的尝试次数，写在then和catch里面一定能够确定的是再调run方法的时候有了并发的资源可用了。\n  }\n}\n",charsets:{cjk:!0}},{title:"chunk",frontmatter:{},regularPath:"/javascript/write/chunk.html",relativePath:"javascript/write/chunk.md",key:"v-7625b92b",path:"/javascript/write/chunk.html",headers:[{level:2,title:"chunk",slug:"chunk",normalizedTitle:"chunk",charIndex:2}],headersStr:"chunk",content:"# chunk\n\nchunk函数是lodash提供的一个函数之一，用处是将数组以指定长度分割为子数组，",normalizedContent:"# chunk\n\nchunk函数是lodash提供的一个函数之一，用处是将数组以指定长度分割为子数组，",charsets:{cjk:!0}},{title:"数字的千分位分隔",frontmatter:{},regularPath:"/javascript/snippets/thousand.html",relativePath:"javascript/snippets/thousand.md",key:"v-25066837",path:"/javascript/snippets/thousand.html",headers:[{level:2,title:"数字的千分位分隔",slug:"数字的千分位分隔",normalizedTitle:"数字的千分位分隔",charIndex:2}],headersStr:"数字的千分位分隔",content:'# 数字的千分位分隔\n\n这个需求主要在金融软件上会比较常用\n\n之前看到过很多版本，比如有正则替换的，但是我觉得用正常的思维来实现代码的可读性会比较好。\n\n思路如下：如果一个数是整数的话，不需要考虑小数，如果是小数的话考虑一下保留多少位有效数字，剩下的就是将整数部分从右往左处理，三个为一组，最终拼起来得到最后的结果\n\nfunction toThousand(num, precision = 2) {\n  if (typeof num !== "number") {\n    throw new TypeError("num must be a number");\n  }\n  if (Number.isNaN(num)) {\n    return num;\n  }\n  // 整数才处理，小数不处理\n  const numStr = String(\n    Math.floor(num) === num ? num : num.toPrecision(precision)\n  );\n  const part = numStr.split(".");\n  let result = "";\n  let offset = part[0].length - 3;\n  // 从右往左3个为一组提取数字\n  while (offset > -3) {\n    const substr = part[0].substring(offset < 0 ? 0 : offset, offset + 3);\n    // 如果当前结果是\'\'，直接处理结果，否则会多加一个,\n    result = result ? substr + "," + result : substr;\n    offset = offset - 3;\n  }\n  // 小数部分直接加到后面就好了\n  if (part.length === 2) {\n    result += "." + part[1];\n  }\n  return result;\n}\n',normalizedContent:'# 数字的千分位分隔\n\n这个需求主要在金融软件上会比较常用\n\n之前看到过很多版本，比如有正则替换的，但是我觉得用正常的思维来实现代码的可读性会比较好。\n\n思路如下：如果一个数是整数的话，不需要考虑小数，如果是小数的话考虑一下保留多少位有效数字，剩下的就是将整数部分从右往左处理，三个为一组，最终拼起来得到最后的结果\n\nfunction tothousand(num, precision = 2) {\n  if (typeof num !== "number") {\n    throw new typeerror("num must be a number");\n  }\n  if (number.isnan(num)) {\n    return num;\n  }\n  // 整数才处理，小数不处理\n  const numstr = string(\n    math.floor(num) === num ? num : num.toprecision(precision)\n  );\n  const part = numstr.split(".");\n  let result = "";\n  let offset = part[0].length - 3;\n  // 从右往左3个为一组提取数字\n  while (offset > -3) {\n    const substr = part[0].substring(offset < 0 ? 0 : offset, offset + 3);\n    // 如果当前结果是\'\'，直接处理结果，否则会多加一个,\n    result = result ? substr + "," + result : substr;\n    offset = offset - 3;\n  }\n  // 小数部分直接加到后面就好了\n  if (part.length === 2) {\n    result += "." + part[1];\n  }\n  return result;\n}\n',charsets:{cjk:!0}},{title:"Array方法的一些实现",frontmatter:{},regularPath:"/javascript/write/array.html",relativePath:"javascript/write/array.md",key:"v-07d1a15a",path:"/javascript/write/array.html",headers:[{level:2,title:"Array方法的一些实现",slug:"array方法的一些实现",normalizedTitle:"array方法的一些实现",charIndex:2},{level:3,title:"Array.prototype.filter",slug:"array-prototype-filter",normalizedTitle:"array.prototype.filter",charIndex:51},{level:3,title:"Array.prototype.map",slug:"array-prototype-map",normalizedTitle:"array.prototype.map",charIndex:2809},{level:3,title:"Array.prototype.forEach",slug:"array-prototype-foreach",normalizedTitle:"array.prototype.foreach",charIndex:3665},{level:3,title:"Array.prototype.every",slug:"array-prototype-every",normalizedTitle:"array.prototype.every",charIndex:4149},{level:3,title:"Array.prototype.some",slug:"array-prototype-some",normalizedTitle:"array.prototype.some",charIndex:4715},{level:3,title:"Array.prototype.reduce",slug:"array-prototype-reduce",normalizedTitle:"array.prototype.reduce",charIndex:5278},{level:3,title:"Array.prototype.includes",slug:"array-prototype-includes",normalizedTitle:"array.prototype.includes",charIndex:6356}],headersStr:"Array方法的一些实现 Array.prototype.filter Array.prototype.map Array.prototype.forEach Array.prototype.every Array.prototype.some Array.prototype.reduce Array.prototype.includes",content:'# Array方法的一些实现\n\n首先，最直接的办法还是通过VSCode查看一个数据方法的定义，我们就拿Array.prototype.filter来举例，以下是它的TS的定义：\n\ninterface Array<T> {\n  /**\n   * Returns the elements of an array that meet the condition specified in a callback function.\n   * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.\n   * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.\n   */\n  filter<S extends T>(\n    predicate: (value: T, index: number, array: T[]) => value is S,\n    thisArg?: any\n  ): S[];\n}\n\n\n先解释一下这个类型体操的含义，读取外部的predicate函数，执行之后得到一个结果，这个结果是数组的子元素，最终由这些子元素组成一个新的数组，其中，thisArg作为一个可选参数，可以决定predicate的函数上下文，若不传，则为undefined。\n\n数组其实是一个特殊的对象。\n\n数组的这些标准遍历方法都有一个共同的特征，遍历时，它会跳过为空的元素，这个空并不是说这个元素的值是undefined（用英语单词表达叫做hole，翻译过来就是洞），而是跳过并没有这个键的位置. 比如：\n\nconst a = [1, 2, 3, 4, 5];\na[6] = 7;\n// [1, 2, 3, 4, 5, empty, 7]，其中，这个empty就是表示的当前索引上存在hole的意思\n\n\n又如：\n\nconst b = [undefined];\n// 数组b是真的有一个key为0，只不过这个值是undefined而已\n\n\n\n# Array.prototype.filter\n\nfilter方法的定义是，每次遍历的时候，将当前元素以及它所在的索引值传递给回调函数，如果回调函数返回为true，数组当前这个索引上的元素将会被添加到结果集中。\n\nfunction nullOrUndefinedCheck() {\n  if (this == null || this === undefined) {\n    throw new TypeError("filter can not called by null or undefined");\n  }\n}\n\nfunction callbackCheck(callback) {\n  if (typeof callback !== "function") {\n    throw new TypeError("predicate must be a function");\n  }\n}\n\nArray.prototype.filter = function (callback, thisArg) {\n  // 异常断言\n  nullOrUndefinedCheck() && callbackCheck(callback);\n  // 强制将数组转化成对象\n  const O = Object(this);\n  // 将数组的length向右移动0位，这个操作的含义是，如果对象的length负数，二进制表示法它将会是其绝对值的补码表示，无符号向右移动，\n  // 相当于将其强制看成一个无符号数，于是，将会得到一个很大的值，并且一定是正数。但是对于非负数，却是没有任何影响的\n  const length = O.length >>> 0;\n  // 定义一个结果集\n  const res = [];\n  for (let i = 0; i < length; i++) {\n    // 此处必须要用in操作符，因为有可能当前值存在，但是结果肯呢个是falsy，判断就不准确了\n    // 并且in操作符会沿着原型依次判断\n    // 为callback绑定用户传入的this上下文，然后分别填充它需要的3个参数\n    if (i in O && callback.call(thisArg, O[i], i, O)) {\n      res.push(O[i]);\n    }\n  }\n  // 返回一个新的结果集\n  return res;\n};\n\n\n比如对数组去重，正常我们需要使用两重for循环（不太聪明的办法），而使用filter来做这件事，代码的简洁度就比较高（本质上和两重for循环是一个意思），\n\n/**\n * 数组去重\n */\nfunction removeDuplicate1(arr) {\n  const results = [];\n  for (let i = 0; i < arr.length; i++) {\n    const cur = arr[i];\n    let flag = true;\n    // 在结果集中查找元素，如果找到了，提前终止循环\n    for (let k = 0; k < results.length; k++) {\n      const compare = results[k];\n      if (compare === cur) {\n        flag = false;\n        break;\n      }\n    }\n    // 没找到，把当前索引的元素添加到结果集中\n    if (flag) {\n      results.push(cur);\n    }\n  }\n  return results;\n}\n\n/**\n * 数组去重\n */\nfunction removeDuplicate(arr) {\n  return arr.filter((val, idx) => {\n    // 判断当前元素是否是第一次出现在数组中的位置和它所在的索引位置是否一样\n    return arr.indexOf(val) === idx;\n  });\n}\n\n\n\n# Array.prototype.map\n\n在明白了filter方法的实现之后，map方法就相当好写了，但是事情并不是我们想的那么简单。\n\n先看一下这个场景的结果：\n\nconst a = [];\na[3] = 2;\na[100] = 4;\nconst result = a.map((v) => {\n  console.log(v);\n  return String(v);\n});\n// [empty × 3, \'2\', empty × 96, \'4\']\n\n\n所以万事一定不能想当然啊~\n\nArray.prototype.map = function (call, thisArg) {\n  // 异常断言\n  nullOrUndefinedCheck() && callbackCheck(callback);\n  // 强制将数组转化成对象\n  const O = Object(this);\n  // 将数组的length向右移动0位，这个操作的含义是，如果对象的length负数，二进制表示法它将会是其绝对值的补码表示，无符号向右移动，\n  // 相当于将其强制看成一个无符号数，于是，将会得到一个很大的值，并且一定是正数。但是对于非负数，却是没有任何影响的\n  const length = O.length >>> 0;\n  const res = [];\n  // 必须让新数组上的长度和原数组保持一致，也就是说，原来本来有洞的位置还是得留着，不能抹掉\n  res.length = length;\n  for (let i = 0; i < length; i++) {\n    // 如果当前位置存在元素\n    if (i in O) {\n      // 将回调函数转化之后的结果返回给新数组\n      res[i] = callback.call(thisArg, O[i], i, O);\n    }\n  }\n  // 返回处理之后的结果\n  return res;\n};\n\n\n\n# Array.prototype.forEach\n\nArray.prototype.forEach = function (callback, thisArg) {\n  // 异常断言\n  nullOrUndefinedCheck() && callbackCheck(callback);\n  // 强制将数组转化成对象\n  const O = Object(this);\n  // 将数组的length向右移动0位，这个操作的含义是，如果对象的length负数，二进制表示法它将会是其绝对值的补码表示，无符号向右移动，\n  // 相当于将其强制看成一个无符号数，于是，将会得到一个很大的值，并且一定是正数。但是对于非负数，却是没有任何影响的\n  const length = O.length >>> 0;\n  for (let i = 0; i < length; i++) {\n    // 跨过hole\n    if (i in O) {\n      callback.call(thisArg, O[i], i, O);\n    }\n  }\n};\n\n\n\n# Array.prototype.every\n\nArray.prototype.every = function (callback, thisArg) {\n  // 异常断言\n  nullOrUndefinedCheck() && callbackCheck(callback);\n  // 强制将数组转化成对象\n  const O = Object(this);\n  // 将数组的length向右移动0位，这个操作的含义是，如果对象的length负数，二进制表示法它将会是其绝对值的补码表示，无符号向右移动，\n  // 相当于将其强制看成一个无符号数，于是，将会得到一个很大的值，并且一定是正数。但是对于非负数，却是没有任何影响的\n  const length = O.length >>> 0;\n  for (let i = 0; i < length; i++) {\n    // 跨过hole\n    if (i in O) {\n      // 有一个是false，就可以直接对外返回false\n      if (!callback.call(thisArg, O[i], i, O)) {\n        return false;\n      }\n    }\n  }\n  return true;\n};\n\n\n\n# Array.prototype.some\n\nArray.prototype.some = function (callback, thisArg) {\n  // 异常断言\n  nullOrUndefinedCheck() && callbackCheck(callback);\n  // 强制将数组转化成对象\n  const O = Object(this);\n  // 将数组的length向右移动0位，这个操作的含义是，如果对象的length负数，二进制表示法它将会是其绝对值的补码表示，无符号向右移动，\n  // 相当于将其强制看成一个无符号数，于是，将会得到一个很大的值，并且一定是正数。但是对于非负数，却是没有任何影响的\n  const length = O.length >>> 0;\n  for (let i = 0; i < length; i++) {\n    // 跨过hole\n    if (i in O) {\n      // 有一个是false，就可以直接对外返回false\n      if (callback.call(thisArg, O[i], i, O)) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n\n\n# Array.prototype.reduce\n\nreduce的定义稍微和前面几个函数不一样。它没有第二个thisArg用来绑定callback上下文的参数，而是多了一个可选参数，以它作为迭代的初始值。\n\nArray.prototype.reduce = function (callback, initialValue) {\n  // 异常断言\n  nullOrUndefinedCheck() && callbackCheck(callback);\n  // 强制将数组转化成对象\n  const O = Object(this);\n  // 将数组的length向右移动0位，这个操作的含义是，如果对象的length负数，二进制表示法它将会是其绝对值的补码表示，无符号向右移动，\n  // 相当于将其强制看成一个无符号数，于是，将会得到一个很大的值，并且一定是正数。但是对于非负数，却是没有任何影响的\n  const length = O.length >>> 0;\n  // 定义迭代的值，暂时先不着急赋值\n  let accumulator;\n  let offset = 0;\n  // 如果没有传递初始值，找第一个可用的值作为初始值\n  if (typeof initialValue === "undefined") {\n    // 跳过开头的那些hole\n    while (!(offset in O) && offset < length) {\n      offset++;\n    }\n    // 退出循环的时候有两种情况，第一种：找到了第一个可用元素，第二种，已经把数组遍历完了还没有找到\n    if (offset === length) {\n      throw new TypeError("Reduce of empty array with no initial value");\n    }\n    accumulator = O[offset];\n  }\n  for (let i = offset + 1; i < length; i++) {\n    // 跳过hole元素\n    if (i in O) {\n      // 将之前的迭代值传入callback，并且将得到的结果赋值给accumulator\n      accumulator = callback(accumulator, O[i], i, O);\n    }\n  }\n  return accumulator;\n};\n\n\n\n# Array.prototype.includes\n\nArray.prototype.includes = function (target, fromIndex) {\n  // 异常断言\n  nullOrUndefinedCheck();\n  // 强制将数组转化成对象\n  const O = Object(this);\n  // 将数组的length向右移动0位，这个操作的含义是，如果对象的length负数，二进制表示法它将会是其绝对值的补码表示，无符号向右移动，\n  // 相当于将其强制看成一个无符号数，于是，将会得到一个很大的值，并且一定是正数。但是对于非负数，却是没有任何影响的\n  const length = O.length >>> 0;\n  let offset = typeof fromIndex === "number" ? fromIndex : 0;\n  for (let i = offset; i < length; i++) {\n    if (\n      i in O &&\n      (O[i] === target || (Number.isNaN(O[i]) && Number.isNaN(target)))\n    ) {\n      return true;\n    }\n  }\n  return false;\n};\n',normalizedContent:'# array方法的一些实现\n\n首先，最直接的办法还是通过vscode查看一个数据方法的定义，我们就拿array.prototype.filter来举例，以下是它的ts的定义：\n\ninterface array<t> {\n  /**\n   * returns the elements of an array that meet the condition specified in a callback function.\n   * @param predicate a function that accepts up to three arguments. the filter method calls the predicate function one time for each element in the array.\n   * @param thisarg an object to which the this keyword can refer in the predicate function. if thisarg is omitted, undefined is used as the this value.\n   */\n  filter<s extends t>(\n    predicate: (value: t, index: number, array: t[]) => value is s,\n    thisarg?: any\n  ): s[];\n}\n\n\n先解释一下这个类型体操的含义，读取外部的predicate函数，执行之后得到一个结果，这个结果是数组的子元素，最终由这些子元素组成一个新的数组，其中，thisarg作为一个可选参数，可以决定predicate的函数上下文，若不传，则为undefined。\n\n数组其实是一个特殊的对象。\n\n数组的这些标准遍历方法都有一个共同的特征，遍历时，它会跳过为空的元素，这个空并不是说这个元素的值是undefined（用英语单词表达叫做hole，翻译过来就是洞），而是跳过并没有这个键的位置. 比如：\n\nconst a = [1, 2, 3, 4, 5];\na[6] = 7;\n// [1, 2, 3, 4, 5, empty, 7]，其中，这个empty就是表示的当前索引上存在hole的意思\n\n\n又如：\n\nconst b = [undefined];\n// 数组b是真的有一个key为0，只不过这个值是undefined而已\n\n\n\n# array.prototype.filter\n\nfilter方法的定义是，每次遍历的时候，将当前元素以及它所在的索引值传递给回调函数，如果回调函数返回为true，数组当前这个索引上的元素将会被添加到结果集中。\n\nfunction nullorundefinedcheck() {\n  if (this == null || this === undefined) {\n    throw new typeerror("filter can not called by null or undefined");\n  }\n}\n\nfunction callbackcheck(callback) {\n  if (typeof callback !== "function") {\n    throw new typeerror("predicate must be a function");\n  }\n}\n\narray.prototype.filter = function (callback, thisarg) {\n  // 异常断言\n  nullorundefinedcheck() && callbackcheck(callback);\n  // 强制将数组转化成对象\n  const o = object(this);\n  // 将数组的length向右移动0位，这个操作的含义是，如果对象的length负数，二进制表示法它将会是其绝对值的补码表示，无符号向右移动，\n  // 相当于将其强制看成一个无符号数，于是，将会得到一个很大的值，并且一定是正数。但是对于非负数，却是没有任何影响的\n  const length = o.length >>> 0;\n  // 定义一个结果集\n  const res = [];\n  for (let i = 0; i < length; i++) {\n    // 此处必须要用in操作符，因为有可能当前值存在，但是结果肯呢个是falsy，判断就不准确了\n    // 并且in操作符会沿着原型依次判断\n    // 为callback绑定用户传入的this上下文，然后分别填充它需要的3个参数\n    if (i in o && callback.call(thisarg, o[i], i, o)) {\n      res.push(o[i]);\n    }\n  }\n  // 返回一个新的结果集\n  return res;\n};\n\n\n比如对数组去重，正常我们需要使用两重for循环（不太聪明的办法），而使用filter来做这件事，代码的简洁度就比较高（本质上和两重for循环是一个意思），\n\n/**\n * 数组去重\n */\nfunction removeduplicate1(arr) {\n  const results = [];\n  for (let i = 0; i < arr.length; i++) {\n    const cur = arr[i];\n    let flag = true;\n    // 在结果集中查找元素，如果找到了，提前终止循环\n    for (let k = 0; k < results.length; k++) {\n      const compare = results[k];\n      if (compare === cur) {\n        flag = false;\n        break;\n      }\n    }\n    // 没找到，把当前索引的元素添加到结果集中\n    if (flag) {\n      results.push(cur);\n    }\n  }\n  return results;\n}\n\n/**\n * 数组去重\n */\nfunction removeduplicate(arr) {\n  return arr.filter((val, idx) => {\n    // 判断当前元素是否是第一次出现在数组中的位置和它所在的索引位置是否一样\n    return arr.indexof(val) === idx;\n  });\n}\n\n\n\n# array.prototype.map\n\n在明白了filter方法的实现之后，map方法就相当好写了，但是事情并不是我们想的那么简单。\n\n先看一下这个场景的结果：\n\nconst a = [];\na[3] = 2;\na[100] = 4;\nconst result = a.map((v) => {\n  console.log(v);\n  return string(v);\n});\n// [empty × 3, \'2\', empty × 96, \'4\']\n\n\n所以万事一定不能想当然啊~\n\narray.prototype.map = function (call, thisarg) {\n  // 异常断言\n  nullorundefinedcheck() && callbackcheck(callback);\n  // 强制将数组转化成对象\n  const o = object(this);\n  // 将数组的length向右移动0位，这个操作的含义是，如果对象的length负数，二进制表示法它将会是其绝对值的补码表示，无符号向右移动，\n  // 相当于将其强制看成一个无符号数，于是，将会得到一个很大的值，并且一定是正数。但是对于非负数，却是没有任何影响的\n  const length = o.length >>> 0;\n  const res = [];\n  // 必须让新数组上的长度和原数组保持一致，也就是说，原来本来有洞的位置还是得留着，不能抹掉\n  res.length = length;\n  for (let i = 0; i < length; i++) {\n    // 如果当前位置存在元素\n    if (i in o) {\n      // 将回调函数转化之后的结果返回给新数组\n      res[i] = callback.call(thisarg, o[i], i, o);\n    }\n  }\n  // 返回处理之后的结果\n  return res;\n};\n\n\n\n# array.prototype.foreach\n\narray.prototype.foreach = function (callback, thisarg) {\n  // 异常断言\n  nullorundefinedcheck() && callbackcheck(callback);\n  // 强制将数组转化成对象\n  const o = object(this);\n  // 将数组的length向右移动0位，这个操作的含义是，如果对象的length负数，二进制表示法它将会是其绝对值的补码表示，无符号向右移动，\n  // 相当于将其强制看成一个无符号数，于是，将会得到一个很大的值，并且一定是正数。但是对于非负数，却是没有任何影响的\n  const length = o.length >>> 0;\n  for (let i = 0; i < length; i++) {\n    // 跨过hole\n    if (i in o) {\n      callback.call(thisarg, o[i], i, o);\n    }\n  }\n};\n\n\n\n# array.prototype.every\n\narray.prototype.every = function (callback, thisarg) {\n  // 异常断言\n  nullorundefinedcheck() && callbackcheck(callback);\n  // 强制将数组转化成对象\n  const o = object(this);\n  // 将数组的length向右移动0位，这个操作的含义是，如果对象的length负数，二进制表示法它将会是其绝对值的补码表示，无符号向右移动，\n  // 相当于将其强制看成一个无符号数，于是，将会得到一个很大的值，并且一定是正数。但是对于非负数，却是没有任何影响的\n  const length = o.length >>> 0;\n  for (let i = 0; i < length; i++) {\n    // 跨过hole\n    if (i in o) {\n      // 有一个是false，就可以直接对外返回false\n      if (!callback.call(thisarg, o[i], i, o)) {\n        return false;\n      }\n    }\n  }\n  return true;\n};\n\n\n\n# array.prototype.some\n\narray.prototype.some = function (callback, thisarg) {\n  // 异常断言\n  nullorundefinedcheck() && callbackcheck(callback);\n  // 强制将数组转化成对象\n  const o = object(this);\n  // 将数组的length向右移动0位，这个操作的含义是，如果对象的length负数，二进制表示法它将会是其绝对值的补码表示，无符号向右移动，\n  // 相当于将其强制看成一个无符号数，于是，将会得到一个很大的值，并且一定是正数。但是对于非负数，却是没有任何影响的\n  const length = o.length >>> 0;\n  for (let i = 0; i < length; i++) {\n    // 跨过hole\n    if (i in o) {\n      // 有一个是false，就可以直接对外返回false\n      if (callback.call(thisarg, o[i], i, o)) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n\n\n# array.prototype.reduce\n\nreduce的定义稍微和前面几个函数不一样。它没有第二个thisarg用来绑定callback上下文的参数，而是多了一个可选参数，以它作为迭代的初始值。\n\narray.prototype.reduce = function (callback, initialvalue) {\n  // 异常断言\n  nullorundefinedcheck() && callbackcheck(callback);\n  // 强制将数组转化成对象\n  const o = object(this);\n  // 将数组的length向右移动0位，这个操作的含义是，如果对象的length负数，二进制表示法它将会是其绝对值的补码表示，无符号向右移动，\n  // 相当于将其强制看成一个无符号数，于是，将会得到一个很大的值，并且一定是正数。但是对于非负数，却是没有任何影响的\n  const length = o.length >>> 0;\n  // 定义迭代的值，暂时先不着急赋值\n  let accumulator;\n  let offset = 0;\n  // 如果没有传递初始值，找第一个可用的值作为初始值\n  if (typeof initialvalue === "undefined") {\n    // 跳过开头的那些hole\n    while (!(offset in o) && offset < length) {\n      offset++;\n    }\n    // 退出循环的时候有两种情况，第一种：找到了第一个可用元素，第二种，已经把数组遍历完了还没有找到\n    if (offset === length) {\n      throw new typeerror("reduce of empty array with no initial value");\n    }\n    accumulator = o[offset];\n  }\n  for (let i = offset + 1; i < length; i++) {\n    // 跳过hole元素\n    if (i in o) {\n      // 将之前的迭代值传入callback，并且将得到的结果赋值给accumulator\n      accumulator = callback(accumulator, o[i], i, o);\n    }\n  }\n  return accumulator;\n};\n\n\n\n# array.prototype.includes\n\narray.prototype.includes = function (target, fromindex) {\n  // 异常断言\n  nullorundefinedcheck();\n  // 强制将数组转化成对象\n  const o = object(this);\n  // 将数组的length向右移动0位，这个操作的含义是，如果对象的length负数，二进制表示法它将会是其绝对值的补码表示，无符号向右移动，\n  // 相当于将其强制看成一个无符号数，于是，将会得到一个很大的值，并且一定是正数。但是对于非负数，却是没有任何影响的\n  const length = o.length >>> 0;\n  let offset = typeof fromindex === "number" ? fromindex : 0;\n  for (let i = offset; i < length; i++) {\n    if (\n      i in o &&\n      (o[i] === target || (number.isnan(o[i]) && number.isnan(target)))\n    ) {\n      return true;\n    }\n  }\n  return false;\n};\n',charsets:{cjk:!0}},{title:"手写 call、apply、bind",frontmatter:{},regularPath:"/javascript/write/call&bind&apply.html",relativePath:"javascript/write/call&bind&apply.md",key:"v-4577a42b",path:"/javascript/write/call&bind&apply.html",headers:[{level:2,title:"手写 call、apply、bind",slug:"手写-call、apply、bind",normalizedTitle:"手写 call、apply、bind",charIndex:2},{level:3,title:"1、模拟实现 call",slug:"_1、模拟实现-call",normalizedTitle:"1、模拟实现 call",charIndex:1388},{level:3,title:"2、模拟实现 apply",slug:"_2、模拟实现-apply",normalizedTitle:"2、模拟实现 apply",charIndex:2206},{level:3,title:"3、模拟实现 bind",slug:"_3、模拟实现-bind",normalizedTitle:"3、模拟实现 bind",charIndex:2839}],headersStr:"手写 call、apply、bind 1、模拟实现 call 2、模拟实现 apply 3、模拟实现 bind",content:'# 手写 call、apply、bind\n\n这三个方法都是定义在函数上的方法，其目的都是改变函数的执行上下文this的指向。\n\n它的TS定义如下：\n\n/**\n * Creates a new function.\n */\ninterface Function {\n  /**\n   * Calls the function, substituting the specified object for the this value of the function, and the specified array for the arguments of the function.\n   * @param thisArg The object to be used as the this object.\n   * @param argArray A set of arguments to be passed to the function.\n   */\n  apply(this: Function, thisArg: any, argArray?: any): any;\n  /**\n   * Calls a method of an object, substituting another object for the current object.\n   * @param thisArg The object to be used as the current object.\n   * @param argArray A list of arguments to be passed to the method.\n   */\n  call(this: Function, thisArg: any, ...argArray: any[]): any;\n  /**\n   * For a given function, creates a bound function that has the same body as the original function.\n   * The this object of the bound function is associated with the specified object, and has the specified initial parameters.\n   * @param thisArg An object to which the this keyword can refer inside the new function.\n   * @param argArray A list of arguments to be passed to the new function.\n   */\n  bind(this: Function, thisArg: any, ...argArray: any[]): any;\n}\n\n\n第一个参数是函数本身，第二个参数是为函数执行时绑定this的指向，第三个参数是可选参数，代表的是原函数的实参列表，因为这是在函数的原型上的定义，当我们在使用时，其实第一个this参数就是函数本身，因此，这就是为什么我们在使用的时候并没有第一个参数的原因。\n\n\n# 1、模拟实现 call\n\n首先，先说一下call的功能，将函数的this上下文绑定在某个对象执行，原函数的参数以剩余参数逐个传递的形式传递。如果对于call的实现原理不太明白的同学可以先参考一下我阐述this的文章。\n\n根据this的默认绑定规则，函数的调用者是谁，this就执行谁，那我们自然而然就会想到，把当前函数赋值给指定的上下文对象的某个key上，然后执行。有了实现思路之后，就可以很容易的编写出如下代码：\n\ntypeof Function.prototype.call !== "function" &&\n  (Function.prototype.call = function (ctx, ...args) {\n    // 如果直接调用函数原型上的方法，就返回undefined;\n    if (this === Function.prototype) {\n      return;\n    }\n    // 默认绑定为window\n    ctx = ctx || window;\n    // 为了防止key在上下文对象上造成冲突，使用Symbol作为key\n    const prop = Symbol("call");\n    // 把当前函数赋值给这个临时key\n    ctx[prop] = this;\n    // 执行函数，并且把函数执行结果记录下来\n    const result = ctx[prop](...args);\n    // 为了防止对执行上下文对象造成污染，还需要删除这个临时key\n    delete ctx[prop];\n    // 返回函数的执行结果\n    return result;\n  });\n\n\n上述代码，因为call接受的是剩余参数的形式，因此，我们需要用扩展运算符将第二个以后的参数收集成一个数组，但是在函数执行的时候，又必须将这个数组打散。\n\n\n# 2、模拟实现 apply\n\n在理解了call之后，编写apply就容易得多了，为了避嫌，我们不会借用call的实现，但是之所以这样说，是因为apply的原理和call几乎完全一样.\n\n模拟实现如下：\n\ntypeof Function.prototype.apply !== "function" &&\n  (Function.prototype.apply = function (ctx, args) {\n    // 如果直接调用函数原型上的方法，就返回undefined;\n    if (this === Function.prototype) {\n      return;\n    }\n    // 默认绑定为window\n    ctx = ctx || window;\n    // 为了防止key在上下文对象上造成冲突，使用Symbol作为key\n    const prop = Symbol("apply");\n    // 把当前函数赋值给这个临时key\n    ctx[prop] = this;\n    // 执行函数，并且把函数执行结果记录下来\n    const result = ctx[prop](...args);\n    // 为了防止对执行上下文对象造成污染，还需要删除这个临时key\n    delete ctx[prop];\n    // 返回函数的执行结果\n    return result;\n  });\n\n\n\n# 3、模拟实现 bind\n\nbind方法和上述两个方法有一点区别较大，bind是得到一个绑定了this上下文的函数，而上述两个函数立即就执行了。\n\nbind还有一个需要注意的点是，在bind执行的时候，可以事先为函数预设参数，得到的函数最终执行的时候，入参会和之前绑定过的进行合并。\n\n模拟实现如下：\n\ntypeof Function.prototype.bind !== "function" &&\n  (Function.prototype.bind = function (ctx, ...bindArgs) {\n    const prop = Symbol("bind");\n    ctx = ctx || window;\n    const _this = this;\n    // 返回一个新函数\n    return function Construct(...restArgs) {\n      // 如果当前函数被当做构造函数来用的话，直接返回合并之后的结果\n      if (this instanceof Construct) {\n        return new _this(...[...bindArgs, ...restArgs]);\n      }\n      ctx[prop] = _this;\n      // 如果当前普通函数用，合并参数再执行\n      const result = ctx[prop](...[...bindArgs, ...restArgs]);\n      delete ctx[prop];\n      return result;\n    };\n  });\n',normalizedContent:'# 手写 call、apply、bind\n\n这三个方法都是定义在函数上的方法，其目的都是改变函数的执行上下文this的指向。\n\n它的ts定义如下：\n\n/**\n * creates a new function.\n */\ninterface function {\n  /**\n   * calls the function, substituting the specified object for the this value of the function, and the specified array for the arguments of the function.\n   * @param thisarg the object to be used as the this object.\n   * @param argarray a set of arguments to be passed to the function.\n   */\n  apply(this: function, thisarg: any, argarray?: any): any;\n  /**\n   * calls a method of an object, substituting another object for the current object.\n   * @param thisarg the object to be used as the current object.\n   * @param argarray a list of arguments to be passed to the method.\n   */\n  call(this: function, thisarg: any, ...argarray: any[]): any;\n  /**\n   * for a given function, creates a bound function that has the same body as the original function.\n   * the this object of the bound function is associated with the specified object, and has the specified initial parameters.\n   * @param thisarg an object to which the this keyword can refer inside the new function.\n   * @param argarray a list of arguments to be passed to the new function.\n   */\n  bind(this: function, thisarg: any, ...argarray: any[]): any;\n}\n\n\n第一个参数是函数本身，第二个参数是为函数执行时绑定this的指向，第三个参数是可选参数，代表的是原函数的实参列表，因为这是在函数的原型上的定义，当我们在使用时，其实第一个this参数就是函数本身，因此，这就是为什么我们在使用的时候并没有第一个参数的原因。\n\n\n# 1、模拟实现 call\n\n首先，先说一下call的功能，将函数的this上下文绑定在某个对象执行，原函数的参数以剩余参数逐个传递的形式传递。如果对于call的实现原理不太明白的同学可以先参考一下我阐述this的文章。\n\n根据this的默认绑定规则，函数的调用者是谁，this就执行谁，那我们自然而然就会想到，把当前函数赋值给指定的上下文对象的某个key上，然后执行。有了实现思路之后，就可以很容易的编写出如下代码：\n\ntypeof function.prototype.call !== "function" &&\n  (function.prototype.call = function (ctx, ...args) {\n    // 如果直接调用函数原型上的方法，就返回undefined;\n    if (this === function.prototype) {\n      return;\n    }\n    // 默认绑定为window\n    ctx = ctx || window;\n    // 为了防止key在上下文对象上造成冲突，使用symbol作为key\n    const prop = symbol("call");\n    // 把当前函数赋值给这个临时key\n    ctx[prop] = this;\n    // 执行函数，并且把函数执行结果记录下来\n    const result = ctx[prop](...args);\n    // 为了防止对执行上下文对象造成污染，还需要删除这个临时key\n    delete ctx[prop];\n    // 返回函数的执行结果\n    return result;\n  });\n\n\n上述代码，因为call接受的是剩余参数的形式，因此，我们需要用扩展运算符将第二个以后的参数收集成一个数组，但是在函数执行的时候，又必须将这个数组打散。\n\n\n# 2、模拟实现 apply\n\n在理解了call之后，编写apply就容易得多了，为了避嫌，我们不会借用call的实现，但是之所以这样说，是因为apply的原理和call几乎完全一样.\n\n模拟实现如下：\n\ntypeof function.prototype.apply !== "function" &&\n  (function.prototype.apply = function (ctx, args) {\n    // 如果直接调用函数原型上的方法，就返回undefined;\n    if (this === function.prototype) {\n      return;\n    }\n    // 默认绑定为window\n    ctx = ctx || window;\n    // 为了防止key在上下文对象上造成冲突，使用symbol作为key\n    const prop = symbol("apply");\n    // 把当前函数赋值给这个临时key\n    ctx[prop] = this;\n    // 执行函数，并且把函数执行结果记录下来\n    const result = ctx[prop](...args);\n    // 为了防止对执行上下文对象造成污染，还需要删除这个临时key\n    delete ctx[prop];\n    // 返回函数的执行结果\n    return result;\n  });\n\n\n\n# 3、模拟实现 bind\n\nbind方法和上述两个方法有一点区别较大，bind是得到一个绑定了this上下文的函数，而上述两个函数立即就执行了。\n\nbind还有一个需要注意的点是，在bind执行的时候，可以事先为函数预设参数，得到的函数最终执行的时候，入参会和之前绑定过的进行合并。\n\n模拟实现如下：\n\ntypeof function.prototype.bind !== "function" &&\n  (function.prototype.bind = function (ctx, ...bindargs) {\n    const prop = symbol("bind");\n    ctx = ctx || window;\n    const _this = this;\n    // 返回一个新函数\n    return function construct(...restargs) {\n      // 如果当前函数被当做构造函数来用的话，直接返回合并之后的结果\n      if (this instanceof construct) {\n        return new _this(...[...bindargs, ...restargs]);\n      }\n      ctx[prop] = _this;\n      // 如果当前普通函数用，合并参数再执行\n      const result = ctx[prop](...[...bindargs, ...restargs]);\n      delete ctx[prop];\n      return result;\n    };\n  });\n',charsets:{cjk:!0}},{frontmatter:{},regularPath:"/javascript/write/debounce.html",relativePath:"javascript/write/debounce.md",key:"v-7e8a4b55",path:"/javascript/write/debounce.html",headersStr:null,content:"",normalizedContent:"",charsets:{}},{title:"克隆",frontmatter:{},regularPath:"/javascript/write/clone.html",relativePath:"javascript/write/clone.md",key:"v-49363b4b",path:"/javascript/write/clone.html",headers:[{level:2,title:"克隆",slug:"克隆",normalizedTitle:"克隆",charIndex:2},{level:3,title:"浅克隆",slug:"浅克隆",normalizedTitle:"浅克隆",charIndex:20},{level:3,title:"深克隆",slug:"深克隆",normalizedTitle:"深克隆",charIndex:24},{level:3,title:"深克隆的实现",slug:"深克隆的实现",normalizedTitle:"深克隆的实现",charIndex:1343}],headersStr:"克隆 浅克隆 深克隆 深克隆的实现",content:'# 克隆\n\n首先，先为大家介绍一下什么是浅克隆和深克隆。\n\n对于浅克隆和深克隆，我们都是针对引用类型来讨论的，比如说：\n\nconst a = "AAA";\nconst b = a;\n\n\n因为a和b，都是基础类型，这个操作，其实就相当于把a拷贝了一份给b，所以这个话题针对非引用类型讨论没有意义。\n\n\n# 浅克隆\n\nconst a = {};\nconst b = a;\n\n\n此刻，a和b都指向同一块内存区域，因此，大家都可以对这块区域进行修改。在实际开发中，经常会存在一些潜在的 bug，因为操作了同一块内存区域导致数据的一致性错误，因此，在处理数据的过程中，针对引用数据类型，一定要足够小心，注意其引用的内容。\n\nDANGER\n\n对于引用类型，不同的变量都引用同一个对象，都可以对这个对象进行修改\n\n\n# 深克隆\n\n下面 2 种情况，是我总结的不太容易察觉的可能是深克隆的情况。\n\n# 场景 1\n\nconst a = { name: "yangxu", age: "28" };\n/* const b = a; */\nconst b = { ...a };\n\n\n根据扩展运算符的运用场景，首先初始化了一个新对象b，然后就把对象a中的所有属性都复制给了b，其实这是完成了一次深克隆。\n\n但是，这只是针对这个场景下的深克隆，假设现在：\n\nconst a = {\n  name: "yangxu",\n  age: "28",\n  location: {\n    province: "sichuan",\n    city: "chengdu",\n    country: "shuangliu",\n  },\n};\nconst b = { ...a };\n\nb.location.province = "beijing";\n/* 输出beijing */\nconsole.log(a.location.province);\n\n\n为什么是beijing，这个操作，就相当于a和b都持有location，因此大家都可以对它进行修改了。\n\nTIP\n\n使用Object.assign和扩展运算符类似\n\n# 场景 2\n\nconst a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nconst b = a.map((v) => v);\n\n\n咋一看，好像是一个没有意义的操作，干嘛要空map一次呢？其实不然，我们知道map返回一个新的数组，那么，因为数组的元素是基本类型，不存在拷贝的问题，因此，我们就好比新建一个数组，把所有的元素都拷贝过去。\n\n下面这个场景和上面类似：\n\nconst a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nconst b = [...a];\n\n\n但是，对于这个场景，就需要注意了。\n\nconst a = [{}, {}, {}, {}, {}, {}, {}, {}, {}];\nconst b = a.map((v) => v);\n\n\n这样并没有完成一次深克隆，因为其实数组的键是特殊的键，即 a[0]和 b[0]都持有同一个对象，大家都能修改这个对象，数据一致性就可能存在问题，因此，这种情况就不能再使用map。\n\n\n# 深克隆的实现\n\n# 使用 JSON.parse + JSON.stringify\n\nconst o = {};\nconst b = JSON.parse(JSON.stringify(o));\n\n\n首先，我觉得绝大部分人说不清楚JSON.stringify的序列化规则，这个是我曾经面试遇到过的一个问题，我特意去看过MDN的描述。具体的序列化规则我就不在此叙述，本文主要阐述一下用它可能存在的问题。\n\n * JSON.stringify 无法解决循环引用的问题；\n * JSON.stringify 无法序列化Symbol，BigInt，Function这类不能被序列化的类型；\n * JSON.stringify 只能序列化对象的可枚举字段；\n * JSON.stringify 序列化的数据可能不准确，如Date，NaN；\n\n# 使用 DFS 实现深克隆\n\n同理，使用BFS或者DFS进行深克隆，仍然解决不全上述描述的问题（但解决度就可以取决于你自己对JS的积累了），但是，这个是基于算法的，它能够向面试官证明你的学习能力、编程能力与记忆力，至少能说明你是一个愿意学习的程序员。\n\n使用DFS或BFS是可以解决对象循环引用的问题。\n\n/**\n * 使用深度优先深拷贝对象\n * @param {Array<any> | object} obj\n * @param { Map<Array<any> | object, Array<any> | object> } map\n * @returns\n */\nfunction deepClone(obj, map = new Map()) {\n  // 如果已经拷贝过，则可以直接返回拷贝过的值，主要是为了防止循环引用\n  let cloneObj = map.get(obj);\n  if (typeof cloneObj !== "undefined") {\n    return cloneObj;\n  }\n  // 初始化拷贝的对象\n  cloneObj = Array.isArray(obj) ? [] : {};\n  // 建立已经拷贝的引用，不能再开始拷贝属性了再建立拷贝引用，否则将会导致递归最大调用栈的问题发生\n  map.set(obj, cloneObj);\n  // 对拷贝对象挨个赋值\n  for (let prop in obj) {\n    // 遇到对象，则递归拷贝\n    if (obj[prop] instanceof Object) {\n      cloneObj[prop] = deepClone(obj[prop], map);\n      // 拷贝完成后，还要将其加入引用Map中去\n      map.set(obj[prop], cloneObj[obj]);\n    } else {\n      cloneObj[prop] = obj[prop];\n    }\n  }\n  return cloneObj;\n}\n\n\n# 使用BFS实现深克隆\n\n与DFS类似，不赘述。\n\n/**\n * 使用广度优先深拷贝一个对象\n * @param {Array<any> | object} obj\n * @returns\n */\nfunction deepClone(obj) {\n  // 根据目标对象确定拷贝是数组还是对象\n  let cloneObj = Array.isArray(obj) ? [] : {};\n  // 用一个map用以记住被拷贝过的内容\n  const map = new Map();\n  // 记住当前对象已经被拷贝过了\n  map.set(obj, cloneObj);\n  // 把原始内容和拷贝的内容追加到队列中去，准备开始以广度优先的方式进行深拷贝\n  const queue = [\n    {\n      source: obj,\n      clone: cloneObj,\n    },\n  ];\n  while (queue.length > 0) {\n    const { source, clone } = queue.shift();\n    for (let prop in source) {\n      if (source[prop] instanceof Object) {\n        // 如果已经拷贝过，则直接将内容复制到目标对象上去\n        if (map.get(source[prop])) {\n          clone[prop] = map.get(source[prop]);\n        } else {\n          // 把当前对象和拷贝的空对象加入到队列中去，准备后序的深拷贝\n          const nextClone = Array.isArray(source[prop]) ? [] : {};\n          queue.push({\n            source: source[prop],\n            clone: nextClone,\n          });\n          // 建立拷贝关系，本轮还是空内容（可以理解为拷贝一个容器），待下一轮循环才拷贝值\n          clone[prop] = nextClone;\n          // 将已经拷贝的内容加入到map中去，防止循环拷贝\n          map.set(source[prop], nextClone);\n        }\n      } else {\n        // 基本类型，可直接拷贝\n        clone[prop] = source[prop];\n      }\n    }\n  }\n  return cloneObj;\n}\n',normalizedContent:'# 克隆\n\n首先，先为大家介绍一下什么是浅克隆和深克隆。\n\n对于浅克隆和深克隆，我们都是针对引用类型来讨论的，比如说：\n\nconst a = "aaa";\nconst b = a;\n\n\n因为a和b，都是基础类型，这个操作，其实就相当于把a拷贝了一份给b，所以这个话题针对非引用类型讨论没有意义。\n\n\n# 浅克隆\n\nconst a = {};\nconst b = a;\n\n\n此刻，a和b都指向同一块内存区域，因此，大家都可以对这块区域进行修改。在实际开发中，经常会存在一些潜在的 bug，因为操作了同一块内存区域导致数据的一致性错误，因此，在处理数据的过程中，针对引用数据类型，一定要足够小心，注意其引用的内容。\n\ndanger\n\n对于引用类型，不同的变量都引用同一个对象，都可以对这个对象进行修改\n\n\n# 深克隆\n\n下面 2 种情况，是我总结的不太容易察觉的可能是深克隆的情况。\n\n# 场景 1\n\nconst a = { name: "yangxu", age: "28" };\n/* const b = a; */\nconst b = { ...a };\n\n\n根据扩展运算符的运用场景，首先初始化了一个新对象b，然后就把对象a中的所有属性都复制给了b，其实这是完成了一次深克隆。\n\n但是，这只是针对这个场景下的深克隆，假设现在：\n\nconst a = {\n  name: "yangxu",\n  age: "28",\n  location: {\n    province: "sichuan",\n    city: "chengdu",\n    country: "shuangliu",\n  },\n};\nconst b = { ...a };\n\nb.location.province = "beijing";\n/* 输出beijing */\nconsole.log(a.location.province);\n\n\n为什么是beijing，这个操作，就相当于a和b都持有location，因此大家都可以对它进行修改了。\n\ntip\n\n使用object.assign和扩展运算符类似\n\n# 场景 2\n\nconst a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nconst b = a.map((v) => v);\n\n\n咋一看，好像是一个没有意义的操作，干嘛要空map一次呢？其实不然，我们知道map返回一个新的数组，那么，因为数组的元素是基本类型，不存在拷贝的问题，因此，我们就好比新建一个数组，把所有的元素都拷贝过去。\n\n下面这个场景和上面类似：\n\nconst a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nconst b = [...a];\n\n\n但是，对于这个场景，就需要注意了。\n\nconst a = [{}, {}, {}, {}, {}, {}, {}, {}, {}];\nconst b = a.map((v) => v);\n\n\n这样并没有完成一次深克隆，因为其实数组的键是特殊的键，即 a[0]和 b[0]都持有同一个对象，大家都能修改这个对象，数据一致性就可能存在问题，因此，这种情况就不能再使用map。\n\n\n# 深克隆的实现\n\n# 使用 json.parse + json.stringify\n\nconst o = {};\nconst b = json.parse(json.stringify(o));\n\n\n首先，我觉得绝大部分人说不清楚json.stringify的序列化规则，这个是我曾经面试遇到过的一个问题，我特意去看过mdn的描述。具体的序列化规则我就不在此叙述，本文主要阐述一下用它可能存在的问题。\n\n * json.stringify 无法解决循环引用的问题；\n * json.stringify 无法序列化symbol，bigint，function这类不能被序列化的类型；\n * json.stringify 只能序列化对象的可枚举字段；\n * json.stringify 序列化的数据可能不准确，如date，nan；\n\n# 使用 dfs 实现深克隆\n\n同理，使用bfs或者dfs进行深克隆，仍然解决不全上述描述的问题（但解决度就可以取决于你自己对js的积累了），但是，这个是基于算法的，它能够向面试官证明你的学习能力、编程能力与记忆力，至少能说明你是一个愿意学习的程序员。\n\n使用dfs或bfs是可以解决对象循环引用的问题。\n\n/**\n * 使用深度优先深拷贝对象\n * @param {array<any> | object} obj\n * @param { map<array<any> | object, array<any> | object> } map\n * @returns\n */\nfunction deepclone(obj, map = new map()) {\n  // 如果已经拷贝过，则可以直接返回拷贝过的值，主要是为了防止循环引用\n  let cloneobj = map.get(obj);\n  if (typeof cloneobj !== "undefined") {\n    return cloneobj;\n  }\n  // 初始化拷贝的对象\n  cloneobj = array.isarray(obj) ? [] : {};\n  // 建立已经拷贝的引用，不能再开始拷贝属性了再建立拷贝引用，否则将会导致递归最大调用栈的问题发生\n  map.set(obj, cloneobj);\n  // 对拷贝对象挨个赋值\n  for (let prop in obj) {\n    // 遇到对象，则递归拷贝\n    if (obj[prop] instanceof object) {\n      cloneobj[prop] = deepclone(obj[prop], map);\n      // 拷贝完成后，还要将其加入引用map中去\n      map.set(obj[prop], cloneobj[obj]);\n    } else {\n      cloneobj[prop] = obj[prop];\n    }\n  }\n  return cloneobj;\n}\n\n\n# 使用bfs实现深克隆\n\n与dfs类似，不赘述。\n\n/**\n * 使用广度优先深拷贝一个对象\n * @param {array<any> | object} obj\n * @returns\n */\nfunction deepclone(obj) {\n  // 根据目标对象确定拷贝是数组还是对象\n  let cloneobj = array.isarray(obj) ? [] : {};\n  // 用一个map用以记住被拷贝过的内容\n  const map = new map();\n  // 记住当前对象已经被拷贝过了\n  map.set(obj, cloneobj);\n  // 把原始内容和拷贝的内容追加到队列中去，准备开始以广度优先的方式进行深拷贝\n  const queue = [\n    {\n      source: obj,\n      clone: cloneobj,\n    },\n  ];\n  while (queue.length > 0) {\n    const { source, clone } = queue.shift();\n    for (let prop in source) {\n      if (source[prop] instanceof object) {\n        // 如果已经拷贝过，则直接将内容复制到目标对象上去\n        if (map.get(source[prop])) {\n          clone[prop] = map.get(source[prop]);\n        } else {\n          // 把当前对象和拷贝的空对象加入到队列中去，准备后序的深拷贝\n          const nextclone = array.isarray(source[prop]) ? [] : {};\n          queue.push({\n            source: source[prop],\n            clone: nextclone,\n          });\n          // 建立拷贝关系，本轮还是空内容（可以理解为拷贝一个容器），待下一轮循环才拷贝值\n          clone[prop] = nextclone;\n          // 将已经拷贝的内容加入到map中去，防止循环拷贝\n          map.set(source[prop], nextclone);\n        }\n      } else {\n        // 基本类型，可直接拷贝\n        clone[prop] = source[prop];\n      }\n    }\n  }\n  return cloneobj;\n}\n',charsets:{cjk:!0}},{title:"Compose函数",frontmatter:{},regularPath:"/javascript/write/compose.html",relativePath:"javascript/write/compose.md",key:"v-2772ede1",path:"/javascript/write/compose.html",headers:[{level:2,title:"Compose函数",slug:"compose函数",normalizedTitle:"compose函数",charIndex:2}],headersStr:"Compose函数",content:'# Compose函数\n\nCompose函数的用处比较多，像比如koa的洋葱模型，React中Redux的插件redux-saga，还有Vue的过滤器，还有babel编译装饰器的处理，这些都是基于Compose函数的。\n\n举一个大家比较熟悉的Vue的例子:\n\n<template>\n  <div class="book">￥{{ price | toFixed(2) | thousands }}</div>\n</template>\n\n<script>\nexport default {\n  name: "Book",\n  filters: {\n    toFixed(price, precision) {\n      return Number.parseFloat(price).toFixed(precision);\n    },\n    thousands(price) {\n      const num_str = price.toString();\n      const parts = num_str.split(".");\n      const exp = /\\d{1,3}(?=(\\d{3})+(\\.\\d*)?$)/g;\n      return (\n        parts[0].replace(exp, "$&,") +\n        (parts.length > 1 ? "." + parts[1].replace(/\\,/g, "") : "")\n      );\n    },\n  },\n  props: {\n    price: {\n      type: Number,\n      required: true,\n      default: 0,\n    },\n  },\n};\n<\/script>\n\n\n去年（2022年），我在面试美团的二面的时候被问到过，不过明白它的原理的话，写起来其实并不难。\n\n在上述这种场景下，我们就可以把Compose函数定义成如下形式。\n\nfunction Compose(fns: Function[], initArgs: any);\n\n\nfunction Compose(fns, initArgs) {\n  let res = null;\n  // 是否初始化\n  let init = false;\n  // Compose函数一般是后加入的先执行\n  const reverseFns = fns.reverse();\n  for (let i = 0; i < reverseFns.length; i++) {\n    const fn = reverseFns[i];\n    // 没有初始化，使用初始化的值，初始化之后使用上一次的值\n    res = fn(init ? res : ((init = true), initArgs));\n  }\n  return res;\n}\n\n\nfunction toFixed(precision) {\n  return function (price) {\n    return Number.parseFloat(price).toFixed(precision);\n  };\n}\n\nfunction toThousands(price) {\n  const num_str = price.toString();\n  const parts = num_str.split(".");\n  const exp = /\\d{1,3}(?=(\\d{3})+(\\.\\d*)?$)/g;\n  return (\n    parts[0].replace(exp, "$&,") +\n    (parts.length > 1 ? "." + parts[1].replace(/\\,/g, "") : "")\n  );\n}\n\nconst price = 1000;\n\nconst renderPrice = Compose([toFixed(2), toThousands], price);\n',normalizedContent:'# compose函数\n\ncompose函数的用处比较多，像比如koa的洋葱模型，react中redux的插件redux-saga，还有vue的过滤器，还有babel编译装饰器的处理，这些都是基于compose函数的。\n\n举一个大家比较熟悉的vue的例子:\n\n<template>\n  <div class="book">￥{{ price | tofixed(2) | thousands }}</div>\n</template>\n\n<script>\nexport default {\n  name: "book",\n  filters: {\n    tofixed(price, precision) {\n      return number.parsefloat(price).tofixed(precision);\n    },\n    thousands(price) {\n      const num_str = price.tostring();\n      const parts = num_str.split(".");\n      const exp = /\\d{1,3}(?=(\\d{3})+(\\.\\d*)?$)/g;\n      return (\n        parts[0].replace(exp, "$&,") +\n        (parts.length > 1 ? "." + parts[1].replace(/\\,/g, "") : "")\n      );\n    },\n  },\n  props: {\n    price: {\n      type: number,\n      required: true,\n      default: 0,\n    },\n  },\n};\n<\/script>\n\n\n去年（2022年），我在面试美团的二面的时候被问到过，不过明白它的原理的话，写起来其实并不难。\n\n在上述这种场景下，我们就可以把compose函数定义成如下形式。\n\nfunction compose(fns: function[], initargs: any);\n\n\nfunction compose(fns, initargs) {\n  let res = null;\n  // 是否初始化\n  let init = false;\n  // compose函数一般是后加入的先执行\n  const reversefns = fns.reverse();\n  for (let i = 0; i < reversefns.length; i++) {\n    const fn = reversefns[i];\n    // 没有初始化，使用初始化的值，初始化之后使用上一次的值\n    res = fn(init ? res : ((init = true), initargs));\n  }\n  return res;\n}\n\n\nfunction tofixed(precision) {\n  return function (price) {\n    return number.parsefloat(price).tofixed(precision);\n  };\n}\n\nfunction tothousands(price) {\n  const num_str = price.tostring();\n  const parts = num_str.split(".");\n  const exp = /\\d{1,3}(?=(\\d{3})+(\\.\\d*)?$)/g;\n  return (\n    parts[0].replace(exp, "$&,") +\n    (parts.length > 1 ? "." + parts[1].replace(/\\,/g, "") : "")\n  );\n}\n\nconst price = 1000;\n\nconst renderprice = compose([tofixed(2), tothousands], price);\n',charsets:{cjk:!0}},{title:"进制转换",frontmatter:{},regularPath:"/javascript/write/conversion-of-number-systems.html",relativePath:"javascript/write/conversion-of-number-systems.md",key:"v-5f78be15",path:"/javascript/write/conversion-of-number-systems.html",headers:[{level:2,title:"进制转换",slug:"进制转换",normalizedTitle:"进制转换",charIndex:2},{level:3,title:"1、toString",slug:"_1、tostring",normalizedTitle:"1、tostring",charIndex:95},{level:3,title:"2、除K取余法",slug:"_2、除k取余法",normalizedTitle:"2、除k取余法",charIndex:1639}],headersStr:"进制转换 1、toString 2、除K取余法",content:'# 进制转换\n\n这算一个不是特别难，但是可能一时半会儿又不太容易想到答案的问题\n\n我们在高中的数学课程中就已经学过一种方法，叫做除K取余法，可以把一个十进制的数转化成任意进制的数。\n\n\n# 1、toString\n\n如果不知道toString可以做进制转换的同学，可以先翻阅一下MDN，Number对象覆盖了Object对象上的toString方法，toString方法返回指定Number对象的字符串表示形式，可接收一个radix参数，范围在2-36，如果未指定radix参数，则默认值为10。\n\n既然说到了这儿，相信有很多同学可能遇到过这个问题（我在2019年的时候面试中国电子科技集团30所的时候被问到过这题）：\n\nconsole.log(["1", "2", "3"].map(parseInt));\n\n\n请问上述代码，输出的结果是什么，并解释为什么\n\n这个问题其实考察的是你的仔细程度和API的掌握度。\n\n首先，上述代码稍稍的进行改写就比较简单明了了。\n\nconst arr = ["1", "2", "3"];\nconst res = arr.map((cur, curIdx, arr) => {\n  return parseInt(cur, curIdx, arr);\n});\nconsole.log(res);\n\n\n为什么可以改写成这样？\n\n因为，Array.prototype.map的TS定义如下:\n\ninterface Array<T> {\n  /**\n   * Calls a defined callback function on each element of an array, and returns an array that contains the results.\n   * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.\n   * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n   */\n  map<U>(\n    callbackfn: (value: T, index: number, array: T[]) => U,\n    thisArg?: any\n  ): U[];\n}\n\n\nparseInt直接以回调的形式传入的，因此，它其实是接受了map方法的所有参数。\n\nparseInt或者Number.parseInt，接受两个参数，第一个参数是需要转换的原始值，第二个参数是转化的进制，是一个可选参数，范围在2-36，如果不传或者传入0视为不传，如果待转换参数是0x或者0X开头，那么默认以十六进制进行转换，否则默认以10进制进行转换。若无法转换，则返回NaN\n\n所以，parseInt(\'1\', 0)，就相当于，parseInt(\'1\')，所以结果为1，parseInt(\'2\', 1)指定的进制不在预期范围内，所以结果为NaN，parseInt(\'3\', 2)这个很多人就比较迷惑了，为什么呀，不是说了进制在2-36之间吗，应该的结果是11，抱歉，我们现在是在把字符串转成Number，二进制数里面怎么可能包含3呢，所以parseInt(\'3\', 2)的结果也是NaN。\n\n综上所述：\n\nconsole.log(["1", "2", "3"].map(parseInt));\n// 1 NaN NaN\n\n\n\n# 2、除K取余法\n\n在说了一些花里胡哨的知识点之后，进入本文的正题——>除K取余法。\n\n我记得在大学上C语言程序设计的前几节实验课，就有一题，比如给你一个三位数，分别打印各位上的数字，这题第一眼看起来，就好像这个思路，但是你会发现，顺着这个思路会越走越远。\n\n因为将A数的十进制转化为B数的b进制之后，你并不知道B数最高位能是多少。但是我们反过来想，个位上一定都是达不到某进制的落单的数（我的个人理解），那么如果将A数对b进制取余，是不是就得到了这个所谓落单的数？是的。一旦确定了个位，相当于这个新数就是一个整的b进制数，将其除以b进制，我们似乎又回到了刚才一个过程，这样不断的从右边往左边递推，并且把这个过程中的数字和单位记录下来，这不就完成了嘛。\n\n于是，有了思路以后，编写代码就比较容易了。\n\n/**\n * 十进制转化成2-36进制的字符串\n * @param { Number } num 输入的十进制内容\n * @param { Number } expectRadix 预期转化的进制\n * @return { String }\n */\nfunction convertNumberSystem(num, expectRadix) {\n  if (expectRadix > 36) {\n    throw new Error("Convert range error, between 2 and 36");\n  }\n  let results = "";\n  let tmp = num;\n  const map = [\n    0,\n    1,\n    2,\n    3,\n    4,\n    5,\n    6,\n    7,\n    8,\n    9,\n    "a",\n    "b",\n    "c",\n    "d",\n    "e",\n    "f",\n    "g",\n    "h",\n    "i",\n    "j",\n    "k",\n    "l",\n    "m",\n    "n",\n    "o",\n    "p",\n    "q",\n    "r",\n    "s",\n    "t",\n    "u",\n    "v",\n    "w",\n    "x",\n    "y",\n    "z",\n  ];\n  // 为什么循环的退出条件写成这样，试想，如果一个数本来就比要转化的进制还小（所以必须取到等号），那这个数不本来就是个位的数了嘛？\n  while (tmp >= expectRadix) {\n    const digit = tmp % expectRadix;\n    // 将当前的位置和当前位置上面的数添加到结果里面去\n    results = map[digit] + results;\n    // 把不能整除的数减去之后，剩下的就一定可以整除了\n    tmp = (tmp - digit) / expectRadix;\n  }\n  // 别忘了，循环如果一次都没有或者循环完成了之后，还有一个最高位的数字没有加上去，因此\n  results = map[tmp] + results;\n  return results;\n}\n\n\n以下是基于jest测试的用例：\n\ndescribe("convertNumberSystem", () => {\n  it("should convert decimal to binary correctly", () => {\n    expect(convertNumberSystem(10, 2)).toBe("1010");\n    expect(convertNumberSystem(3242300, 26)).toBe((3242300).toString(26));\n    expect(convertNumberSystem(9, 3)).toBe((9).toString(3));\n    expect(convertNumberSystem(2, 3)).toBe((2).toString(3));\n    expect(convertNumberSystem(100, 16)).toBe((100).toString(16));\n  });\n\n  it("should convert decimal to octal correctly", () => {\n    expect(convertNumberSystem(123, 8)).toBe("173");\n  });\n\n  it("should convert decimal to hexadecimal correctly", () => {\n    expect(convertNumberSystem(255, 16)).toBe("ff");\n  });\n\n  it("should throw an error when the expected radix is greater than 36", () => {\n    expect(() => convertNumberSystem(123, 37)).toThrowError(\n      "Convert range error, between 2 and 36"\n    );\n  });\n});\n',normalizedContent:'# 进制转换\n\n这算一个不是特别难，但是可能一时半会儿又不太容易想到答案的问题\n\n我们在高中的数学课程中就已经学过一种方法，叫做除k取余法，可以把一个十进制的数转化成任意进制的数。\n\n\n# 1、tostring\n\n如果不知道tostring可以做进制转换的同学，可以先翻阅一下mdn，number对象覆盖了object对象上的tostring方法，tostring方法返回指定number对象的字符串表示形式，可接收一个radix参数，范围在2-36，如果未指定radix参数，则默认值为10。\n\n既然说到了这儿，相信有很多同学可能遇到过这个问题（我在2019年的时候面试中国电子科技集团30所的时候被问到过这题）：\n\nconsole.log(["1", "2", "3"].map(parseint));\n\n\n请问上述代码，输出的结果是什么，并解释为什么\n\n这个问题其实考察的是你的仔细程度和api的掌握度。\n\n首先，上述代码稍稍的进行改写就比较简单明了了。\n\nconst arr = ["1", "2", "3"];\nconst res = arr.map((cur, curidx, arr) => {\n  return parseint(cur, curidx, arr);\n});\nconsole.log(res);\n\n\n为什么可以改写成这样？\n\n因为，array.prototype.map的ts定义如下:\n\ninterface array<t> {\n  /**\n   * calls a defined callback function on each element of an array, and returns an array that contains the results.\n   * @param callbackfn a function that accepts up to three arguments. the map method calls the callbackfn function one time for each element in the array.\n   * @param thisarg an object to which the this keyword can refer in the callbackfn function. if thisarg is omitted, undefined is used as the this value.\n   */\n  map<u>(\n    callbackfn: (value: t, index: number, array: t[]) => u,\n    thisarg?: any\n  ): u[];\n}\n\n\nparseint直接以回调的形式传入的，因此，它其实是接受了map方法的所有参数。\n\nparseint或者number.parseint，接受两个参数，第一个参数是需要转换的原始值，第二个参数是转化的进制，是一个可选参数，范围在2-36，如果不传或者传入0视为不传，如果待转换参数是0x或者0x开头，那么默认以十六进制进行转换，否则默认以10进制进行转换。若无法转换，则返回nan\n\n所以，parseint(\'1\', 0)，就相当于，parseint(\'1\')，所以结果为1，parseint(\'2\', 1)指定的进制不在预期范围内，所以结果为nan，parseint(\'3\', 2)这个很多人就比较迷惑了，为什么呀，不是说了进制在2-36之间吗，应该的结果是11，抱歉，我们现在是在把字符串转成number，二进制数里面怎么可能包含3呢，所以parseint(\'3\', 2)的结果也是nan。\n\n综上所述：\n\nconsole.log(["1", "2", "3"].map(parseint));\n// 1 nan nan\n\n\n\n# 2、除k取余法\n\n在说了一些花里胡哨的知识点之后，进入本文的正题——>除k取余法。\n\n我记得在大学上c语言程序设计的前几节实验课，就有一题，比如给你一个三位数，分别打印各位上的数字，这题第一眼看起来，就好像这个思路，但是你会发现，顺着这个思路会越走越远。\n\n因为将a数的十进制转化为b数的b进制之后，你并不知道b数最高位能是多少。但是我们反过来想，个位上一定都是达不到某进制的落单的数（我的个人理解），那么如果将a数对b进制取余，是不是就得到了这个所谓落单的数？是的。一旦确定了个位，相当于这个新数就是一个整的b进制数，将其除以b进制，我们似乎又回到了刚才一个过程，这样不断的从右边往左边递推，并且把这个过程中的数字和单位记录下来，这不就完成了嘛。\n\n于是，有了思路以后，编写代码就比较容易了。\n\n/**\n * 十进制转化成2-36进制的字符串\n * @param { number } num 输入的十进制内容\n * @param { number } expectradix 预期转化的进制\n * @return { string }\n */\nfunction convertnumbersystem(num, expectradix) {\n  if (expectradix > 36) {\n    throw new error("convert range error, between 2 and 36");\n  }\n  let results = "";\n  let tmp = num;\n  const map = [\n    0,\n    1,\n    2,\n    3,\n    4,\n    5,\n    6,\n    7,\n    8,\n    9,\n    "a",\n    "b",\n    "c",\n    "d",\n    "e",\n    "f",\n    "g",\n    "h",\n    "i",\n    "j",\n    "k",\n    "l",\n    "m",\n    "n",\n    "o",\n    "p",\n    "q",\n    "r",\n    "s",\n    "t",\n    "u",\n    "v",\n    "w",\n    "x",\n    "y",\n    "z",\n  ];\n  // 为什么循环的退出条件写成这样，试想，如果一个数本来就比要转化的进制还小（所以必须取到等号），那这个数不本来就是个位的数了嘛？\n  while (tmp >= expectradix) {\n    const digit = tmp % expectradix;\n    // 将当前的位置和当前位置上面的数添加到结果里面去\n    results = map[digit] + results;\n    // 把不能整除的数减去之后，剩下的就一定可以整除了\n    tmp = (tmp - digit) / expectradix;\n  }\n  // 别忘了，循环如果一次都没有或者循环完成了之后，还有一个最高位的数字没有加上去，因此\n  results = map[tmp] + results;\n  return results;\n}\n\n\n以下是基于jest测试的用例：\n\ndescribe("convertnumbersystem", () => {\n  it("should convert decimal to binary correctly", () => {\n    expect(convertnumbersystem(10, 2)).tobe("1010");\n    expect(convertnumbersystem(3242300, 26)).tobe((3242300).tostring(26));\n    expect(convertnumbersystem(9, 3)).tobe((9).tostring(3));\n    expect(convertnumbersystem(2, 3)).tobe((2).tostring(3));\n    expect(convertnumbersystem(100, 16)).tobe((100).tostring(16));\n  });\n\n  it("should convert decimal to octal correctly", () => {\n    expect(convertnumbersystem(123, 8)).tobe("173");\n  });\n\n  it("should convert decimal to hexadecimal correctly", () => {\n    expect(convertnumbersystem(255, 16)).tobe("ff");\n  });\n\n  it("should throw an error when the expected radix is greater than 36", () => {\n    expect(() => convertnumbersystem(123, 37)).tothrowerror(\n      "convert range error, between 2 and 36"\n    );\n  });\n});\n',charsets:{cjk:!0}},{title:"柯里化",frontmatter:{},regularPath:"/javascript/write/currying.html",relativePath:"javascript/write/currying.md",key:"v-482ede15",path:"/javascript/write/currying.html",headers:[{level:2,title:"柯里化",slug:"柯里化",normalizedTitle:"柯里化",charIndex:2},{level:3,title:"判断数据的类型",slug:"判断数据的类型",normalizedTitle:"判断数据的类型",charIndex:163},{level:3,title:"延迟计算",slug:"延迟计算",normalizedTitle:"延迟计算",charIndex:1416}],headersStr:"柯里化 判断数据的类型 延迟计算",content:'# 柯里化\n\n> 在计算机科学中，柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。\n\n这是比较官方的话术，如果没有一些实际的开发经验的话，有些同学可能不太好懂\n\n因此从几个例子体会一下，柯里化在实际开发中带来的收益\n\n\n# 判断数据的类型\n\n由于JS的历史渊源，typeof运算符对于null来说，得到的值是object。另外，不管参数是数组还是对象，typeof得到的结果都是object，会对我们造成一些困扰，其余场景返回对应的结果。因此，我们需要封装一些逻辑才能得到一个符合实际开发需要的类型判断方法。\n\n/**\n * 判断一个数据的类型\n * @param {any} o\n * @returns\n */\nfunction getType(o) {\n  if (o === null) {\n    return "null";\n  } else if (typeof o === "object") {\n    return Array.isArray(o) ? "array" : "object";\n  } else {\n    return typeof o;\n  }\n}\n\n\n但是，这个方法对于调用者来说，是非常难受的，如果你读过一些常见的开源库的源码的话，在它们的工具方法中会封装出类似的方法。\n\n调用方来说，比如要判断当前对象是否是null，代码肯定不能写成getType(o) === \'null\'，那调用方每次都还要去关心getType的返回值了，直接给调用方造成了心智负担，并且，这种代码其实是跟平台(比如要判断当前函数的this是否指向globalThis，不同的平台nodejs是Global对象，浏览器是window对象)耦合在一起了的，这种编码是无法接受的。\n\n于是，我们需要做的事儿还需要继续做。\n\nfunction isType(expectType, o) {\n  return expectType === getType(o);\n}\n\n\n有了这个isType函数，只是更进一步了，为了降低外界的心智负担，我们最好的办法是直接给它一个确切类型的判断函数。所以，我们会在isType再封装一次，直接把expectType给确定下来，这样调用者直接使用特定类型的判断函数，他得到一个trueorfalse，就比较清爽了。\n\nexport function isNull(o) {\n  return isType("null", o);\n}\nexport function isArray(o) {\n  return isType("array", o);\n}\nexport function isObject(o) {\n  return isType("object", o);\n}\nexport function isNumber(o) {\n  return isType("number", o);\n}\n//...\n\n\n本来，isType是一个接收多个参数的函数，但是被我们提前确定了第一个参数(isNull，isArray，isObject)，然后返回接受剩下参数的函数了。\n\n说到这儿，其实您大概也理解了柯里化的意思了吧，我大概的理解就是：降低函数的通用性，提高函数的专用性\n\n\n# 延迟计算\n\n另外，如果跟闭包技术结合的话，柯里化另外一个作用起到了一个提前确定参数，延迟计算的效果（比如我们得到的isNull，最后执行的时候取决于外界调用，但是只是事先的确定了expectType）\n\n有的同学可能遇到过这个比较变态的面试题：\n\n// 实现一个`add`函数，要求能够达到一下效果\nadd(1)(2)(3)(4); // 10\nadd(1, 2)(3, 4); // 10\nadd(1)(2, 3, 4); // 10\nadd(1, 2, 3)(4); // 10\nadd(1, 2, 3, 4); // 10\n\n\n需要观察，add函数如果一下子传递4个参数的话，那么就可以直接算出结果了，如果只传递小于4个参数，它得到的是一个函数，并且，最终达到4个参数也会求值。\n\n发现了这个特点以后，代码就比较好写了:\n\nfunction _add(a, b, c, d) {\n  return a + b + c + d;\n}\n\n/**\n * 通用柯里化函数\n * @param {Function} fn\n * @param  {any[]} outerArgs\n * @returns\n */\nfunction currying(fn, ...outerArgs) {\n  return function (...innerArgs) {\n    const args = [...outerArgs, ...innerArgs];\n    // 如果参数已经确定完毕了，则执行传入的函数\n    if (args.length === fn.length) {\n      return fn.apply(this, args);\n    } else {\n      // 否则，将已经确定的参数绑定，递归调用currying\n      return currying(fn, ...args);\n    }\n  };\n}\n\nconst add = currying(_add);\n\n\n其实这个通用的柯里化函数看起来还是比较好理解的，首先，柯里化是不断的在为函数确定参数，为谁确定参数，那肯定是需要用户传入的函数，剩下的就是用户随意传递的参数了，用户传递的函数的参数个数是确定的，一旦参数确定完成了，那这个函数肯定就可以执行了；如果还没有确定完，因为要对外返回一个函数，最简单的办法就是递归调用当前这个处理流程。\n\n这个通用的柯里化函数也可以用来处理最开始我们的那个场景，如：\n\nexport function isNull(o) {\n  return currying(isType, "null")(o);\n}\nexport function isArray(o) {\n  return currying(isType, "array")(o);\n}\nexport function isObject(o) {\n  return currying(isType, "object")(o);\n}\nexport function isNumber(o) {\n  return currying(isType, "number")(o);\n}\n',normalizedContent:'# 柯里化\n\n> 在计算机科学中，柯里化（currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。\n\n这是比较官方的话术，如果没有一些实际的开发经验的话，有些同学可能不太好懂\n\n因此从几个例子体会一下，柯里化在实际开发中带来的收益\n\n\n# 判断数据的类型\n\n由于js的历史渊源，typeof运算符对于null来说，得到的值是object。另外，不管参数是数组还是对象，typeof得到的结果都是object，会对我们造成一些困扰，其余场景返回对应的结果。因此，我们需要封装一些逻辑才能得到一个符合实际开发需要的类型判断方法。\n\n/**\n * 判断一个数据的类型\n * @param {any} o\n * @returns\n */\nfunction gettype(o) {\n  if (o === null) {\n    return "null";\n  } else if (typeof o === "object") {\n    return array.isarray(o) ? "array" : "object";\n  } else {\n    return typeof o;\n  }\n}\n\n\n但是，这个方法对于调用者来说，是非常难受的，如果你读过一些常见的开源库的源码的话，在它们的工具方法中会封装出类似的方法。\n\n调用方来说，比如要判断当前对象是否是null，代码肯定不能写成gettype(o) === \'null\'，那调用方每次都还要去关心gettype的返回值了，直接给调用方造成了心智负担，并且，这种代码其实是跟平台(比如要判断当前函数的this是否指向globalthis，不同的平台nodejs是global对象，浏览器是window对象)耦合在一起了的，这种编码是无法接受的。\n\n于是，我们需要做的事儿还需要继续做。\n\nfunction istype(expecttype, o) {\n  return expecttype === gettype(o);\n}\n\n\n有了这个istype函数，只是更进一步了，为了降低外界的心智负担，我们最好的办法是直接给它一个确切类型的判断函数。所以，我们会在istype再封装一次，直接把expecttype给确定下来，这样调用者直接使用特定类型的判断函数，他得到一个trueorfalse，就比较清爽了。\n\nexport function isnull(o) {\n  return istype("null", o);\n}\nexport function isarray(o) {\n  return istype("array", o);\n}\nexport function isobject(o) {\n  return istype("object", o);\n}\nexport function isnumber(o) {\n  return istype("number", o);\n}\n//...\n\n\n本来，istype是一个接收多个参数的函数，但是被我们提前确定了第一个参数(isnull，isarray，isobject)，然后返回接受剩下参数的函数了。\n\n说到这儿，其实您大概也理解了柯里化的意思了吧，我大概的理解就是：降低函数的通用性，提高函数的专用性\n\n\n# 延迟计算\n\n另外，如果跟闭包技术结合的话，柯里化另外一个作用起到了一个提前确定参数，延迟计算的效果（比如我们得到的isnull，最后执行的时候取决于外界调用，但是只是事先的确定了expecttype）\n\n有的同学可能遇到过这个比较变态的面试题：\n\n// 实现一个`add`函数，要求能够达到一下效果\nadd(1)(2)(3)(4); // 10\nadd(1, 2)(3, 4); // 10\nadd(1)(2, 3, 4); // 10\nadd(1, 2, 3)(4); // 10\nadd(1, 2, 3, 4); // 10\n\n\n需要观察，add函数如果一下子传递4个参数的话，那么就可以直接算出结果了，如果只传递小于4个参数，它得到的是一个函数，并且，最终达到4个参数也会求值。\n\n发现了这个特点以后，代码就比较好写了:\n\nfunction _add(a, b, c, d) {\n  return a + b + c + d;\n}\n\n/**\n * 通用柯里化函数\n * @param {function} fn\n * @param  {any[]} outerargs\n * @returns\n */\nfunction currying(fn, ...outerargs) {\n  return function (...innerargs) {\n    const args = [...outerargs, ...innerargs];\n    // 如果参数已经确定完毕了，则执行传入的函数\n    if (args.length === fn.length) {\n      return fn.apply(this, args);\n    } else {\n      // 否则，将已经确定的参数绑定，递归调用currying\n      return currying(fn, ...args);\n    }\n  };\n}\n\nconst add = currying(_add);\n\n\n其实这个通用的柯里化函数看起来还是比较好理解的，首先，柯里化是不断的在为函数确定参数，为谁确定参数，那肯定是需要用户传入的函数，剩下的就是用户随意传递的参数了，用户传递的函数的参数个数是确定的，一旦参数确定完成了，那这个函数肯定就可以执行了；如果还没有确定完，因为要对外返回一个函数，最简单的办法就是递归调用当前这个处理流程。\n\n这个通用的柯里化函数也可以用来处理最开始我们的那个场景，如：\n\nexport function isnull(o) {\n  return currying(istype, "null")(o);\n}\nexport function isarray(o) {\n  return currying(istype, "array")(o);\n}\nexport function isobject(o) {\n  return currying(istype, "object")(o);\n}\nexport function isnumber(o) {\n  return currying(istype, "number")(o);\n}\n',charsets:{cjk:!0}},{title:"EventEmitter",frontmatter:{},regularPath:"/javascript/write/event-emitter.html",relativePath:"javascript/write/event-emitter.md",key:"v-1eba418f",path:"/javascript/write/event-emitter.html",headers:[{level:2,title:"EventEmitter",slug:"eventemitter",normalizedTitle:"eventemitter",charIndex:2}],headersStr:"EventEmitter",content:'# EventEmitter\n\nEventsEmitter准确说就是发布订阅模式。\n\n在实际开发中，它有着非常广泛的应用，比如可以用它结合Promise的API来做一些异步操作的通知，实现比较优雅的API设计。\n\n对于它，我们需要实现几个API\n\n * $on 监听指定频道，同一个频道可以多次监听\n * $once 监听指定频道一次，触发之后就终止监听\n * $off 停止指定频道的监听\n * $emit 触发某个频道的事件\n\n在DOM的removeEventListeners和addEventListeners其实就是用的这种思路，但是，需要注意的是removeEventListeners必须要传入在addEventListeners相同的handler，否则无法移除事件的监听。但是在有时候这样使用不是特别方便，为此，我将$off第二个参数设计成了可选参数，如果传入了则指定移除特定的handler，如果没有传，则移除当前频道的所有handler。\n\n代码实现如下：\n\nclass EventEmitter {\n  _map = new Map();\n\n  /**\n   * 触发一个事件\n   * @param {String} channel 触发的事件管道\n   * @param  {...any} args 参数列表\n   */\n  $emit(channel, ...args) {\n    const eventSets = this._map.get(channel);\n    if (!Array.isArray(eventSets)) {\n      return;\n    }\n    eventSets.forEach((f) => {\n      f.apply(this, args);\n    });\n  }\n\n  /**\n   * 单次监听事件\n   * @param {String} channel 监听事件的频道\n   * @param {Function} handler 监听事件的处理器\n   */\n  $once(channel, handler) {\n    this.$on(channel, handler, true);\n  }\n\n  /**\n   * 监听事件\n   * @param {String} channel 监听事件的频道\n   * @param {Function} handler 监听事件的处理器\n   * @param {boolean} once 是否仅监听一次\n   */\n  $on(channel, handler, once) {\n    let eventSets = this._map.get(channel);\n    if (!Array.isArray(eventSets)) {\n      eventSets = [];\n    }\n    if (!once) {\n      eventSets.push(handler);\n    } else {\n      const wrapperFunc = function(...args) {\n        handler.apply(this, args);\n        this.$off(channel, wrapperFunc);\n      };\n      eventSets.push(wrapperFunc);\n    }\n    this._map.set(channel, eventSets);\n  }\n\n  /**\n   * 移除事件监听\n   * @param {String} channel 移除监听事件的频道\n   * @param {Function} handler 移除监听事件的处理器\n   */\n  $off(channel, handler) {\n    let eventSets = this._map.get(channel);\n    if (!Array.isArray(eventSets)) {\n      console.warn("移除的事件频道不存在");\n      return;\n    }\n    // 如果不传递handler则移除该管道的所有监听\n    if (typeof handler !== "function") {\n      this._map.delete(channel);\n    } else {\n      // 否则只删除一个事件监听器\n      const delIdx = eventSets.findIndex((f) => f === handler);\n      if (delIdx < 0) {\n        console.warn("当前尚未设置此handler的监听");\n        return;\n      } else {\n        eventSets.splice(delIdx, 1);\n        this._map.set(channel, eventSets);\n      }\n    }\n  }\n}\n\n\n以下是测试用例：\n\nconst events = new EventEmitter();\n\nevents.$on("handleClick", (...args) => {\n  console.log("handleClick", args);\n});\n\nevents.$once("handleClick", (...args) => {\n  console.log("handleClick Once", args);\n});\n\nfunction handler(...args) {\n  console.log(args, "函数");\n}\n\nevents.$on("click", handler);\nevents.$once("click", handler);\nevents.$emit("handleClick", 1, 2, 3, 4, 5);\nevents.$emit("handleClick", 1, 2, 3, 4, 5);\nevents.$emit("click", 1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\nevents.$emit("click", 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, "second");\nevents.$off("click", handler);\nevents.$emit("click", 1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\nevents.$off("handleClick");\nevents.$emit("handleClick", 1, 2, 3, 4, 5);\n// handleClick (5) [1, 2, 3, 4, 5]\n// handleClick Once (5) [1, 2, 3, 4, 5]\n// handleClick (5) [1, 2, 3, 4, 5]\n// (10) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 函数\n// (10) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 函数\n// (11) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, \'second\'] 函数\n',normalizedContent:'# eventemitter\n\neventsemitter准确说就是发布订阅模式。\n\n在实际开发中，它有着非常广泛的应用，比如可以用它结合promise的api来做一些异步操作的通知，实现比较优雅的api设计。\n\n对于它，我们需要实现几个api\n\n * $on 监听指定频道，同一个频道可以多次监听\n * $once 监听指定频道一次，触发之后就终止监听\n * $off 停止指定频道的监听\n * $emit 触发某个频道的事件\n\n在dom的removeeventlisteners和addeventlisteners其实就是用的这种思路，但是，需要注意的是removeeventlisteners必须要传入在addeventlisteners相同的handler，否则无法移除事件的监听。但是在有时候这样使用不是特别方便，为此，我将$off第二个参数设计成了可选参数，如果传入了则指定移除特定的handler，如果没有传，则移除当前频道的所有handler。\n\n代码实现如下：\n\nclass eventemitter {\n  _map = new map();\n\n  /**\n   * 触发一个事件\n   * @param {string} channel 触发的事件管道\n   * @param  {...any} args 参数列表\n   */\n  $emit(channel, ...args) {\n    const eventsets = this._map.get(channel);\n    if (!array.isarray(eventsets)) {\n      return;\n    }\n    eventsets.foreach((f) => {\n      f.apply(this, args);\n    });\n  }\n\n  /**\n   * 单次监听事件\n   * @param {string} channel 监听事件的频道\n   * @param {function} handler 监听事件的处理器\n   */\n  $once(channel, handler) {\n    this.$on(channel, handler, true);\n  }\n\n  /**\n   * 监听事件\n   * @param {string} channel 监听事件的频道\n   * @param {function} handler 监听事件的处理器\n   * @param {boolean} once 是否仅监听一次\n   */\n  $on(channel, handler, once) {\n    let eventsets = this._map.get(channel);\n    if (!array.isarray(eventsets)) {\n      eventsets = [];\n    }\n    if (!once) {\n      eventsets.push(handler);\n    } else {\n      const wrapperfunc = function(...args) {\n        handler.apply(this, args);\n        this.$off(channel, wrapperfunc);\n      };\n      eventsets.push(wrapperfunc);\n    }\n    this._map.set(channel, eventsets);\n  }\n\n  /**\n   * 移除事件监听\n   * @param {string} channel 移除监听事件的频道\n   * @param {function} handler 移除监听事件的处理器\n   */\n  $off(channel, handler) {\n    let eventsets = this._map.get(channel);\n    if (!array.isarray(eventsets)) {\n      console.warn("移除的事件频道不存在");\n      return;\n    }\n    // 如果不传递handler则移除该管道的所有监听\n    if (typeof handler !== "function") {\n      this._map.delete(channel);\n    } else {\n      // 否则只删除一个事件监听器\n      const delidx = eventsets.findindex((f) => f === handler);\n      if (delidx < 0) {\n        console.warn("当前尚未设置此handler的监听");\n        return;\n      } else {\n        eventsets.splice(delidx, 1);\n        this._map.set(channel, eventsets);\n      }\n    }\n  }\n}\n\n\n以下是测试用例：\n\nconst events = new eventemitter();\n\nevents.$on("handleclick", (...args) => {\n  console.log("handleclick", args);\n});\n\nevents.$once("handleclick", (...args) => {\n  console.log("handleclick once", args);\n});\n\nfunction handler(...args) {\n  console.log(args, "函数");\n}\n\nevents.$on("click", handler);\nevents.$once("click", handler);\nevents.$emit("handleclick", 1, 2, 3, 4, 5);\nevents.$emit("handleclick", 1, 2, 3, 4, 5);\nevents.$emit("click", 1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\nevents.$emit("click", 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, "second");\nevents.$off("click", handler);\nevents.$emit("click", 1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\nevents.$off("handleclick");\nevents.$emit("handleclick", 1, 2, 3, 4, 5);\n// handleclick (5) [1, 2, 3, 4, 5]\n// handleclick once (5) [1, 2, 3, 4, 5]\n// handleclick (5) [1, 2, 3, 4, 5]\n// (10) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 函数\n// (10) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 函数\n// (11) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, \'second\'] 函数\n',charsets:{cjk:!0}},{title:"instanceof",frontmatter:{},regularPath:"/javascript/write/instanceof.html",relativePath:"javascript/write/instanceof.md",key:"v-6a3acd75",path:"/javascript/write/instanceof.html",headers:[{level:2,title:"instanceof",slug:"instanceof",normalizedTitle:"instanceof",charIndex:2}],headersStr:"instanceof",content:'# instanceof\n\ninstanceof 在实际开发中经常用来判断类型，语法是：\n\na instanceof b;\n\n\n如果a是b的实例，那么这个语句返回true，否则返回false。\n\n但是它有一个使用条件限制，参与运算的两个参数都必须是引用类型才可以。\n\nMDN 的原文如下：\n\n> instanceof 运算符用来检测constructor.prototype是否存在于参数object的原型链上。\n> \n> 参数 object，某个实例对象；\n> \n> 参数 constructor某个构造函数\n\ninstanceof的实现思路也特别简单，就是判断左边对象的原型链上是否存在右边的构造器的原型对象，有了这个思路，我们便可以很容易的写出来。\n\n/**\n * 判断一个对象o是否是ancestor的实例\n * @param {Object} o\n * @param {Object} ancestor\n */\nfunction MyInstanceOf(o, ancestor) {\n  // 左边参数必须是个引用类型\n  if (!isRef(o)) {\n    return false;\n  }\n  // 右边参数必须是个构造器\n  if (!ancestor || typeof ancestor.prototype !== "object") {\n    return false;\n  }\n  let proto = o.__proto__;\n  // 循环终止的条件是找到头了也没有找到\n  while (proto) {\n    // 如果找到了可以直接返回结果\n    if (proto === ancestor.prototype) {\n      return true;\n    }\n    // 向上迭代\n    proto = proto.__proto__;\n  }\n  return false;\n}\n\n/**\n * 判断o是否是引用类型\n * @param {Object} o\n * @returns\n */\nfunction isRef(o) {\n  return ["[object Object]", "[object Array]", "[object Function]"].includes(\n    Object.prototype.toString.call(o)\n  );\n}\n\n\n以下是测试用例:\n\nconsole.log(MyInstanceOf([], Array));\n\nconst o = {};\n\nconst parent = {};\n\nObject.setPrototypeOf(o, parent);\n\nconsole.log(MyInstanceOf(o, parent));\n\nclass A {}\n\nclass B extends A {}\n\nclass C extends B {}\n\nconst a = new A();\n\nconst c = new C();\n\nconsole.log(MyInstanceOf(a, A));\n\nconsole.log(MyInstanceOf(c, C));\n\nconsole.log(MyInstanceOf(c, B));\n\nconsole.log(MyInstanceOf(c, A));\n\n// true\n// false\n// true\n// true\n// true\n// true\n',normalizedContent:'# instanceof\n\ninstanceof 在实际开发中经常用来判断类型，语法是：\n\na instanceof b;\n\n\n如果a是b的实例，那么这个语句返回true，否则返回false。\n\n但是它有一个使用条件限制，参与运算的两个参数都必须是引用类型才可以。\n\nmdn 的原文如下：\n\n> instanceof 运算符用来检测constructor.prototype是否存在于参数object的原型链上。\n> \n> 参数 object，某个实例对象；\n> \n> 参数 constructor某个构造函数\n\ninstanceof的实现思路也特别简单，就是判断左边对象的原型链上是否存在右边的构造器的原型对象，有了这个思路，我们便可以很容易的写出来。\n\n/**\n * 判断一个对象o是否是ancestor的实例\n * @param {object} o\n * @param {object} ancestor\n */\nfunction myinstanceof(o, ancestor) {\n  // 左边参数必须是个引用类型\n  if (!isref(o)) {\n    return false;\n  }\n  // 右边参数必须是个构造器\n  if (!ancestor || typeof ancestor.prototype !== "object") {\n    return false;\n  }\n  let proto = o.__proto__;\n  // 循环终止的条件是找到头了也没有找到\n  while (proto) {\n    // 如果找到了可以直接返回结果\n    if (proto === ancestor.prototype) {\n      return true;\n    }\n    // 向上迭代\n    proto = proto.__proto__;\n  }\n  return false;\n}\n\n/**\n * 判断o是否是引用类型\n * @param {object} o\n * @returns\n */\nfunction isref(o) {\n  return ["[object object]", "[object array]", "[object function]"].includes(\n    object.prototype.tostring.call(o)\n  );\n}\n\n\n以下是测试用例:\n\nconsole.log(myinstanceof([], array));\n\nconst o = {};\n\nconst parent = {};\n\nobject.setprototypeof(o, parent);\n\nconsole.log(myinstanceof(o, parent));\n\nclass a {}\n\nclass b extends a {}\n\nclass c extends b {}\n\nconst a = new a();\n\nconst c = new c();\n\nconsole.log(myinstanceof(a, a));\n\nconsole.log(myinstanceof(c, c));\n\nconsole.log(myinstanceof(c, b));\n\nconsole.log(myinstanceof(c, a));\n\n// true\n// false\n// true\n// true\n// true\n// true\n',charsets:{cjk:!0}},{title:"Flatten",frontmatter:{},regularPath:"/javascript/write/flatten.html",relativePath:"javascript/write/flatten.md",key:"v-778a4b06",path:"/javascript/write/flatten.html",headers:[{level:2,title:"Flatten",slug:"flatten",normalizedTitle:"flatten",charIndex:2},{level:3,title:"0、直接toString",slug:"_0、直接tostring",normalizedTitle:"0、直接tostring",charIndex:193},{level:3,title:"1、正则替换",slug:"_1、正则替换",normalizedTitle:"1、正则替换",charIndex:455},{level:3,title:"2、DFS——递归实现",slug:"_2、dfs-递归实现",normalizedTitle:"2、dfs——递归实现",charIndex:1019},{level:3,title:"4、BFS",slug:"_4、bfs",normalizedTitle:"4、bfs",charIndex:2005}],headersStr:"Flatten 0、直接toString 1、正则替换 2、DFS——递归实现 4、BFS",content:'# Flatten\n\n这是一道携程的算法手写题。\n\n> 已知如下数组：\n> \n> const arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];\n> \n> 编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组\n\n本文就讨论一下如何拍平数组。\n\n\n# 0、直接toString\n\nMDN的阐述是:\n\n> toString() 方法返回一个字符串，表示指定的数组及其元素。Array对象覆盖了Object的toString方法。对于数组对象，toString方法在内部调用join() 方法拼接数组中的元素并返回一个字符串，其中包含用逗号分隔的每个数组元素。如果join方法不可用，或者它不是一个函数，将使用 Object.prototype.toString 代替，返回 [object Array]。\n\n缺点是很明显的，无法指定拍平的层级，也无法保留数据本来的类型\n\n\n# 1、正则替换\n\n正则替换也属于是比较naive的解法了，（而且使用这个解法的人可能根本还不知道toString的作用呢，哈哈哈，比如我，曾经面试美团的时候，第一面就是这题）如果我是一个面试官，求职者只会使用正则替换的话，假设满分100分，我觉得可以打30分。\n\n正则替换的思路非常简单，首先，数组看成一个字符串，然后，我们只需要替换里面的[，]即可。但是直接这样做的缺陷是非常明显的，要么最后得到的数据类型全部是string或者要么全部是number（挨个Number.parseInt），如果面试官要求你不要影响原来的数据类型的话，还得花一些功夫的。（也正是这一点，所以它还算比toString要好一些）\n\nfunction flatten(arr) {\n  const strArr = JSON.stringify(arr);\n  // 注意，正则表达式不要写错，我们需要全局替换空格或者\\[或者\\]，所以要将它们三个写成一个字符集\n  const tmpStr = strArr.replace(/[\\s\\[\\]]*/g, "");\n  // 使用eval可以保留数组原本的类型\n  return eval("[" + tmpStr + "]");\n}\n\n\n这个缺点也是非常明显的，无法做到指定拍平多少级的数组\n\n\n# 2、DFS——递归实现\n\n仅掌握前面两种解法同学绝大部分是没有系统的学过数据结构的人，其实这是一个常见的树形结构的应用。对于树形结构，一般会有两种解题思路，要么深度优先遍历（DFS），要么广度优先遍历（BFS）\n\n不使用reduce：\n\n/**\n * 拍平数组的方法\n * @param {number[]} arr 需要被拍平的深度\n * @param {number} maxDeep 最大拍平深度\n * @returns\n */\nfunction flatten2(arr, maxDeep) {\n  const flattenPass = [];\n  arr.forEach((v) => {\n    if (Array.isArray(v) && maxDeep > 0) {\n      flattenPass.push(...flatten2(v, maxDeep - 1));\n    } else {\n      flattenPass.push(v);\n    }\n  });\n  return flattenPass;\n}\n\n\n如果你在面试中很快就使用递归完成了的话，那么面试官肯定会问你有没有改进的空间，上述代码看起来还是有那么一点儿丑的，使用reduce的话，看起来就会优雅许多。\n\n使用reduce：\n\n/**\n * 拍平数组的方法\n * @param {number[]} arr 需要被拍平的深度\n * @param {number} maxDeep 最大拍平深度\n * @returns\n */\nfunction flatten3(arr, maxDeep) {\n  return arr.reduce((total, cur) => {\n    // 为什么concat的是[cur]呢，因为，如果cur是数组，concat会给抹平，而给它包上这一次就可以防止它被抹平，才能跟最大拍平深度对应的上\n    return total.concat(\n      Array.isArray(cur) && maxDeep > 0 ? flatten3(cur, maxDeep - 1) : [cur]\n    );\n  }, []);\n}\n\n\n确实，使用reduce的代码看起来非常简洁。\n\n上述的实现是实际开发中最好的实现。\n\n\n# 4、BFS\n\n广度优先遍历实现思路比较简单，但是需要考虑层级的问题，就需要额外的处理。\n\n广度优先遍历是有一个标准的范式的，如果对此有不太清楚的同学可以查看我算法相关的博客。这个场景，我们需要知道当前处理的层级，最简单的办法就是把层级和节点值放在一起，这样在取出值进行处理的时候一下子就可以知道它所处的层级了。另外稍微复杂一点儿的办法还可以用Map建立引用关系，处理起来要复杂的多，因此示例就没有采用这种办法。\n\n/**\n * 拍平数组的方法\n * @param {number[]} arr 需要被拍平的深度\n * @param {number} maxDeep 最大拍平深度\n * @returns\n */\nfunction flatten5(arr, maxDepth) {\n  const results = [];\n  const queue = [];\n  arr.forEach((v) => {\n    // 在处理第一层的时候将其标记为第0层\n    queue.push({\n      val: v,\n      depth: 0,\n    });\n  });\n  while (queue.length) {\n    const node = queue.shift();\n    const { val, depth } = node;\n    // 如果当前节点需要处理，并且还没有到最大处理层数，则可继续处理，否则直接忽略\n    if (Array.isArray(val) && depth < maxDepth) {\n      val.forEach((sub) => {\n        queue.push({\n          val: sub,\n          depth: depth + 1,\n        });\n      });\n    } else {\n      results.push(val);\n    }\n  }\n  return results;\n}\n\n\n另外，广度优先遍历处理结果，数据元素的相对位置可能是非预期的。',normalizedContent:'# flatten\n\n这是一道携程的算法手写题。\n\n> 已知如下数组：\n> \n> const arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];\n> \n> 编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组\n\n本文就讨论一下如何拍平数组。\n\n\n# 0、直接tostring\n\nmdn的阐述是:\n\n> tostring() 方法返回一个字符串，表示指定的数组及其元素。array对象覆盖了object的tostring方法。对于数组对象，tostring方法在内部调用join() 方法拼接数组中的元素并返回一个字符串，其中包含用逗号分隔的每个数组元素。如果join方法不可用，或者它不是一个函数，将使用 object.prototype.tostring 代替，返回 [object array]。\n\n缺点是很明显的，无法指定拍平的层级，也无法保留数据本来的类型\n\n\n# 1、正则替换\n\n正则替换也属于是比较naive的解法了，（而且使用这个解法的人可能根本还不知道tostring的作用呢，哈哈哈，比如我，曾经面试美团的时候，第一面就是这题）如果我是一个面试官，求职者只会使用正则替换的话，假设满分100分，我觉得可以打30分。\n\n正则替换的思路非常简单，首先，数组看成一个字符串，然后，我们只需要替换里面的[，]即可。但是直接这样做的缺陷是非常明显的，要么最后得到的数据类型全部是string或者要么全部是number（挨个number.parseint），如果面试官要求你不要影响原来的数据类型的话，还得花一些功夫的。（也正是这一点，所以它还算比tostring要好一些）\n\nfunction flatten(arr) {\n  const strarr = json.stringify(arr);\n  // 注意，正则表达式不要写错，我们需要全局替换空格或者\\[或者\\]，所以要将它们三个写成一个字符集\n  const tmpstr = strarr.replace(/[\\s\\[\\]]*/g, "");\n  // 使用eval可以保留数组原本的类型\n  return eval("[" + tmpstr + "]");\n}\n\n\n这个缺点也是非常明显的，无法做到指定拍平多少级的数组\n\n\n# 2、dfs——递归实现\n\n仅掌握前面两种解法同学绝大部分是没有系统的学过数据结构的人，其实这是一个常见的树形结构的应用。对于树形结构，一般会有两种解题思路，要么深度优先遍历（dfs），要么广度优先遍历（bfs）\n\n不使用reduce：\n\n/**\n * 拍平数组的方法\n * @param {number[]} arr 需要被拍平的深度\n * @param {number} maxdeep 最大拍平深度\n * @returns\n */\nfunction flatten2(arr, maxdeep) {\n  const flattenpass = [];\n  arr.foreach((v) => {\n    if (array.isarray(v) && maxdeep > 0) {\n      flattenpass.push(...flatten2(v, maxdeep - 1));\n    } else {\n      flattenpass.push(v);\n    }\n  });\n  return flattenpass;\n}\n\n\n如果你在面试中很快就使用递归完成了的话，那么面试官肯定会问你有没有改进的空间，上述代码看起来还是有那么一点儿丑的，使用reduce的话，看起来就会优雅许多。\n\n使用reduce：\n\n/**\n * 拍平数组的方法\n * @param {number[]} arr 需要被拍平的深度\n * @param {number} maxdeep 最大拍平深度\n * @returns\n */\nfunction flatten3(arr, maxdeep) {\n  return arr.reduce((total, cur) => {\n    // 为什么concat的是[cur]呢，因为，如果cur是数组，concat会给抹平，而给它包上这一次就可以防止它被抹平，才能跟最大拍平深度对应的上\n    return total.concat(\n      array.isarray(cur) && maxdeep > 0 ? flatten3(cur, maxdeep - 1) : [cur]\n    );\n  }, []);\n}\n\n\n确实，使用reduce的代码看起来非常简洁。\n\n上述的实现是实际开发中最好的实现。\n\n\n# 4、bfs\n\n广度优先遍历实现思路比较简单，但是需要考虑层级的问题，就需要额外的处理。\n\n广度优先遍历是有一个标准的范式的，如果对此有不太清楚的同学可以查看我算法相关的博客。这个场景，我们需要知道当前处理的层级，最简单的办法就是把层级和节点值放在一起，这样在取出值进行处理的时候一下子就可以知道它所处的层级了。另外稍微复杂一点儿的办法还可以用map建立引用关系，处理起来要复杂的多，因此示例就没有采用这种办法。\n\n/**\n * 拍平数组的方法\n * @param {number[]} arr 需要被拍平的深度\n * @param {number} maxdeep 最大拍平深度\n * @returns\n */\nfunction flatten5(arr, maxdepth) {\n  const results = [];\n  const queue = [];\n  arr.foreach((v) => {\n    // 在处理第一层的时候将其标记为第0层\n    queue.push({\n      val: v,\n      depth: 0,\n    });\n  });\n  while (queue.length) {\n    const node = queue.shift();\n    const { val, depth } = node;\n    // 如果当前节点需要处理，并且还没有到最大处理层数，则可继续处理，否则直接忽略\n    if (array.isarray(val) && depth < maxdepth) {\n      val.foreach((sub) => {\n        queue.push({\n          val: sub,\n          depth: depth + 1,\n        });\n      });\n    } else {\n      results.push(val);\n    }\n  }\n  return results;\n}\n\n\n另外，广度优先遍历处理结果，数据元素的相对位置可能是非预期的。',charsets:{cjk:!0}},{title:"JSONP",frontmatter:{},regularPath:"/javascript/write/jsonp.html",relativePath:"javascript/write/jsonp.md",key:"v-20d19b16",path:"/javascript/write/jsonp.html",headers:[{level:2,title:"JSONP",slug:"jsonp",normalizedTitle:"jsonp",charIndex:2}],headersStr:"JSONP",content:'# JSONP\n\n一种古老的跨域方式，兼容性比较好，但是只支持GET形式的请求。\n\njsonp的实现思路跟XMLHttpRequest没有任何关系，其实现思路利用的是普通资源加载的思路（这也就是为什么jsonp只支持GET请求方式的原因）\n\n首先，我们要根据用户传递的数据，将其拼接在URL上，还要在URL上指定一个key叫做jsonpCallback的查询字符串，值是一个任意的值，但是你得将这个值记录下来（jsonpCallback这个名字是一个约定，不能写成别的名字)，服务器会根据我们传递的参数以及jsonpCallback的值，给我们返回一段文本，这段文本的内容如下(假设我们传递的jsonpCallback的值为response，假设此次服务端需要返回10个数值给我们)：\n\nresponse(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n\n\n而，我们将这段文本以JavaScript去解析，就好比是在window上调用了一个叫做response的函数（为什么说之前要将设置的jsonpCallback的值给记录下来，原因如此）。\n\n所以，通用的JSONP函数实现如下：（基于Promise实现）\n\n(function (window, document) {\n  "use strict";\n  let jsonp = function (url, data) {\n    return new Promise((resolve, reject) => {\n      // 1.将传入的data数据转化为url字符串形式\n      let dataString = url.indexOf("?") == -1 ? "?" : "&";\n      for (let key in data) {\n        dataString += key + "=" + data[key] + "&";\n      }\n      // 2 处理url中的回调函数\n      // cbFuncName回调函数的名字 ：my_json_cb_名字的前缀 + 随机数（把小数点去掉）\n      let cbFuncName =\n        "my_json_cb_" + Math.random().toString().replace(".", "");\n      dataString += "jsonpCallback=" + cbFuncName;\n      // 3.创建一个script标签并插入到页面中\n      let scriptEle = document.createElement("script");\n      scriptEle.src = encodeURI(url + dataString);\n      // 4.挂载回调函数\n      window[cbFuncName] = function (data) {\n        resolve(data);\n        // 处理完回调函数的数据之后，删除jsonp的script标签\n        document.body.removeChild(scriptEle);\n      };\n      scriptEle.onerror = reject;\n      document.body.appendChild(scriptEle);\n    });\n  };\n  window.$jsonp = jsonp;\n})(window, document);\n',normalizedContent:'# jsonp\n\n一种古老的跨域方式，兼容性比较好，但是只支持get形式的请求。\n\njsonp的实现思路跟xmlhttprequest没有任何关系，其实现思路利用的是普通资源加载的思路（这也就是为什么jsonp只支持get请求方式的原因）\n\n首先，我们要根据用户传递的数据，将其拼接在url上，还要在url上指定一个key叫做jsonpcallback的查询字符串，值是一个任意的值，但是你得将这个值记录下来（jsonpcallback这个名字是一个约定，不能写成别的名字)，服务器会根据我们传递的参数以及jsonpcallback的值，给我们返回一段文本，这段文本的内容如下(假设我们传递的jsonpcallback的值为response，假设此次服务端需要返回10个数值给我们)：\n\nresponse(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n\n\n而，我们将这段文本以javascript去解析，就好比是在window上调用了一个叫做response的函数（为什么说之前要将设置的jsonpcallback的值给记录下来，原因如此）。\n\n所以，通用的jsonp函数实现如下：（基于promise实现）\n\n(function (window, document) {\n  "use strict";\n  let jsonp = function (url, data) {\n    return new promise((resolve, reject) => {\n      // 1.将传入的data数据转化为url字符串形式\n      let datastring = url.indexof("?") == -1 ? "?" : "&";\n      for (let key in data) {\n        datastring += key + "=" + data[key] + "&";\n      }\n      // 2 处理url中的回调函数\n      // cbfuncname回调函数的名字 ：my_json_cb_名字的前缀 + 随机数（把小数点去掉）\n      let cbfuncname =\n        "my_json_cb_" + math.random().tostring().replace(".", "");\n      datastring += "jsonpcallback=" + cbfuncname;\n      // 3.创建一个script标签并插入到页面中\n      let scriptele = document.createelement("script");\n      scriptele.src = encodeuri(url + datastring);\n      // 4.挂载回调函数\n      window[cbfuncname] = function (data) {\n        resolve(data);\n        // 处理完回调函数的数据之后，删除jsonp的script标签\n        document.body.removechild(scriptele);\n      };\n      scriptele.onerror = reject;\n      document.body.appendchild(scriptele);\n    });\n  };\n  window.$jsonp = jsonp;\n})(window, document);\n',charsets:{cjk:!0}},{title:"设计LazyMan类",frontmatter:{},regularPath:"/javascript/write/lazy-man.html",relativePath:"javascript/write/lazy-man.md",key:"v-2e578055",path:"/javascript/write/lazy-man.html",headers:[{level:2,title:"设计LazyMan类",slug:"设计lazyman类",normalizedTitle:"设计lazyman类",charIndex:2},{level:3,title:"1、要求",slug:"_1、要求",normalizedTitle:"1、要求",charIndex:17},{level:3,title:"2、分析",slug:"_2、分析",normalizedTitle:"2、分析",charIndex:513},{level:3,title:"3、递归实现",slug:"_3、递归实现",normalizedTitle:"3、递归实现",charIndex:2295},{level:3,title:"4、迭代实现",slug:"_4、迭代实现",normalizedTitle:"4、迭代实现",charIndex:4180},{level:3,title:"5、测试用例",slug:"_5、测试用例",normalizedTitle:"5、测试用例",charIndex:6043}],headersStr:"设计LazyMan类 1、要求 2、分析 3、递归实现 4、迭代实现 5、测试用例",content:'# 设计LazyMan类\n\n\n# 1、要求\n\n设计一个LazyMan函数，能够满足一下输出：\n\nLazyMan("Tony");\n// Hi I am Tony\n\nLazyMan("Tony").sleep(10).eat("lunch");\n// Hi I am Tony\n// 等待了10秒...\n// I am eating lunch\n\nLazyMan("Tony").eat("lunch").sleep(10).eat("dinner");\n// Hi I am Tony\n// I am eating lunch\n// 等待了10秒...\n// I am eating diner\n\nLazyMan("Tony")\n  .eat("lunch")\n  .eat("dinner")\n  .sleepFirst(5)\n  .sleep(10)\n  .eat("junk food");\n// Hi I am Tony\n// 等待了5秒...\n// I am eating lunch\n// I am eating dinner\n// 等待了10秒...\n// I am eating junk food\n\n\n\n# 2、分析\n\n首先观察，调用构造函数（因为我为了jest测试方便，本文以一个类的形式实现的）或者调用eat方法，看起来(实际上，另说嘛)好像是立即输出了内容，调用sleetFirst需要先进行等待然后才可以执行eat的内容，调用sleep看起来就是一个普通的延迟任务，不会导致eat的执行顺序改变。\n\n这个实现的难点在于第三个测试用例，连续调用了两次eat方法，但是一旦调用了sleetFirst方法，反而先执行的是等待，根据事件轮询常考的知识点，可以一下就有一个大概的思路，eat方法肯定不是在同步代码执行的，如果是在setTimeout(() => {}, 0) 这样的宏任务执行的话，那就说得通了，因为连续调用 2次eat都在执行同步代码，调用sleepFirst也是同步代码，下一个事件轮循真正开始干活儿，并且eat方法在调用前每次都要先清空定时器。\n\n这类异步问题，99%都是基于队列来实现的。\n\n另外，可以看到的是，sleepFirst优先级明显要高于eat和sleep，那么，有了权重的概念，本文是可以用堆来实现的。\n\n如果不用堆来做的话，那就用2个队列（不过，如果后续需要增加不同权重的任务类型，那代码就得修改成基于堆实现，这是跑不掉的），所以，本着满足简单，本文就不以堆来实现了。\n\n大概描绘一下实现思路，每个操作都产生一个Promise，优先级高的加到高优先级队列里，优先级低的加到普通队列里，开始执行的时候，根据优先级取出所有的任务组合成一个新队列（原来的也要清空），利用这个新队列构建一个Promise链，上一个Promise状态改变才能执行下一个异步任务。\n\n构建Promise链也就是这个题目的核心，也是刷这道面试题的实际意义，如果你看过axios的源码的话，就明白怎么做，axios的拦截器就是用的是Promise链处理的\n\n构建Promise链使用递归的实现非常简单的，其原理就跟async的编译结果差不多：\n\n/**\n * @params { Array<Task> } 任务队列\n */\nfunction fn(list) {\n  if (list.length <= 0) {\n    return;\n  }\n  const task = list.shift();\n  task().then(fn);\n}\n\n\n用迭代来做的话，这个操作就比较难懂了：\n\nfunction build(list) {\n  // 定义一个用于开始迭代的Promise，其实也是为了方便编程\n  let p = Promise.resolve();\n  // 不处理完成所有的异步任务不结束\n  while (list.length) {\n    // 取出一个任务\n    const task = list.shift();\n    // 将当前的task部署在上一个Promise的then方法上，令p = p.then(task)，\n    // 相当于得到了task()执行返回的结果，从而可以在同步的代码中部署出一个Promise链。\n    // 需要注意的是，这个时刻只是部署，至于触发，还是得等到任务节点的状态改变，\n    // 这个写法就是axios源码中对拦截器管理的实现\n    p = p.then(task);\n  }\n}\n\n\n这个实现，一定不要朝着首先取出一个任务节点，再取出一个节点，两个节点进行关联这种思路做，因为第二个否则会越走越远了。\n\n以下是错误的实现：\n\nfunction build(list) {\n  const task = list.shift();\n  while (task) {\n    const nextTask = list.shift();\n    if (nextTask) {\n      // 很明显，此刻的nextTask已经部署了\n      task().then(nextTask);\n    } else {\n      task();\n    }\n    // 如果将nextTask交给task，下轮循环进来的时候，task执行就执行了，\n    // 那就会出现后面的任务跑到前面任务执行的错误\n    task = nextTask;\n  }\n}\n\n\n\n# 3、递归实现\n\nexport class LazyMan {\n  private emergencyQueue: Array<() => Promise<void>> = [];\n\n  private normalQueue: Array<() => Promise<void>> = [];\n\n  private timer: NodeJS.Timeout | null = null;\n\n  done: null | Function = null;\n\n  constructor(name: string) {\n    console.log("Hi I am " + name);\n  }\n\n  private wrapperAwaitTask(second: number) {\n    return (msg: string) =>\n      new Promise<void>((resolve) => {\n        setTimeout(() => {\n          if (msg) {\n            console.log(msg);\n          }\n          resolve();\n        }, second * 1000);\n      });\n  }\n\n  setFinish(fn: Function) {\n    // 这个方法是给Jest用的，可以无需关心\n    this.done = fn;\n  }\n\n  sleepFirst(second: number) {\n    const task = this.wrapperAwaitTask(second);\n    this.emergencyQueue.push(() => task("等待了" + second + "秒..."));\n    return this;\n  }\n\n  sleep(second: number) {\n    const task = this.wrapperAwaitTask(second);\n    this.normalQueue.push(() => task("等待了" + second + "秒..."));\n    return this;\n  }\n\n  private run() {\n    this.timer = null;\n    const queue: Array<() => Promise<void>> = [\n      ...this.emergencyQueue,\n      ...this.normalQueue,\n      // 这个任务也是给Jest通知异步任务完成的，不用Jest做测试可以忽略这个函数\n      async () => {\n        this.done && this.done();\n        this.done = null;\n      },\n    ];\n    this.emergencyQueue.length = 0;\n    // this.emergencyQueue = [];\n    this.normalQueue.length = 0;\n    // this.normalQueue = [];\n    const fn = () => {\n      if (queue.length <= 0) {\n        return;\n      }\n      const task = queue.shift();\n      task!().then(() => {\n        fn();\n      });\n    };\n    fn();\n  }\n\n  eat(meal: string) {\n    if (this.timer) {\n      clearTimeout(this.timer);\n      this.timer = null;\n    }\n    const task = this.wrapperAwaitTask(0);\n    this.normalQueue.push(() => task("I am eating " + meal));\n    this.timer = setTimeout(() => {\n      this.run();\n    }, 0);\n    return this;\n  }\n}\n\n\n\n# 4、迭代实现\n\nexport class LazyMan {\n  private emergencyQueue: Array<() => Promise<void>> = [];\n\n  private normalQueue: Array<() => Promise<void>> = [];\n\n  private timer: NodeJS.Timeout | null = null;\n\n  done: null | Function = null;\n\n  constructor(name: string) {\n    console.log("Hi I am " + name);\n  }\n\n  private wrapperAwaitTask(second: number) {\n    return (msg: string) =>\n      new Promise<void>((resolve) => {\n        setTimeout(() => {\n          if (msg) {\n            console.log(msg);\n          }\n          resolve();\n        }, second * 1000);\n      });\n  }\n\n  setFinish(fn: Function) {\n    this.done = fn;\n  }\n\n  sleepFirst(second: number) {\n    const task = this.wrapperAwaitTask(second);\n    this.emergencyQueue.push(() => task("等待了" + second + "秒..."));\n    return this;\n  }\n\n  sleep(second: number) {\n    const task = this.wrapperAwaitTask(second);\n    this.normalQueue.push(() => task("等待了" + second + "秒..."));\n    return this;\n  }\n\n  private run() {\n    const queue: Array<() => Promise<void>> = [\n      ...this.emergencyQueue,\n      ...this.normalQueue,\n      async () => {\n        this.done && this.done();\n        this.done = null;\n      },\n    ];\n    // 此处可以采用这种变通的方法清空数组，因为这个跟框架无关，不需要关心数据的响应式，如果在Vue框架内，就不能用这种写法了，数组无法监听改变\n    this.emergencyQueue.length = 0;\n    // this.emergencyQueue = [];\n    this.normalQueue.length = 0;\n    // this.normalQueue = [];\n\n    // 此处是在构建Promise链\n    let p = Promise.resolve();\n    while (queue.length) {\n      const task = queue.shift();\n      p = p.then(() => {\n        return task!();\n      });\n    }\n  }\n\n  eat(meal: string) {\n    if (this.timer) {\n      clearTimeout(this.timer);\n      this.timer = null;\n    }\n    const task = this.wrapperAwaitTask(0);\n    this.normalQueue.push(() => task("I am eating " + meal));\n    this.timer = setTimeout(() => {\n      this.run();\n    }, 0);\n    return this;\n  }\n}\n\n\n\n# 5、测试用例\n\nimport { LazyMan } from "./LazyMan";\n\ndescribe("lazy man design", () => {\n  it("case 1", (done) => {\n    const man = new LazyMan("Tony");\n    man.setFinish(done);\n    man.sleep(10).eat("lunch");\n  }, 100000);\n\n  it("case 2", (done) => {\n    const man = new LazyMan("Tony");\n    man.setFinish(done);\n    man.eat("lunch").sleep(10).eat("dinner");\n  }, 100000);\n\n  it("case 3", (done) => {\n    const man = new LazyMan("Tony");\n    man.setFinish(done);\n    man.eat("lunch").eat("dinner").sleepFirst(5).sleep(10).eat("junk food");\n  }, 100000);\n});\n',normalizedContent:'# 设计lazyman类\n\n\n# 1、要求\n\n设计一个lazyman函数，能够满足一下输出：\n\nlazyman("tony");\n// hi i am tony\n\nlazyman("tony").sleep(10).eat("lunch");\n// hi i am tony\n// 等待了10秒...\n// i am eating lunch\n\nlazyman("tony").eat("lunch").sleep(10).eat("dinner");\n// hi i am tony\n// i am eating lunch\n// 等待了10秒...\n// i am eating diner\n\nlazyman("tony")\n  .eat("lunch")\n  .eat("dinner")\n  .sleepfirst(5)\n  .sleep(10)\n  .eat("junk food");\n// hi i am tony\n// 等待了5秒...\n// i am eating lunch\n// i am eating dinner\n// 等待了10秒...\n// i am eating junk food\n\n\n\n# 2、分析\n\n首先观察，调用构造函数（因为我为了jest测试方便，本文以一个类的形式实现的）或者调用eat方法，看起来(实际上，另说嘛)好像是立即输出了内容，调用sleetfirst需要先进行等待然后才可以执行eat的内容，调用sleep看起来就是一个普通的延迟任务，不会导致eat的执行顺序改变。\n\n这个实现的难点在于第三个测试用例，连续调用了两次eat方法，但是一旦调用了sleetfirst方法，反而先执行的是等待，根据事件轮询常考的知识点，可以一下就有一个大概的思路，eat方法肯定不是在同步代码执行的，如果是在settimeout(() => {}, 0) 这样的宏任务执行的话，那就说得通了，因为连续调用 2次eat都在执行同步代码，调用sleepfirst也是同步代码，下一个事件轮循真正开始干活儿，并且eat方法在调用前每次都要先清空定时器。\n\n这类异步问题，99%都是基于队列来实现的。\n\n另外，可以看到的是，sleepfirst优先级明显要高于eat和sleep，那么，有了权重的概念，本文是可以用堆来实现的。\n\n如果不用堆来做的话，那就用2个队列（不过，如果后续需要增加不同权重的任务类型，那代码就得修改成基于堆实现，这是跑不掉的），所以，本着满足简单，本文就不以堆来实现了。\n\n大概描绘一下实现思路，每个操作都产生一个promise，优先级高的加到高优先级队列里，优先级低的加到普通队列里，开始执行的时候，根据优先级取出所有的任务组合成一个新队列（原来的也要清空），利用这个新队列构建一个promise链，上一个promise状态改变才能执行下一个异步任务。\n\n构建promise链也就是这个题目的核心，也是刷这道面试题的实际意义，如果你看过axios的源码的话，就明白怎么做，axios的拦截器就是用的是promise链处理的\n\n构建promise链使用递归的实现非常简单的，其原理就跟async的编译结果差不多：\n\n/**\n * @params { array<task> } 任务队列\n */\nfunction fn(list) {\n  if (list.length <= 0) {\n    return;\n  }\n  const task = list.shift();\n  task().then(fn);\n}\n\n\n用迭代来做的话，这个操作就比较难懂了：\n\nfunction build(list) {\n  // 定义一个用于开始迭代的promise，其实也是为了方便编程\n  let p = promise.resolve();\n  // 不处理完成所有的异步任务不结束\n  while (list.length) {\n    // 取出一个任务\n    const task = list.shift();\n    // 将当前的task部署在上一个promise的then方法上，令p = p.then(task)，\n    // 相当于得到了task()执行返回的结果，从而可以在同步的代码中部署出一个promise链。\n    // 需要注意的是，这个时刻只是部署，至于触发，还是得等到任务节点的状态改变，\n    // 这个写法就是axios源码中对拦截器管理的实现\n    p = p.then(task);\n  }\n}\n\n\n这个实现，一定不要朝着首先取出一个任务节点，再取出一个节点，两个节点进行关联这种思路做，因为第二个否则会越走越远了。\n\n以下是错误的实现：\n\nfunction build(list) {\n  const task = list.shift();\n  while (task) {\n    const nexttask = list.shift();\n    if (nexttask) {\n      // 很明显，此刻的nexttask已经部署了\n      task().then(nexttask);\n    } else {\n      task();\n    }\n    // 如果将nexttask交给task，下轮循环进来的时候，task执行就执行了，\n    // 那就会出现后面的任务跑到前面任务执行的错误\n    task = nexttask;\n  }\n}\n\n\n\n# 3、递归实现\n\nexport class lazyman {\n  private emergencyqueue: array<() => promise<void>> = [];\n\n  private normalqueue: array<() => promise<void>> = [];\n\n  private timer: nodejs.timeout | null = null;\n\n  done: null | function = null;\n\n  constructor(name: string) {\n    console.log("hi i am " + name);\n  }\n\n  private wrapperawaittask(second: number) {\n    return (msg: string) =>\n      new promise<void>((resolve) => {\n        settimeout(() => {\n          if (msg) {\n            console.log(msg);\n          }\n          resolve();\n        }, second * 1000);\n      });\n  }\n\n  setfinish(fn: function) {\n    // 这个方法是给jest用的，可以无需关心\n    this.done = fn;\n  }\n\n  sleepfirst(second: number) {\n    const task = this.wrapperawaittask(second);\n    this.emergencyqueue.push(() => task("等待了" + second + "秒..."));\n    return this;\n  }\n\n  sleep(second: number) {\n    const task = this.wrapperawaittask(second);\n    this.normalqueue.push(() => task("等待了" + second + "秒..."));\n    return this;\n  }\n\n  private run() {\n    this.timer = null;\n    const queue: array<() => promise<void>> = [\n      ...this.emergencyqueue,\n      ...this.normalqueue,\n      // 这个任务也是给jest通知异步任务完成的，不用jest做测试可以忽略这个函数\n      async () => {\n        this.done && this.done();\n        this.done = null;\n      },\n    ];\n    this.emergencyqueue.length = 0;\n    // this.emergencyqueue = [];\n    this.normalqueue.length = 0;\n    // this.normalqueue = [];\n    const fn = () => {\n      if (queue.length <= 0) {\n        return;\n      }\n      const task = queue.shift();\n      task!().then(() => {\n        fn();\n      });\n    };\n    fn();\n  }\n\n  eat(meal: string) {\n    if (this.timer) {\n      cleartimeout(this.timer);\n      this.timer = null;\n    }\n    const task = this.wrapperawaittask(0);\n    this.normalqueue.push(() => task("i am eating " + meal));\n    this.timer = settimeout(() => {\n      this.run();\n    }, 0);\n    return this;\n  }\n}\n\n\n\n# 4、迭代实现\n\nexport class lazyman {\n  private emergencyqueue: array<() => promise<void>> = [];\n\n  private normalqueue: array<() => promise<void>> = [];\n\n  private timer: nodejs.timeout | null = null;\n\n  done: null | function = null;\n\n  constructor(name: string) {\n    console.log("hi i am " + name);\n  }\n\n  private wrapperawaittask(second: number) {\n    return (msg: string) =>\n      new promise<void>((resolve) => {\n        settimeout(() => {\n          if (msg) {\n            console.log(msg);\n          }\n          resolve();\n        }, second * 1000);\n      });\n  }\n\n  setfinish(fn: function) {\n    this.done = fn;\n  }\n\n  sleepfirst(second: number) {\n    const task = this.wrapperawaittask(second);\n    this.emergencyqueue.push(() => task("等待了" + second + "秒..."));\n    return this;\n  }\n\n  sleep(second: number) {\n    const task = this.wrapperawaittask(second);\n    this.normalqueue.push(() => task("等待了" + second + "秒..."));\n    return this;\n  }\n\n  private run() {\n    const queue: array<() => promise<void>> = [\n      ...this.emergencyqueue,\n      ...this.normalqueue,\n      async () => {\n        this.done && this.done();\n        this.done = null;\n      },\n    ];\n    // 此处可以采用这种变通的方法清空数组，因为这个跟框架无关，不需要关心数据的响应式，如果在vue框架内，就不能用这种写法了，数组无法监听改变\n    this.emergencyqueue.length = 0;\n    // this.emergencyqueue = [];\n    this.normalqueue.length = 0;\n    // this.normalqueue = [];\n\n    // 此处是在构建promise链\n    let p = promise.resolve();\n    while (queue.length) {\n      const task = queue.shift();\n      p = p.then(() => {\n        return task!();\n      });\n    }\n  }\n\n  eat(meal: string) {\n    if (this.timer) {\n      cleartimeout(this.timer);\n      this.timer = null;\n    }\n    const task = this.wrapperawaittask(0);\n    this.normalqueue.push(() => task("i am eating " + meal));\n    this.timer = settimeout(() => {\n      this.run();\n    }, 0);\n    return this;\n  }\n}\n\n\n\n# 5、测试用例\n\nimport { lazyman } from "./lazyman";\n\ndescribe("lazy man design", () => {\n  it("case 1", (done) => {\n    const man = new lazyman("tony");\n    man.setfinish(done);\n    man.sleep(10).eat("lunch");\n  }, 100000);\n\n  it("case 2", (done) => {\n    const man = new lazyman("tony");\n    man.setfinish(done);\n    man.eat("lunch").sleep(10).eat("dinner");\n  }, 100000);\n\n  it("case 3", (done) => {\n    const man = new lazyman("tony");\n    man.setfinish(done);\n    man.eat("lunch").eat("dinner").sleepfirst(5).sleep(10).eat("junk food");\n  }, 100000);\n});\n',charsets:{cjk:!0}},{title:"Map",frontmatter:{},regularPath:"/javascript/write/map-and-set.html",relativePath:"javascript/write/map-and-set.md",key:"v-bfa91d62",path:"/javascript/write/map-and-set.html",headers:[{level:2,title:"Map",slug:"map",normalizedTitle:"map",charIndex:2},{level:2,title:"Set",slug:"set",normalizedTitle:"set",charIndex:6013}],headersStr:"Map Set",content:'# Map\n\nES6的Map相比于ES5以前使用对象做哈希映射，功能要强大的多。\n\n使用对象做哈希有一个天生的劣势，只能支持String类型的Key(ES6以后，可以支持Symbol类型的Key)，如果传入的数据不是String类型，会被强制转换成String，在有些时候就比较鸡肋了，所以使用Map是最好的选择。\n\n使用ES5实现Map就只能使用数组来进行存储，需要维持Map的Key列表和Value列表关心，在每次查找的过程中，通过数组方法的全等比较，同时，还要注意NaN这个特殊类型的处理（在ES6中，多次向Map添加Key为NaN的值，仅会视为一条记录）。\n\n需要注意的点是，如果实现过程中需要用缓存Key来提高使用效率的话，因为Map键的特殊性，必须要使用一个内部的哨兵对象来初始化它的值，不能使用null，也不能使用undefined。\n\n最后，只需要按照规格实现Map的迭代器即可。\n\n以下是一个ES6环境下Map的实现，但是因为Symbol的唯一值特性，所以无法支持使用Symbol作为Key的场景。\n\nconst map = new MyMap();\nconst s = Symbol("map");\nmap.set(s, "hello world");\nmap.get(s); // undefined\n\n\n主要原因就是在比较Key的时候，Symbol既无法像普通对象那样比较地址，也无法像基础类型变量那样比较值，所导致的。\n\nfunction GenerateIterator(keys, values, selector) {\n  const SentinelArray = [];\n\n  const render = (key, value) => {\n    return {\n      key,\n      value,\n    };\n  };\n\n  class MyMapIterator {\n    _index = -1;\n\n    _keys = SentinelArray;\n\n    _values = SentinelArray;\n\n    _selector = render;\n\n    [Symbol.iterator]() {\n      return this;\n    }\n\n    constructor(keys, values, selector) {\n      this._keys = keys;\n      this._values = values;\n      this._index = 0;\n      this._selector = selector || render;\n    }\n\n    next() {\n      var index = this._index;\n      if (index >= 0 && index < this._keys.length) {\n        var result = this._selector(this._keys[index], this._values[index]);\n        if (index + 1 >= this._keys.length) {\n          this.initIterator();\n        } else {\n          this._index++;\n        }\n        return { value: result, done: false };\n      }\n      return { value: undefined, done: true };\n    }\n\n    return(value) {\n      if (this._index >= 0) {\n        this.initIterator();\n      }\n      return {\n        value,\n        done: true,\n      };\n    }\n\n    throw(reason) {\n      if (this._index >= 0) {\n        this.initIterator();\n      }\n      throw reason;\n    }\n\n    initIterator() {\n      this._index = -1;\n      this._keys = SentinelArray;\n      this._values = SentinelArray;\n      this._selector = render;\n    }\n  }\n\n  return new MyMapIterator(keys, values, selector);\n}\n\nfunction MyMap(iterator) {\n  const SentinelKey = {};\n\n  class MyMapImplement {\n    cachedKey = SentinelKey;\n\n    cachedKeyIdx = -1;\n\n    // 存储keys\n    storageKeys = [];\n    // 存储值\n    storageContents = [];\n\n    // 需要为Map对象部署一个迭代器\n    [Symbol.iterator]() {\n      return GenerateIterator(this.storageKeys, this.storageContents);\n    }\n\n    get size() {\n      return this.storageKeys.length;\n    }\n\n    constructor(iterator) {\n      // 如果有初始化参数，必须是一个迭代器\n      const values =\n        iterator && typeof iterator[Symbol.iterator] === "function"\n          ? [...iterator]\n          : [];\n      values.length &&\n        values.forEach(([key, value]) => {\n          this.set(key, value);\n        });\n    }\n\n    /**\n     * 删除Map中的key\n     * @param {any} key\n     */\n    delete(key) {\n      // 命中缓存，直接返回缓存值\n      const cacheIdx = this._getCache(key);\n      // 如果命中缓存值，快速删除\n      if (cacheIdx > -1) {\n        // 删除key\n        this.storageKeys.splice(cacheIdx, 1);\n        // 删除val\n        this.storageContents.splice(cacheIdx, 1);\n        // 初始化缓存\n        this._initCache();\n        return true;\n      } else {\n        const idx = this._find(key);\n        if (idx > -1) {\n          // 删除key\n          this.storageKeys.splice(idx, 1);\n          // 删除val\n          this.storageContents.splice(idx, 1);\n        }\n        return idx > -1;\n      }\n    }\n\n    /**\n     * 设置值\n     * @param {any} key\n     * @param {any} value\n     * @returns { boolean }\n     */\n    set(key, value) {\n      // 如果存在键值，更新\n      if (this.has(key)) {\n        const cachedKeyIdx = this.cachedKeyIdx;\n        this.storageContents[cachedKeyIdx] = value;\n        this.storageKeys[cachedKeyIdx] = key;\n      } else {\n        // 以最后一个作为缓存\n        this.cachedKey = key;\n        this.cachedKeyIdx = this.storageKeys.length;\n        this.storageKeys.push(key);\n        this.storageContents.push(value);\n      }\n    }\n\n    /**\n     * 检测Map中是否包含某个值\n     * @param {any} key\n     */\n    has(key) {\n      return this._find(key) > -1;\n    }\n\n    /**\n     * 获取值\n     * @param {any} key\n     * @returns {any}\n     */\n    get(key) {\n      // 命中缓存，直接返回缓存值\n      const cacheIdx = this._getCache(key);\n      if (cacheIdx > -1) {\n        return this.cachedVal;\n      }\n      // 根据Key查找索引\n      const idx = this._find(key);\n      // 根据索引查找值\n      const val = this.storageContents[idx];\n      // 找得到，设置缓存\n      if (idx > -1) {\n        this.cachedKey = key;\n        this.cachedKeyIdx = idx;\n      }\n      return val;\n    }\n\n    /**\n     * 返回Map对象上所有的值，返回类型为迭代器\n     */\n    values() {\n      return GenerateIterator(\n        this.storageKeys,\n        this.storageContents,\n        (key, value) => {\n          return value;\n        }\n      );\n    }\n\n    /**\n     * 传入回调函数，以遍历Map对象上的Key-Value\n     */\n    forEach(fn) {\n      this.storageKeys.forEach((key, keyIdx) => {\n        const val = this.storageContents[keyIdx];\n        fn(key, val, this);\n      });\n    }\n\n    /**\n     * 返回Map的所有Key-Value，返回类型是一个迭代器，和Map自身的迭代器是同一个东西\n     */\n    entries() {\n      return this[Symbol.iterator]();\n    }\n\n    /**\n     * 返回Map的所有键，返回类型是一个迭代器\n     */\n    keys() {\n      return GenerateIterator(\n        this.storageKeys,\n        this.storageContents,\n        (key, value) => {\n          return key;\n        }\n      );\n    }\n\n    _initCache() {\n      this.cachedKey = SentinelKey;\n      this.cachedKeyIdx = -1;\n    }\n\n    _find(key) {\n      return this.storageKeys.findIndex((v) => {\n        // 因为某个Symbol值只能在同一个变量持有它的情况下才能比较，而find方法内部无法完成这样的操作的\n        return (Number.isNaN(v) && Number.isNaN(key)) || v === key;\n      });\n    }\n\n    /**\n     * 获取缓存，命中缓存返回 非负数，否则返回 -1\n     * @param {any} key\n     * @returns { number }\n     */\n    _getCache(key) {\n      return (Number.isNaN(this.cachedKey) && Number.isNaN(key)) ||\n        this.cachedKey === key\n        ? this.cachedKeyIdx\n        : -1;\n    }\n\n    clear() {\n      this.storageKeys.length = 0;\n      this.storageContents.length = 0;\n      this._initCache();\n    }\n  }\n\n  return new MyMapImplement(iterator);\n}\n\n\n\n# Set\n\n如果实现了Map，那么实现Set就是手到擒来了。因为Set是一个特殊的Map，它的Key和Value是同一个。\n\n之所以数组去重能够使用Set实现，其本质就是因为Map保证了键的唯一性。\n\nconst set = new Set([1, 1, 2, 3, "1"]);\nconst res = [...set]; // 1，2，3，\'1\'\n\n\n比如以下情况不能实现去重，因为不是用同一个变量引用的对象，就是三个对象，Map 就会创建多条记录，也就无法完成去重了。\n\nconst set = new Set([{}, {}, {}]);\nconst res = [...set]; // {}，{}，{}\n\n\n以下是Set的实现：\n\nimport { MyMap } from "./Map";\n\nclass MySet {\n  _map = new MyMap();\n\n  get size() {\n    return this._map.size;\n  }\n\n  [Symbol.iterator]() {\n    return this._map.values();\n  }\n\n  constructor(iterator) {\n    const arr = [...iterator];\n    arr.length &&\n      arr.forEach((val) => {\n        this._map.set(val, val);\n      });\n  }\n\n  keys() {\n    return this._map.keys();\n  }\n\n  values() {\n    return this._map.values();\n  }\n\n  entries() {\n    return this._map.entries();\n  }\n\n  add(val) {\n    return this._map.set(val, val);\n  }\n\n  delete(val) {\n    return this._map.delete(val);\n  }\n\n  has(key) {\n    return this._map.has(key);\n  }\n\n  forEach(fn) {\n    this._map.forEach(fn);\n  }\n\n  clear() {\n    this._map.clear();\n  }\n}\n',normalizedContent:'# map\n\nes6的map相比于es5以前使用对象做哈希映射，功能要强大的多。\n\n使用对象做哈希有一个天生的劣势，只能支持string类型的key(es6以后，可以支持symbol类型的key)，如果传入的数据不是string类型，会被强制转换成string，在有些时候就比较鸡肋了，所以使用map是最好的选择。\n\n使用es5实现map就只能使用数组来进行存储，需要维持map的key列表和value列表关心，在每次查找的过程中，通过数组方法的全等比较，同时，还要注意nan这个特殊类型的处理（在es6中，多次向map添加key为nan的值，仅会视为一条记录）。\n\n需要注意的点是，如果实现过程中需要用缓存key来提高使用效率的话，因为map键的特殊性，必须要使用一个内部的哨兵对象来初始化它的值，不能使用null，也不能使用undefined。\n\n最后，只需要按照规格实现map的迭代器即可。\n\n以下是一个es6环境下map的实现，但是因为symbol的唯一值特性，所以无法支持使用symbol作为key的场景。\n\nconst map = new mymap();\nconst s = symbol("map");\nmap.set(s, "hello world");\nmap.get(s); // undefined\n\n\n主要原因就是在比较key的时候，symbol既无法像普通对象那样比较地址，也无法像基础类型变量那样比较值，所导致的。\n\nfunction generateiterator(keys, values, selector) {\n  const sentinelarray = [];\n\n  const render = (key, value) => {\n    return {\n      key,\n      value,\n    };\n  };\n\n  class mymapiterator {\n    _index = -1;\n\n    _keys = sentinelarray;\n\n    _values = sentinelarray;\n\n    _selector = render;\n\n    [symbol.iterator]() {\n      return this;\n    }\n\n    constructor(keys, values, selector) {\n      this._keys = keys;\n      this._values = values;\n      this._index = 0;\n      this._selector = selector || render;\n    }\n\n    next() {\n      var index = this._index;\n      if (index >= 0 && index < this._keys.length) {\n        var result = this._selector(this._keys[index], this._values[index]);\n        if (index + 1 >= this._keys.length) {\n          this.inititerator();\n        } else {\n          this._index++;\n        }\n        return { value: result, done: false };\n      }\n      return { value: undefined, done: true };\n    }\n\n    return(value) {\n      if (this._index >= 0) {\n        this.inititerator();\n      }\n      return {\n        value,\n        done: true,\n      };\n    }\n\n    throw(reason) {\n      if (this._index >= 0) {\n        this.inititerator();\n      }\n      throw reason;\n    }\n\n    inititerator() {\n      this._index = -1;\n      this._keys = sentinelarray;\n      this._values = sentinelarray;\n      this._selector = render;\n    }\n  }\n\n  return new mymapiterator(keys, values, selector);\n}\n\nfunction mymap(iterator) {\n  const sentinelkey = {};\n\n  class mymapimplement {\n    cachedkey = sentinelkey;\n\n    cachedkeyidx = -1;\n\n    // 存储keys\n    storagekeys = [];\n    // 存储值\n    storagecontents = [];\n\n    // 需要为map对象部署一个迭代器\n    [symbol.iterator]() {\n      return generateiterator(this.storagekeys, this.storagecontents);\n    }\n\n    get size() {\n      return this.storagekeys.length;\n    }\n\n    constructor(iterator) {\n      // 如果有初始化参数，必须是一个迭代器\n      const values =\n        iterator && typeof iterator[symbol.iterator] === "function"\n          ? [...iterator]\n          : [];\n      values.length &&\n        values.foreach(([key, value]) => {\n          this.set(key, value);\n        });\n    }\n\n    /**\n     * 删除map中的key\n     * @param {any} key\n     */\n    delete(key) {\n      // 命中缓存，直接返回缓存值\n      const cacheidx = this._getcache(key);\n      // 如果命中缓存值，快速删除\n      if (cacheidx > -1) {\n        // 删除key\n        this.storagekeys.splice(cacheidx, 1);\n        // 删除val\n        this.storagecontents.splice(cacheidx, 1);\n        // 初始化缓存\n        this._initcache();\n        return true;\n      } else {\n        const idx = this._find(key);\n        if (idx > -1) {\n          // 删除key\n          this.storagekeys.splice(idx, 1);\n          // 删除val\n          this.storagecontents.splice(idx, 1);\n        }\n        return idx > -1;\n      }\n    }\n\n    /**\n     * 设置值\n     * @param {any} key\n     * @param {any} value\n     * @returns { boolean }\n     */\n    set(key, value) {\n      // 如果存在键值，更新\n      if (this.has(key)) {\n        const cachedkeyidx = this.cachedkeyidx;\n        this.storagecontents[cachedkeyidx] = value;\n        this.storagekeys[cachedkeyidx] = key;\n      } else {\n        // 以最后一个作为缓存\n        this.cachedkey = key;\n        this.cachedkeyidx = this.storagekeys.length;\n        this.storagekeys.push(key);\n        this.storagecontents.push(value);\n      }\n    }\n\n    /**\n     * 检测map中是否包含某个值\n     * @param {any} key\n     */\n    has(key) {\n      return this._find(key) > -1;\n    }\n\n    /**\n     * 获取值\n     * @param {any} key\n     * @returns {any}\n     */\n    get(key) {\n      // 命中缓存，直接返回缓存值\n      const cacheidx = this._getcache(key);\n      if (cacheidx > -1) {\n        return this.cachedval;\n      }\n      // 根据key查找索引\n      const idx = this._find(key);\n      // 根据索引查找值\n      const val = this.storagecontents[idx];\n      // 找得到，设置缓存\n      if (idx > -1) {\n        this.cachedkey = key;\n        this.cachedkeyidx = idx;\n      }\n      return val;\n    }\n\n    /**\n     * 返回map对象上所有的值，返回类型为迭代器\n     */\n    values() {\n      return generateiterator(\n        this.storagekeys,\n        this.storagecontents,\n        (key, value) => {\n          return value;\n        }\n      );\n    }\n\n    /**\n     * 传入回调函数，以遍历map对象上的key-value\n     */\n    foreach(fn) {\n      this.storagekeys.foreach((key, keyidx) => {\n        const val = this.storagecontents[keyidx];\n        fn(key, val, this);\n      });\n    }\n\n    /**\n     * 返回map的所有key-value，返回类型是一个迭代器，和map自身的迭代器是同一个东西\n     */\n    entries() {\n      return this[symbol.iterator]();\n    }\n\n    /**\n     * 返回map的所有键，返回类型是一个迭代器\n     */\n    keys() {\n      return generateiterator(\n        this.storagekeys,\n        this.storagecontents,\n        (key, value) => {\n          return key;\n        }\n      );\n    }\n\n    _initcache() {\n      this.cachedkey = sentinelkey;\n      this.cachedkeyidx = -1;\n    }\n\n    _find(key) {\n      return this.storagekeys.findindex((v) => {\n        // 因为某个symbol值只能在同一个变量持有它的情况下才能比较，而find方法内部无法完成这样的操作的\n        return (number.isnan(v) && number.isnan(key)) || v === key;\n      });\n    }\n\n    /**\n     * 获取缓存，命中缓存返回 非负数，否则返回 -1\n     * @param {any} key\n     * @returns { number }\n     */\n    _getcache(key) {\n      return (number.isnan(this.cachedkey) && number.isnan(key)) ||\n        this.cachedkey === key\n        ? this.cachedkeyidx\n        : -1;\n    }\n\n    clear() {\n      this.storagekeys.length = 0;\n      this.storagecontents.length = 0;\n      this._initcache();\n    }\n  }\n\n  return new mymapimplement(iterator);\n}\n\n\n\n# set\n\n如果实现了map，那么实现set就是手到擒来了。因为set是一个特殊的map，它的key和value是同一个。\n\n之所以数组去重能够使用set实现，其本质就是因为map保证了键的唯一性。\n\nconst set = new set([1, 1, 2, 3, "1"]);\nconst res = [...set]; // 1，2，3，\'1\'\n\n\n比如以下情况不能实现去重，因为不是用同一个变量引用的对象，就是三个对象，map 就会创建多条记录，也就无法完成去重了。\n\nconst set = new set([{}, {}, {}]);\nconst res = [...set]; // {}，{}，{}\n\n\n以下是set的实现：\n\nimport { mymap } from "./map";\n\nclass myset {\n  _map = new mymap();\n\n  get size() {\n    return this._map.size;\n  }\n\n  [symbol.iterator]() {\n    return this._map.values();\n  }\n\n  constructor(iterator) {\n    const arr = [...iterator];\n    arr.length &&\n      arr.foreach((val) => {\n        this._map.set(val, val);\n      });\n  }\n\n  keys() {\n    return this._map.keys();\n  }\n\n  values() {\n    return this._map.values();\n  }\n\n  entries() {\n    return this._map.entries();\n  }\n\n  add(val) {\n    return this._map.set(val, val);\n  }\n\n  delete(val) {\n    return this._map.delete(val);\n  }\n\n  has(key) {\n    return this._map.has(key);\n  }\n\n  foreach(fn) {\n    this._map.foreach(fn);\n  }\n\n  clear() {\n    this._map.clear();\n  }\n}\n',charsets:{cjk:!0}},{title:"异步加法",frontmatter:{},regularPath:"/javascript/write/parallel-pk-serial.html",relativePath:"javascript/write/parallel-pk-serial.md",key:"v-321f0ff5",path:"/javascript/write/parallel-pk-serial.html",headers:[{level:2,title:"异步加法",slug:"异步加法",normalizedTitle:"异步加法",charIndex:2},{level:3,title:"串行",slug:"串行",normalizedTitle:"串行",charIndex:836},{level:3,title:"并行",slug:"并行",normalizedTitle:"并行",charIndex:1499},{level:3,title:"测试",slug:"测试",normalizedTitle:"测试",charIndex:2678}],headersStr:"异步加法 串行 并行 测试",content:'# 异步加法\n\n现在云计算早已融入了我们的日常生活，分布式服务随处可见，比如打开一个知名点儿的App，常常能看到“云计算服务由某某某提供”这类的字样。 所以，在有些时候，可能某些计算需要在远端进行，这就是我们这个问题产生的原因。\n\n下面要阐述的内容，是一道大厂的面试题，但是具体是字节跳动还是阿里的面试题我已经记不清楚了。\n\n比如，要实现两个数的加法：\n\nfunction asyncAdd(a, b, callback) {\n  // 遵循nodejs 异步API的约定\n  // 1、参数列表最后一个为回调函数\n  // 2、回调函数第一个参数为err，如果为null说明程序正常运行，后面是正常的参数，如果不为null，所以异步任务的执行过程中有错误产生。\n  setTimeout(() => {\n    callback(null, a + b);\n  }, 1000);\n}\n\n\n可以使用promisify将其转为一个基于Promise的异步加法。\n\nconst add = promisify(asyncAdd);\n\n\n或者直接将其设计为基于Promise的异步加法。\n\nfunction add(a, b) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      const rnd = Math.random();\n      // 为了模拟异常的场景，假设有3%的概率抛出错误\n      if (rnd <= 0.03) {\n        reject(new Error("an error has occurred when calculating"));\n      }\n      resolve(a + b);\n    }, 1000);\n  });\n}\n\n\n现在有一个新的问题，一个数组有很多数，我们需要用这个异步加法对其进行求和。\n\n\n# 串行\n\n串行处理的思路很简单，就想普通数组的求和过程一样，从头累加到尾。\n\n/**\n * 串行求和函数\n * @param {Array<number>} data\n * @returns {Promise<number>}\n */\nfunction serialAccumulateAsync(data) {\n  return new Promise((resolve, reject) => {\n    // try-catch只能捕获同步错误\n    try {\n      data\n        .reduce((prevVal, curVal) => {\n          return Promise.resolve(prevVal).then((val) => {\n            // 此处可以不用部署catch错误的函数\n            return add(val, curVal);\n          });\n        })\n        .then(resolve)\n        // 此处需要部署异步处理的函数以捕获异步处理过程中的错误\n        .catch(reject);\n    } catch (exp) {\n      reject(exp);\n    }\n  });\n}\n\n\n但是，串行的问题就是浪费了时间，每次求和都要等待，这个解法是一个非常不划算的（以add函数延迟1S计算，数组长度为N，计算要N-1秒，这是一个线性时间花费）。\n\n\n# 并行\n\n虽然JS没有多线程的能力，但是我们却可以通过设计让异步加法变的更快，其思路跟归并排序是一样的。\n\n将一个数组，两两归并，得到一个新数组，如果新数组的长度大于1，说明还能继续重复上述过程，如果得到的新数组长度等于1，说明计算已经完成了，这个元素就是我们要求的和。\n\n/**\n * 并行求和函数\n * @param {Array<number>} data\n * @returns {Promise<number>}\n */\nfunction parallelAccumulateAsync(data) {\n  if (data.length === 1) {\n    return Promise.resolve(data[0]);\n  }\n  return new Promise((resolve, reject) => {\n    // try-catch只能捕获同步错误\n    try {\n      let mergedArrPromise = [];\n      for (let i = 0; i < data.length; i += 2) {\n        // 有可能最后一个元素不存在，data[i + 1]可能是undefined\n        mergedArrPromise.push(add(data[i], data[i + 1] || 0));\n      }\n      // 不用担心Promise.all的then方法部署的时候异步任务已经执行完了，因为then里面是在微任务队列中执行，即add的逻辑是在\n      // 微任务队列的执行的，此刻还有同步任务代码逻辑需要执行，同步任务肯定是比微任务快的\n      Promise.all(mergedArrPromise)\n        .then((arr) => {\n          // 递归调用求和函数\n          return parallelAccumulateAsync(arr);\n        })\n        .then(resolve)\n        .catch(reject);\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n\n\n根据归并排序中所学到的知识，归并排序的时间复杂度是N*logN，我们在这个计算过程中，假设数组长度是10个，第一次需要花费1S（5个任务同时并行），第二次需要花费1S(3个任务同时并行)，第三次需要花费1S，（2个任务同时并行），第四次再尝试计算的时候，发现数组长度已经为1，不再计算，整个过程就是二分的效果，所以总体的时间花费是logN秒，相比较串行计算，这个计算过程可是提高了非常多的效率。\n\n\n# 测试\n\nfunction add(a, b) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      const rnd = Math.random();\n      // 为了模拟异常的场景，假设有3%的概率抛出错误\n      if (rnd <= 0.03) {\n        // 为了测试时间，就不模拟错误的场景了\n        reject(new Error("an error has occurred when calculating"));\n      }\n      resolve(a + b);\n    }, 1000);\n  });\n}\n\nfunction parallelAccumulateAsync(data) {\n  if (data.length === 1) {\n    return Promise.resolve(data[0]);\n  }\n  return new Promise((resolve, reject) => {\n    try {\n      let mergedArrPromise = [];\n      for (let i = 0; i < data.length; i += 2) {\n        // 有可能最后一个元素不存在，data[i + 1]可能是undefined\n        mergedArrPromise.push(add(data[i], data[i + 1] || 0));\n      }\n      // 不用担心Promise.all的then方法部署的时候异步任务已经执行完了，因为then里面是在微任务队列中执行，即add的逻辑是在\n      // 微任务队列的执行的，此刻还有同步任务代码逻辑需要执行，同步任务肯定是比微任务快的\n      Promise.all(mergedArrPromise)\n        .then((arr) => {\n          // 递归调用求和函数\n          return parallelAccumulateAsync(arr);\n        })\n        .then(resolve)\n        .catch(reject);\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n\nfunction serialAccumulateAsync(data) {\n  return new Promise((resolve, reject) => {\n    try {\n      data\n        .reduce((prevVal, curVal) => {\n          return Promise.resolve(prevVal).then((val) => {\n            return add(val, curVal);\n          });\n        })\n        .then(resolve)\n        .catch(reject);\n    } catch (exp) {\n      reject(exp);\n    }\n  });\n}\n\n// 待处理数据\nconst data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\nlet now = Date.now();\nconsole.log("并行异步任务开始了...");\nparallelAccumulateAsync(data)\n  .then((sum) => {\n    console.log("并行异步任务完成了...");\n    console.log(sum);\n    console.log(Date.now() - now); // 约4S\n  })\n  .catch((err) => {\n    console.log("并行异步任务出错了...");\n    console.log(err);\n  });\n\nnow = Date.now();\nconsole.log("串行异步任务开始了...");\nserialAccumulateAsync(data)\n  .then((sum) => {\n    console.log("串行异步任务完成了...");\n    console.log(sum);\n    console.log(Date.now() - now); // 约9S\n  })\n  .catch((err) => {\n    console.log("串行异步任务出错了...");\n    console.log(err);\n  });\n',normalizedContent:'# 异步加法\n\n现在云计算早已融入了我们的日常生活，分布式服务随处可见，比如打开一个知名点儿的app，常常能看到“云计算服务由某某某提供”这类的字样。 所以，在有些时候，可能某些计算需要在远端进行，这就是我们这个问题产生的原因。\n\n下面要阐述的内容，是一道大厂的面试题，但是具体是字节跳动还是阿里的面试题我已经记不清楚了。\n\n比如，要实现两个数的加法：\n\nfunction asyncadd(a, b, callback) {\n  // 遵循nodejs 异步api的约定\n  // 1、参数列表最后一个为回调函数\n  // 2、回调函数第一个参数为err，如果为null说明程序正常运行，后面是正常的参数，如果不为null，所以异步任务的执行过程中有错误产生。\n  settimeout(() => {\n    callback(null, a + b);\n  }, 1000);\n}\n\n\n可以使用promisify将其转为一个基于promise的异步加法。\n\nconst add = promisify(asyncadd);\n\n\n或者直接将其设计为基于promise的异步加法。\n\nfunction add(a, b) {\n  return new promise((resolve, reject) => {\n    settimeout(() => {\n      const rnd = math.random();\n      // 为了模拟异常的场景，假设有3%的概率抛出错误\n      if (rnd <= 0.03) {\n        reject(new error("an error has occurred when calculating"));\n      }\n      resolve(a + b);\n    }, 1000);\n  });\n}\n\n\n现在有一个新的问题，一个数组有很多数，我们需要用这个异步加法对其进行求和。\n\n\n# 串行\n\n串行处理的思路很简单，就想普通数组的求和过程一样，从头累加到尾。\n\n/**\n * 串行求和函数\n * @param {array<number>} data\n * @returns {promise<number>}\n */\nfunction serialaccumulateasync(data) {\n  return new promise((resolve, reject) => {\n    // try-catch只能捕获同步错误\n    try {\n      data\n        .reduce((prevval, curval) => {\n          return promise.resolve(prevval).then((val) => {\n            // 此处可以不用部署catch错误的函数\n            return add(val, curval);\n          });\n        })\n        .then(resolve)\n        // 此处需要部署异步处理的函数以捕获异步处理过程中的错误\n        .catch(reject);\n    } catch (exp) {\n      reject(exp);\n    }\n  });\n}\n\n\n但是，串行的问题就是浪费了时间，每次求和都要等待，这个解法是一个非常不划算的（以add函数延迟1s计算，数组长度为n，计算要n-1秒，这是一个线性时间花费）。\n\n\n# 并行\n\n虽然js没有多线程的能力，但是我们却可以通过设计让异步加法变的更快，其思路跟归并排序是一样的。\n\n将一个数组，两两归并，得到一个新数组，如果新数组的长度大于1，说明还能继续重复上述过程，如果得到的新数组长度等于1，说明计算已经完成了，这个元素就是我们要求的和。\n\n/**\n * 并行求和函数\n * @param {array<number>} data\n * @returns {promise<number>}\n */\nfunction parallelaccumulateasync(data) {\n  if (data.length === 1) {\n    return promise.resolve(data[0]);\n  }\n  return new promise((resolve, reject) => {\n    // try-catch只能捕获同步错误\n    try {\n      let mergedarrpromise = [];\n      for (let i = 0; i < data.length; i += 2) {\n        // 有可能最后一个元素不存在，data[i + 1]可能是undefined\n        mergedarrpromise.push(add(data[i], data[i + 1] || 0));\n      }\n      // 不用担心promise.all的then方法部署的时候异步任务已经执行完了，因为then里面是在微任务队列中执行，即add的逻辑是在\n      // 微任务队列的执行的，此刻还有同步任务代码逻辑需要执行，同步任务肯定是比微任务快的\n      promise.all(mergedarrpromise)\n        .then((arr) => {\n          // 递归调用求和函数\n          return parallelaccumulateasync(arr);\n        })\n        .then(resolve)\n        .catch(reject);\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n\n\n根据归并排序中所学到的知识，归并排序的时间复杂度是n*logn，我们在这个计算过程中，假设数组长度是10个，第一次需要花费1s（5个任务同时并行），第二次需要花费1s(3个任务同时并行)，第三次需要花费1s，（2个任务同时并行），第四次再尝试计算的时候，发现数组长度已经为1，不再计算，整个过程就是二分的效果，所以总体的时间花费是logn秒，相比较串行计算，这个计算过程可是提高了非常多的效率。\n\n\n# 测试\n\nfunction add(a, b) {\n  return new promise((resolve, reject) => {\n    settimeout(() => {\n      const rnd = math.random();\n      // 为了模拟异常的场景，假设有3%的概率抛出错误\n      if (rnd <= 0.03) {\n        // 为了测试时间，就不模拟错误的场景了\n        reject(new error("an error has occurred when calculating"));\n      }\n      resolve(a + b);\n    }, 1000);\n  });\n}\n\nfunction parallelaccumulateasync(data) {\n  if (data.length === 1) {\n    return promise.resolve(data[0]);\n  }\n  return new promise((resolve, reject) => {\n    try {\n      let mergedarrpromise = [];\n      for (let i = 0; i < data.length; i += 2) {\n        // 有可能最后一个元素不存在，data[i + 1]可能是undefined\n        mergedarrpromise.push(add(data[i], data[i + 1] || 0));\n      }\n      // 不用担心promise.all的then方法部署的时候异步任务已经执行完了，因为then里面是在微任务队列中执行，即add的逻辑是在\n      // 微任务队列的执行的，此刻还有同步任务代码逻辑需要执行，同步任务肯定是比微任务快的\n      promise.all(mergedarrpromise)\n        .then((arr) => {\n          // 递归调用求和函数\n          return parallelaccumulateasync(arr);\n        })\n        .then(resolve)\n        .catch(reject);\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n\nfunction serialaccumulateasync(data) {\n  return new promise((resolve, reject) => {\n    try {\n      data\n        .reduce((prevval, curval) => {\n          return promise.resolve(prevval).then((val) => {\n            return add(val, curval);\n          });\n        })\n        .then(resolve)\n        .catch(reject);\n    } catch (exp) {\n      reject(exp);\n    }\n  });\n}\n\n// 待处理数据\nconst data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\nlet now = date.now();\nconsole.log("并行异步任务开始了...");\nparallelaccumulateasync(data)\n  .then((sum) => {\n    console.log("并行异步任务完成了...");\n    console.log(sum);\n    console.log(date.now() - now); // 约4s\n  })\n  .catch((err) => {\n    console.log("并行异步任务出错了...");\n    console.log(err);\n  });\n\nnow = date.now();\nconsole.log("串行异步任务开始了...");\nserialaccumulateasync(data)\n  .then((sum) => {\n    console.log("串行异步任务完成了...");\n    console.log(sum);\n    console.log(date.now() - now); // 约9s\n  })\n  .catch((err) => {\n    console.log("串行异步任务出错了...");\n    console.log(err);\n  });\n',charsets:{cjk:!0}},{title:"new",frontmatter:{},regularPath:"/javascript/write/new.html",relativePath:"javascript/write/new.md",key:"v-2ad68845",path:"/javascript/write/new.html",headers:[{level:2,title:"new",slug:"new",normalizedTitle:"new",charIndex:2}],headersStr:"new",content:'# new\n\nnew运算符，创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。\n\nnew后边紧跟着一个构造函数或者Class（Class本质上还是一个构造函数，只不过是一个ES6的语法糖而已）。\n\n在MDN或《你不知道的JavaScript》（中）所提到的 new 的过程大概如下：\n\n * 1、创建一个空的简单JavaScript对象（即 {}）；\n * 2、为步骤1新创建的对象添加属性 __proto__，将该属性链接至构造函数的原型对象；\n * 3、将步骤1新创建的对象作为this的上下文；\n * 4、如果该函数没有返回对象，则返回this。\n\n因此，其实现大致如下：\n\nfunction MyNew(func, ...args) {\n  if (!func || typeof func.prototype?.constructor !== "function") {\n    throw new Error("the MyNew must be called by a constructor");\n  }\n  // 创建一个空对象\n  const o = {};\n  // 将当前空对象的原型挂载在构造函数的原型对象上\n  o.__proto__ = func.prototype;\n  // 以当前空对象为上下文执行构造函数\n  const results = func.apply(o, args);\n  // 如果构造函数返回的类型是引用类型，返回构造函数返回的结果，否则返回这个创建的对象\n  return typeof results === "object" && results !== null ? results : o;\n}\n\n\n测试用例如下：\n\nfunction Person(name, age) {\n  this.name = name;\n  this.age = age;\n}\n\nfunction Joker(name, age) {\n  this.name = name;\n  this.age = age;\n  return {};\n}\n\nfunction Twister(name, age) {\n  this.name = name;\n  this.age = age;\n  return null;\n}\n\nconst p1 = MyNew(Person, "Bill Gates", 80);\nconst p2 = MyNew(Joker, "Trump", 90);\nconst p3 = MyNew(Twister, "Zelensky", 60);\nconsole.log(p1);\nconsole.log(p1 instanceof Person);\nconsole.log(p2);\nconsole.log(p3);\n// { name: \'Bill Gates\', age: 80 }\n// true\n// {}\n// { name: \'Zelensky\', age: 60 }\n',normalizedContent:'# new\n\nnew运算符，创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。\n\nnew后边紧跟着一个构造函数或者class（class本质上还是一个构造函数，只不过是一个es6的语法糖而已）。\n\n在mdn或《你不知道的javascript》（中）所提到的 new 的过程大概如下：\n\n * 1、创建一个空的简单javascript对象（即 {}）；\n * 2、为步骤1新创建的对象添加属性 __proto__，将该属性链接至构造函数的原型对象；\n * 3、将步骤1新创建的对象作为this的上下文；\n * 4、如果该函数没有返回对象，则返回this。\n\n因此，其实现大致如下：\n\nfunction mynew(func, ...args) {\n  if (!func || typeof func.prototype?.constructor !== "function") {\n    throw new error("the mynew must be called by a constructor");\n  }\n  // 创建一个空对象\n  const o = {};\n  // 将当前空对象的原型挂载在构造函数的原型对象上\n  o.__proto__ = func.prototype;\n  // 以当前空对象为上下文执行构造函数\n  const results = func.apply(o, args);\n  // 如果构造函数返回的类型是引用类型，返回构造函数返回的结果，否则返回这个创建的对象\n  return typeof results === "object" && results !== null ? results : o;\n}\n\n\n测试用例如下：\n\nfunction person(name, age) {\n  this.name = name;\n  this.age = age;\n}\n\nfunction joker(name, age) {\n  this.name = name;\n  this.age = age;\n  return {};\n}\n\nfunction twister(name, age) {\n  this.name = name;\n  this.age = age;\n  return null;\n}\n\nconst p1 = mynew(person, "bill gates", 80);\nconst p2 = mynew(joker, "trump", 90);\nconst p3 = mynew(twister, "zelensky", 60);\nconsole.log(p1);\nconsole.log(p1 instanceof person);\nconsole.log(p2);\nconsole.log(p3);\n// { name: \'bill gates\', age: 80 }\n// true\n// {}\n// { name: \'zelensky\', age: 60 }\n',charsets:{cjk:!0}},{frontmatter:{},regularPath:"/javascript/write/throttle.html",relativePath:"javascript/write/throttle.md",key:"v-3c1db7b5",path:"/javascript/write/throttle.html",headersStr:null,content:"",normalizedContent:"",charsets:{}},{title:"String.prototype.trim",frontmatter:{},regularPath:"/javascript/write/trim.html",relativePath:"javascript/write/trim.md",key:"v-6a2ff5b5",path:"/javascript/write/trim.html",headers:[{level:2,title:"String.prototype.trim",slug:"string-prototype-trim",normalizedTitle:"string.prototype.trim",charIndex:2}],headersStr:"String.prototype.trim",content:'# String.prototype.trim\n\ntrim函数主要的功能是替换字符串首尾的空格，但是有些时候还有去掉字符串指定字符的需求，因此，我们可以对其增强。\n\n既然是增强，当然不能改变其本来都能力，如果用户按原本的规则调用，直接去掉空格就好。\n\n如果用户想指定取出字符串首尾指定的字符串，允许传入普通字符和正则表达式进行替换。\n\n实现如下：\n\n(function () {\n  let nativeTrim =\n    String.prototype.trim ||\n    function trim() {\n      return this.replace(/^\\s*|\\s*$/g, "");\n    };\n  String.prototype.trim = function (char) {\n    if (typeof char === "undefined") {\n      return nativeTrim.apply(this);\n    }\n    if (char instanceof RegExp) {\n      char = char.source;\n    } else {\n      // 替换转义字符，防止将其识别成了正则表达式\n      char = char.replace(/\\\\/g, "\\\\\\\\");\n    }\n    // 声明正则表达式的替换规则\n    const regExp = new RegExp(`^${char}*|${char}*$`, "g");\n    return this.replace(regExp, "");\n  };\n})();\n',normalizedContent:'# string.prototype.trim\n\ntrim函数主要的功能是替换字符串首尾的空格，但是有些时候还有去掉字符串指定字符的需求，因此，我们可以对其增强。\n\n既然是增强，当然不能改变其本来都能力，如果用户按原本的规则调用，直接去掉空格就好。\n\n如果用户想指定取出字符串首尾指定的字符串，允许传入普通字符和正则表达式进行替换。\n\n实现如下：\n\n(function () {\n  let nativetrim =\n    string.prototype.trim ||\n    function trim() {\n      return this.replace(/^\\s*|\\s*$/g, "");\n    };\n  string.prototype.trim = function (char) {\n    if (typeof char === "undefined") {\n      return nativetrim.apply(this);\n    }\n    if (char instanceof regexp) {\n      char = char.source;\n    } else {\n      // 替换转义字符，防止将其识别成了正则表达式\n      char = char.replace(/\\\\/g, "\\\\\\\\");\n    }\n    // 声明正则表达式的替换规则\n    const regexp = new regexp(`^${char}*|${char}*$`, "g");\n    return this.replace(regexp, "");\n  };\n})();\n',charsets:{cjk:!0}},{title:"promisify",frontmatter:{},regularPath:"/javascript/write/promisify.html",relativePath:"javascript/write/promisify.md",key:"v-f58eb5be",path:"/javascript/write/promisify.html",headers:[{level:2,title:"promisify",slug:"promisify",normalizedTitle:"promisify",charIndex:2}],headersStr:"promisify",content:'# promisify\n\npromisify是回调函数和Promise之间的桥梁，这个工具函数可以将一个基于异步函数设计的API改造成基于Promise的API，从而避免回调地狱的问题。\n\n但是，能够被promisify函数处理的异步API必须遵循Node.js的异步API的设计规范，即：\n\n * 1、异步处理函数的参数最后一个必须是异步完成之后的回调函数\n * 2、回调函数的第一个参数是错误信息err，如果err为null，则认为异步任务操作成功，其余参数为回调内容；否则代表此处异步操作失败，err为失败的原因。\n\n以Node.js的readFile为例，正常使用这个方法，大致代码如下：\n\nconst path = require("path");\nconst fs = require("fs");\nconst fileAbsPath = path.resolve(__dirname, "./README.md");\nfs.readFile(fileAbsPath, { encoding: "utf-8" }, function fn(err, content) {\n  if (err) {\n    console.log(err);\n    return;\n  }\n  console.log(content);\n});\n\n\n如果使用promisify处理这个函数的话，将会得到以下的调用形式：\n\nconst path = require("path");\nconst fs = require("fs");\nconst readFile = promisify(fs.readFile);\nconst fileAbsPath = path.resolve(__dirname, "./README.md");\nreadFile(fileAbsPath)\n  .then((content) => {\n    console.log(content);\n  })\n  .catch((err) => {\n    console.log(err);\n  });\n\n\n所以，根据以上的调用形式，可以明确几个点：\n\n * promisify函数返回的是一个新函数，这个新函数的返回值是一个Promise。\n * 新函数的入参是原函数入参除了回调函数以外的所有参数。\n * 新函数的返回值的Promise的then方法参数是之前我们写在回调函数的参数，catch方法的参数是异步处理过程中产生错误的信息。\n\n有了这几个基本都认知，就可以编写代码了：\n\n/**\n * 将一个基于回调的异步处理操作转化成基于Promise的异步处理操作\n * @param {Function} fn 函数\n */\nfunction promisify(fn) {\n  if (typeof fn !== "function") {\n    throw new Error("promisify must enhance a function");\n  }\n  // 返回一个新的函数\n  return function promisifyFn() {\n    return new Promise((resolve, reject) => {\n      const inputArgs = [...arguments];\n      // 为原函数绑定参数，并执行\n      fn.apply(this, [\n        ...inputArgs,\n        function asyncTaskCallback() {\n          const params = [...arguments];\n          const realParams = params.slice(1);\n          const err = params[0];\n          if (err) {\n            reject(err);\n          } else {\n            resolve(realParams);\n          }\n        },\n      ]);\n    });\n  };\n}\n\n\n如果你现在还看不懂这个函数所处理的内容，可以再仔细阅读我们说到需要明确的第二点。\n\n因为原函数的参数，都是由用户传入的，最后一个回调函数肯定不能用户再传递了，否则又回去了，所以这个回调函数由promisify函数部署，并且在这个回调函数里面改变Promise的状态，其入参就是异步操作完成之后回调给我们的内容，第一个参数可能是err，剩下的是真正的回调内容。\n\n上述操作，promisify函数的功能已经大概完成了，但是还有一个点，如果用户想指定promisifyFn函数执行上下文还无法支持；另外，resolve给调用者的内容，对于只有一个参数的情况，直接把这个参数给调用者，使用起来要方便许多，因此，对上面的实现进行一些改造。\n\n/**\n * 将一个基于回调的异步处理操作转化成基于Promise的异步处理操作\n * @param {Function} fn 函数\n * @param {object} ctx 指定promisifyFn执行的函数上下文\n */\nfunction promisify(fn, ctx) {\n  if (typeof fn !== "function") {\n    throw new Error("promisify must enhance a function");\n  }\n  return function promisifyFn() {\n    const context = ctx || this;\n    return new Promise((resolve, reject) => {\n      const inputArgs = [...arguments];\n      fn.apply(context, [\n        ...inputArgs,\n        function asyncTaskCallback() {\n          const params = [...arguments];\n          const realParams = params.slice(1);\n          // 将参数提取出来，以简化调用方的使用\n          const resolveParams =\n            realParams.length <= 1 ? realParams[0] : realParams;\n          const err = params[0];\n          if (err) {\n            reject(err);\n          } else {\n            resolve(realParams);\n          }\n        },\n      ]);\n    });\n  };\n}\n',normalizedContent:'# promisify\n\npromisify是回调函数和promise之间的桥梁，这个工具函数可以将一个基于异步函数设计的api改造成基于promise的api，从而避免回调地狱的问题。\n\n但是，能够被promisify函数处理的异步api必须遵循node.js的异步api的设计规范，即：\n\n * 1、异步处理函数的参数最后一个必须是异步完成之后的回调函数\n * 2、回调函数的第一个参数是错误信息err，如果err为null，则认为异步任务操作成功，其余参数为回调内容；否则代表此处异步操作失败，err为失败的原因。\n\n以node.js的readfile为例，正常使用这个方法，大致代码如下：\n\nconst path = require("path");\nconst fs = require("fs");\nconst fileabspath = path.resolve(__dirname, "./readme.md");\nfs.readfile(fileabspath, { encoding: "utf-8" }, function fn(err, content) {\n  if (err) {\n    console.log(err);\n    return;\n  }\n  console.log(content);\n});\n\n\n如果使用promisify处理这个函数的话，将会得到以下的调用形式：\n\nconst path = require("path");\nconst fs = require("fs");\nconst readfile = promisify(fs.readfile);\nconst fileabspath = path.resolve(__dirname, "./readme.md");\nreadfile(fileabspath)\n  .then((content) => {\n    console.log(content);\n  })\n  .catch((err) => {\n    console.log(err);\n  });\n\n\n所以，根据以上的调用形式，可以明确几个点：\n\n * promisify函数返回的是一个新函数，这个新函数的返回值是一个promise。\n * 新函数的入参是原函数入参除了回调函数以外的所有参数。\n * 新函数的返回值的promise的then方法参数是之前我们写在回调函数的参数，catch方法的参数是异步处理过程中产生错误的信息。\n\n有了这几个基本都认知，就可以编写代码了：\n\n/**\n * 将一个基于回调的异步处理操作转化成基于promise的异步处理操作\n * @param {function} fn 函数\n */\nfunction promisify(fn) {\n  if (typeof fn !== "function") {\n    throw new error("promisify must enhance a function");\n  }\n  // 返回一个新的函数\n  return function promisifyfn() {\n    return new promise((resolve, reject) => {\n      const inputargs = [...arguments];\n      // 为原函数绑定参数，并执行\n      fn.apply(this, [\n        ...inputargs,\n        function asynctaskcallback() {\n          const params = [...arguments];\n          const realparams = params.slice(1);\n          const err = params[0];\n          if (err) {\n            reject(err);\n          } else {\n            resolve(realparams);\n          }\n        },\n      ]);\n    });\n  };\n}\n\n\n如果你现在还看不懂这个函数所处理的内容，可以再仔细阅读我们说到需要明确的第二点。\n\n因为原函数的参数，都是由用户传入的，最后一个回调函数肯定不能用户再传递了，否则又回去了，所以这个回调函数由promisify函数部署，并且在这个回调函数里面改变promise的状态，其入参就是异步操作完成之后回调给我们的内容，第一个参数可能是err，剩下的是真正的回调内容。\n\n上述操作，promisify函数的功能已经大概完成了，但是还有一个点，如果用户想指定promisifyfn函数执行上下文还无法支持；另外，resolve给调用者的内容，对于只有一个参数的情况，直接把这个参数给调用者，使用起来要方便许多，因此，对上面的实现进行一些改造。\n\n/**\n * 将一个基于回调的异步处理操作转化成基于promise的异步处理操作\n * @param {function} fn 函数\n * @param {object} ctx 指定promisifyfn执行的函数上下文\n */\nfunction promisify(fn, ctx) {\n  if (typeof fn !== "function") {\n    throw new error("promisify must enhance a function");\n  }\n  return function promisifyfn() {\n    const context = ctx || this;\n    return new promise((resolve, reject) => {\n      const inputargs = [...arguments];\n      fn.apply(context, [\n        ...inputargs,\n        function asynctaskcallback() {\n          const params = [...arguments];\n          const realparams = params.slice(1);\n          // 将参数提取出来，以简化调用方的使用\n          const resolveparams =\n            realparams.length <= 1 ? realparams[0] : realparams;\n          const err = params[0];\n          if (err) {\n            reject(err);\n          } else {\n            resolve(realparams);\n          }\n        },\n      ]);\n    });\n  };\n}\n',charsets:{cjk:!0}},{title:"Promise",frontmatter:{},regularPath:"/javascript/write/promise.html",relativePath:"javascript/write/promise.md",key:"v-c740fce2",path:"/javascript/write/promise.html",headers:[{level:2,title:"Promise",slug:"promise",normalizedTitle:"promise",charIndex:2},{level:3,title:"1、Promise.prototype.then方法",slug:"_1、promise-prototype-then方法",normalizedTitle:"1、promise.prototype.then方法",charIndex:3123},{level:3,title:"2、Promise.prototype.catch方法",slug:"_2、promise-prototype-catch方法",normalizedTitle:"2、promise.prototype.catch方法",charIndex:11915},{level:3,title:"3、Promise.prototype.finally方法",slug:"_3、promise-prototype-finally方法",normalizedTitle:"3、promise.prototype.finally方法",charIndex:12078},{level:3,title:"4、Promise.resolve方法",slug:"_4、promise-resolve方法",normalizedTitle:"4、promise.resolve方法",charIndex:12898},{level:3,title:"5、Promise.reject方法",slug:"_5、promise-reject方法",normalizedTitle:"5、promise.reject方法",charIndex:13995},{level:3,title:"6、Promise.all方法",slug:"_6、promise-all方法",normalizedTitle:"6、promise.all方法",charIndex:14230},{level:3,title:"7、Promise.race 方法",slug:"_7、promise-race-方法",normalizedTitle:"7、promise.race 方法",charIndex:15743},{level:3,title:"8、Promise.allSettled 方法",slug:"_8、promise-allsettled-方法",normalizedTitle:"8、promise.allsettled 方法",charIndex:16802},{level:3,title:"9、Promise.any 方法",slug:"_9、promise-any-方法",normalizedTitle:"9、promise.any 方法",charIndex:18374}],headersStr:"Promise 1、Promise.prototype.then方法 2、Promise.prototype.catch方法 3、Promise.prototype.finally方法 4、Promise.resolve方法 5、Promise.reject方法 6、Promise.all方法 7、Promise.race 方法 8、Promise.allSettled 方法 9、Promise.any 方法",content:'# Promise\n\nPromise的手写可以算的是前端面试中编码题中地狱级别的了，这里面不光有极多的场景需要考虑，并且蕴含很多编程技法在里面，如果读者有幸遇到过，那么恭喜你，你可真是幸运呢。\n\n这几年也看过很多版本的手写Promise实现了，我觉得都不怎么样（点名批评掘金的一些文章，有些实现甚至都不能用，纯属代码搬运工，误人子弟），某一天，在知乎上看到了一个前辈的文章，觉得挺好，因此本文中的实现，基本上参考这里，原文中是用ES5的构造函数的形式实现的，但是我觉得不够优雅，于是采用的是ES6的class写法。\n\n本文非常长，请耐心阅读。\n\n首先，Promise必须有一个构造器，里面传入的参数是我们部署的函数，并且这个函数有两个入参，一个是resolve，另一个是reject，这都是Promise内部的函数，当Promise执行的时候，会将其作为参数传递给我们部署的函数。\n\n/**\n * 定义Promise的三种状态\n */\nconst PENDING = "pending";\n\nconst FULFILLED = "fulfilled";\n\nconst REJECTED = "rejected";\n\nclass MyPromise {\n  /**\n   * 定义Promise的初始状态，初始状态为pending\n   */\n  state = PENDING;\n  /**\n   * 定义Promise的初始值，初始值为undefined\n   */\n  val = undefined;\n  /**\n   * 定义Promise的错误原因，初始值为undefined\n   */\n  reason = undefined;\n\n  resolve = (val) => {\n    // 只有状态为pending状态的才能变为FULFILLED\n    if (this.state === PENDING) {\n      this.val = val;\n      this.state = FULFILLED;\n    }\n  };\n\n  reject = (reason) => {\n    // 只有状态为pending状态的才能变为REJECTED\n    if (this.state === PENDING) {\n      this.reason = reason;\n      this.state = REJECTED;\n    }\n  };\n\n  constructor(executor) {\n    try {\n      executor(this.resolve, this.reject);\n    } catch (exp) {\n      this.reject(exp);\n    }\n  }\n}\n\n\n以上代码是最简单的实现，手写Promise有个基本的雏形了。\n\n回想一下，我们在实际代码中，经常这样干：\n\nfunction doTask() {\n  return new Promise((resolve, reject) => {\n    // 模拟一些异步操作\n    setTimeout(() => {\n      reject(new Error("asynchronous task error"));\n    }, 5000);\n  });\n}\n\n\n很明显，try-catch是同步任务的代码，这个setTimeout的错误是捕获不了的。\n\n因此，上述的代码进行第一步改造。\n\n/**\n * 定义Promise的三种状态\n */\nconst PENDING = "pending";\n\nconst FULFILLED = "fulfilled";\n\nconst REJECTED = "rejected";\n\nclass MyPromise {\n  /**\n   * 定义Promise的初始状态，初始状态为pending\n   */\n  state = PENDING;\n  /**\n   * 定义Promise的初始值，初始值为undefined\n   */\n  val = undefined;\n  /**\n   * 定义Promise的错误原因，初始值为undefined\n   */\n  reason = undefined;\n  /**\n   * 定义成功的异步任务队列\n   */\n  resolveCallbacks = [];\n  /**\n   * 定义失败的异步任务队列\n   */\n  rejectedCallbacks = [];\n\n  resolve = (val) => {\n    // 只有状态为pending状态的才能变为FULFILLED\n    if (this.state === PENDING) {\n      // 如果构造器塞给我们的是一个Promise，我们需要递归的将其展平\n      if (val instanceof MyPromise) {\n        val.then(\n          (resolveVal) => {\n            this.resolve(resolveVal);\n          },\n          (reason) => {\n            this.reject(reason);\n          }\n        );\n      } else {\n        this.val = val;\n        this.state = FULFILLED;\n        // 清除异步任务队列\n        while (this.resolveCallbacks.length) {\n          const fn = this.resolveCallbacks.shift();\n          typeof fn === "function" && fn(val);\n        }\n      }\n    }\n  };\n\n  reject = (reason) => {\n    // 只有状态为pending状态的才能变为REJECTED\n    if (this.state === PENDING) {\n      this.reason = reason;\n      this.state = REJECTED;\n      // 异步任务队列里面记住了需要做但是还尚未做的事儿，因此需清除异步任务队列\n      while (this.rejectedCallbacks.length) {\n        const fn = this.rejectedCallbacks.shift();\n        typeof fn === "function" && fn(reason);\n      }\n    }\n  };\n\n  constructor(executor) {\n    try {\n      executor(this.resolve, this.reject);\n    } catch (exp) {\n      this.reject(exp);\n    }\n  }\n}\n\n\n现在，我们增加了一个用于成功的任务队列，一个用于失败的任务队列。暂时还看不出来这个任务队列的内容从哪儿来，因为我们还没有写Promise.prototype.then方法。\n\n\n# 1、Promise.prototype.then方法\n\n到目前为止，Promise也不见得有多离谱，接下来就是要迎接地狱级的then方法了。then方法有两个参数，一个是我们部署的前一个Promise状态为fulfilled的处理器，另外一个是前一个Promise状态为rejected的处理器，并且then方法需要返回一个新的Promise。\n\nMyPromise.prototype.then = function (onFulfilledCallback, onRejectedCallback) {\n    // 待返回的新的Promise\n    let promise2;\n    // 如果没有部署成功的回调，部署一个默认的，并且透传上一个Promise的成功值\n    onFulfilledCallback =\n      typeof onFulfilledCallback === "function"\n        ? onFulfilledCallback\n        : (v) => v;\n    // 如果没有部署失败的回调，部署一个默认的，并且透传上一个Promise的错误\n    onRejectedCallback =\n      typeof onRejectedCallback === "function"\n        ? onRejectedCallback\n        : (reason) => {\n            throw reason;\n          };\n    // 向外界返回一个新的Promise\n    return (promise2 = new MyPromise((resolve, reject) => {\n      // 定义fulfilled的微任务处理器\n      const fulfilledMicroTask = () => {\n        queueMicroTask(() => {\n          try {\n            const fulfilledVal = onFulfilledCallback(this.val);\n            /**\n             * Promise A+规范中提到的\n             */\n            /**\n             * If a promise is resolved with a thenable that participates in a circular thenable chain,\n             * such that the recursive nature of [[Resolve]](promise, thenable) eventually causes [[Resolve]](promise, thenable) to be called again,\n             * following the above algorithm will lead to infinite recursion. Implementations are encouraged,\n             * but not required, to detect such recursion and reject promise with an informative TypeError as the reason\n             */\n            if (fulfilledVal === promise2) {\n              throw new TypeError("detect promise recursion called");\n            }\n            // 如果上一个Promise的返回值是Promise的话，就相当于插入了一个多的Promise，所以，我们把当前Promise的resolve方法和reject方法部署在它的then上\n            if (fulfilledVal instanceof MyPromise) {\n              fulfilledVal.then(resolve, reject);\n            } else {\n              resolve(fulfilledVal);\n            }\n          } catch (exp) {\n            reject(exp);\n          }\n        });\n      };\n      // 定义rejected的微任务处理\n      const rejectedMicroTask = () => {\n        queueMicroTask(() => {\n          try {\n            const rejectedVal = onRejectedCallback(this.reason);\n            if (rejectedVal === promise2) {\n              throw new TypeError("detect promise recursion called");\n            }\n            if (rejectedVal instanceof MyPromise) {\n              fulfilledMicroTask.then(resolve, reject);\n            } else {\n              resolve(rejectedVal);\n            }\n          } catch (exp) {\n            reject(exp);\n          }\n        });\n      };\n      // 上一个Promise还是pending状态，因此，需要把当前的函数加入到异步任务队列里面去，\n      // 为什么需要使用queueMicroTask呢，因为then的代码是在事件轮循当前同步任务关联的微任务队列里面执行的\n      if (this.state === PENDING) {\n        this.rejectedCallbacks.push(rejectedMicroTask);\n        this.resolveCallbacks.push(fulfilledMicroTask);\n      } else if (this.state === REJECTED) {\n        // 如果上一个Promise的状态已经变成rejected了，可以直接执行异常逻辑\n        rejectedMicroTask();\n      } else if (this.state === FULFILLED) {\n        // 如果上一个Promise的状态已经变成resolved了，可以直接执行正常逻辑\n        fulfilledMicroTask();\n      }\n    }));\n  }\n}\n\n\n上面的代码，真是老太太的裹脚布，又臭又长。\n\n不过拆开来看，其实不是特别难理解，首先先不看占了很大篇幅的rejectedMicroTask和fulfilledMicroTask，因为then方法有些时候是先部署，并不是立马就会执行到的，所以上一个Promise仍然还有可能是pending状态的。之前我们定义的异步队列就可以在此时把要做的事儿先记下来，到了某个时刻再做就行了。实际开发中，这种手段是经常用的（比如A方法依赖一个脚本才能运行，但是又不知道这个脚本在什么时候加载完成，但是我页面初始化就要调用A方法, 就可以考虑这个手段，所以我个人觉得有些时候去学习一些源码其实是对我们编程手段的补充，并不是造火箭，因为平时工作你只能用到你20%的知识，但是你另外80%的知识积累决定的是你最终能跑多远。）\n\n如果当前的Promise已经不是pending了，直接就可以执行了，比如Promise.reject或者Promise.resolve这类场景，直接就可以执行了，所以这就是后面两个分支的意义。\n\n然后，对于onFulfilledCallback, onRejectedCallback这两个函数需要兜底并且向后透传上一个Promise的信息，因为实际开发中，编写代码并不是每次都会循规蹈矩的把两个回调都写上，但是我们的Promise链仍然可以正常调用，正是这个原因\n\n接着来看我们定义的两个函数，一个用于处理成功即fulfilledMicroTask，一个用于处理失败即rejectedMicroTask，因为then方法是在事件轮循当前同步任务关联的微任务队列里面执行的，这就是为什么我们要用queueMicroTask这个API将其包裹起来的原因（如果没有queueMicroTask的话，那就只能用setTimeout了）。\n\n如果当前Promise返回的值是then新创建的promise2，这将形成循环调用，这肯定不行的，因此需要抛出错误，根据Promise A+的规范，需要抛出一个TypeError的错误。\n\n如果当前Promise返回的值又是一个Promise的话，就好比在当前Promise和then方法返回的Promise之间插入了一个新的Promise，因此，要把then方法生成的Promise的resolve和reject回调部署在插入的这个Promise的then的回调上。\n\n上述代码看起来比较冗余，明显这个判断逻辑被我们写了两遍，因此，将其抽离成一个函数，并且把最开始的构造函数相关的代码补齐，就得到了下述代码：\n\n/**\n * 定义Promise的三种状态\n */\nconst PENDING = "pending";\n\nconst FULFILLED = "fulfilled";\n\nconst REJECTED = "rejected";\n\nclass MyPromise {\n  /**\n   * 定义Promise的初始状态，初始状态为pending\n   */\n  state = PENDING;\n  /**\n   * 定义Promise的初始值，初始值为undefined\n   */\n  val = undefined;\n  /**\n   * 定义Promise的错误原因，初始值为undefined\n   */\n  reason = undefined;\n  /**\n   * 定义成功的异步任务队列\n   */\n  resolveCallbacks = [];\n  /**\n   * 定义失败的一部任务队列\n   */\n  rejectedCallbacks = [];\n\n  resolve = (val) => {\n    // 只有状态为pending状态的才能变为FULFILLED\n    if (this.state === PENDING) {\n      this.val = val;\n      this.state = FULFILLED;\n      // 清除异步任务队列\n      while (this.resolveCallbacks.length) {\n        const fn = this.resolveCallbacks.shift();\n        typeof fn === "function" && fn(val);\n      }\n    }\n  };\n\n  reject = (reason) => {\n    // 只有状态为pending状态的才能变为REJECTED\n    if (this.state === PENDING) {\n      this.reason = reason;\n      this.state = REJECTED;\n      // 清除异步任务队列\n      while (this.rejectedCallbacks.length) {\n        const fn = this.rejectedCallbacks.shift();\n        typeof fn === "function" && fn(reason);\n      }\n    }\n  };\n\n  constructor(executor) {\n    try {\n      executor(this.resolve, this.reject);\n    } catch (exp) {\n      this.reject(exp);\n    }\n  }\n\n  then(onFulfilledCallback, onRejectedCallback) {\n    let promise2;\n    // 如果没有部署成功的回调，部署一个默认的，并且透传上一个Promise的成功值\n    onFulfilledCallback =\n      typeof onFulfilledCallback === "function"\n        ? onFulfilledCallback\n        : (v) => v;\n    // 如果没有部署失败的回调，部署一个默认的，并且透传上一个Promise的错误\n    onRejectedCallback =\n      typeof onRejectedCallback === "function"\n        ? onRejectedCallback\n        : (reason) => {\n            throw reason;\n          };\n    // 向外界返回一个新的Promise\n    return (promise2 = new MyPromise((resolve, reject) => {\n      // 抽离的一个用于判断当前Promise的返回值逻辑\n      function resolvePromise(promise2, x, resolve, reject) {\n        if (promise2 === x) {\n          /**\n           * Promise A+规范中提到的\n           */\n          /**\n           * If a promise is resolved with a thenable that participates in a circular thenable chain,\n           * such that the recursive nature of [[Resolve]](promise, thenable) eventually causes [[Resolve]](promise, thenable) to be called again,\n           * following the above algorithm will lead to infinite recursion. Implementations are encouraged,\n           * but not required, to detect such recursion and reject promise with an informative TypeError as the reason\n           */\n          throw new TypeError("detect promise recursion called");\n        }\n        // 如果是一个Promise，就部署resolve和reject在其then方法上 （这个地方应该改成类Promise更科学）\n        if (x instanceof MyPromise) {\n          x.then(resolve, reject);\n        } else {\n          // 普通值，直接当做fulfilled处理\n          resolve(x);\n        }\n      }\n      // 定义fulfilled的微任务处理器\n      const fulfilledMicroTask = () => {\n        queueMicroTask(() => {\n          try {\n            const fulfilledVal = onFulfilledCallback(this.val);\n            resolvePromise(promise2, fulfilledVal, resolve, reject);\n          } catch (exp) {\n            reject(exp);\n          }\n        });\n      };\n\n      // 定义rejected的微任务处理\n      const rejectedMicroTask = () => {\n        queueMicroTask(() => {\n          try {\n            const rejectedVal = onRejectedCallback(this.reason);\n            resolvePromise(promise2, rejectedVal, resolve, reject);\n          } catch (exp) {\n            reject(exp);\n          }\n        });\n      };\n\n      // 上一个Promise还是pending状态，因此，需要把当前的函数加入到异步任务队列里面去，\n      // 为什么需要使用queueMicroTask呢，因为then的代码是在事件轮循当前同步任务关联的微任务队列里面执行的\n      if (this.state === PENDING) {\n        this.rejectedCallbacks.push(rejectedMicroTask);\n        this.resolveCallbacks.push(fulfilledMicroTask);\n      } else if (this.state === REJECTED) {\n        // 如果上一个Promise的状态已经变成rejected了，可以直接执行异常逻辑\n        rejectedMicroTask();\n      } else if (this.state === FULFILLED) {\n        // 如果上一个Promise的状态已经变成resolved了，可以直接执行正常逻辑\n        fulfilledMicroTask();\n      }\n    }));\n  }\n}\n\n\n以下是我们上述代码的测试用例：\n\nconst p = new MyPromise((resolve, reject) => {\n  setTimeout(() => {\n    resolve(300);\n  }, 3000);\n})\n  .then((val) => {\n    return val * 100;\n  })\n  .then((val) => {\n    throw new Error(val);\n  })\n  .then()\n  .then(null, (error) => {\n    console.log(error);\n  })\n  .then()\n  .then(() => {\n    return new MyPromise((resolve, reject) => {\n      setTimeout(() => {\n        resolve(1000);\n      }, 1000);\n    });\n  })\n  .then((val) => {\n    console.log(val);\n  });\n\n\n如果你认真的看到了这儿，恭喜你，Promise你已经掌握了~。\n\n参考文章实现的then到此并没有完，它还考虑了不同实现的Promise的通信问题，本文不考虑，有兴趣的读者可以参考原文。\n\n接下来要做的事儿就相对比较简单了，我们把Promise身上的一些方法补全。\n\n\n# 2、Promise.prototype.catch方法\n\n这个方法是一个语法糖，为了避免我们在写Promise链的时候每个then上都去部署reject的回调\n\nMyPromise.prototype.catch = function (fn) {\n  return this.then(null, fn);\n};\n\n\n\n# 3、Promise.prototype.finally方法\n\n这个方法也是一个语法糖，因为有些时候我们不需要关心上一个Promise的执行结果，都必须要做一些事儿，如果没有这个方法，我们的代码就必须写成这样\n\nconst a = new Promise((resolve, reject) => {\n  Math.random() > 0.5 ? resolve() : reject();\n});\n\na.then(() => {\n  console.log("今天你的运气真的好");\n  console.log("今天的抽奖已经结束");\n}).catch(() => {\n  console.log("今天你的运气真的不好");\n  console.log("今天的抽奖已经结束");\n});\n\n\n从上面的写法也看的出来，其实就是需要在then方法的两个分支上部署同一个回调函数，因此，实现就比较简单了。\n\nMyPromise.prototype.finally = function (fn) {\n  return this.then(\n    () => {\n      fn();\n    },\n    () => {\n      fn();\n    }\n  );\n};\n\n\n所以，我们的业务代码就可以改写成这样：\n\nconst a = new Promise((resolve, reject) => {\n  Math.random() > 0.5 ? resolve() : reject();\n});\n\na.then(() => {\n  console.log("今天你的运气真的好");\n})\n  .catch(() => {\n    console.log("今天你的运气真的不好");\n  })\n  .finally(() => {\n    console.log("今天的抽奖已经结束");\n  });\n\n\n\n# 4、Promise.resolve方法\n\nPromise.resolve方法MDN的阐述是这样的：Promise.resolve(value) 方法返回一个以给定值解析后的Promise对象。\n\n * 如果这个值是一个Promise，那么将返回这个Promise；\n * 如果这个值是thenable（即带有then方法，但是又不是一个Promise），返回的Promise 会“跟随”这个thenable的对象，采用它的最终状态；\n * 否则返回的Promise将以此值完成。\n * 此函数将类Promise对象的多层嵌套展平。\n\nMyPromise.resolve = function (value) {\n  // 如果这个值是一个`Promise`，那么将返回这个`Promise`\n  if (value instanceof MyPromise) {\n    return value;\n  } else if (value && typeof value.then === "function") {\n    return new MyPromise((resolve, reject) => {\n      value.then(resolve, reject);\n    }).then(\n      (val) => {\n        // 递归抹平类Promise，这一点也很重要\n        return val && typeof val.then === "function"\n          ? MyPromise.resolve(val)\n          : val;\n      },\n      (err) => {\n        // 透传错误\n        throw err;\n      }\n    );\n  } else {\n    // 将普通值包裹成一个Promise\n    return new MyPromise((resolve) => {\n      resolve(value);\n    });\n  }\n};\n\n\nDANGER\n\n不要在解析为自身的thenable上调用Promise.resolve。这将导致无限递归，因为它试图展平无限嵌套的Promise。\n\nlet thenable = {\n  then: (resolve, reject) => {\n    resolve(thenable);\n  },\n};\n\nPromise.resolve(thenable); //这会造成一个死循环\n\n\n\n# 5、Promise.reject方法\n\nMDN的阐述是：Promise.reject方法返回一个带有拒绝原因的Promise对象。\n\n因为一切对象都可能是Promise拒绝的原因，相比Promise.resolve就没有那么复杂了。\n\nMyPromise.reject = function (reason) {\n  return new Promise((resolve, reject) => {\n    reject(reason);\n  });\n};\n\n\n\n# 6、Promise.all方法\n\nMDN的阐述是：\n\nPromise.all方法接收一个Promise的Iterable类型 （注：Array，Map，Set，Generator函数的执行结果都属于ES6的Iterable类型） 的输入，并且只返回一个Promise实例，那个输入的所有Promise的resolve回调的结果是一个数组。这个Promise的resolve回调执行是在所有输入的 Promise的resolve回调都结束，或者输入的Iterable里没有Promise了的时候。\n\n它的reject回调执行时，只要任何一个输入的Promise的 reject回调执行或者输入不合法的Promise就会立即抛出错误，并且reject的是第一个抛出的错误信息。\n\n这个阐述可是真的让人摸不着头脑。我根据我的开发经验进行转述，Promise.all接受一个可迭代对象，返回一个Promise，如果入参里面的所有Promise的状态都变成fulfilled之后，这个Promise变成fulfilled状态，并且结果是根据入参组成的数组（比如迭代器第一次的值是个Promise，就返回这个Promise状态为fulfilled之后的值，如果是普通对象，直接原路返回），如果迭代过程中的第一个Promise变成了rejected，这个返回的Promise的状态则为rejected，原因则是透传的第一个reject的原因。\n\n以下是实现的Promise.all\n\nMyPromise.all = function (iterator) {\n  let arr;\n  // 强制将迭代器转成数组，如果当前对象不是迭代器，那就是报类型错误\n  arr = [...iterator];\n  // 如果传入的参数是空，快速响应\n  if (arr.length === 0) {\n    return MyPromise.resolve([]);\n  }\n  return new MyPromise((resolve, reject) => {\n    // 记录最终的结果\n    let records = [];\n    // 记录已经fulfilled的Promise的个数\n    let size = 0;\n    for (let i = 0; i < arr.length; i++) {\n      let p = arr[i];\n      // 如果不是MyPromise的实例，包裹，因为这样才能够延迟响应（微任务队列里面完成）\n      if (!(p instanceof MyPromise)) {\n        p = MyPromise.resolve(p);\n      }\n      p.then((val) => {\n        // 在then里面处理结果和处理已经fulfilled的Promise的个数，如果所有的Promise都已经fulfilled了的话，返回的Promise就可以fulfilled了\n        records[i] = val;\n        size++;\n        if (size === arr.length) {\n          resolve(records);\n        }\n      }).catch((err) => {\n        // 只有上述有任何一个出错了，直接透传错误的reason\n        reject(err);\n      });\n    }\n  });\n};\n\n\n\n# 7、Promise.race 方法\n\nMDN的解释是：\n\nPromise.race(iterable)方法返回一个Promise，一旦迭代器中的某个Promise的状态不再是pending，返回的Promise就会变成fulfilled或者rejected。\n\n简言之就是哪个Promise的状态先改变，返回的Promise的结果就以谁的为准。需要注意的是，如果传的迭代是空的，则返回的Promise将永远等待。\n\n如果迭代包含一个或多个非Promise值或fulfilled或rejected的Promise，则Promise.race将解析为迭代中找到的第一个值。(简言之就是，返回第一个普通值或者状态已经改变的Promise的值)。\n\n比如：\n\nconst p1 = Promise.race([]); //p1的状态永远是pending\n\nconst p2 = Promise.race([\n  1,\n  2,\n  new Promise((resolve, reject) => {\n    setTimeout(resolve, 0);\n  }),\n]);\n// p2的状态暂时是pending，在本轮事件循环完成，微任务队列清空之后，状态为fulfilled，值为1\n\n\n因此，实现大致如下：\n\nMyPromise.race = function (iterator) {\n  const arr = [...iterator];\n  return new MyPromise((resolve, reject) => {\n    // 如果arr为空，则永远pending\n    for (let i = 0; i < arr.length; i++) {\n      let p = arr[i];\n      // 如果不是MyPromise的实例，包裹\n      if (!(p instanceof MyPromise)) {\n        p = MyPromise.resolve(p);\n      }\n      p.then((val) => {\n        // 任意一个状态变化了，就可以直接返回fulfilled的值\n        resolve(val);\n      }).catch((err) => {\n        // 任意一个出错，就透传这个错误\n        reject(err);\n      });\n    }\n  });\n};\n\n\n\n# 8、Promise.allSettled 方法\n\nMDN的解释是：\n\nPromise.allSettled方法以 Promise组成的可迭代对象作为输入，并且返回一个Promise实例。当输入的所有Promise都已敲定时（包括传递空的可迭代类型），返回的Promise将变成fulfilled，并带有描述每个 Promise结果的对象数组。\n\n如果传递的是空，则直接返回一个fulfilled的Promise，否则，当给定的Iterable中所有Promise已经敲定时（要么fulfilled，要么rejected）。fulfilled的值是一个对象数组，其中的对象按照Iterable中Promise传递的顺序，描述每一个Promise的结果，无论完成顺序如何。\n\n用简单的话解释起来就是，Promise.allSettled得到的Promise不会出现rejected的状态，如果传入参数是空，直接返回，如果传入的有参数，那么就挨个把每个Promise的结果按传入的顺序返回PromiseSettledResult(我起的名字)。\n\nconst FULFILLED = "fulfilled";\nconst REJECTED = "rejected";\ntype STATUS = FULFILLED | REJECTED;\ninterface PromiseSettledResult {\n  // 结果的状态\n  status: STATUS;\n  // 结果的值\n  value?: any;\n  // 错误的原因\n  reason: Error;\n}\n\n\n因此，大致实现如下：\n\nMyPromise.allSettled = function (iterator) {\n  const arr = [...iterator];\n  return new MyPromise((resolve) => {\n    // 如果数组是空的，直接返回一个fulfilled的结果\n    if (arr.length === 0) {\n      resolve([]);\n    }\n    // 定义每个Promise的结果记录数组 和 计数器\n    let size = 0;\n    let results = [];\n    for (let i = 0; i < arr.length; i++) {\n      let p = arr[i];\n      if (!(p instanceof MyPromise)) {\n        p = MyPromise.resolve(p);\n      }\n      // 无论是成功还是失败，都要把结果记录下来\n      p.then((val) => {\n        size++;\n        results[i] = {\n          value: val,\n          status: FULFILLED,\n        };\n        if (size === arr.length) {\n          resolve(results);\n        }\n      }).catch((err) => {\n        size++;\n        results[i] = {\n          status: REJECTED,\n          reason: err,\n        };\n        if (size === arr.length) {\n          resolve(results);\n        }\n      });\n    }\n  });\n};\n\n\n\n# 9、Promise.any 方法\n\nPromise.any接收一个由Promise所组成的可迭代对象，该方法会返回一个新的Promise，一旦可迭代对象内的任意一个Promise变成了fulfilled状态，那么由该方法所返回的Promise就会变成fulfilled状态，并且它的fulfilled值就是可迭代对象内的首先fulfilled的Promise的fulfilled值。如果可迭代对象内的Promise最终都没有fulfilled（即所有Promise都被reject了），那么该方法所返回的Promise就会变成rejected状态，并且它的reason会是一个AggregateError实例，这是Error的子类，用于把单一的错误集合在一起。\n\n如果传入了一个空的可迭代对象，那么就会返回一个rejected的Promise。\n\n如果传入了一个不含有Promise的可迭代对象，那么就会返回一个异步fulfilled的 Promise。\n\n其余情况下都会返回一个pending状态的Promise。如果可迭代对象中的任意一个Promise的状态变成fulfilled了，那么这个处于等待状态的Promise就会异步地(本轮事件循环同步任务结束，并且微任务队列也已经清空)切换至fulfilled状态。如果可迭代对象中的所有Promise都rejected了，那么这个pending状态的Promise就会异步地切换至rejected。\n\nMyPromise.any = function (iterator) {\n  const arr = [...iterator];\n  // 入了一个空的可迭代对象，那么就会返回一个已经被拒的promise\n  if (arr.length === 0) {\n    return MyPromise.reject(new AggregateError([]));\n  }\n  return new MyPromise((resolve, reject) => {\n    // 定义被拒绝的计数和错误数组\n    let rejectedSize = 0;\n    let rejectedErrs = [];\n    for (let i = 0; i < arr.length; i++) {\n      let p = arr[i];\n      if (!(p instanceof MyPromise)) {\n        p = MyPromise.resolve(p);\n      }\n      p.then((val) => {\n        // 有一个promise fulfilled，则这个promise的值就是最终返回的Promise的值\n        resolve(val);\n      }).catch((err) => {\n        // 如果所有的Promise都拒绝了，则抛出错误\n        rejectedSize++;\n        rejectedErrs[i] = err;\n        if (rejectedSize === arr.length) {\n          reject(new AggregateError(rejectedErrs));\n        }\n      });\n    }\n  });\n};\n\n\n综合以上的阐述，以下是我实现的一个完整的Promise类。\n\n/**\n * 定义Promise的三种状态\n */\nconst PENDING = "pending";\n\nconst FULFILLED = "fulfilled";\n\nconst REJECTED = "rejected";\n\nclass MyPromise {\n  /**\n   * 定义Promise的初始状态，初始状态为pending\n   */\n  state = PENDING;\n  /**\n   * 定义Promise的初始值，初始值为undefined\n   */\n  val = undefined;\n  /**\n   * 定义Promise的错误原因，初始值为undefined\n   */\n  reason = undefined;\n  /**\n   * 定义成功的异步任务队列\n   */\n  resolveCallbacks = [];\n  /**\n   * 定义失败的一部任务队列\n   */\n  rejectedCallbacks = [];\n\n  resolve = (val) => {\n    // 只有状态为pending状态的才能变为FULFILLED\n    if (this.state === PENDING) {\n      // 如果构造器塞给我们的是一个Promise，我们需要递归的将其展平\n      if (val instanceof MyPromise) {\n        val.then(\n          (resolveVal) => {\n            this.resolve(resolveVal);\n          },\n          (reason) => {\n            this.reject(reason);\n          }\n        );\n      } else {\n        this.val = val;\n        this.state = FULFILLED;\n        // 清除异步任务队列\n        while (this.resolveCallbacks.length) {\n          const fn = this.resolveCallbacks.shift();\n          typeof fn === "function" && fn(val);\n        }\n      }\n    }\n  };\n\n  reject = (reason) => {\n    // 只有状态为pending状态的才能变为REJECTED\n    if (this.state === PENDING) {\n      this.reason = reason;\n      this.state = REJECTED;\n      // 清除异步任务队列\n      while (this.rejectedCallbacks.length) {\n        const fn = this.rejectedCallbacks.shift();\n        typeof fn === "function" && fn(reason);\n      }\n    }\n  };\n\n  constructor(executor) {\n    try {\n      executor(this.resolve, this.reject);\n    } catch (exp) {\n      this.reject(exp);\n    }\n  }\n\n  then(onFulfilledCallback, onRejectedCallback) {\n    let promise2;\n    // 如果没有部署成功的回调，部署一个默认的，并且透传上一个Promise的成功值\n    onFulfilledCallback =\n      typeof onFulfilledCallback === "function"\n        ? onFulfilledCallback\n        : (v) => v;\n    // 如果没有部署失败的回调，部署一个默认的，并且透传上一个Promise的错误\n    onRejectedCallback =\n      typeof onRejectedCallback === "function"\n        ? onRejectedCallback\n        : (reason) => {\n            throw reason;\n          };\n    // 向外界返回一个新的Promise\n    return (promise2 = new MyPromise((resolve, reject) => {\n      // 抽离的一个用于判断当前Promise的返回值逻辑\n      function resolvePromise(promise2, x, resolve, reject) {\n        if (promise2 === x) {\n          /**\n           * Promise A+规范中提到的\n           */\n          /**\n           * If a promise is resolved with a thenable that participates in a circular thenable chain,\n           * such that the recursive nature of [[Resolve]](promise, thenable) eventually causes [[Resolve]](promise, thenable) to be called again,\n           * following the above algorithm will lead to infinite recursion. Implementations are encouraged,\n           * but not required, to detect such recursion and reject promise with an informative TypeError as the reason\n           */\n          throw new TypeError("detect promise recursion called");\n        }\n        // 如果是一个Promise，就部署resolve和reject在其then方法上\n        if (x instanceof MyPromise) {\n          x.then(resolve, reject);\n        } else {\n          // 普通值，直接当做fulfilled处理\n          resolve(x);\n        }\n      }\n      // 定义fulfilled的微任务处理器\n      const fulfilledMicroTask = () => {\n        queueMicrotask(() => {\n          try {\n            // 有可能外界给的结果就是一个Promise，那么这个Promise就要插队了，必须用户部署的then函数监听的结果将会是这个Promise的结果\n            if (this.val instanceof MyPromise) {\n              this.val.then(resolve, reject);\n            } else {\n              const fulfilledVal = onFulfilledCallback(this.val);\n              resolvePromise(promise2, fulfilledVal, resolve, reject);\n            }\n          } catch (exp) {\n            reject(exp);\n          }\n        });\n      };\n      // 定义rejected的微任务处理\n      const rejectedMicroTask = () => {\n        queueMicrotask(() => {\n          try {\n            const rejectedVal = onRejectedCallback(this.reason);\n            resolvePromise(promise2, rejectedVal, resolve, reject);\n          } catch (exp) {\n            reject(exp);\n          }\n        });\n      };\n      // 上一个Promise还是pending状态，因此，需要把当前的函数加入到异步任务队列里面去，\n      // 为什么需要使用queueMicroTask呢，因为then的代码是在事件轮循当前同步任务关联的微任务队列里面执行的\n      if (this.state === PENDING) {\n        this.rejectedCallbacks.push(rejectedMicroTask);\n        this.resolveCallbacks.push(fulfilledMicroTask);\n      } else if (this.state === REJECTED) {\n        // 如果上一个Promise的状态已经变成rejected了，可以直接执行异常逻辑\n        rejectedMicroTask();\n      } else if (this.state === FULFILLED) {\n        // 如果上一个Promise的状态已经变成resolved了，可以直接执行正常逻辑\n        fulfilledMicroTask();\n      }\n    }));\n  }\n\n  catch(fn) {\n    return this.then(null, (err) => {\n      return fn(err);\n    });\n  }\n\n  finally(fn) {\n    return this.then(\n      () => {\n        // 不能直接绑定fn，需要吃掉返回值\n        fn();\n      },\n      () => {\n        // 不能直接绑定fn，需要吃点reason\n        fn();\n      }\n    );\n  }\n\n  static resolve(value) {\n    if (value instanceof MyPromise) {\n      return value;\n    } else if (value && typeof value.then === "function") {\n      return new MyPromise((resolve, reject) => {\n        value.then(resolve, reject);\n      }).then(\n        (val) => {\n          // 递归的解类Promise对象\n          return val && typeof val.then === "function"\n            ? MyPromise.resolve(val)\n            : val;\n        },\n        (err) => {\n          throw err;\n        }\n      );\n    } else {\n      return new MyPromise((resolve) => {\n        resolve(value);\n      });\n    }\n  }\n\n  static reject(reason) {\n    return new MyPromise((resolve, reject) => {\n      reject(reason);\n    });\n  }\n\n  static all(iterator) {\n    // 强制将迭代器转成数组\n    let arr = [...iterator];\n    if (arr.length === 0) {\n      return MyPromise.resolve([]);\n    }\n    return new MyPromise((resolve, reject) => {\n      let records = [];\n      let size = 0;\n      for (let i = 0; i < arr.length; i++) {\n        let p = arr[i];\n        // 如果不是MyPromise的实例，包裹\n        if (!(p instanceof MyPromise)) {\n          p = MyPromise.resolve(p);\n        }\n        p.then((val) => {\n          records[i] = val;\n          size++;\n          if (size === arr.length) {\n            resolve(records);\n          }\n        }).catch((err) => {\n          reject(err);\n        });\n      }\n    });\n  }\n\n  static allSettled(iterator) {\n    const arr = [...iterator];\n    return new MyPromise((resolve) => {\n      // 如果数组是空的，直接返回一个兑现的结果\n      if (arr.length === 0) {\n        resolve([]);\n      }\n      // 定义每个Promise的结果记录数组 和 计数器\n      let size = 0;\n      let results = [];\n      for (let i = 0; i < arr.length; i++) {\n        let p = arr[i];\n        if (!(p instanceof MyPromise)) {\n          p = MyPromise.resolve(p);\n        }\n        p.then((val) => {\n          size++;\n          results[i] = {\n            value: val,\n            status: FULFILLED,\n          };\n          if (size === arr.length) {\n            resolve(results);\n          }\n        }).catch((err) => {\n          size++;\n          results[i] = {\n            status: REJECTED,\n            reason: err,\n          };\n          if (size === arr.length) {\n            resolve(results);\n          }\n        });\n      }\n    });\n  }\n\n  static race(iterator) {\n    const arr = [...iterator];\n    return new MyPromise((resolve, reject) => {\n      // 如果arr为空，则永远pending\n      for (let i = 0; i < arr.length; i++) {\n        let p = arr[i];\n        // 如果不是MyPromise的实例，包裹\n        if (!(p instanceof MyPromise)) {\n          p = MyPromise.resolve(p);\n        }\n        p.then((val) => {\n          // 任意一个状态变化了，就可以直接返回fulfilled的值\n          resolve(val);\n        }).catch((err) => {\n          // 任意一个出错，就透传这个错误\n          reject(err);\n        });\n      }\n    });\n  }\n\n  static any(iterator) {\n    const arr = [...iterator];\n    // 入了一个空的可迭代对象，那么就会返回一个已经被拒的promise\n    if (arr.length === 0) {\n      return MyPromise.reject(new AggregateError([]));\n    }\n    return new MyPromise((resolve, reject) => {\n      // 定义被拒绝的计数和错误数组\n      let rejectedSize = 0;\n      let rejectedErrs = [];\n      for (let i = 0; i < arr.length; i++) {\n        let p = arr[i];\n        if (!(p instanceof MyPromise)) {\n          p = MyPromise.resolve(p);\n        }\n        p.then((val) => {\n          // 有一个promise fulfilled，则这个promise的值就是最终返回的Promise的值\n          resolve(val);\n        }).catch((err) => {\n          // 如果所有的Promise都拒绝了，则抛出错误\n          rejectedSize++;\n          rejectedErrs[i] = err;\n          if (rejectedSize === arr.length) {\n            reject(new AggregateError(rejectedErrs));\n          }\n        });\n      }\n    });\n  }\n}\n',normalizedContent:'# promise\n\npromise的手写可以算的是前端面试中编码题中地狱级别的了，这里面不光有极多的场景需要考虑，并且蕴含很多编程技法在里面，如果读者有幸遇到过，那么恭喜你，你可真是幸运呢。\n\n这几年也看过很多版本的手写promise实现了，我觉得都不怎么样（点名批评掘金的一些文章，有些实现甚至都不能用，纯属代码搬运工，误人子弟），某一天，在知乎上看到了一个前辈的文章，觉得挺好，因此本文中的实现，基本上参考这里，原文中是用es5的构造函数的形式实现的，但是我觉得不够优雅，于是采用的是es6的class写法。\n\n本文非常长，请耐心阅读。\n\n首先，promise必须有一个构造器，里面传入的参数是我们部署的函数，并且这个函数有两个入参，一个是resolve，另一个是reject，这都是promise内部的函数，当promise执行的时候，会将其作为参数传递给我们部署的函数。\n\n/**\n * 定义promise的三种状态\n */\nconst pending = "pending";\n\nconst fulfilled = "fulfilled";\n\nconst rejected = "rejected";\n\nclass mypromise {\n  /**\n   * 定义promise的初始状态，初始状态为pending\n   */\n  state = pending;\n  /**\n   * 定义promise的初始值，初始值为undefined\n   */\n  val = undefined;\n  /**\n   * 定义promise的错误原因，初始值为undefined\n   */\n  reason = undefined;\n\n  resolve = (val) => {\n    // 只有状态为pending状态的才能变为fulfilled\n    if (this.state === pending) {\n      this.val = val;\n      this.state = fulfilled;\n    }\n  };\n\n  reject = (reason) => {\n    // 只有状态为pending状态的才能变为rejected\n    if (this.state === pending) {\n      this.reason = reason;\n      this.state = rejected;\n    }\n  };\n\n  constructor(executor) {\n    try {\n      executor(this.resolve, this.reject);\n    } catch (exp) {\n      this.reject(exp);\n    }\n  }\n}\n\n\n以上代码是最简单的实现，手写promise有个基本的雏形了。\n\n回想一下，我们在实际代码中，经常这样干：\n\nfunction dotask() {\n  return new promise((resolve, reject) => {\n    // 模拟一些异步操作\n    settimeout(() => {\n      reject(new error("asynchronous task error"));\n    }, 5000);\n  });\n}\n\n\n很明显，try-catch是同步任务的代码，这个settimeout的错误是捕获不了的。\n\n因此，上述的代码进行第一步改造。\n\n/**\n * 定义promise的三种状态\n */\nconst pending = "pending";\n\nconst fulfilled = "fulfilled";\n\nconst rejected = "rejected";\n\nclass mypromise {\n  /**\n   * 定义promise的初始状态，初始状态为pending\n   */\n  state = pending;\n  /**\n   * 定义promise的初始值，初始值为undefined\n   */\n  val = undefined;\n  /**\n   * 定义promise的错误原因，初始值为undefined\n   */\n  reason = undefined;\n  /**\n   * 定义成功的异步任务队列\n   */\n  resolvecallbacks = [];\n  /**\n   * 定义失败的异步任务队列\n   */\n  rejectedcallbacks = [];\n\n  resolve = (val) => {\n    // 只有状态为pending状态的才能变为fulfilled\n    if (this.state === pending) {\n      // 如果构造器塞给我们的是一个promise，我们需要递归的将其展平\n      if (val instanceof mypromise) {\n        val.then(\n          (resolveval) => {\n            this.resolve(resolveval);\n          },\n          (reason) => {\n            this.reject(reason);\n          }\n        );\n      } else {\n        this.val = val;\n        this.state = fulfilled;\n        // 清除异步任务队列\n        while (this.resolvecallbacks.length) {\n          const fn = this.resolvecallbacks.shift();\n          typeof fn === "function" && fn(val);\n        }\n      }\n    }\n  };\n\n  reject = (reason) => {\n    // 只有状态为pending状态的才能变为rejected\n    if (this.state === pending) {\n      this.reason = reason;\n      this.state = rejected;\n      // 异步任务队列里面记住了需要做但是还尚未做的事儿，因此需清除异步任务队列\n      while (this.rejectedcallbacks.length) {\n        const fn = this.rejectedcallbacks.shift();\n        typeof fn === "function" && fn(reason);\n      }\n    }\n  };\n\n  constructor(executor) {\n    try {\n      executor(this.resolve, this.reject);\n    } catch (exp) {\n      this.reject(exp);\n    }\n  }\n}\n\n\n现在，我们增加了一个用于成功的任务队列，一个用于失败的任务队列。暂时还看不出来这个任务队列的内容从哪儿来，因为我们还没有写promise.prototype.then方法。\n\n\n# 1、promise.prototype.then方法\n\n到目前为止，promise也不见得有多离谱，接下来就是要迎接地狱级的then方法了。then方法有两个参数，一个是我们部署的前一个promise状态为fulfilled的处理器，另外一个是前一个promise状态为rejected的处理器，并且then方法需要返回一个新的promise。\n\nmypromise.prototype.then = function (onfulfilledcallback, onrejectedcallback) {\n    // 待返回的新的promise\n    let promise2;\n    // 如果没有部署成功的回调，部署一个默认的，并且透传上一个promise的成功值\n    onfulfilledcallback =\n      typeof onfulfilledcallback === "function"\n        ? onfulfilledcallback\n        : (v) => v;\n    // 如果没有部署失败的回调，部署一个默认的，并且透传上一个promise的错误\n    onrejectedcallback =\n      typeof onrejectedcallback === "function"\n        ? onrejectedcallback\n        : (reason) => {\n            throw reason;\n          };\n    // 向外界返回一个新的promise\n    return (promise2 = new mypromise((resolve, reject) => {\n      // 定义fulfilled的微任务处理器\n      const fulfilledmicrotask = () => {\n        queuemicrotask(() => {\n          try {\n            const fulfilledval = onfulfilledcallback(this.val);\n            /**\n             * promise a+规范中提到的\n             */\n            /**\n             * if a promise is resolved with a thenable that participates in a circular thenable chain,\n             * such that the recursive nature of [[resolve]](promise, thenable) eventually causes [[resolve]](promise, thenable) to be called again,\n             * following the above algorithm will lead to infinite recursion. implementations are encouraged,\n             * but not required, to detect such recursion and reject promise with an informative typeerror as the reason\n             */\n            if (fulfilledval === promise2) {\n              throw new typeerror("detect promise recursion called");\n            }\n            // 如果上一个promise的返回值是promise的话，就相当于插入了一个多的promise，所以，我们把当前promise的resolve方法和reject方法部署在它的then上\n            if (fulfilledval instanceof mypromise) {\n              fulfilledval.then(resolve, reject);\n            } else {\n              resolve(fulfilledval);\n            }\n          } catch (exp) {\n            reject(exp);\n          }\n        });\n      };\n      // 定义rejected的微任务处理\n      const rejectedmicrotask = () => {\n        queuemicrotask(() => {\n          try {\n            const rejectedval = onrejectedcallback(this.reason);\n            if (rejectedval === promise2) {\n              throw new typeerror("detect promise recursion called");\n            }\n            if (rejectedval instanceof mypromise) {\n              fulfilledmicrotask.then(resolve, reject);\n            } else {\n              resolve(rejectedval);\n            }\n          } catch (exp) {\n            reject(exp);\n          }\n        });\n      };\n      // 上一个promise还是pending状态，因此，需要把当前的函数加入到异步任务队列里面去，\n      // 为什么需要使用queuemicrotask呢，因为then的代码是在事件轮循当前同步任务关联的微任务队列里面执行的\n      if (this.state === pending) {\n        this.rejectedcallbacks.push(rejectedmicrotask);\n        this.resolvecallbacks.push(fulfilledmicrotask);\n      } else if (this.state === rejected) {\n        // 如果上一个promise的状态已经变成rejected了，可以直接执行异常逻辑\n        rejectedmicrotask();\n      } else if (this.state === fulfilled) {\n        // 如果上一个promise的状态已经变成resolved了，可以直接执行正常逻辑\n        fulfilledmicrotask();\n      }\n    }));\n  }\n}\n\n\n上面的代码，真是老太太的裹脚布，又臭又长。\n\n不过拆开来看，其实不是特别难理解，首先先不看占了很大篇幅的rejectedmicrotask和fulfilledmicrotask，因为then方法有些时候是先部署，并不是立马就会执行到的，所以上一个promise仍然还有可能是pending状态的。之前我们定义的异步队列就可以在此时把要做的事儿先记下来，到了某个时刻再做就行了。实际开发中，这种手段是经常用的（比如a方法依赖一个脚本才能运行，但是又不知道这个脚本在什么时候加载完成，但是我页面初始化就要调用a方法, 就可以考虑这个手段，所以我个人觉得有些时候去学习一些源码其实是对我们编程手段的补充，并不是造火箭，因为平时工作你只能用到你20%的知识，但是你另外80%的知识积累决定的是你最终能跑多远。）\n\n如果当前的promise已经不是pending了，直接就可以执行了，比如promise.reject或者promise.resolve这类场景，直接就可以执行了，所以这就是后面两个分支的意义。\n\n然后，对于onfulfilledcallback, onrejectedcallback这两个函数需要兜底并且向后透传上一个promise的信息，因为实际开发中，编写代码并不是每次都会循规蹈矩的把两个回调都写上，但是我们的promise链仍然可以正常调用，正是这个原因\n\n接着来看我们定义的两个函数，一个用于处理成功即fulfilledmicrotask，一个用于处理失败即rejectedmicrotask，因为then方法是在事件轮循当前同步任务关联的微任务队列里面执行的，这就是为什么我们要用queuemicrotask这个api将其包裹起来的原因（如果没有queuemicrotask的话，那就只能用settimeout了）。\n\n如果当前promise返回的值是then新创建的promise2，这将形成循环调用，这肯定不行的，因此需要抛出错误，根据promise a+的规范，需要抛出一个typeerror的错误。\n\n如果当前promise返回的值又是一个promise的话，就好比在当前promise和then方法返回的promise之间插入了一个新的promise，因此，要把then方法生成的promise的resolve和reject回调部署在插入的这个promise的then的回调上。\n\n上述代码看起来比较冗余，明显这个判断逻辑被我们写了两遍，因此，将其抽离成一个函数，并且把最开始的构造函数相关的代码补齐，就得到了下述代码：\n\n/**\n * 定义promise的三种状态\n */\nconst pending = "pending";\n\nconst fulfilled = "fulfilled";\n\nconst rejected = "rejected";\n\nclass mypromise {\n  /**\n   * 定义promise的初始状态，初始状态为pending\n   */\n  state = pending;\n  /**\n   * 定义promise的初始值，初始值为undefined\n   */\n  val = undefined;\n  /**\n   * 定义promise的错误原因，初始值为undefined\n   */\n  reason = undefined;\n  /**\n   * 定义成功的异步任务队列\n   */\n  resolvecallbacks = [];\n  /**\n   * 定义失败的一部任务队列\n   */\n  rejectedcallbacks = [];\n\n  resolve = (val) => {\n    // 只有状态为pending状态的才能变为fulfilled\n    if (this.state === pending) {\n      this.val = val;\n      this.state = fulfilled;\n      // 清除异步任务队列\n      while (this.resolvecallbacks.length) {\n        const fn = this.resolvecallbacks.shift();\n        typeof fn === "function" && fn(val);\n      }\n    }\n  };\n\n  reject = (reason) => {\n    // 只有状态为pending状态的才能变为rejected\n    if (this.state === pending) {\n      this.reason = reason;\n      this.state = rejected;\n      // 清除异步任务队列\n      while (this.rejectedcallbacks.length) {\n        const fn = this.rejectedcallbacks.shift();\n        typeof fn === "function" && fn(reason);\n      }\n    }\n  };\n\n  constructor(executor) {\n    try {\n      executor(this.resolve, this.reject);\n    } catch (exp) {\n      this.reject(exp);\n    }\n  }\n\n  then(onfulfilledcallback, onrejectedcallback) {\n    let promise2;\n    // 如果没有部署成功的回调，部署一个默认的，并且透传上一个promise的成功值\n    onfulfilledcallback =\n      typeof onfulfilledcallback === "function"\n        ? onfulfilledcallback\n        : (v) => v;\n    // 如果没有部署失败的回调，部署一个默认的，并且透传上一个promise的错误\n    onrejectedcallback =\n      typeof onrejectedcallback === "function"\n        ? onrejectedcallback\n        : (reason) => {\n            throw reason;\n          };\n    // 向外界返回一个新的promise\n    return (promise2 = new mypromise((resolve, reject) => {\n      // 抽离的一个用于判断当前promise的返回值逻辑\n      function resolvepromise(promise2, x, resolve, reject) {\n        if (promise2 === x) {\n          /**\n           * promise a+规范中提到的\n           */\n          /**\n           * if a promise is resolved with a thenable that participates in a circular thenable chain,\n           * such that the recursive nature of [[resolve]](promise, thenable) eventually causes [[resolve]](promise, thenable) to be called again,\n           * following the above algorithm will lead to infinite recursion. implementations are encouraged,\n           * but not required, to detect such recursion and reject promise with an informative typeerror as the reason\n           */\n          throw new typeerror("detect promise recursion called");\n        }\n        // 如果是一个promise，就部署resolve和reject在其then方法上 （这个地方应该改成类promise更科学）\n        if (x instanceof mypromise) {\n          x.then(resolve, reject);\n        } else {\n          // 普通值，直接当做fulfilled处理\n          resolve(x);\n        }\n      }\n      // 定义fulfilled的微任务处理器\n      const fulfilledmicrotask = () => {\n        queuemicrotask(() => {\n          try {\n            const fulfilledval = onfulfilledcallback(this.val);\n            resolvepromise(promise2, fulfilledval, resolve, reject);\n          } catch (exp) {\n            reject(exp);\n          }\n        });\n      };\n\n      // 定义rejected的微任务处理\n      const rejectedmicrotask = () => {\n        queuemicrotask(() => {\n          try {\n            const rejectedval = onrejectedcallback(this.reason);\n            resolvepromise(promise2, rejectedval, resolve, reject);\n          } catch (exp) {\n            reject(exp);\n          }\n        });\n      };\n\n      // 上一个promise还是pending状态，因此，需要把当前的函数加入到异步任务队列里面去，\n      // 为什么需要使用queuemicrotask呢，因为then的代码是在事件轮循当前同步任务关联的微任务队列里面执行的\n      if (this.state === pending) {\n        this.rejectedcallbacks.push(rejectedmicrotask);\n        this.resolvecallbacks.push(fulfilledmicrotask);\n      } else if (this.state === rejected) {\n        // 如果上一个promise的状态已经变成rejected了，可以直接执行异常逻辑\n        rejectedmicrotask();\n      } else if (this.state === fulfilled) {\n        // 如果上一个promise的状态已经变成resolved了，可以直接执行正常逻辑\n        fulfilledmicrotask();\n      }\n    }));\n  }\n}\n\n\n以下是我们上述代码的测试用例：\n\nconst p = new mypromise((resolve, reject) => {\n  settimeout(() => {\n    resolve(300);\n  }, 3000);\n})\n  .then((val) => {\n    return val * 100;\n  })\n  .then((val) => {\n    throw new error(val);\n  })\n  .then()\n  .then(null, (error) => {\n    console.log(error);\n  })\n  .then()\n  .then(() => {\n    return new mypromise((resolve, reject) => {\n      settimeout(() => {\n        resolve(1000);\n      }, 1000);\n    });\n  })\n  .then((val) => {\n    console.log(val);\n  });\n\n\n如果你认真的看到了这儿，恭喜你，promise你已经掌握了~。\n\n参考文章实现的then到此并没有完，它还考虑了不同实现的promise的通信问题，本文不考虑，有兴趣的读者可以参考原文。\n\n接下来要做的事儿就相对比较简单了，我们把promise身上的一些方法补全。\n\n\n# 2、promise.prototype.catch方法\n\n这个方法是一个语法糖，为了避免我们在写promise链的时候每个then上都去部署reject的回调\n\nmypromise.prototype.catch = function (fn) {\n  return this.then(null, fn);\n};\n\n\n\n# 3、promise.prototype.finally方法\n\n这个方法也是一个语法糖，因为有些时候我们不需要关心上一个promise的执行结果，都必须要做一些事儿，如果没有这个方法，我们的代码就必须写成这样\n\nconst a = new promise((resolve, reject) => {\n  math.random() > 0.5 ? resolve() : reject();\n});\n\na.then(() => {\n  console.log("今天你的运气真的好");\n  console.log("今天的抽奖已经结束");\n}).catch(() => {\n  console.log("今天你的运气真的不好");\n  console.log("今天的抽奖已经结束");\n});\n\n\n从上面的写法也看的出来，其实就是需要在then方法的两个分支上部署同一个回调函数，因此，实现就比较简单了。\n\nmypromise.prototype.finally = function (fn) {\n  return this.then(\n    () => {\n      fn();\n    },\n    () => {\n      fn();\n    }\n  );\n};\n\n\n所以，我们的业务代码就可以改写成这样：\n\nconst a = new promise((resolve, reject) => {\n  math.random() > 0.5 ? resolve() : reject();\n});\n\na.then(() => {\n  console.log("今天你的运气真的好");\n})\n  .catch(() => {\n    console.log("今天你的运气真的不好");\n  })\n  .finally(() => {\n    console.log("今天的抽奖已经结束");\n  });\n\n\n\n# 4、promise.resolve方法\n\npromise.resolve方法mdn的阐述是这样的：promise.resolve(value) 方法返回一个以给定值解析后的promise对象。\n\n * 如果这个值是一个promise，那么将返回这个promise；\n * 如果这个值是thenable（即带有then方法，但是又不是一个promise），返回的promise 会“跟随”这个thenable的对象，采用它的最终状态；\n * 否则返回的promise将以此值完成。\n * 此函数将类promise对象的多层嵌套展平。\n\nmypromise.resolve = function (value) {\n  // 如果这个值是一个`promise`，那么将返回这个`promise`\n  if (value instanceof mypromise) {\n    return value;\n  } else if (value && typeof value.then === "function") {\n    return new mypromise((resolve, reject) => {\n      value.then(resolve, reject);\n    }).then(\n      (val) => {\n        // 递归抹平类promise，这一点也很重要\n        return val && typeof val.then === "function"\n          ? mypromise.resolve(val)\n          : val;\n      },\n      (err) => {\n        // 透传错误\n        throw err;\n      }\n    );\n  } else {\n    // 将普通值包裹成一个promise\n    return new mypromise((resolve) => {\n      resolve(value);\n    });\n  }\n};\n\n\ndanger\n\n不要在解析为自身的thenable上调用promise.resolve。这将导致无限递归，因为它试图展平无限嵌套的promise。\n\nlet thenable = {\n  then: (resolve, reject) => {\n    resolve(thenable);\n  },\n};\n\npromise.resolve(thenable); //这会造成一个死循环\n\n\n\n# 5、promise.reject方法\n\nmdn的阐述是：promise.reject方法返回一个带有拒绝原因的promise对象。\n\n因为一切对象都可能是promise拒绝的原因，相比promise.resolve就没有那么复杂了。\n\nmypromise.reject = function (reason) {\n  return new promise((resolve, reject) => {\n    reject(reason);\n  });\n};\n\n\n\n# 6、promise.all方法\n\nmdn的阐述是：\n\npromise.all方法接收一个promise的iterable类型 （注：array，map，set，generator函数的执行结果都属于es6的iterable类型） 的输入，并且只返回一个promise实例，那个输入的所有promise的resolve回调的结果是一个数组。这个promise的resolve回调执行是在所有输入的 promise的resolve回调都结束，或者输入的iterable里没有promise了的时候。\n\n它的reject回调执行时，只要任何一个输入的promise的 reject回调执行或者输入不合法的promise就会立即抛出错误，并且reject的是第一个抛出的错误信息。\n\n这个阐述可是真的让人摸不着头脑。我根据我的开发经验进行转述，promise.all接受一个可迭代对象，返回一个promise，如果入参里面的所有promise的状态都变成fulfilled之后，这个promise变成fulfilled状态，并且结果是根据入参组成的数组（比如迭代器第一次的值是个promise，就返回这个promise状态为fulfilled之后的值，如果是普通对象，直接原路返回），如果迭代过程中的第一个promise变成了rejected，这个返回的promise的状态则为rejected，原因则是透传的第一个reject的原因。\n\n以下是实现的promise.all\n\nmypromise.all = function (iterator) {\n  let arr;\n  // 强制将迭代器转成数组，如果当前对象不是迭代器，那就是报类型错误\n  arr = [...iterator];\n  // 如果传入的参数是空，快速响应\n  if (arr.length === 0) {\n    return mypromise.resolve([]);\n  }\n  return new mypromise((resolve, reject) => {\n    // 记录最终的结果\n    let records = [];\n    // 记录已经fulfilled的promise的个数\n    let size = 0;\n    for (let i = 0; i < arr.length; i++) {\n      let p = arr[i];\n      // 如果不是mypromise的实例，包裹，因为这样才能够延迟响应（微任务队列里面完成）\n      if (!(p instanceof mypromise)) {\n        p = mypromise.resolve(p);\n      }\n      p.then((val) => {\n        // 在then里面处理结果和处理已经fulfilled的promise的个数，如果所有的promise都已经fulfilled了的话，返回的promise就可以fulfilled了\n        records[i] = val;\n        size++;\n        if (size === arr.length) {\n          resolve(records);\n        }\n      }).catch((err) => {\n        // 只有上述有任何一个出错了，直接透传错误的reason\n        reject(err);\n      });\n    }\n  });\n};\n\n\n\n# 7、promise.race 方法\n\nmdn的解释是：\n\npromise.race(iterable)方法返回一个promise，一旦迭代器中的某个promise的状态不再是pending，返回的promise就会变成fulfilled或者rejected。\n\n简言之就是哪个promise的状态先改变，返回的promise的结果就以谁的为准。需要注意的是，如果传的迭代是空的，则返回的promise将永远等待。\n\n如果迭代包含一个或多个非promise值或fulfilled或rejected的promise，则promise.race将解析为迭代中找到的第一个值。(简言之就是，返回第一个普通值或者状态已经改变的promise的值)。\n\n比如：\n\nconst p1 = promise.race([]); //p1的状态永远是pending\n\nconst p2 = promise.race([\n  1,\n  2,\n  new promise((resolve, reject) => {\n    settimeout(resolve, 0);\n  }),\n]);\n// p2的状态暂时是pending，在本轮事件循环完成，微任务队列清空之后，状态为fulfilled，值为1\n\n\n因此，实现大致如下：\n\nmypromise.race = function (iterator) {\n  const arr = [...iterator];\n  return new mypromise((resolve, reject) => {\n    // 如果arr为空，则永远pending\n    for (let i = 0; i < arr.length; i++) {\n      let p = arr[i];\n      // 如果不是mypromise的实例，包裹\n      if (!(p instanceof mypromise)) {\n        p = mypromise.resolve(p);\n      }\n      p.then((val) => {\n        // 任意一个状态变化了，就可以直接返回fulfilled的值\n        resolve(val);\n      }).catch((err) => {\n        // 任意一个出错，就透传这个错误\n        reject(err);\n      });\n    }\n  });\n};\n\n\n\n# 8、promise.allsettled 方法\n\nmdn的解释是：\n\npromise.allsettled方法以 promise组成的可迭代对象作为输入，并且返回一个promise实例。当输入的所有promise都已敲定时（包括传递空的可迭代类型），返回的promise将变成fulfilled，并带有描述每个 promise结果的对象数组。\n\n如果传递的是空，则直接返回一个fulfilled的promise，否则，当给定的iterable中所有promise已经敲定时（要么fulfilled，要么rejected）。fulfilled的值是一个对象数组，其中的对象按照iterable中promise传递的顺序，描述每一个promise的结果，无论完成顺序如何。\n\n用简单的话解释起来就是，promise.allsettled得到的promise不会出现rejected的状态，如果传入参数是空，直接返回，如果传入的有参数，那么就挨个把每个promise的结果按传入的顺序返回promisesettledresult(我起的名字)。\n\nconst fulfilled = "fulfilled";\nconst rejected = "rejected";\ntype status = fulfilled | rejected;\ninterface promisesettledresult {\n  // 结果的状态\n  status: status;\n  // 结果的值\n  value?: any;\n  // 错误的原因\n  reason: error;\n}\n\n\n因此，大致实现如下：\n\nmypromise.allsettled = function (iterator) {\n  const arr = [...iterator];\n  return new mypromise((resolve) => {\n    // 如果数组是空的，直接返回一个fulfilled的结果\n    if (arr.length === 0) {\n      resolve([]);\n    }\n    // 定义每个promise的结果记录数组 和 计数器\n    let size = 0;\n    let results = [];\n    for (let i = 0; i < arr.length; i++) {\n      let p = arr[i];\n      if (!(p instanceof mypromise)) {\n        p = mypromise.resolve(p);\n      }\n      // 无论是成功还是失败，都要把结果记录下来\n      p.then((val) => {\n        size++;\n        results[i] = {\n          value: val,\n          status: fulfilled,\n        };\n        if (size === arr.length) {\n          resolve(results);\n        }\n      }).catch((err) => {\n        size++;\n        results[i] = {\n          status: rejected,\n          reason: err,\n        };\n        if (size === arr.length) {\n          resolve(results);\n        }\n      });\n    }\n  });\n};\n\n\n\n# 9、promise.any 方法\n\npromise.any接收一个由promise所组成的可迭代对象，该方法会返回一个新的promise，一旦可迭代对象内的任意一个promise变成了fulfilled状态，那么由该方法所返回的promise就会变成fulfilled状态，并且它的fulfilled值就是可迭代对象内的首先fulfilled的promise的fulfilled值。如果可迭代对象内的promise最终都没有fulfilled（即所有promise都被reject了），那么该方法所返回的promise就会变成rejected状态，并且它的reason会是一个aggregateerror实例，这是error的子类，用于把单一的错误集合在一起。\n\n如果传入了一个空的可迭代对象，那么就会返回一个rejected的promise。\n\n如果传入了一个不含有promise的可迭代对象，那么就会返回一个异步fulfilled的 promise。\n\n其余情况下都会返回一个pending状态的promise。如果可迭代对象中的任意一个promise的状态变成fulfilled了，那么这个处于等待状态的promise就会异步地(本轮事件循环同步任务结束，并且微任务队列也已经清空)切换至fulfilled状态。如果可迭代对象中的所有promise都rejected了，那么这个pending状态的promise就会异步地切换至rejected。\n\nmypromise.any = function (iterator) {\n  const arr = [...iterator];\n  // 入了一个空的可迭代对象，那么就会返回一个已经被拒的promise\n  if (arr.length === 0) {\n    return mypromise.reject(new aggregateerror([]));\n  }\n  return new mypromise((resolve, reject) => {\n    // 定义被拒绝的计数和错误数组\n    let rejectedsize = 0;\n    let rejectederrs = [];\n    for (let i = 0; i < arr.length; i++) {\n      let p = arr[i];\n      if (!(p instanceof mypromise)) {\n        p = mypromise.resolve(p);\n      }\n      p.then((val) => {\n        // 有一个promise fulfilled，则这个promise的值就是最终返回的promise的值\n        resolve(val);\n      }).catch((err) => {\n        // 如果所有的promise都拒绝了，则抛出错误\n        rejectedsize++;\n        rejectederrs[i] = err;\n        if (rejectedsize === arr.length) {\n          reject(new aggregateerror(rejectederrs));\n        }\n      });\n    }\n  });\n};\n\n\n综合以上的阐述，以下是我实现的一个完整的promise类。\n\n/**\n * 定义promise的三种状态\n */\nconst pending = "pending";\n\nconst fulfilled = "fulfilled";\n\nconst rejected = "rejected";\n\nclass mypromise {\n  /**\n   * 定义promise的初始状态，初始状态为pending\n   */\n  state = pending;\n  /**\n   * 定义promise的初始值，初始值为undefined\n   */\n  val = undefined;\n  /**\n   * 定义promise的错误原因，初始值为undefined\n   */\n  reason = undefined;\n  /**\n   * 定义成功的异步任务队列\n   */\n  resolvecallbacks = [];\n  /**\n   * 定义失败的一部任务队列\n   */\n  rejectedcallbacks = [];\n\n  resolve = (val) => {\n    // 只有状态为pending状态的才能变为fulfilled\n    if (this.state === pending) {\n      // 如果构造器塞给我们的是一个promise，我们需要递归的将其展平\n      if (val instanceof mypromise) {\n        val.then(\n          (resolveval) => {\n            this.resolve(resolveval);\n          },\n          (reason) => {\n            this.reject(reason);\n          }\n        );\n      } else {\n        this.val = val;\n        this.state = fulfilled;\n        // 清除异步任务队列\n        while (this.resolvecallbacks.length) {\n          const fn = this.resolvecallbacks.shift();\n          typeof fn === "function" && fn(val);\n        }\n      }\n    }\n  };\n\n  reject = (reason) => {\n    // 只有状态为pending状态的才能变为rejected\n    if (this.state === pending) {\n      this.reason = reason;\n      this.state = rejected;\n      // 清除异步任务队列\n      while (this.rejectedcallbacks.length) {\n        const fn = this.rejectedcallbacks.shift();\n        typeof fn === "function" && fn(reason);\n      }\n    }\n  };\n\n  constructor(executor) {\n    try {\n      executor(this.resolve, this.reject);\n    } catch (exp) {\n      this.reject(exp);\n    }\n  }\n\n  then(onfulfilledcallback, onrejectedcallback) {\n    let promise2;\n    // 如果没有部署成功的回调，部署一个默认的，并且透传上一个promise的成功值\n    onfulfilledcallback =\n      typeof onfulfilledcallback === "function"\n        ? onfulfilledcallback\n        : (v) => v;\n    // 如果没有部署失败的回调，部署一个默认的，并且透传上一个promise的错误\n    onrejectedcallback =\n      typeof onrejectedcallback === "function"\n        ? onrejectedcallback\n        : (reason) => {\n            throw reason;\n          };\n    // 向外界返回一个新的promise\n    return (promise2 = new mypromise((resolve, reject) => {\n      // 抽离的一个用于判断当前promise的返回值逻辑\n      function resolvepromise(promise2, x, resolve, reject) {\n        if (promise2 === x) {\n          /**\n           * promise a+规范中提到的\n           */\n          /**\n           * if a promise is resolved with a thenable that participates in a circular thenable chain,\n           * such that the recursive nature of [[resolve]](promise, thenable) eventually causes [[resolve]](promise, thenable) to be called again,\n           * following the above algorithm will lead to infinite recursion. implementations are encouraged,\n           * but not required, to detect such recursion and reject promise with an informative typeerror as the reason\n           */\n          throw new typeerror("detect promise recursion called");\n        }\n        // 如果是一个promise，就部署resolve和reject在其then方法上\n        if (x instanceof mypromise) {\n          x.then(resolve, reject);\n        } else {\n          // 普通值，直接当做fulfilled处理\n          resolve(x);\n        }\n      }\n      // 定义fulfilled的微任务处理器\n      const fulfilledmicrotask = () => {\n        queuemicrotask(() => {\n          try {\n            // 有可能外界给的结果就是一个promise，那么这个promise就要插队了，必须用户部署的then函数监听的结果将会是这个promise的结果\n            if (this.val instanceof mypromise) {\n              this.val.then(resolve, reject);\n            } else {\n              const fulfilledval = onfulfilledcallback(this.val);\n              resolvepromise(promise2, fulfilledval, resolve, reject);\n            }\n          } catch (exp) {\n            reject(exp);\n          }\n        });\n      };\n      // 定义rejected的微任务处理\n      const rejectedmicrotask = () => {\n        queuemicrotask(() => {\n          try {\n            const rejectedval = onrejectedcallback(this.reason);\n            resolvepromise(promise2, rejectedval, resolve, reject);\n          } catch (exp) {\n            reject(exp);\n          }\n        });\n      };\n      // 上一个promise还是pending状态，因此，需要把当前的函数加入到异步任务队列里面去，\n      // 为什么需要使用queuemicrotask呢，因为then的代码是在事件轮循当前同步任务关联的微任务队列里面执行的\n      if (this.state === pending) {\n        this.rejectedcallbacks.push(rejectedmicrotask);\n        this.resolvecallbacks.push(fulfilledmicrotask);\n      } else if (this.state === rejected) {\n        // 如果上一个promise的状态已经变成rejected了，可以直接执行异常逻辑\n        rejectedmicrotask();\n      } else if (this.state === fulfilled) {\n        // 如果上一个promise的状态已经变成resolved了，可以直接执行正常逻辑\n        fulfilledmicrotask();\n      }\n    }));\n  }\n\n  catch(fn) {\n    return this.then(null, (err) => {\n      return fn(err);\n    });\n  }\n\n  finally(fn) {\n    return this.then(\n      () => {\n        // 不能直接绑定fn，需要吃掉返回值\n        fn();\n      },\n      () => {\n        // 不能直接绑定fn，需要吃点reason\n        fn();\n      }\n    );\n  }\n\n  static resolve(value) {\n    if (value instanceof mypromise) {\n      return value;\n    } else if (value && typeof value.then === "function") {\n      return new mypromise((resolve, reject) => {\n        value.then(resolve, reject);\n      }).then(\n        (val) => {\n          // 递归的解类promise对象\n          return val && typeof val.then === "function"\n            ? mypromise.resolve(val)\n            : val;\n        },\n        (err) => {\n          throw err;\n        }\n      );\n    } else {\n      return new mypromise((resolve) => {\n        resolve(value);\n      });\n    }\n  }\n\n  static reject(reason) {\n    return new mypromise((resolve, reject) => {\n      reject(reason);\n    });\n  }\n\n  static all(iterator) {\n    // 强制将迭代器转成数组\n    let arr = [...iterator];\n    if (arr.length === 0) {\n      return mypromise.resolve([]);\n    }\n    return new mypromise((resolve, reject) => {\n      let records = [];\n      let size = 0;\n      for (let i = 0; i < arr.length; i++) {\n        let p = arr[i];\n        // 如果不是mypromise的实例，包裹\n        if (!(p instanceof mypromise)) {\n          p = mypromise.resolve(p);\n        }\n        p.then((val) => {\n          records[i] = val;\n          size++;\n          if (size === arr.length) {\n            resolve(records);\n          }\n        }).catch((err) => {\n          reject(err);\n        });\n      }\n    });\n  }\n\n  static allsettled(iterator) {\n    const arr = [...iterator];\n    return new mypromise((resolve) => {\n      // 如果数组是空的，直接返回一个兑现的结果\n      if (arr.length === 0) {\n        resolve([]);\n      }\n      // 定义每个promise的结果记录数组 和 计数器\n      let size = 0;\n      let results = [];\n      for (let i = 0; i < arr.length; i++) {\n        let p = arr[i];\n        if (!(p instanceof mypromise)) {\n          p = mypromise.resolve(p);\n        }\n        p.then((val) => {\n          size++;\n          results[i] = {\n            value: val,\n            status: fulfilled,\n          };\n          if (size === arr.length) {\n            resolve(results);\n          }\n        }).catch((err) => {\n          size++;\n          results[i] = {\n            status: rejected,\n            reason: err,\n          };\n          if (size === arr.length) {\n            resolve(results);\n          }\n        });\n      }\n    });\n  }\n\n  static race(iterator) {\n    const arr = [...iterator];\n    return new mypromise((resolve, reject) => {\n      // 如果arr为空，则永远pending\n      for (let i = 0; i < arr.length; i++) {\n        let p = arr[i];\n        // 如果不是mypromise的实例，包裹\n        if (!(p instanceof mypromise)) {\n          p = mypromise.resolve(p);\n        }\n        p.then((val) => {\n          // 任意一个状态变化了，就可以直接返回fulfilled的值\n          resolve(val);\n        }).catch((err) => {\n          // 任意一个出错，就透传这个错误\n          reject(err);\n        });\n      }\n    });\n  }\n\n  static any(iterator) {\n    const arr = [...iterator];\n    // 入了一个空的可迭代对象，那么就会返回一个已经被拒的promise\n    if (arr.length === 0) {\n      return mypromise.reject(new aggregateerror([]));\n    }\n    return new mypromise((resolve, reject) => {\n      // 定义被拒绝的计数和错误数组\n      let rejectedsize = 0;\n      let rejectederrs = [];\n      for (let i = 0; i < arr.length; i++) {\n        let p = arr[i];\n        if (!(p instanceof mypromise)) {\n          p = mypromise.resolve(p);\n        }\n        p.then((val) => {\n          // 有一个promise fulfilled，则这个promise的值就是最终返回的promise的值\n          resolve(val);\n        }).catch((err) => {\n          // 如果所有的promise都拒绝了，则抛出错误\n          rejectedsize++;\n          rejectederrs[i] = err;\n          if (rejectedsize === arr.length) {\n            reject(new aggregateerror(rejectederrs));\n          }\n        });\n      }\n    });\n  }\n}\n',charsets:{cjk:!0}},{title:"数组去重",frontmatter:{},regularPath:"/javascript/write/remove-duplicate.html",relativePath:"javascript/write/remove-duplicate.md",key:"v-e2f77296",path:"/javascript/write/remove-duplicate.html",headers:[{level:2,title:"数组去重",slug:"数组去重",normalizedTitle:"数组去重",charIndex:2},{level:3,title:"1、两重for循环",slug:"_1、两重for循环",normalizedTitle:"1、两重for循环",charIndex:96},{level:3,title:"2、使用ES6的Set",slug:"_2、使用es6的set",normalizedTitle:"2、使用es6的set",charIndex:809},{level:3,title:"3、双指针",slug:"_3、双指针",normalizedTitle:"3、双指针",charIndex:1008},{level:3,title:"4、哈希表",slug:"_4、哈希表",normalizedTitle:"4、哈希表",charIndex:2176}],headersStr:"数组去重 1、两重for循环 2、使用ES6的Set 3、双指针 4、哈希表",content:"# 数组去重\n\n数组去重作为前端入门级的面试题，可以说出现的频率实在是太高了。我在17年刚毕业的那会儿面试新华三，就被问到了这道题，尴尬的是我竟然没有写出来。\n\n最少有3种实现方式。\n\n\n# 1、两重for循环\n\n这个可以说是通解了，属于没有什么技术含量的解法了。其思路就是首先第一重循环作用于数组本身，然后遇到新来的一个元素，再结果集里面再施加一重循环，查找是否在结果集中存在，若存在就跳过，否则就将其添加到结果集中。\n\nfunction removeDuplicate(arr) {\n  const dataSets = [];\n  for (let i = 0; i < arr.length; i++) {\n    const num = arr[i];\n    // 在结果集中查找是否存在\n    if (dataSets.every((v) => v !== num)) {\n      dataSets.push(num);\n    }\n  }\n  return dataSets;\n}\n\n\n另外，还有一种简洁的写法：\n\n/**\n * 数组去重\n * @param {number[]} arr 待去重数组\n * @returns\n */\nfunction removeDuplicate(arr) {\n  // 本质上和两重for循环是一样的意思\n  return arr.filter((v, idx) => {\n    // 过滤依据是，如果当前元素第一次出现的索引和它在数组中的索引匹配的上，说明它只有一个\n    return arr.indexOf(v) === idx;\n  });\n}\n\n\n如果你面试初级前端的岗位的话，能写出上述代码，可以证明你已经具备编写常见的业务代码的能力了，但是如果是中高级岗位只能写出上述代码，你就得深刻的进行反思了，上述代码的算法复杂度O(N²)。\n\n\n# 2、使用ES6的Set\n\n这个实现就比较简单了，因为ES6的Set是一个特殊的Map，它是一个key-value相同的Map，也就是，一旦遇到重复的值，后面的把前面的覆盖掉，也就可以实现去重的效果了。\n\nfunction removeDuplicate(arr) {\n  return [...new Set(arr)];\n}\n\n\n这种实现方法一般，能说明你能熟练的使用ES6的API了。\n\n\n# 3、双指针\n\n有序数组的去重关键就是怎么样利用起来有序的这个条件。\n\n如果数据结构这门课学的比较好的同学一定知道合并两个有序数组这个题，这是归并排序的基础。那么有序数组的去重的与它的区别就仅仅体现在如果在合并的过程中，遇到两个数组元素相等的时候，只添加一个元素到结果集就好。\n\n/**\n * 有序数组去重\n * @param {number[]} arr1\n * @param {number[]} arr2\n */\nfunction removeDuplicate(arr1, arr2) {\n  let offset1 = 0;\n  let offset2 = 0;\n  const result = [];\n  //如果有一个数组已经合并完成了的话，循环退出\n  while (offset1 < arr1.length && offset2 < arr2.length) {\n    // 分别从两个数组中取出\n    let v1 = arr1[offset1];\n    let v2 = arr2[offset2];\n    //值相等的时候合并一个就好\n    if (v1 === v2) {\n      result.push(v1);\n      offset1++;\n      offset2++;\n    } else if (v1 < v2) {\n      // 合并小的值\n      result.push(v1);\n      offset1++;\n    } else if (v2 < v1) {\n      // 合并小的值\n      result.push(v2);\n      offset2++;\n    }\n  }\n  // 在上述循环退出来以后，有3种情况，有可能两个数组都合并完了，有可能数组1还没有合并完，也有可能数组2还没有合并完，也就是说以下两个while循环不可能同时成立，至多执行1个\n  while (offset1 < arr1.length) {\n    result.push(arr1[offset1++]);\n  }\n  while (offset2 < arr2.length) {\n    result.push(arr2[offset2++]);\n  }\n  return result;\n}\n\n\n这样处理之后，不仅完成了数组去重，而且仍然能够保证结果集有序。\n\n如果算上之前对数组进行排序的时间复杂度的话，排序算法最优的平均复杂度为O(N*logN)，合并数组的过程时间复杂度为O(N)，取最多的复杂度，所以，这种办法的时间复杂度是O(N*logN)(无论什么办法，最终得到的新数组总需要花费空间存储，所以这个空间复杂度肯定是不能讨论的)\n\n\n# 4、哈希表\n\n对于任意数组的合并，采用哈希表是一个比较优秀的解法，如果在面试过程中你能写出这种去重的办法面试官肯定会非常欣赏你的。\n\n思路非常简单，首先，我们先对一个数组建立哈希表，然后遍历另外一个数组，每次遍历的时候，插入哈希表，因为哈希表就算新来的值把之前的覆盖也无所谓，最终我们需要的是哈希表的记录的 key\n\n/**\n * 数组去重\n * @param {number[]} arr1\n * @param {number[]} arr2\n */\nfunction removeDuplicate(arr1, arr2) {\n  const map = new Map();\n  // 将没有在哈希表中出现过的元素加入到哈希表中\n  for (let i = 0; i < arr1.length; i++) {\n    const num = arr1[i];\n    map.set(num, 1);\n  }\n  // 遍历另外一个数组，如果哈希表中还没有，加入，否则跳过\n  for (let i = 0; i < arr2.length; i++) {\n    const num = arr2[i];\n    map.set(num, 1);\n  }\n  //以哈希表的键的集合作为结果集，就是不重复的元素，map.keys()得到的是一个Iterator，使用扩展运算符可以将其变成一个真的数组\n  return [...map.keys()];\n}\n\n\n这个实现用哪个数组建哈希表无所谓，因为哈希表最终建立的记录数总是趋近于两个数组的总长度的。\n\n建立哈希表需要一个循环O(N)，遍历数组需要一个循环O(N)，遍历哈希的记录数需要一个循环O(N)，去掉系数3，上述操作的时间复杂度是O(N)，哈希表记录的内容趋近于两者的总和，因此空间复杂度O(N)\n\n其实方法2的底层实现就是最后的这个实现，因为我们在Set是一个key-value相同的Map，后来的元素即便将之前的元素覆盖掉，但是最终Map的记录还是只记录了一条的，所以最终得到的结果就是两个数组无重复的并集啦。",normalizedContent:"# 数组去重\n\n数组去重作为前端入门级的面试题，可以说出现的频率实在是太高了。我在17年刚毕业的那会儿面试新华三，就被问到了这道题，尴尬的是我竟然没有写出来。\n\n最少有3种实现方式。\n\n\n# 1、两重for循环\n\n这个可以说是通解了，属于没有什么技术含量的解法了。其思路就是首先第一重循环作用于数组本身，然后遇到新来的一个元素，再结果集里面再施加一重循环，查找是否在结果集中存在，若存在就跳过，否则就将其添加到结果集中。\n\nfunction removeduplicate(arr) {\n  const datasets = [];\n  for (let i = 0; i < arr.length; i++) {\n    const num = arr[i];\n    // 在结果集中查找是否存在\n    if (datasets.every((v) => v !== num)) {\n      datasets.push(num);\n    }\n  }\n  return datasets;\n}\n\n\n另外，还有一种简洁的写法：\n\n/**\n * 数组去重\n * @param {number[]} arr 待去重数组\n * @returns\n */\nfunction removeduplicate(arr) {\n  // 本质上和两重for循环是一样的意思\n  return arr.filter((v, idx) => {\n    // 过滤依据是，如果当前元素第一次出现的索引和它在数组中的索引匹配的上，说明它只有一个\n    return arr.indexof(v) === idx;\n  });\n}\n\n\n如果你面试初级前端的岗位的话，能写出上述代码，可以证明你已经具备编写常见的业务代码的能力了，但是如果是中高级岗位只能写出上述代码，你就得深刻的进行反思了，上述代码的算法复杂度o(n²)。\n\n\n# 2、使用es6的set\n\n这个实现就比较简单了，因为es6的set是一个特殊的map，它是一个key-value相同的map，也就是，一旦遇到重复的值，后面的把前面的覆盖掉，也就可以实现去重的效果了。\n\nfunction removeduplicate(arr) {\n  return [...new set(arr)];\n}\n\n\n这种实现方法一般，能说明你能熟练的使用es6的api了。\n\n\n# 3、双指针\n\n有序数组的去重关键就是怎么样利用起来有序的这个条件。\n\n如果数据结构这门课学的比较好的同学一定知道合并两个有序数组这个题，这是归并排序的基础。那么有序数组的去重的与它的区别就仅仅体现在如果在合并的过程中，遇到两个数组元素相等的时候，只添加一个元素到结果集就好。\n\n/**\n * 有序数组去重\n * @param {number[]} arr1\n * @param {number[]} arr2\n */\nfunction removeduplicate(arr1, arr2) {\n  let offset1 = 0;\n  let offset2 = 0;\n  const result = [];\n  //如果有一个数组已经合并完成了的话，循环退出\n  while (offset1 < arr1.length && offset2 < arr2.length) {\n    // 分别从两个数组中取出\n    let v1 = arr1[offset1];\n    let v2 = arr2[offset2];\n    //值相等的时候合并一个就好\n    if (v1 === v2) {\n      result.push(v1);\n      offset1++;\n      offset2++;\n    } else if (v1 < v2) {\n      // 合并小的值\n      result.push(v1);\n      offset1++;\n    } else if (v2 < v1) {\n      // 合并小的值\n      result.push(v2);\n      offset2++;\n    }\n  }\n  // 在上述循环退出来以后，有3种情况，有可能两个数组都合并完了，有可能数组1还没有合并完，也有可能数组2还没有合并完，也就是说以下两个while循环不可能同时成立，至多执行1个\n  while (offset1 < arr1.length) {\n    result.push(arr1[offset1++]);\n  }\n  while (offset2 < arr2.length) {\n    result.push(arr2[offset2++]);\n  }\n  return result;\n}\n\n\n这样处理之后，不仅完成了数组去重，而且仍然能够保证结果集有序。\n\n如果算上之前对数组进行排序的时间复杂度的话，排序算法最优的平均复杂度为o(n*logn)，合并数组的过程时间复杂度为o(n)，取最多的复杂度，所以，这种办法的时间复杂度是o(n*logn)(无论什么办法，最终得到的新数组总需要花费空间存储，所以这个空间复杂度肯定是不能讨论的)\n\n\n# 4、哈希表\n\n对于任意数组的合并，采用哈希表是一个比较优秀的解法，如果在面试过程中你能写出这种去重的办法面试官肯定会非常欣赏你的。\n\n思路非常简单，首先，我们先对一个数组建立哈希表，然后遍历另外一个数组，每次遍历的时候，插入哈希表，因为哈希表就算新来的值把之前的覆盖也无所谓，最终我们需要的是哈希表的记录的 key\n\n/**\n * 数组去重\n * @param {number[]} arr1\n * @param {number[]} arr2\n */\nfunction removeduplicate(arr1, arr2) {\n  const map = new map();\n  // 将没有在哈希表中出现过的元素加入到哈希表中\n  for (let i = 0; i < arr1.length; i++) {\n    const num = arr1[i];\n    map.set(num, 1);\n  }\n  // 遍历另外一个数组，如果哈希表中还没有，加入，否则跳过\n  for (let i = 0; i < arr2.length; i++) {\n    const num = arr2[i];\n    map.set(num, 1);\n  }\n  //以哈希表的键的集合作为结果集，就是不重复的元素，map.keys()得到的是一个iterator，使用扩展运算符可以将其变成一个真的数组\n  return [...map.keys()];\n}\n\n\n这个实现用哪个数组建哈希表无所谓，因为哈希表最终建立的记录数总是趋近于两个数组的总长度的。\n\n建立哈希表需要一个循环o(n)，遍历数组需要一个循环o(n)，遍历哈希的记录数需要一个循环o(n)，去掉系数3，上述操作的时间复杂度是o(n)，哈希表记录的内容趋近于两者的总和，因此空间复杂度o(n)\n\n其实方法2的底层实现就是最后的这个实现，因为我们在set是一个key-value相同的map，后来的元素即便将之前的元素覆盖掉，但是最终map的记录还是只记录了一条的，所以最终得到的结果就是两个数组无重复的并集啦。",charsets:{cjk:!0}},{title:"MySQL 学习笔记",frontmatter:{},regularPath:"/mysql.html",relativePath:"mysql.md",key:"v-571ef5f5",path:"/mysql.html",headers:[{level:2,title:"登录",slug:"登录",normalizedTitle:"登录",charIndex:17},{level:2,title:"常见命令",slug:"常见命令",normalizedTitle:"常见命令",charIndex:64},{level:2,title:"注释",slug:"注释",normalizedTitle:"注释",charIndex:291},{level:2,title:"DQL 语言",slug:"dql-语言",normalizedTitle:"dql 语言",charIndex:358},{level:3,title:"查询",slug:"查询",normalizedTitle:"查询",charIndex:369},{level:2,title:"DML 语言",slug:"dml-语言",normalizedTitle:"dml 语言",charIndex:9612},{level:2,title:"DDL 语言",slug:"ddl-语言",normalizedTitle:"ddl 语言",charIndex:9623}],headersStr:"登录 常见命令 注释 DQL 语言 查询 DML 语言 DDL 语言",content:"# MySQL 学习笔记\n\n\n# 登录\n\nmysql -u root -p -h localhost -P 3306\n\n\n\n# 常见命令\n\n# 显示所有的数据库\nshow databases;\n# 选择数据库 xxx\nuse xxx;\n# 展示数据的表\nshow tables;\nshow tables from xxx;\n# 显示当前所在的数据库\nselect database();\n# 查看指定表的表结构\ndesc xxx;\n# 查看数据库的版本\nselect version();\n\n\n## 利用bash命令\nmysql --version;\nmysql -V;\n\n\n\n# 注释\n\n单行注释： -- 注释内容;（注意--后面有一个空格） 单行注释：#注释内容 多行注释：/* 我是一个注释内容 */\n\n\n# DQL 语言\n\n\n# 查询\n\n# select\n\n# 从表中查询字段\nselect * from employees;\nselect username,age,gender from employees;\nselect username as myName from employees;\n# 关键字区分\n# select NAME from employees NAME会被当做关键字，因此可以用``包起来，如。\nselect `name` from employees;\n\n# 查询常量值\nselect 100\n# 查询函数\nselect NOW();\nselect version();\n# 查询表达式\nselect 2*100;\n\n# 别名 as可以省略\nselect 2+100 as `add`;\nselect 2/100 'test';\n\n# 去重 distinct;\nselect distinct * from employees;\n\n# + 只存在数值相加的功能，但是如果是字符串和数字相加，则判断能否转化成数字型，能转就转，不能转就相当于是0\n# `NULL`和任何内容连接都是`NULL`\n\n\n\n# where 条件查询\n\n1、按条件表达式\n\n> < = != <> >= <=等。\n\nselect * from employees where salary > 1200;\nselect * from employees where department_id != 90;\n\n\n推荐用<>代替!=;\n\n2、按逻辑表达式\n\n&& || ! and or not等。\n\nselect * from employees where salary > 1200 && department_id > 90;\nselect * from employees where salary >= 10000 && salary <= 15000;\n\n\n推荐用 and， or， not。\n\n3、模糊查询\n\nlike; between and; in; is null; is not null等。\n\nselect * from employees where salary between 12000 and 15000;\nselect * from employees where commission_pct is not null and first_name like '%Jo%';\n# 匹配员工名中第三个字符为A，第五个字符为e的员工名\nselect last_name as lastName from employees where first_name like '__A_e%';\n\n\nlike和通配符搭配使用，%代表匹配任意个字符（0-n），_代表任意单个字符\n\n转义字符：\n\n# 直接转义\nselect last_name from employees where last_name like '_\\_%';\n# 使用escape关键字转义\nselect last_name from employees where last_name like '_$_%' escape '$';\n\n\n(not) between and，包含左右的临界值，但是必须是左大右小。\n\nselect * from employees where job_id in ('IT_PORT', 'AD_VP', 'AD_PRES');\n\n\nin 列表的内容的值类型必须一致或兼容。\n\nselect * from employees where commission_pct is null;\n\n\nis null 或者 is not null 可以判断NULL，但是，=，!=，<>不能判断NULL;\n\nselect * from employees where commission_pct <=> 12000;\n\n\n安全等于: <=>，既可以判断NULL，又可以判断普通数值。\n\n# 排序 order by\n\nasc 升序，desc降序，不写默认asc;\n\nselect * from employees where salary>12000 order by salary desc;\nselect * from employees where salary<12000 order by salary asc;\n# 按年薪的高低显示员工的信息和年薪\nselect *, salary * 12 * (1+IFNULL(commission_pct, 0)) as year_salary from employees order by year_salary desc;\n# 按函数排序\nselect *, salary * 12 * (1+IFNULL(commission_pct, 0)) as year_salary from employees order by LENGTH(last_name) desc;\n# 多关键字排序，多个关键字之间用逗号隔开，先按工资排序，再按编号排序\nselect * from employees order by salary desc, employee_id asc;\n\n\n# 常见函数\n\n字符串函数：\n\nLENGTH：求字符串的长度。 CONCAT：将字符串进行连接。 UPPER：将字符串转大写。 LOWER：将字符串转小写。 SUBSTR：取指定位置的子字符串， INSTR（和JS的indexOf类似）。 TRIM：消除字符串左右的空格。 LPAD：在字符串的左边填充指定的字符。 RPAD：在字符串的右边填充指定的字符。 REPLACE：将指定的字符替换。\n\n注意：索引从1开始。\n\nshow variables like '%char%';\n\n\n数学函数：\n\nROUND：四舍五入； CEIL：向上取整； FLOOR：向下取整； truncate：小数点保留 N 位有效数字； MOD：取余；\n\n日期函数：\n\nNOW：返回系统当前的时间； CURDATE：返回系统当前的日期，不包含时分秒。 CURTIME：返回系统当前的时间，不包含年月日。 YEAR：返回系统当前的年份。 MONTH：返回系统当前的月份。 MONTHNAME：返回系统当前月份的名称，如November。 ... DATE_FORMATE：将日期转换成字符。 STR_TO_DATE：将字符串转换成日期。\n\n其它函数：\n\nVERSION：返回数据库的版本。 DATABASE：返回当前使用的数据库。 USER：返回当前登录的用户。\n\nselect STR_TO_DATE('9-12-1994','%m-%d-%y');\nselect DATE_FORMAT('2022-10-10', '%y年%m月%d日');\n\n\n格式符   功能\n%Y    四位的年份\n%y    2 位的年份\n%m    月份, 01,02,03,04,05,06,07,08,09,10,11,12\n%c    月份, 1,2,3,4,5,6,7,8,9,10,11,12\n%d    月份, 1,2,3,4,5,6,7,8,9,10,11,12\n%H    小时，24 小时制\n%h    小时，12 小时制\n%i    分钟，01-59\n%s    秒，01-59\n\n流程控制函数：\n\nIFNULL： IF：IF(exp1, exp2, exp3)，如果exp1成立返回exp2，否则返回exp3。 CASE：\n\ncase 表达式 when 常量 1 then 值或语句 1 when 常量 2 then 值或语句 2 when 常量 3 then 值或语句 3 (else 值或语句) end\n\ncase when 条件 1 then 值或语句 1 when 条件 2 then 值或语句 2 when 条件 3 then 值或语句 3 (else 值或语句) end\n\nselect salary, department_id, case department_id when 30 then salary * 1.1 when 50 then salary * 1.2 else salary end as new_salary from employees;\n\n\n聚合函数：\n\nMAX：求最大值 MIN：求最小值 SUM：求和 AVG：求平均值 COUNT：统计\n\nsum和avg一般用于数值处理；max，min，count可以处理任何类型；\n\nsum、avg、count、min、max都将会忽略NULL。\n\n可以和distinct搭配，如：\n\nselect SUM(distinct salary), SUM(salary) from employees;\nselect COUNT(distinct salary) from employees;\n\n\nCOUNT函数的详细介绍，用于统计行数，如：\n\n# 用于统计行数\nselect count(*) from employees;\n# 或者\nselect count(1) from employees;\n\n\n在MYISAM引擎下，count(*)的效率高，在INNODB引擎下，COUNT(1)和COUNT(*)差不多，但是要比COUNT(字段名)要高。\n\n# group by\n\n和分组函数一同查询的字段要求是group by后的字段 伪代码如：\n\nselect column, group_function(column) from xxx_table [where condition] [group by group_by_expression] [order by column];\n\n\n例如：\n\nselect max(salary), job_id from employees group by job_id;\nselect count(*), location_id from departments group by location_id;\n\n\nwhere一定在group by之前，order by一定在最后。\n\n使用having关键字用于添加分组后的筛选：如查询部门员工数大于 2 的部门 id\n\nselect count(*), department_id from employees group by department_id having count(*) > 2;\n\n\n分组查询筛选，分为两类，一是分组前筛选，使用where（原始表数据），一类是分组后筛选，使用having（分组之后的结果集），如果是使用分组函数做条件的话，那么肯定是放在having子句中，能用分组前作筛选的，就优先考虑使用分组前筛选，group by字句支持单个或多个字段进行分组，若采用多个字段分组，则字段之间需要使用,分隔，无顺序要求。\n\n# 连接查询\n\n笛卡尔积的错误情况：\n\n# 假设输出12行\nselect count(*) from boys;\n# 假设输出4行\nselect count(*) from beauty;\n# 最终结果 4*12行\nselect `name`, `boyName` from beauty, boys;\n\n\n笛卡尔积的现象：表 1 有 m 行，表 2 有 n 行，结果 m*n 行，是因为没有有效的连接；\n\n\n分类:\n  内连接\n    等值连接\n    非等值连接\n    自连接\n  外连接\n    左外连接\n    右外连接\n    完全链接\n  交叉连接\n\n\n等值连接：\n\n# 两个表的顺序可以交换\nselect `name`, `boyName` from beauty, boys where beauty.boyfriend_id = boys.id;\n\n\n等值连接加上筛选，使用and连接。\n\nselect last_name, department_name from employees e, departments d where e.department_id = d.department_id and e.commission_pct is not null;\n# 查询所有女朋友的个数大于2的男生\nselect boy.boyName, count(*) as stat from boys as boy, beauty as girl where girl.boyfriend_id = boy.id group by boy.boyName having stat > 2 order by stat desc;\n\n\n多表等值连接连接的结果为多表的交集部分，多表连接的顺序没有要求，一般需要为表起别名。\n\n非等值连接： 即不用等号的连接查询。\n\nselect e.salary, j.grade_level from employees as e, job_grades as j where e.salary between j.lowest_sal and j.highest_sal;\n\n\n自连接：\n\n# 查询员工和领导的名称\nselect e.employee_id,e.last_name,m.employee_id as parent_id,m.last_name as parent_last_name from employees as e, employees as m where e.manager_id = m.employee_id;\n\n\n(inner) join： （查找两个表的并集）\n\nselect 查询列表 from 表1 inner join 表2 on 连接条件 [where 字句] [group by字句] [having字句] [order by 字句] [limit 字句]\n# 查询部门人数大于10的部门名称并且按人数降序排列\nSELECT d.department_name, COUNT(*) as 部门人数 from employees as e INNER JOIN departments as d on e.department_id = d.department_id GROUP BY d.department_name HAVING\t部门人数 >10 ORDER BY 部门人数 DESC;\n# 非等值连接\nselect salary,grade_level from employees as e inner join job_grades as g on e.salary between g.lowest_sal and g.highest_sal;\n# 自连接\nselect e.last_name, m.last_name from employees as e inner join employees as m on e.employee_id = m.manager_id;\n\n\nouter join:\n\n应用场景一般用于查找一个表中有，另外一个表中没有的情况，外连接的查询结果为主表中的所有记录，如果从表中有和它匹配的记录，则填充，否则填充NULL。 外连接查询结果=内连接结果+主表中有但从表中没有的记录。 全外连接=内连接的结果+表 1 中有但表 2 中没有的结果+表 2 中有的结果但表 1 中没有的结果（即求两表的并集）\n\nleft outer join: 左边的是主表，右边的是从表 right outer join: 左边的是从表，右边的主表\n\n左外连接和右外连接交换两个表的顺序，可以实现同样的效果。\n\n# 查找没有男朋友的女生列表\n# 最好选从表中的主键列作为筛选，因为主键列一般都是非空字段\nselect girl.name, girl.borndate from beauty as girl left outer join boys as boy on girl.boyfriend_id = boy.id where boy.id is null;\n\n\n交叉链接： 即笛卡尔乘积\n\nselect b.*, g.* from beauty as g cross join boys as b;\n# 等价于\nselect g.*, b.* from beauty as g, boys as b;\n\n\n# 子查询\n\n出现在其它语句中的 select 语句。 子查询先于主查询。\n\n# 查询工资比`Abel`高的人\nselect * from employees where salary > (\n  select salary from employees where last_name = 'Abel'\n);\n# 子查询中使用分组函数\nselect last_name, job_id, salary from employees where salary = (select min(salary) from employees);\n# 和`having`字句一起使用 查询最低工资大于50号部门最低工资的部门id和其最低工资\nselect department_id, min(salary) from employees group by department_id having min(salary) > (select min(salary) from employees where department_id = 50);\n# 使用IN\nselect last_name from employees where department_id in (\n   select distinct department_id from departments where location_id in (1400, 1700)\n);\n# 使用any或者some\n# 查询其它部门中比job_id为`IT_PROG`部门任一低工资的员工的员工号、姓名、job_id以及salary\nselect  last_name, employee_id, job_id, salary from employees where salary < any(\n  select distinct salary from employees where job_id='IT_PROG'\n) and job_id <> 'IT_PROG';\n# 使用all\n# 查询其它部门中比job_id为`IT_PROG`部门任一低工资的员工的员工号、姓名、job_id以及salary\nselect  last_name, employee_id, job_id, salary from employees where salary < all(\n  select distinct salary from employees where job_id='IT_PROG'\n) and job_id <> 'IT_PROG';\n# 不常用的行子查询\n# 查询员工编号最小并且工资最高的员工信息\nselect * from employees where job_id = (\n  select min(job_id) from employees\n)\nand salary = (\n  select max(salary) from employees\n);\n# 或者\nselect * from employees where (job_id,salary) = (\n  select min(job_id), max(salary) from employees\n);\n# 查询每个部门的员工个数\nselect (\n  select count(*) from employees as e where e.department_id = d.department_id\n) as 员工个数 from departments as d having 员工个数 > 0 order by 员工个数 desc;\n\n\nfrom后面字句，把一个查询结果当做表来使用\n\n# 查询各个部门的平均工资对应的工资等级\nselect ag_dep.*, g.grade_level from (\n  select AVG(salary) as ag, department_id from employees group by department_id\n) as ag_dep inner join job_grades as g on ag_dep.ag between lowest_sal and highest_sal;\n\n\n相关子查询(exists)\n\n语法： exists(完整的查询语句)，返回1或者0\n\n# 查询有员工的部门名\nselect department_name from departments as d where exists (\n  select * from employees as e where d.department_id = e.department_id\n);\n# 等价转换\nselect department_name from departments as d inner join employees as e on d.department_id = e.department_id group by d.department_id having count(*) > 0;\n# 查询没有女朋友的男生信息\n# 使用in\nselect boy.* from boys as boy where boy.id not in (\n  select boyfriend_id from beauty\n);\n# 使用exists\nselect boy.* from boys as boy where not exists(\n  select boyfriend_id from beauty as girl where boy.id = girl.boyfriend_id\n);\n\n\n\n# DML 语言\n\n\n# DDL 语言",normalizedContent:"# mysql 学习笔记\n\n\n# 登录\n\nmysql -u root -p -h localhost -p 3306\n\n\n\n# 常见命令\n\n# 显示所有的数据库\nshow databases;\n# 选择数据库 xxx\nuse xxx;\n# 展示数据的表\nshow tables;\nshow tables from xxx;\n# 显示当前所在的数据库\nselect database();\n# 查看指定表的表结构\ndesc xxx;\n# 查看数据库的版本\nselect version();\n\n\n## 利用bash命令\nmysql --version;\nmysql -v;\n\n\n\n# 注释\n\n单行注释： -- 注释内容;（注意--后面有一个空格） 单行注释：#注释内容 多行注释：/* 我是一个注释内容 */\n\n\n# dql 语言\n\n\n# 查询\n\n# select\n\n# 从表中查询字段\nselect * from employees;\nselect username,age,gender from employees;\nselect username as myname from employees;\n# 关键字区分\n# select name from employees name会被当做关键字，因此可以用``包起来，如。\nselect `name` from employees;\n\n# 查询常量值\nselect 100\n# 查询函数\nselect now();\nselect version();\n# 查询表达式\nselect 2*100;\n\n# 别名 as可以省略\nselect 2+100 as `add`;\nselect 2/100 'test';\n\n# 去重 distinct;\nselect distinct * from employees;\n\n# + 只存在数值相加的功能，但是如果是字符串和数字相加，则判断能否转化成数字型，能转就转，不能转就相当于是0\n# `null`和任何内容连接都是`null`\n\n\n\n# where 条件查询\n\n1、按条件表达式\n\n> < = != <> >= <=等。\n\nselect * from employees where salary > 1200;\nselect * from employees where department_id != 90;\n\n\n推荐用<>代替!=;\n\n2、按逻辑表达式\n\n&& || ! and or not等。\n\nselect * from employees where salary > 1200 && department_id > 90;\nselect * from employees where salary >= 10000 && salary <= 15000;\n\n\n推荐用 and， or， not。\n\n3、模糊查询\n\nlike; between and; in; is null; is not null等。\n\nselect * from employees where salary between 12000 and 15000;\nselect * from employees where commission_pct is not null and first_name like '%jo%';\n# 匹配员工名中第三个字符为a，第五个字符为e的员工名\nselect last_name as lastname from employees where first_name like '__a_e%';\n\n\nlike和通配符搭配使用，%代表匹配任意个字符（0-n），_代表任意单个字符\n\n转义字符：\n\n# 直接转义\nselect last_name from employees where last_name like '_\\_%';\n# 使用escape关键字转义\nselect last_name from employees where last_name like '_$_%' escape '$';\n\n\n(not) between and，包含左右的临界值，但是必须是左大右小。\n\nselect * from employees where job_id in ('it_port', 'ad_vp', 'ad_pres');\n\n\nin 列表的内容的值类型必须一致或兼容。\n\nselect * from employees where commission_pct is null;\n\n\nis null 或者 is not null 可以判断null，但是，=，!=，<>不能判断null;\n\nselect * from employees where commission_pct <=> 12000;\n\n\n安全等于: <=>，既可以判断null，又可以判断普通数值。\n\n# 排序 order by\n\nasc 升序，desc降序，不写默认asc;\n\nselect * from employees where salary>12000 order by salary desc;\nselect * from employees where salary<12000 order by salary asc;\n# 按年薪的高低显示员工的信息和年薪\nselect *, salary * 12 * (1+ifnull(commission_pct, 0)) as year_salary from employees order by year_salary desc;\n# 按函数排序\nselect *, salary * 12 * (1+ifnull(commission_pct, 0)) as year_salary from employees order by length(last_name) desc;\n# 多关键字排序，多个关键字之间用逗号隔开，先按工资排序，再按编号排序\nselect * from employees order by salary desc, employee_id asc;\n\n\n# 常见函数\n\n字符串函数：\n\nlength：求字符串的长度。 concat：将字符串进行连接。 upper：将字符串转大写。 lower：将字符串转小写。 substr：取指定位置的子字符串， instr（和js的indexof类似）。 trim：消除字符串左右的空格。 lpad：在字符串的左边填充指定的字符。 rpad：在字符串的右边填充指定的字符。 replace：将指定的字符替换。\n\n注意：索引从1开始。\n\nshow variables like '%char%';\n\n\n数学函数：\n\nround：四舍五入； ceil：向上取整； floor：向下取整； truncate：小数点保留 n 位有效数字； mod：取余；\n\n日期函数：\n\nnow：返回系统当前的时间； curdate：返回系统当前的日期，不包含时分秒。 curtime：返回系统当前的时间，不包含年月日。 year：返回系统当前的年份。 month：返回系统当前的月份。 monthname：返回系统当前月份的名称，如november。 ... date_formate：将日期转换成字符。 str_to_date：将字符串转换成日期。\n\n其它函数：\n\nversion：返回数据库的版本。 database：返回当前使用的数据库。 user：返回当前登录的用户。\n\nselect str_to_date('9-12-1994','%m-%d-%y');\nselect date_format('2022-10-10', '%y年%m月%d日');\n\n\n格式符   功能\n%y    四位的年份\n%y    2 位的年份\n%m    月份, 01,02,03,04,05,06,07,08,09,10,11,12\n%c    月份, 1,2,3,4,5,6,7,8,9,10,11,12\n%d    月份, 1,2,3,4,5,6,7,8,9,10,11,12\n%h    小时，24 小时制\n%h    小时，12 小时制\n%i    分钟，01-59\n%s    秒，01-59\n\n流程控制函数：\n\nifnull： if：if(exp1, exp2, exp3)，如果exp1成立返回exp2，否则返回exp3。 case：\n\ncase 表达式 when 常量 1 then 值或语句 1 when 常量 2 then 值或语句 2 when 常量 3 then 值或语句 3 (else 值或语句) end\n\ncase when 条件 1 then 值或语句 1 when 条件 2 then 值或语句 2 when 条件 3 then 值或语句 3 (else 值或语句) end\n\nselect salary, department_id, case department_id when 30 then salary * 1.1 when 50 then salary * 1.2 else salary end as new_salary from employees;\n\n\n聚合函数：\n\nmax：求最大值 min：求最小值 sum：求和 avg：求平均值 count：统计\n\nsum和avg一般用于数值处理；max，min，count可以处理任何类型；\n\nsum、avg、count、min、max都将会忽略null。\n\n可以和distinct搭配，如：\n\nselect sum(distinct salary), sum(salary) from employees;\nselect count(distinct salary) from employees;\n\n\ncount函数的详细介绍，用于统计行数，如：\n\n# 用于统计行数\nselect count(*) from employees;\n# 或者\nselect count(1) from employees;\n\n\n在myisam引擎下，count(*)的效率高，在innodb引擎下，count(1)和count(*)差不多，但是要比count(字段名)要高。\n\n# group by\n\n和分组函数一同查询的字段要求是group by后的字段 伪代码如：\n\nselect column, group_function(column) from xxx_table [where condition] [group by group_by_expression] [order by column];\n\n\n例如：\n\nselect max(salary), job_id from employees group by job_id;\nselect count(*), location_id from departments group by location_id;\n\n\nwhere一定在group by之前，order by一定在最后。\n\n使用having关键字用于添加分组后的筛选：如查询部门员工数大于 2 的部门 id\n\nselect count(*), department_id from employees group by department_id having count(*) > 2;\n\n\n分组查询筛选，分为两类，一是分组前筛选，使用where（原始表数据），一类是分组后筛选，使用having（分组之后的结果集），如果是使用分组函数做条件的话，那么肯定是放在having子句中，能用分组前作筛选的，就优先考虑使用分组前筛选，group by字句支持单个或多个字段进行分组，若采用多个字段分组，则字段之间需要使用,分隔，无顺序要求。\n\n# 连接查询\n\n笛卡尔积的错误情况：\n\n# 假设输出12行\nselect count(*) from boys;\n# 假设输出4行\nselect count(*) from beauty;\n# 最终结果 4*12行\nselect `name`, `boyname` from beauty, boys;\n\n\n笛卡尔积的现象：表 1 有 m 行，表 2 有 n 行，结果 m*n 行，是因为没有有效的连接；\n\n\n分类:\n  内连接\n    等值连接\n    非等值连接\n    自连接\n  外连接\n    左外连接\n    右外连接\n    完全链接\n  交叉连接\n\n\n等值连接：\n\n# 两个表的顺序可以交换\nselect `name`, `boyname` from beauty, boys where beauty.boyfriend_id = boys.id;\n\n\n等值连接加上筛选，使用and连接。\n\nselect last_name, department_name from employees e, departments d where e.department_id = d.department_id and e.commission_pct is not null;\n# 查询所有女朋友的个数大于2的男生\nselect boy.boyname, count(*) as stat from boys as boy, beauty as girl where girl.boyfriend_id = boy.id group by boy.boyname having stat > 2 order by stat desc;\n\n\n多表等值连接连接的结果为多表的交集部分，多表连接的顺序没有要求，一般需要为表起别名。\n\n非等值连接： 即不用等号的连接查询。\n\nselect e.salary, j.grade_level from employees as e, job_grades as j where e.salary between j.lowest_sal and j.highest_sal;\n\n\n自连接：\n\n# 查询员工和领导的名称\nselect e.employee_id,e.last_name,m.employee_id as parent_id,m.last_name as parent_last_name from employees as e, employees as m where e.manager_id = m.employee_id;\n\n\n(inner) join： （查找两个表的并集）\n\nselect 查询列表 from 表1 inner join 表2 on 连接条件 [where 字句] [group by字句] [having字句] [order by 字句] [limit 字句]\n# 查询部门人数大于10的部门名称并且按人数降序排列\nselect d.department_name, count(*) as 部门人数 from employees as e inner join departments as d on e.department_id = d.department_id group by d.department_name having\t部门人数 >10 order by 部门人数 desc;\n# 非等值连接\nselect salary,grade_level from employees as e inner join job_grades as g on e.salary between g.lowest_sal and g.highest_sal;\n# 自连接\nselect e.last_name, m.last_name from employees as e inner join employees as m on e.employee_id = m.manager_id;\n\n\nouter join:\n\n应用场景一般用于查找一个表中有，另外一个表中没有的情况，外连接的查询结果为主表中的所有记录，如果从表中有和它匹配的记录，则填充，否则填充null。 外连接查询结果=内连接结果+主表中有但从表中没有的记录。 全外连接=内连接的结果+表 1 中有但表 2 中没有的结果+表 2 中有的结果但表 1 中没有的结果（即求两表的并集）\n\nleft outer join: 左边的是主表，右边的是从表 right outer join: 左边的是从表，右边的主表\n\n左外连接和右外连接交换两个表的顺序，可以实现同样的效果。\n\n# 查找没有男朋友的女生列表\n# 最好选从表中的主键列作为筛选，因为主键列一般都是非空字段\nselect girl.name, girl.borndate from beauty as girl left outer join boys as boy on girl.boyfriend_id = boy.id where boy.id is null;\n\n\n交叉链接： 即笛卡尔乘积\n\nselect b.*, g.* from beauty as g cross join boys as b;\n# 等价于\nselect g.*, b.* from beauty as g, boys as b;\n\n\n# 子查询\n\n出现在其它语句中的 select 语句。 子查询先于主查询。\n\n# 查询工资比`abel`高的人\nselect * from employees where salary > (\n  select salary from employees where last_name = 'abel'\n);\n# 子查询中使用分组函数\nselect last_name, job_id, salary from employees where salary = (select min(salary) from employees);\n# 和`having`字句一起使用 查询最低工资大于50号部门最低工资的部门id和其最低工资\nselect department_id, min(salary) from employees group by department_id having min(salary) > (select min(salary) from employees where department_id = 50);\n# 使用in\nselect last_name from employees where department_id in (\n   select distinct department_id from departments where location_id in (1400, 1700)\n);\n# 使用any或者some\n# 查询其它部门中比job_id为`it_prog`部门任一低工资的员工的员工号、姓名、job_id以及salary\nselect  last_name, employee_id, job_id, salary from employees where salary < any(\n  select distinct salary from employees where job_id='it_prog'\n) and job_id <> 'it_prog';\n# 使用all\n# 查询其它部门中比job_id为`it_prog`部门任一低工资的员工的员工号、姓名、job_id以及salary\nselect  last_name, employee_id, job_id, salary from employees where salary < all(\n  select distinct salary from employees where job_id='it_prog'\n) and job_id <> 'it_prog';\n# 不常用的行子查询\n# 查询员工编号最小并且工资最高的员工信息\nselect * from employees where job_id = (\n  select min(job_id) from employees\n)\nand salary = (\n  select max(salary) from employees\n);\n# 或者\nselect * from employees where (job_id,salary) = (\n  select min(job_id), max(salary) from employees\n);\n# 查询每个部门的员工个数\nselect (\n  select count(*) from employees as e where e.department_id = d.department_id\n) as 员工个数 from departments as d having 员工个数 > 0 order by 员工个数 desc;\n\n\nfrom后面字句，把一个查询结果当做表来使用\n\n# 查询各个部门的平均工资对应的工资等级\nselect ag_dep.*, g.grade_level from (\n  select avg(salary) as ag, department_id from employees group by department_id\n) as ag_dep inner join job_grades as g on ag_dep.ag between lowest_sal and highest_sal;\n\n\n相关子查询(exists)\n\n语法： exists(完整的查询语句)，返回1或者0\n\n# 查询有员工的部门名\nselect department_name from departments as d where exists (\n  select * from employees as e where d.department_id = e.department_id\n);\n# 等价转换\nselect department_name from departments as d inner join employees as e on d.department_id = e.department_id group by d.department_id having count(*) > 0;\n# 查询没有女朋友的男生信息\n# 使用in\nselect boy.* from boys as boy where boy.id not in (\n  select boyfriend_id from beauty\n);\n# 使用exists\nselect boy.* from boys as boy where not exists(\n  select boyfriend_id from beauty as girl where boy.id = girl.boyfriend_id\n);\n\n\n\n# dml 语言\n\n\n# ddl 语言",charsets:{cjk:!0}},{title:"杂项专题",frontmatter:{title:"杂项专题"},regularPath:"/others/",relativePath:"others/index.md",key:"v-31509cce",path:"/others/",headersStr:null,content:" * 杂项专题\n * 常见面试题",normalizedContent:" * 杂项专题\n * 常见面试题",charsets:{cjk:!0}},{title:"1、有序数组求满足某个和为某个值的组合",frontmatter:{},regularPath:"/others/interview.html",relativePath:"others/interview.md",key:"v-ef606112",path:"/others/interview.html",headers:[{level:2,title:"1、有序数组求满足某个和为某个值的组合",slug:"_1、有序数组求满足某个和为某个值的组合",normalizedTitle:"1、有序数组求满足某个和为某个值的组合",charIndex:2},{level:2,title:"2、试写一个求和函数",slug:"_2、试写一个求和函数",normalizedTitle:"2、试写一个求和函数",charIndex:1088}],headersStr:"1、有序数组求满足某个和为某个值的组合 2、试写一个求和函数",content:'# 1、有序数组求满足某个和为某个值的组合\n\n编写一个函数sum，给定一个已知有序数组（从小到大）和一个目标值，求得所有可以组成目标值的数对，每个数组元素只能使用一次，要求算法复杂度越低越好。\n\n对于这题的思路，如果你还仅仅只想到两个for循环的话，那么说明你功力尚浅，还需继续努力哦。\n\n思路分析：\n\n题设给定的是一个有序数组，那么该怎么把有序数组这个条件利用起来呢？首先，我们想考虑一些边界的 case，假设target特别小或者特别大，假如我们取最后两个数来进行相加，仍然比target小的话，那么是否就说明一个满足条件的组合都没有呢？设想，最后两个较大的数都不满足，比倒数第二个前面更小的就更不可能了。有了这个思路之后，双指针的结题思维方式就已经建立了。\n\n首先，我们定义两个指针，分别指向数组的第一个元素和最后一个元素，那么如果对这两个元素求和的话，如果刚好相等，是否当前这组已经满足了，那么就左指针向后走一位，右指针向前走一位。如果和比目标值小，说明当前左指针对应的元素太小了，那么就把左指针向后移动一位。反之，如果和比目标值大，说明当前右指针对应的元素太大了，那么就把右指针往前移动一位。什么时候停止呢？如果左指针跟右指针相遇了，那么根据题设条件元素只能用一次，所以这个时刻就应该终止了。\n\n根据上面的分析，就很容易给出答案：\n\nfunction sum(arr, target) {\n  let start = 0;\n  let end = arr.length - 1;\n  const group = [];\n  // 当左右指针相遇的时候 终止循环\n  while (start < end) {\n    let a = arr[start];\n    let b = arr[end];\n    let tempSum = a + b;\n    // 目标值比target小，说明左指针对应的元素太小了\n    if (tempSum < target) {\n      start++;\n    }\n    // 目标值比target大，说明右指针对应的元素太大了\n    else if (tempSum > target) {\n      end--;\n    }\n    // 找到了的话，说明刚好合适，为了不重复使用元素，左指针后移，右指针前移\n    else {\n      start++;\n      end--;\n      group.push([a, b]);\n    }\n  }\n  return group;\n}\n\n\n\n# 2、试写一个求和函数\n\n试写一个求和函数，实现下面的效果\n\nsum(1, 2, 3, 4, 5); //expect 15\nsum(5, -5); // expect 0\nsum("1.0", false, 1, true, 1, "A", 1, "B"); // expect 4\nsum("0.1", "0.2"); // expect 0.3 not be 0.3000002\n\n\n这题，我们采用高规格的结题思路解决它，首先，先回想一下Number.parseFloat的处理流程，对于一个字符串，首先我们想设想符合规则的情况，如果开头是空格，则忽略，紧接着可能是-和+，然后可能开始遇到数字，需要考虑多个 0 的问题，需要仅保留一个 0，然后可能是.，如果是.的话，后面必须解析到数字才行，其余的情况均视为无法解析出正确的数字。\n\n下面是我给出的实现，如果仍然有 case 没有考虑完全的话，欢迎各位读者 issue\n\n/**\n * 将字符串解析成数字\n * @param {string} str 待解析字符串\n */\nfunction MyParseFloat(str) {\n  str = str.replace(/^\\s*/, "");\n  let pos = 0;\n  // 是否有符号\n  let signal = {\n    val: "",\n    proceed: false,\n  };\n  // 是否有小数点\n  let point = {\n    pos: -1,\n    proceed: false,\n  };\n  // 小数点前面的数字\n  let beforePointDigits = [];\n  let afterPointDigits = [];\n  while (pos < str.length) {\n    const char = str[pos];\n    if (["+", "-"].includes(char)) {\n      // 处理过了的话，直接可以结束循环\n      if (signal.proceed) {\n        break;\n      }\n      // 符号，没有处理过\n      signal.proceed = true;\n      signal.val = char;\n    } else if (char === ".") {\n      // 处理过小数点了的话，直接可以结束循环\n      if (point.proceed) {\n        break;\n      }\n      point.proceed = true;\n      point.pos = pos;\n    } else if (/\\d/.test(char)) {\n      // 数字，如果在小数点之前出现的数字，放在前面\n      if (point.proceed) {\n        afterPointDigits.push(char);\n      } else {\n        beforePointDigits.push(char);\n      }\n    } else {\n      // 非数字且非空格直接可以结束\n      break;\n    }\n    pos++;\n  }\n  // 消除前导0\n  while (beforePointDigits.length > 1 && beforePointDigits[0] == "0") {\n    beforePointDigits.shift();\n  }\n  // 如果是小数点直接打头，补足一个前导0\n  if (point.proceed && beforePointDigits.length === 0) {\n    beforePointDigits.push("0");\n  }\n  // 消除结尾的0\n  while (\n    afterPointDigits.length &&\n    afterPointDigits[afterPointDigits.length - 1] == "0"\n  ) {\n    afterPointDigits.pop();\n  }\n  // 如果一个数字都没有解析出来的话，说明解析出错了\n  if (beforePointDigits.length === 0 && afterPointDigits.length === 0) {\n    return NaN;\n  }\n  // 处理符号\n  const symbol = signal.val === "-" ? "-" : "";\n  // 处理-0\n  if (\n    symbol === "-" &&\n    beforePointDigits.length === 1 &&\n    beforePointDigits[0] === "0" &&\n    afterPointDigits.length === 0\n  ) {\n    return "0";\n  }\n  return (\n    symbol +\n    beforePointDigits.join() +\n    (point.proceed && afterPointDigits.length > 0 ? "." : "") +\n    afterPointDigits.join()\n  );\n}\n\n\n在实现了parseFloat之后，接着有一个非常重要的问题，因为计算机的浮点数相加不准确的问题，但是题设却希望 0.1+0.2===0.3，很显然，直接用数字相加减肯定是行不通的，那么只能转换成字符串相加，其大概的处理流程和合并两个有序数组类似。\n\nfunction add(a, b) {}\n',normalizedContent:'# 1、有序数组求满足某个和为某个值的组合\n\n编写一个函数sum，给定一个已知有序数组（从小到大）和一个目标值，求得所有可以组成目标值的数对，每个数组元素只能使用一次，要求算法复杂度越低越好。\n\n对于这题的思路，如果你还仅仅只想到两个for循环的话，那么说明你功力尚浅，还需继续努力哦。\n\n思路分析：\n\n题设给定的是一个有序数组，那么该怎么把有序数组这个条件利用起来呢？首先，我们想考虑一些边界的 case，假设target特别小或者特别大，假如我们取最后两个数来进行相加，仍然比target小的话，那么是否就说明一个满足条件的组合都没有呢？设想，最后两个较大的数都不满足，比倒数第二个前面更小的就更不可能了。有了这个思路之后，双指针的结题思维方式就已经建立了。\n\n首先，我们定义两个指针，分别指向数组的第一个元素和最后一个元素，那么如果对这两个元素求和的话，如果刚好相等，是否当前这组已经满足了，那么就左指针向后走一位，右指针向前走一位。如果和比目标值小，说明当前左指针对应的元素太小了，那么就把左指针向后移动一位。反之，如果和比目标值大，说明当前右指针对应的元素太大了，那么就把右指针往前移动一位。什么时候停止呢？如果左指针跟右指针相遇了，那么根据题设条件元素只能用一次，所以这个时刻就应该终止了。\n\n根据上面的分析，就很容易给出答案：\n\nfunction sum(arr, target) {\n  let start = 0;\n  let end = arr.length - 1;\n  const group = [];\n  // 当左右指针相遇的时候 终止循环\n  while (start < end) {\n    let a = arr[start];\n    let b = arr[end];\n    let tempsum = a + b;\n    // 目标值比target小，说明左指针对应的元素太小了\n    if (tempsum < target) {\n      start++;\n    }\n    // 目标值比target大，说明右指针对应的元素太大了\n    else if (tempsum > target) {\n      end--;\n    }\n    // 找到了的话，说明刚好合适，为了不重复使用元素，左指针后移，右指针前移\n    else {\n      start++;\n      end--;\n      group.push([a, b]);\n    }\n  }\n  return group;\n}\n\n\n\n# 2、试写一个求和函数\n\n试写一个求和函数，实现下面的效果\n\nsum(1, 2, 3, 4, 5); //expect 15\nsum(5, -5); // expect 0\nsum("1.0", false, 1, true, 1, "a", 1, "b"); // expect 4\nsum("0.1", "0.2"); // expect 0.3 not be 0.3000002\n\n\n这题，我们采用高规格的结题思路解决它，首先，先回想一下number.parsefloat的处理流程，对于一个字符串，首先我们想设想符合规则的情况，如果开头是空格，则忽略，紧接着可能是-和+，然后可能开始遇到数字，需要考虑多个 0 的问题，需要仅保留一个 0，然后可能是.，如果是.的话，后面必须解析到数字才行，其余的情况均视为无法解析出正确的数字。\n\n下面是我给出的实现，如果仍然有 case 没有考虑完全的话，欢迎各位读者 issue\n\n/**\n * 将字符串解析成数字\n * @param {string} str 待解析字符串\n */\nfunction myparsefloat(str) {\n  str = str.replace(/^\\s*/, "");\n  let pos = 0;\n  // 是否有符号\n  let signal = {\n    val: "",\n    proceed: false,\n  };\n  // 是否有小数点\n  let point = {\n    pos: -1,\n    proceed: false,\n  };\n  // 小数点前面的数字\n  let beforepointdigits = [];\n  let afterpointdigits = [];\n  while (pos < str.length) {\n    const char = str[pos];\n    if (["+", "-"].includes(char)) {\n      // 处理过了的话，直接可以结束循环\n      if (signal.proceed) {\n        break;\n      }\n      // 符号，没有处理过\n      signal.proceed = true;\n      signal.val = char;\n    } else if (char === ".") {\n      // 处理过小数点了的话，直接可以结束循环\n      if (point.proceed) {\n        break;\n      }\n      point.proceed = true;\n      point.pos = pos;\n    } else if (/\\d/.test(char)) {\n      // 数字，如果在小数点之前出现的数字，放在前面\n      if (point.proceed) {\n        afterpointdigits.push(char);\n      } else {\n        beforepointdigits.push(char);\n      }\n    } else {\n      // 非数字且非空格直接可以结束\n      break;\n    }\n    pos++;\n  }\n  // 消除前导0\n  while (beforepointdigits.length > 1 && beforepointdigits[0] == "0") {\n    beforepointdigits.shift();\n  }\n  // 如果是小数点直接打头，补足一个前导0\n  if (point.proceed && beforepointdigits.length === 0) {\n    beforepointdigits.push("0");\n  }\n  // 消除结尾的0\n  while (\n    afterpointdigits.length &&\n    afterpointdigits[afterpointdigits.length - 1] == "0"\n  ) {\n    afterpointdigits.pop();\n  }\n  // 如果一个数字都没有解析出来的话，说明解析出错了\n  if (beforepointdigits.length === 0 && afterpointdigits.length === 0) {\n    return nan;\n  }\n  // 处理符号\n  const symbol = signal.val === "-" ? "-" : "";\n  // 处理-0\n  if (\n    symbol === "-" &&\n    beforepointdigits.length === 1 &&\n    beforepointdigits[0] === "0" &&\n    afterpointdigits.length === 0\n  ) {\n    return "0";\n  }\n  return (\n    symbol +\n    beforepointdigits.join() +\n    (point.proceed && afterpointdigits.length > 0 ? "." : "") +\n    afterpointdigits.join()\n  );\n}\n\n\n在实现了parsefloat之后，接着有一个非常重要的问题，因为计算机的浮点数相加不准确的问题，但是题设却希望 0.1+0.2===0.3，很显然，直接用数字相加减肯定是行不通的，那么只能转换成字符串相加，其大概的处理流程和合并两个有序数组类似。\n\nfunction add(a, b) {}\n',charsets:{cjk:!0}}],themeConfig:{enableDarkMode:!0,repo:"https://github.com/sicau-hsuyang/sicau-hsuyang.github.io.git",nav:[{text:"数据结构&算法",link:"/data-structure/"},{text:"设计模式",link:"/design-pattern/"},{text:"JavaScript",link:"/javascript/"},{text:"前端框架",link:"/frameworks/"}],sidebar:{"/javascript/":[{title:"JavaScript专题",path:"/javascript/"},{title:"函数上下文this",path:"/javascript/this"},{title:"原型及原型链",path:"/javascript/prototype"},{title:"继承",path:"/javascript/extend"},{title:"闭包",path:"/javascript/closure"},{title:"Ajax",path:"/javascript/ajax"},{title:"手写",children:[{title:"trim",path:"/javascript/write/trim"},{title:"Promise",path:"/javascript/write/promise"},{title:"数组",path:"/javascript/write/array"},{title:"深浅克隆",path:"/javascript/write/clone"},{title:"apply、call、bind",path:"/javascript/write/call&bind&apply"},{title:"EventEmitter",path:"/javascript/write/event-emitter"},{title:"Flatten",path:"/javascript/write/flatten"},{title:"instanceof",path:"/javascript/write/instanceof"},{title:"new",path:"/javascript/write/new"},{title:"柯里化",path:"/javascript/write/currying"},{title:"数组去重",path:"/javascript/write/remove-duplicate"},{title:"进制转换",path:"/javascript/write/conversion-of-number-systems"},{title:"Map与Set",path:"/javascript/write/map-and-set"},{title:"JSONP",path:"/javascript/write/jsonp"},{title:"promisify",path:"/javascript/write/promisify"},{title:"异步任务调度器",path:"/javascript/write/async-task-scheduler"},{title:"异步加法的串行和并行实现",path:"/javascript/write/parallel-pk-serial"},{title:"LazyMan",path:"/javascript/write/lazy-man"}]},{title:"es6",children:[{title:"扩展运算符",path:"/javascript/es6/spread-symbol"},{title:"迭代器",path:"/javascript/es6/iterator"},{title:"Class",path:"/javascript/es6/class"},{title:"Generator",path:"/javascript/es6/generator"},{title:"Async函数",path:"/javascript/es6/async"}]},{title:"实用代码片段",children:[{title:"可重试的请求方法",path:"/javascript/snippets/repeatable-request.md"},{title:"复制内容到剪贴板",path:"/javascript/snippets/copy-into-clipboard.md"},{title:"安全的取值和赋值方法",path:"/javascript/snippets/safety-getandset.md"},{title:"数字千分位分隔",path:"/javascript/snippets/thousand.md"},{title:"日期格式化",path:"/javascript/snippets/date-format.md"},{title:"图片懒加载",path:"/javascript/snippets/lazyload.md"}]}],"/data-structure/":[{title:"常见的数据结构和算法",path:"/data-structure/"},{title:"数组",children:[{title:"数组的介绍",path:"/data-structure/list/array"},{title:"合并2（K）个有序数组",path:"/data-structure/list/mergeArray"},{title:"洗牌算法",path:"/data-structure/list/shuffle"}]},{title:"链表",children:[{title:"链表的介绍",path:"/data-structure/list/linkedList"},{title:"双向链表的介绍",path:"/data-structure/list/doubleLinkedList"},{title:"LRUCache",path:"/data-structure/list/lru-cache"},{title:"LFUCache",path:"/data-structure/list/lfu-cache"}]},{title:"字符串",children:[{title:"KMP算法",path:"/data-structure/string/KMP"}]},{title:"队列",children:[{title:"队列的介绍",path:"/data-structure/queue/desc"},{title:"队列的应用——广度优先遍历",path:"/data-structure/tree/N-Tree/bfsVisit"}]},{title:"栈",children:[{title:"栈的介绍",path:"/data-structure/stack/desc"},{title:"栈的应用之逆序",path:"/data-structure/stack/reverse"},{title:"栈的应用之DFS",path:"/data-structure/stack/dfs"},{title:"栈的应用之词法分析",path:"/data-structure/stack/syntaxAnalysis"},{title:"单调栈与应用",path:"/data-structure/stack/monotonous-stack"}]},{title:"堆（优先队列）",children:[{title:"堆的介绍",path:"/data-structure/heap/desc"},{title:"堆的应用——排序",path:"/data-structure/sort/heapSort"},{title:"堆的应用——前K个高频元素",path:"/data-structure/heap/topKFrequent"}]},{title:"树",sidebarDepth:4,children:[{title:"二叉树",children:[{title:"先序遍历",path:"/data-structure/tree/binaryTree/preOrderVisit"},{title:"中序遍历",path:"/data-structure/tree/binaryTree/inOrderVisit"},{title:"后序遍历",path:"/data-structure/tree/binaryTree/postOrderVisit"},{title:"层序遍历",path:"/data-structure/tree/binaryTree/levelOrderVisit"},{title:"Morris遍历法",path:"/data-structure/tree/binaryTree/morrisVisit"},{title:"二叉树的构建",path:"/data-structure/tree/binaryTree/construct"}]},{title:"N叉树",children:[{title:"深度优先遍历",path:"/data-structure/tree/N-Tree/dfsVisit"},{title:"广度优先遍历",path:"/data-structure/tree/N-Tree/bfsVisit"},{title:"字典树",path:"/data-structure/tree/N-Tree/Trie"}]},{title:"二叉搜索树",children:[{title:"二叉搜索树的介绍",path:"/data-structure/tree/binarySearchTree/desc"}]}]},{title:"图",children:[{title:"图的介绍",path:"/data-structure/graph/desc"},{title:"深度优先搜索",path:"/data-structure/graph/dfs"},{title:"广度优先搜索",path:"/data-structure/graph/bfs"},{title:"最短路径",path:"/data-structure/graph/shortest-path"},{title:"拓扑排序",path:"/data-structure/graph/topology-sort"},{title:"最小生成树",path:"/data-structure/graph/minimum-spanning-tree"}]},{title:"哈希表",children:[{title:"哈希表的介绍",path:"/data-structure/hash/desc"},{title:"哈希表的应用——两数之和",path:"/data-structure/hash/sum"},{title:"哈希表的应用——构建树",path:"/data-structure/hash/buildTree"},{title:"哈希表的应用——LRUCache",path:"/data-structure/list/lru-cache"},{title:"哈希表的应用——深克隆",path:"/data-structure/hash/deepClone"},{title:"哈希表的应用——从链表中删去总和值为零的连续节点",path:"/data-structure/hash/removeZero"}]},{title:"排序",children:[{title:"排序算法的比较",path:"/data-structure/sort/compare"},{title:"冒泡排序",path:"/data-structure/sort/bubbleSort"},{title:"选择排序",path:"/data-structure/sort/selectionSort"},{title:"插入排序",path:"/data-structure/sort/insertionSort"},{title:"希尔排序",path:"/data-structure/sort/shellSort"},{title:"快速排序",path:"/data-structure/sort/quickSort"},{title:"归并排序",path:"/data-structure/sort/mergeSort"},{title:"堆排序",path:"/data-structure/sort/heapSort"},{title:"桶排序",path:"/data-structure/sort/bucketSort"},{title:"基数排序",path:"/data-structure/sort/radixSort"}]},{title:"查找",children:[{title:"二分查找",path:"/data-structure/search/binarySearch"},{title:"平衡二叉树（AVL）",path:"/data-structure/search/avlTree"},{title:"跳跃链表",path:"/data-structure/search/skipList"}]}],"/design-pattern/":[{title:"面向对象设计原则&设计模式",path:"/design-pattern/"},{title:"单例模式",path:"/design-pattern/singleton"},{title:"工厂模式",path:"/design-pattern/factory"},{title:"命令模式",path:"/design-pattern/command"},{title:"代理模式",path:"/design-pattern/proxy"},{title:"模板方法模式",path:"/design-pattern/template-method"},{title:"观察者模式",path:"/design-pattern/watcher"},{title:"桥接模式",path:"/design-pattern/bridge"},{title:"适配器模式",path:"/design-pattern/adaptor"},{title:"装饰模式",path:"/design-pattern/decorator"},{title:"策略模式",path:"/design-pattern/strategy"},{title:"享元模式",path:"/design-pattern/flyweight"},{title:"中介者模式",path:"/design-pattern/mediator"},{title:"状态模式",path:"/design-pattern/state"},{title:"职责链模式",path:"/design-pattern/responsibility-chain"}]},codeSwitcher:{groups:{default:{ts:"TypeScript",js:"JavaScript"},"plugin-usage":{tuple:"Tuple",object:"Object"}}}}};t(228);r.a.component("CodeGroup",()=>Promise.all([t.e(0),t.e(5)]).then(t.bind(null,317))),r.a.component("NextSteps",()=>Promise.all([t.e(0),t.e(7)]).then(t.bind(null,450))),r.a.component("Step",()=>Promise.all([t.e(0),t.e(8)]).then(t.bind(null,318))),r.a.component("CodeBlock",()=>Promise.all([t.e(0),t.e(4)]).then(t.bind(null,319))),r.a.component("Summary",()=>Promise.all([t.e(0),t.e(9)]).then(t.bind(null,451))),r.a.component("Badge",()=>Promise.all([t.e(0),t.e(3)]).then(t.bind(null,452))),r.a.component("VPIconExternalLink",()=>Promise.all([t.e(0),t.e(10)]).then(t.bind(null,453))),r.a.component("Details",()=>Promise.all([t.e(0),t.e(6)]).then(t.bind(null,454))),r.a.component("VPLink",()=>t.e(12).then(t.bind(null,320)));r.a.component("CodeSwitcher",()=>Promise.all([t.e(0),t.e(11)]).then(t.bind(null,315)));t(229);var Le=[{},({Vue:n})=>{n.mixin({computed:{$dataBlock(){return this.$options.__data__block__}}})},{},{},{}],Me=[];class De extends class{constructor(){this.store=new r.a({data:{state:{}}})}$get(n){return this.store.state[n]}$set(n,e){r.a.set(this.store.state,n,e)}$emit(...n){this.store.$emit(...n)}$on(...n){this.store.$on(...n)}}{}Object.assign(De.prototype,{getPageAsyncComponent:ce,getLayoutAsyncComponent:ue,getAsyncComponent:de,getVueComponent:pe});var Re={install(n){const e=new De;n.$vuepress=e,n.prototype.$vuepress=e}};function qe(n,e){const t=e.toLowerCase();return n.options.routes.some(n=>n.path.toLowerCase()===t)}var Fe={props:{pageKey:String,slotKey:{type:String,default:"default"}},render(n){const e=this.pageKey||this.$parent.$page.key;return fe("pageKey",e),r.a.component(e)||r.a.component(e,ce(e)),r.a.component(e)?n(e):n("")}},$e={functional:!0,props:{slotKey:String,required:!0},render:(n,{props:e,slots:t})=>n("div",{class:["content__"+e.slotKey]},t()[e.slotKey])},Ve={computed:{openInNewWindowTitle(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},Be=(t(230),t(231),Object(Ae.a)(Ve,(function(){var n=this._self._c;return n("span",[n("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[n("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),n("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),n("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports),He={functional:!0,render(n,{parent:e,children:t}){if(e._isMounted)return t;e.$once("hook:mounted",()=>{e.$forceUpdate()})}};r.a.config.productionTip=!1,r.a.use(Jn),r.a.use(Re),r.a.mixin(function(n,e,t=r.a){!function(n){n.locales&&Object.keys(n.locales).forEach(e=>{n.locales[e].path=e});Object.freeze(n)}(e),t.$vuepress.$set("siteData",e);const a=new(n(t.$vuepress.$get("siteData"))),o=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(a)),i={};return Object.keys(o).reduce((n,e)=>(e.startsWith("$")&&(n[e]=o[e].get),n),i),{computed:i}}(n=>class{setPage(n){this.__page=n}get $site(){return n}get $themeConfig(){return this.$site.themeConfig}get $frontmatter(){return this.$page.frontmatter}get $localeConfig(){const{locales:n={}}=this.$site;let e,t;for(const r in n)"/"===r?t=n[r]:0===this.$page.path.indexOf(r)&&(e=n[r]);return e||t||{}}get $siteTitle(){return this.$localeConfig.title||this.$site.title||""}get $canonicalUrl(){const{canonicalUrl:n}=this.$page.frontmatter;return"string"==typeof n&&n}get $title(){const n=this.$page,{metaTitle:e}=this.$page.frontmatter;if("string"==typeof e)return e;const t=this.$siteTitle,r=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?r?r+" | "+t:t:r||"VuePress"}get $description(){const n=function(n){if(n){const e=n.filter(n=>"description"===n.name)[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}get $lang(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}get $localePath(){return this.$localeConfig.path||"/"}get $themeLocaleConfig(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}get $page(){return this.__page?this.__page:function(n,e){for(let t=0;t<n.length;t++){const r=n[t];if(r.path.toLowerCase()===e.toLowerCase())return r}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}},Oe)),r.a.component("Content",Fe),r.a.component("ContentSlotsDistributor",$e),r.a.component("OutboundLink",Be),r.a.component("ClientOnly",He),r.a.component("Layout",ue("Layout")),r.a.component("NotFound",ue("NotFound")),r.a.prototype.$withBase=function(n){const e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.9.7",hash:"52949cf"},async function(n){const e="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:Oe.routerBase||Oe.base,t=new Jn({base:e,mode:"history",fallback:!1,routes:ze,scrollBehavior:(n,e,t)=>t||(n.hash?!r.a.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})});!function(n){n.beforeEach((e,t,r)=>{if(qe(n,e.path))r();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){const t=e.path.replace(/\/$/,"")+".html";qe(n,t)?r(t):r()}else r();else{const t=e.path+"/",a=e.path+".html";qe(n,a)?r(a):qe(n,t)?r(t):r()}})}(t);const a={};try{await Promise.all(Le.filter(n=>"function"==typeof n).map(e=>e({Vue:r.a,options:a,router:t,siteData:Oe,isServer:n})))}catch(n){console.error(n)}return{app:new r.a(Object.assign(a,{router:t,render:n=>n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},Me.map(e=>n(e)))])})),router:t}}(!1).then(({app:n,router:e})=>{e.onReady(()=>{n.$mount("#app")})})}]);