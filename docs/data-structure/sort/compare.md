## 排序算法的比较与总结

### 规范

排序算法必须原地排序，不能修改数组的引用，只能修改数组内容

排序算法必须向外界提供统一的接口，仅接收一个数组作为参数，不返回任何内容；

### 复杂度、稳定性与额外占用空间比较

| 排序算法名称                                   | 平均算法复杂度 | 是否稳定 | 是否额外空间复杂度 |
| ---------------------------------------------- | -------------- | -------- | ------------------ |
| [冒泡排序](/data-structure/sort/bubbleSort)    | O(N²)          | 是       | 否                 |
| [选择排序](/data-structure/sort/selectionSort) | O(N²)          | 是       | 否                 |
| [插入排序](/data-structure/sort/insertionSort) | O(N²)          | 是       | 否                 |
| [希尔排序](/data-structure/sort/shellSort)     | O(N\*logN)     | 否       | 否                 |
| [快速排序](/data-structure/sort/quickSort)     | O(N\*logN)     | 否       | 否                 |
| [归并排序](/data-structure/sort/mergeSort)     | O(N\*logN)     | 是       | 是，O(N)           |
| [堆排序](/data-structure/sort/heapSort)        | O(N\*logN)     | 否       | 否                 |
| [基数排序](/data-structure/sort/radixSort)     | TODO           | TODO     | TODO               |
| [桶排序 ](/data-structure/sort/bucketSort)     | TODO           | TODO     | TODO               |

### 时间比较

我们各类的语言底层（如 JS 的`Array.prototype.sort`）提供的排序算法就是根据不同排序算法的稳定性、时间复杂度、空间复杂度差异，根据待排数据的性质，在三者之间进行取舍，从而实现更加高效的排序算法。

为了让大家直观的体验不同排序算法的差异，我对这些排序算法在 LeetCode 上都依次进行了提交（同一个排序算法 3 次提交，对结果取最接近平均值的那组数据），然后将结果进行了统计，结果如下：

| 排序算法名称                   | 执行用时 | 执行用时击败所有提交区间 | 内存消耗 | 内存消耗击败所有提交区间 | 是否稳定 |
| ------------------------------ | -------- | ------------------------ | -------- | ------------------------ | -------- |
| 冒泡排序                       | 6036ms   | 10.62%                   | 50.7MB   | 89.30%                   | 是       |
| 选择排序                       | 7100 ms  | 6.86%                    | 50.7 MB  | 86.00%                   | 是       |
| 插入排序                       | 1508 ms  | 39.15%                   | 50.8 MB  | 85.80%                   | 是       |
| 希尔排序                       | 108 ms   | 95.09%                   | 50.8 MB  | 85.80%                   | 是       |
| 朴素快速排序                   | 1512 ms  | 39.06%                   | 57.5 MB  | 37.14%                   | 否       |
| 三元取中快速排序               | 112 ms   | 91.57%                   | 50.8 MB  | 83.76%                   | 否       |
| 归并排序（递归版）             | 620 ms   | 48.71%                   | 54.2 MB  | 49.68%                   | 是       |
| 归并排序（非递归版）           | 120 ms   | 83.46%                   | 51.6 MB  | 63.65%                   | 是       |
| 堆排序                         | 108 ms   | 95.09%                   | 50.5 MB  | 93.77%                   | 否       |
| 基数排序                       | TODO     | TODO                     | TODO     | TODO                     | TODO     |
| 桶排序                         | TODO     | TODO                     | TODO     | TODO                     | TODO     |
| 程序内置排序函数（以 JS 为例） | 108 ms   | 95.09%                   | 50.6 MB  | 92.65%                   | 不讨论   |

最后通过这个表格验证了我们的结论，因为语言底层的排序算法通过对不同对数据环境下的数据采用了符合场景的排序算法，速度是最快的。（在 LeetCode 上提交各种排序算法的我，那个小丑竟然是我自己）。有的同学可能会说我学排序算法学了个寂寞，不如直接就用语言提供的排序算法就好啊，其实我们学习是为了掌握理论，为的知道其底层原理，便于解决各种生产中的 bug，是对能力的一种培养。再者，面试官再问你各种排序算法，你心里面也有个谱了吧。
