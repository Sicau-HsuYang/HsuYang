## 防抖

防抖（`debounce`）是一种控制函数执行频率的技术。

它可以限制某个函数在一定时间内执行的次数，从而避免过于频繁的调用。在防抖技术中，只有在延迟一定时间后没有再次触发相同事件，才会执行该函数，否则函数就会被取消。

通过防抖技术，可以有效地减少一些高频率事件的执行次数，避免频繁操作给浏览器带来不必要的负担，同时也可以提升应用程序的性能。

如果你觉得上述的概念听起来比较晦涩难懂，那我举一个生活中实际例子你就明白了。

电梯，大家都乘坐过吧，电梯关门的时间是一定的，如果你进了电梯，准备下楼，但是此时有一个人按了电梯门，好了，你走不掉了，又得等一定的时间电梯才会关门，要是现在又来一个人，他又给按住了，那又得等一定的时间电梯才会关门了（如果你此时正赶着去打卡，那你内心一定是崩溃的，但是实际生活中你肯定有这种倒霉的时刻），这个过程就是防抖。

### 1、简单实现

简单实现是很容易的，以下是实现：

```ts
/**
 * 防抖
 * @param fn 原函数
 * @param delay 延迟时间
 * @returns
 */
function debounce(fn: Function, delay: number) {
  let timer: NodeJS.Timer;
  return function debounced() {
    clearTimeout(timer);
    timer = setTimeout(() => {
      fn.apply(this, arguments);
    }, delay);
  };
}
```

如果你能把这个简单版本的防抖写出来，证明你至少对`防抖`、`闭包`、`定时器`等知识点熟识了，能应付简单的面试了。

### 2、进阶实现

如果你仔细看过`lodash`关于`debounce`的`API`描述，你会发现`lodash`提供的防抖一点儿都不简单。

> 创建一个`debounced`（防抖动）函数，该函数会从上一次被调用后，延迟`wait`毫秒后调用`func`方法。 `debounced`（防抖动）函数提供一个 `cancel` 方法取消延迟的函数调用以及`flush`方法立即调用。 可以提供一个`options`（选项） 对象决定如何调用`func`方法，`options.leading` 与|或 `options.trailing` 决定延迟前后如何触发（注：是 先调用后等待 还是 先等待后调用）。 `func`调用时会传入最后一次提供给`debounced`（防抖动）函数 的参数。 后续调用的`debounced`（防抖动）函数返回是最后一次`func`调用的结果。

- `func` (Function): 要防抖动的函数。
- `[wait=0]` (number): 需要延迟的毫秒数。
- `[options=]` (Object): 选项对象。
- `[options.leading=false]` (boolean): 指定在延迟开始前调用。
- `[options.maxWait]` (number): 设置 func 允许被延迟的最大值。
- `[options.trailing=true]` (boolean): 指定在延迟结束后调用。

为什么会多这么多的选项呢？

在简单版本中，我们也看到了，如果用户一直触发，那将会一次都不会触发，但是实际上我们可能希望第一次开始的时候能否先触发一次（至少有个反应嘛，免得用户以为程序出`bug`了呢），另外这个函数一旦延迟了，是不可取消的，那么就存在一些边界情况，比如现在在前端的`SPA`中，当前执行的某个操作非常性能，对其进行了防抖操作，但此刻用户或许是因为点错了又切换到了别的路由里面去了，能否不要再执行这个耗时操作了呢？

正因为这些问题，所以简单版本的`debounce`需要应付实际复杂的开发场景还是显得有点儿力不从心了。
